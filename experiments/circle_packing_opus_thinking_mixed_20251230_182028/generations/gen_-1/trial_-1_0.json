{
  "trial_id": "trial_-1_0",
  "generation": -1,
  "parent_id": null,
  "metrics": {},
  "code": "",
  "prompt": "Create a Python solution to pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of radii. No circles can overlap or extend outside the square. Output only the solve() function that returns a list of (x, y, r) tuples.",
  "response": "def solve():\n    import math\n    import random\n    \n    n = 26\n    \n    def is_valid(x, y, r, circles, idx=-1):\n        if r <= 0:\n            return False\n        if x - r < 0 or x + r > 1 or y - r < 0 or y + r > 1:\n            return False\n        for i, (cx, cy, cr) in enumerate(circles):\n            if i == idx:\n                continue\n            dist = math.sqrt((x - cx)**2 + (y - cy)**2)\n            if dist < r + cr - 1e-9:\n                return False\n        return True\n    \n    def max_radius_at(x, y, circles, idx=-1):\n        max_r = min(x, 1 - x, y, 1 - y)\n        for i, (cx, cy, cr) in enumerate(circles):\n            if i == idx:\n                continue\n            dist = math.sqrt((x - cx)**2 + (y - cy)**2)\n            max_r = min(max_r, dist - cr)\n        return max(0, max_r)\n    \n    def greedy_init():\n        circles = []\n        for _ in range(n):\n            best_x, best_y, best_r = 0.5, 0.5, 0\n            for _ in range(1000):\n                x = random.uniform(0, 1)\n                y = random.uniform(0, 1)\n                r = max_radius_at(x, y, circles)\n                if r > best_r:\n                    best_x, best_y, best_r = x, y, r\n            if best_r > 1e-9:\n                circles.append((best_x, best_y, best_r))\n            else:\n                circles.append((random.uniform(0.1, 0.9), random.uniform(0.1, 0.9), 0.001))\n        return circles\n    \n    def total_radius(circles):\n        return sum(r for x, y, r in circles)\n    \n    def optimize(circles):\n        circles = list(circles)\n        best_sum = total_radius(circles)\n        \n        for iteration in range(2000):\n            temp = 0.1 * (1 - iteration / 2000)\n            \n            i = random.randint(0, n - 1)\n            old_x, old_y, old_r = circles[i]\n            \n            move_type = random.randint(0, 2)\n            \n            if move_type == 0:\n                dx = random.gauss(0, temp)\n                dy = random.gauss(0, temp)\n                new_x = max(0.001, min(0.999, old_x + dx))\n                new_y = max(0.001, min(0.999, old_y + dy))\n            elif move_type == 1:\n                new_x = random.uniform(0.01, 0.99)\n                new_y = random.uniform(0.01, 0.99)\n            else:\n                new_x, new_y = old_x, old_y\n            \n            new_r = max_radius_at(new_x, new_y, circles, i)\n            \n            if new_r > 1e-9:\n                circles[i] = (new_x, new_y, new_r)\n                new_sum = total_radius(circles)\n                if new_sum > best_sum:\n                    best_sum = new_sum\n                else:\n                    if random.random() > math.exp((new_sum - best_sum) / max(temp, 0.001)):\n                        circles[i] = (old_x, old_y, old_r)\n        \n        return circles\n    \n    def refine(circles):\n        circles = list(circles)\n        for _ in range(500):\n            for i in range(n):\n                x, y, r = circles[i]\n                best_x, best_y = x, y\n                best_r = r\n                \n                for dx, dy in [(0.001, 0), (-0.001, 0), (0, 0.001), (0, -0.001),\n                               (0.0005, 0.0005), (-0.0005, 0.0005), (0.0005, -0.0005), (-0.0005, -0.0005)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 < nx < 1 and 0 < ny < 1:\n                        nr = max_radius_at(nx, ny, circles, i)\n                        if nr > best_r:\n                            best_x, best_y, best_r = nx, ny, nr\n                \n                circles[i] = (best_x, best_y, best_r)\n        return circles\n    \n    best_circles = None\n    best_total = 0\n    \n    for _ in range(5):\n        circles = greedy_init()\n        circles = optimize(circles)\n        circles = refine(circles)\n        t = total_radius(circles)\n        if t > best_total:\n            best_total = t\n            best_circles = circles\n    \n    return best_circles",
  "reasoning": "def solve():\n    import math\n    import random\n    \n    n = 26\n    \n    def is_valid(x, y, r, circles, idx=-1):\n        if r <= 0:\n            return False\n        if x - r < 0 or x + r > 1 or y - r < 0 or y + r > 1:\n            return False\n        for i, (cx, cy, cr) in enumerate(circles):\n            if i == idx:\n                continue\n            dist = math.sqrt((x - cx)**2 + (y - cy)**2)\n            if dist < r + cr - 1e-9:\n                return False\n        return True\n    \n    def max_radius_at(x, y, circles, idx=-1):\n        max_r = min(x, 1 - x, y, 1 - y)\n        for i, (cx, cy, cr) in enumerate(circles):\n            if i == idx:\n                continue\n            dist = math.sqrt((x - cx)**2 + (y - cy)**2)\n            max_r = min(max_r, dist - cr)\n        return max(0, max_r)\n    \n    def greedy_init():\n        circles = []\n        for _ in range(n):\n            best_x, best_y, best_r = 0.5, 0.5, 0\n            for _ in range(1000):\n                x = random.uniform(0, 1)\n                y = random.uniform(0, 1)\n                r = max_radius_at(x, y, circles)\n                if r > best_r:\n                    best_x, best_y, best_r = x, y, r\n            if best_r > 1e-9:\n                circles.append((best_x, best_y, best_r))\n            else:\n                circles.append((random.uniform(0.1, 0.9), random.uniform(0.1, 0.9), 0.001))\n        return circles\n    \n    def total_radius(circles):\n        return sum(r for x, y, r in circles)\n    \n    def optimize(circles):\n        circles = list(circles)\n        best_sum = total_radius(circles)\n        \n        for iteration in range(2000):\n            temp = 0.1 * (1 - iteration / 2000)\n            \n            i = random.randint(0, n - 1)\n            old_x, old_y, old_r = circles[i]\n            \n            move_type = random.randint(0, 2)\n            \n            if move_type == 0:\n                dx = random.gauss(0, temp)\n                dy = random.gauss(0, temp)\n                new_x = max(0.001, min(0.999, old_x + dx))\n                new_y = max(0.001, min(0.999, old_y + dy))\n            elif move_type == 1:\n                new_x = random.uniform(0.01, 0.99)\n                new_y = random.uniform(0.01, 0.99)\n            else:\n                new_x, new_y = old_x, old_y\n            \n            new_r = max_radius_at(new_x, new_y, circles, i)\n            \n            if new_r > 1e-9:\n                circles[i] = (new_x, new_y, new_r)\n                new_sum = total_radius(circles)\n                if new_sum > best_sum:\n                    best_sum = new_sum\n                else:\n                    if random.random() > math.exp((new_sum - best_sum) / max(temp, 0.001)):\n                        circles[i] = (old_x, old_y, old_r)\n        \n        return circles\n    \n    def refine(circles):\n        circles = list(circles)\n        for _ in range(500):\n            for i in range(n):\n                x, y, r = circles[i]\n                best_x, best_y = x, y\n                best_r = r\n                \n                for dx, dy in [(0.001, 0), (-0.001, 0), (0, 0.001), (0, -0.001),\n                               (0.0005, 0.0005), (-0.0005, 0.0005), (0.0005, -0.0005), (-0.0005, -0.0005)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 < nx < 1 and 0 < ny < 1:\n                        nr = max_radius_at(nx, ny, circles, i)\n                        if nr > best_r:\n                            best_x, best_y, best_r = nx, ny, nr\n                \n                circles[i] = (best_x, best_y, best_r)\n        return circles\n    \n    best_circles = None\n    best_total = 0\n    \n    for _ in range(5):\n        circles = greedy_init()\n        circles = optimize(circles)\n        circles = refine(circles)\n        t = total_radius(circles)\n        if t > best_total:\n            best_total = t\n            best_circles = circles\n    \n    return best_circles",
  "timestamp": "2025-12-30T18:21:10.090343",
  "cost_data": null
}