{
  "trial_id": "trial_4_10",
  "generation": 4,
  "parent_id": "trial_3_3",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses pattern search refinement on top of differential evolution.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def compute_radii(centers):\n        \"\"\"Compute maximum valid radii for given centers.\"\"\"\n        centers = centers.reshape(n, 2)\n        radii = np.zeros(n)\n        \n        for i in range(n):\n            # Distance to boundaries\n            min_radius = min(centers[i, 0], 1 - centers[i, 0], \n                           centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    if radii[j] > 0:\n                        min_radius = min(min_radius, dist - radii[j])\n            \n            radii[i] = max(0, min_radius)\n        \n        return radii\n    \n    def objective(x):\n        \"\"\"Negative sum of radii (for minimization).\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        return -np.sum(radii)\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if configuration is valid.\"\"\"\n        centers = centers.reshape(n, 2)\n        \n        # Check boundaries\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < -1e-6 or centers[i, 0] + radii[i] > 1 + 1e-6 or\n                centers[i, 1] - radii[i] < -1e-6 or centers[i, 1] + radii[i] > 1 + 1e-6):\n                return False\n        \n        # Check overlaps\n        dists = cdist(centers, centers)\n        for i in range(n):\n            for j in range(i+1, n):\n                if dists[i, j] < radii[i] + radii[j] - 1e-6:\n                    return False\n        \n        return True\n    \n    # Initial solution using differential evolution\n    print(\"Phase 1: Differential Evolution\")\n    bounds = [(0, 1)] * (2 * n)\n    \n    result = differential_evolution(\n        objective,\n        bounds,\n        maxiter=300,\n        popsize=20,\n        seed=42,\n        atol=1e-6,\n        tol=1e-6,\n        workers=1\n    )\n    \n    best_centers = result.x.reshape(n, 2)\n    best_radii = compute_radii(best_centers)\n    best_sum = np.sum(best_radii)\n    \n    print(f\"After DE: sum = {best_sum:.6f}\")\n    \n    # Pattern search refinement\n    def pattern_search(centers, max_iter=100, initial_step=0.01):\n        \"\"\"Pattern search along coordinate and diagonal directions.\"\"\"\n        centers = centers.copy()\n        step_size = initial_step\n        \n        # Directions: x, y, and diagonals\n        directions = [\n            np.array([1, 0]), np.array([0, 1]),\n            np.array([1, 1]) / np.sqrt(2), np.array([1, -1]) / np.sqrt(2)\n        ]\n        \n        for iteration in range(max_iter):\n            improved = False\n            current_radii = compute_radii(centers)\n            current_sum = np.sum(current_radii)\n            \n            # Try moving each circle in each direction\n            for i in range(n):\n                for direction in directions:\n                    for sign in [1, -1]:\n                        new_centers = centers.copy()\n                        new_centers[i] += sign * step_size * direction\n                        \n                        # Check bounds\n                        if (new_centers[i, 0] < 0 or new_centers[i, 0] > 1 or\n                            new_centers[i, 1] < 0 or new_centers[i, 1] > 1):\n                            continue\n                        \n                        new_radii = compute_radii(new_centers)\n                        new_sum = np.sum(new_radii)\n                        \n                        if new_sum > current_sum + 1e-8:\n                            centers = new_centers\n                            current_sum = new_sum\n                            improved = True\n                            break\n                    \n                    if improved:\n                        break\n                \n                if improved:\n                    break\n            \n            if not improved:\n                step_size *= 0.5\n                if step_size < 1e-6:\n                    break\n        \n        return centers\n    \n    print(\"Phase 2: Pattern Search\")\n    best_centers = pattern_search(best_centers, max_iter=200, initial_step=0.02)\n    best_radii = compute_radii(best_centers)\n    best_sum = np.sum(best_radii)\n    print(f\"After Pattern Search: sum = {best_sum:.6f}\")\n    \n    # Nelder-Mead refinement\n    print(\"Phase 3: Nelder-Mead Polish\")\n    result = minimize(\n        objective,\n        best_centers.flatten(),\n        method='Nelder-Mead',\n        options={'maxiter': 5000, 'xatol': 1e-8, 'fatol': 1e-8}\n    )\n    \n    if result.fun < -best_sum:\n        best_centers = result.x.reshape(n, 2)\n        best_radii = compute_radii(best_centers)\n        best_sum = np.sum(best_radii)\n    \n    print(f\"After Nelder-Mead: sum = {best_sum:.6f}\")\n    \n    # Additional pattern search with smaller steps\n    print(\"Phase 4: Fine Pattern Search\")\n    best_centers = pattern_search(best_centers, max_iter=100, initial_step=0.005)\n    best_radii = compute_radii(best_centers)\n    best_sum = np.sum(best_radii)\n    print(f\"After Fine Pattern Search: sum = {best_sum:.6f}\")\n    \n    # Final radius expansion with binary search\n    print(\"Phase 5: Radius Expansion\")\n    \n    def try_expand_radius(centers, radii, idx, target_radius):\n        \"\"\"Check if we can expand radius of circle idx to target_radius.\"\"\"\n        new_radii = radii.copy()\n        new_radii[idx] = target_radius\n        \n        # Check boundaries\n        if (centers[idx, 0] - target_radius < -1e-9 or \n            centers[idx, 0] + target_radius > 1 + 1e-9 or\n            centers[idx, 1] - target_radius < -1e-9 or \n            centers[idx, 1] + target_radius > 1 + 1e-9):\n            return False\n        \n        # Check overlaps\n        for j in range(n):\n            if j != idx:\n                dist = np.linalg.norm(centers[idx] - centers[j])\n                if dist < new_radii[idx] + new_radii[j] - 1e-9:\n                    return False\n        \n        return True\n    \n    # Try to expand each radius\n    for i in range(n):\n        # Binary search for maximum radius\n        low = best_radii[i]\n        high = min(best_centers[i, 0], 1 - best_centers[i, 0],\n                   best_centers[i, 1], 1 - best_centers[i, 1])\n        \n        for _ in range(50):\n            mid = (low + high) / 2\n            if try_expand_radius(best_centers, best_radii, i, mid):\n                low = mid\n            else:\n                high = mid\n            \n            if high - low < 1e-9:\n                break\n        \n        best_radii[i] = low\n    \n    best_sum = np.sum(best_radii)\n    print(f\"After Radius Expansion: sum = {best_sum:.6f}\")\n    \n    # Verify validity\n    if not is_valid(best_centers, best_radii):\n        print(\"Warning: Solution may not be valid, adjusting...\")\n        # Recompute radii conservatively\n        best_radii = compute_radii(best_centers)\n        best_sum = np.sum(best_radii)\n    \n    print(f\"Final sum of radii: {best_sum:.6f}\")\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 1272.06520485878,
    "error": "Timeout after 300s"
  },
  "prompt": "Gradient-free optimization with pattern search.\n\nBased on trial_3_3 but add pattern search refinement:\n1. Get best solution from trial_3_3\n2. Apply coordinate pattern search:\n   - For each circle, search along coordinate axes\n   - Also search along diagonal directions\n   - Use adaptive step sizes\n3. Apply Nelder-Mead simplex method for final polish\n4. Multiple restarts with decreasing tolerances\n5. Final radius expansion with binary search for each radius\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses pattern search refinement on top of differential evolution.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def compute_radii(centers):\n        \"\"\"Compute maximum valid radii for given centers.\"\"\"\n        centers = centers.reshape(n, 2)\n        radii = np.zeros(n)\n        \n        for i in range(n):\n            # Distance to boundaries\n            min_radius = min(centers[i, 0], 1 - centers[i, 0], \n                           centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    if radii[j] > 0:\n                        min_radius = min(min_radius, dist - radii[j])\n            \n            radii[i] = max(0, min_radius)\n        \n        return radii\n    \n    def objective(x):\n        \"\"\"Negative sum of radii (for minimization).\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        return -np.sum(radii)\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if configuration is valid.\"\"\"\n        centers = centers.reshape(n, 2)\n        \n        # Check boundaries\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < -1e-6 or centers[i, 0] + radii[i] > 1 + 1e-6 or\n                centers[i, 1] - radii[i] < -1e-6 or centers[i, 1] + radii[i] > 1 + 1e-6):\n                return False\n        \n        # Check overlaps\n        dists = cdist(centers, centers)\n        for i in range(n):\n            for j in range(i+1, n):\n                if dists[i, j] < radii[i] + radii[j] - 1e-6:\n                    return False\n        \n        return True\n    \n    # Initial solution using differential evolution\n    print(\"Phase 1: Differential Evolution\")\n    bounds = [(0, 1)] * (2 * n)\n    \n    result = differential_evolution(\n        objective,\n        bounds,\n        maxiter=300,\n        popsize=20,\n        seed=42,\n        atol=1e-6,\n        tol=1e-6,\n        workers=1\n    )\n    \n    best_centers = result.x.reshape(n, 2)\n    best_radii = compute_radii(best_centers)\n    best_sum = np.sum(best_radii)\n    \n    print(f\"After DE: sum = {best_sum:.6f}\")\n    \n    # Pattern search refinement\n    def pattern_search(centers, max_iter=100, initial_step=0.01):\n        \"\"\"Pattern search along coordinate and diagonal directions.\"\"\"\n        centers = centers.copy()\n        step_size = initial_step\n        \n        # Directions: x, y, and diagonals\n        directions = [\n            np.array([1, 0]), np.array([0, 1]),\n            np.array([1, 1]) / np.sqrt(2), np.array([1, -1]) / np.sqrt(2)\n        ]\n        \n        for iteration in range(max_iter):\n            improved = False\n            current_radii = compute_radii(centers)\n            current_sum = np.sum(current_radii)\n            \n            # Try moving each circle in each direction\n            for i in range(n):\n                for direction in directions:\n                    for sign in [1, -1]:\n                        new_centers = centers.copy()\n                        new_centers[i] += sign * step_size * direction\n                        \n                        # Check bounds\n                        if (new_centers[i, 0] < 0 or new_centers[i, 0] > 1 or\n                            new_centers[i, 1] < 0 or new_centers[i, 1] > 1):\n                            continue\n                        \n                        new_radii = compute_radii(new_centers)\n                        new_sum = np.sum(new_radii)\n                        \n                        if new_sum > current_sum + 1e-8:\n                            centers = new_centers\n                            current_sum = new_sum\n                            improved = True\n                            break\n                    \n                    if improved:\n                        break\n                \n                if improved:\n                    break\n            \n            if not improved:\n                step_size *= 0.5\n                if step_size < 1e-6:\n                    break\n        \n        return centers\n    \n    print(\"Phase 2: Pattern Search\")\n    best_centers = pattern_search(best_centers, max_iter=200, initial_step=0.02)\n    best_radii = compute_radii(best_centers)\n    best_sum = np.sum(best_radii)\n    print(f\"After Pattern Search: sum = {best_sum:.6f}\")\n    \n    # Nelder-Mead refinement\n    print(\"Phase 3: Nelder-Mead Polish\")\n    result = minimize(\n        objective,\n        best_centers.flatten(),\n        method='Nelder-Mead',\n        options={'maxiter': 5000, 'xatol': 1e-8, 'fatol': 1e-8}\n    )\n    \n    if result.fun < -best_sum:\n        best_centers = result.x.reshape(n, 2)\n        best_radii = compute_radii(best_centers)\n        best_sum = np.sum(best_radii)\n    \n    print(f\"After Nelder-Mead: sum = {best_sum:.6f}\")\n    \n    # Additional pattern search with smaller steps\n    print(\"Phase 4: Fine Pattern Search\")\n    best_centers = pattern_search(best_centers, max_iter=100, initial_step=0.005)\n    best_radii = compute_radii(best_centers)\n    best_sum = np.sum(best_radii)\n    print(f\"After Fine Pattern Search: sum = {best_sum:.6f}\")\n    \n    # Final radius expansion with binary search\n    print(\"Phase 5: Radius Expansion\")\n    \n    def try_expand_radius(centers, radii, idx, target_radius):\n        \"\"\"Check if we can expand radius of circle idx to target_radius.\"\"\"\n        new_radii = radii.copy()\n        new_radii[idx] = target_radius\n        \n        # Check boundaries\n        if (centers[idx, 0] - target_radius < -1e-9 or \n            centers[idx, 0] + target_radius > 1 + 1e-9 or\n            centers[idx, 1] - target_radius < -1e-9 or \n            centers[idx, 1] + target_radius > 1 + 1e-9):\n            return False\n        \n        # Check overlaps\n        for j in range(n):\n            if j != idx:\n                dist = np.linalg.norm(centers[idx] - centers[j])\n                if dist < new_radii[idx] + new_radii[j] - 1e-9:\n                    return False\n        \n        return True\n    \n    # Try to expand each radius\n    for i in range(n):\n        # Binary search for maximum radius\n        low = best_radii[i]\n        high = min(best_centers[i, 0], 1 - best_centers[i, 0],\n                   best_centers[i, 1], 1 - best_centers[i, 1])\n        \n        for _ in range(50):\n            mid = (low + high) / 2\n            if try_expand_radius(best_centers, best_radii, i, mid):\n                low = mid\n            else:\n                high = mid\n            \n            if high - low < 1e-9:\n                break\n        \n        best_radii[i] = low\n    \n    best_sum = np.sum(best_radii)\n    print(f\"After Radius Expansion: sum = {best_sum:.6f}\")\n    \n    # Verify validity\n    if not is_valid(best_centers, best_radii):\n        print(\"Warning: Solution may not be valid, adjusting...\")\n        # Recompute radii conservatively\n        best_radii = compute_radii(best_centers)\n        best_sum = np.sum(best_radii)\n    \n    print(f\"Final sum of radii: {best_sum:.6f}\")\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T16:12:06.423560",
  "cost_data": null
}