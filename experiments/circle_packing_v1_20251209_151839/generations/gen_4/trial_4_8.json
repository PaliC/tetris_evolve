{
  "trial_id": "trial_4_8",
  "generation": 4,
  "parent_id": "trial_3_3",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses second-order optimization with Hessian information.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Start from trial_3_3 configuration (5x5 grid + 1 circle)\n    def get_initial_config():\n        grid_size = 5\n        spacing = 1.0 / (grid_size + 1)\n        centers = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                x = spacing * (i + 1)\n                y = spacing * (j + 1)\n                centers.append([x, y])\n        # Add 26th circle at center\n        centers.append([0.5, 0.5])\n        centers = np.array(centers)\n        \n        # Compute initial radii\n        min_dist = np.inf\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = min(min_dist, dist)\n        \n        # Conservative initial radius\n        r_init = min_dist / 2.2\n        \n        # Check boundary constraints\n        for i in range(n):\n            r_bound = min(centers[i, 0], centers[i, 1], \n                         1 - centers[i, 0], 1 - centers[i, 1])\n            r_init = min(r_init, r_bound * 0.95)\n        \n        radii = np.full(n, r_init)\n        return centers, radii\n    \n    def pack_to_vector(centers, radii):\n        \"\"\"Convert centers and radii to optimization vector.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def vector_to_pack(x, n):\n        \"\"\"Convert optimization vector to centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii (maximize sum of radii).\"\"\"\n        _, radii = vector_to_pack(x, n)\n        return -np.sum(radii)\n    \n    def objective_grad(x):\n        \"\"\"Gradient of objective.\"\"\"\n        grad = np.zeros_like(x)\n        grad[2*n:] = -1.0  # Gradient w.r.t. radii\n        return grad\n    \n    def constraint_function(x):\n        \"\"\"All constraints as a single vector.\"\"\"\n        centers, radii = vector_to_pack(x, n)\n        constraints = []\n        \n        # Non-overlap constraints: dist(i,j) >= r_i + r_j\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Boundary constraints\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        \n        # Non-negativity of radii\n        for i in range(n):\n            constraints.append(radii[i])\n        \n        return np.array(constraints)\n    \n    def constraint_jacobian(x):\n        \"\"\"Jacobian of constraints.\"\"\"\n        centers, radii = vector_to_pack(x, n)\n        num_constraints = n*(n-1)//2 + 4*n + n\n        jac = np.zeros((num_constraints, len(x)))\n        \n        idx = 0\n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                if dist > 1e-10:\n                    # Gradient w.r.t. center_i\n                    jac[idx, 2*i:2*i+2] = diff / dist\n                    # Gradient w.r.t. center_j\n                    jac[idx, 2*j:2*j+2] = -diff / dist\n                # Gradient w.r.t. radii\n                jac[idx, 2*n + i] = -1\n                jac[idx, 2*n + j] = -1\n                idx += 1\n        \n        # Boundary constraints\n        for i in range(n):\n            # left: x_i - r_i >= 0\n            jac[idx, 2*i] = 1\n            jac[idx, 2*n + i] = -1\n            idx += 1\n            # right: 1 - x_i - r_i >= 0\n            jac[idx, 2*i] = -1\n            jac[idx, 2*n + i] = -1\n            idx += 1\n            # bottom: y_i - r_i >= 0\n            jac[idx, 2*i + 1] = 1\n            jac[idx, 2*n + i] = -1\n            idx += 1\n            # top: 1 - y_i - r_i >= 0\n            jac[idx, 2*i + 1] = -1\n            jac[idx, 2*n + i] = -1\n            idx += 1\n        \n        # Non-negativity of radii\n        for i in range(n):\n            jac[idx, 2*n + i] = 1\n            idx += 1\n        \n        return jac\n    \n    # Get initial configuration\n    centers_init, radii_init = get_initial_config()\n    x0 = pack_to_vector(centers_init, radii_init)\n    \n    # Set up nonlinear constraint\n    nlc = NonlinearConstraint(\n        constraint_function,\n        lb=0,\n        ub=np.inf,\n        jac=constraint_jacobian\n    )\n    \n    best_result = None\n    best_sum = -np.inf\n    \n    # Phase 1: Initial optimization with trust-constr\n    print(\"Phase 1: Initial second-order optimization...\")\n    result = minimize(\n        objective,\n        x0,\n        method='trust-constr',\n        jac=objective_grad,\n        constraints=[nlc],\n        options={\n            'maxiter': 5000,\n            'gtol': 1e-12,\n            'xtol': 1e-12,\n            'verbose': 0\n        }\n    )\n    \n    if result.success:\n        current_sum = -result.fun\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_result = result.x.copy()\n            print(f\"Initial optimization: sum = {current_sum:.6f}\")\n    \n    # Phase 2: Multiple restarts with small perturbations\n    print(\"Phase 2: Multiple restarts from best solution...\")\n    if best_result is not None:\n        for restart in range(5):\n            # Small random perturbation\n            perturbation = np.random.randn(len(best_result)) * 0.001\n            x_restart = best_result + perturbation\n            \n            result = minimize(\n                objective,\n                x_restart,\n                method='trust-constr',\n                jac=objective_grad,\n                constraints=[nlc],\n                options={\n                    'maxiter': 3000,\n                    'gtol': 1e-13,\n                    'xtol': 1e-13,\n                    'verbose': 0\n                }\n            )\n            \n            if result.success:\n                current_sum = -result.fun\n                if current_sum > best_sum:\n                    best_sum = current_sum\n                    best_result = result.x.copy()\n                    print(f\"Restart {restart+1}: improved to {current_sum:.6f}\")\n    \n    # Phase 3: Aggressive radius expansion\n    print(\"Phase 3: Aggressive radius expansion...\")\n    if best_result is not None:\n        centers, radii = vector_to_pack(best_result, n)\n        \n        # Try to expand each radius individually\n        for iteration in range(10):\n            improved = False\n            for i in range(n):\n                # Try to increase radius i\n                r_old = radii[i]\n                \n                # Find maximum safe radius\n                max_r = min(centers[i, 0], centers[i, 1], \n                           1 - centers[i, 0], 1 - centers[i, 1])\n                \n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        max_r = min(max_r, dist - radii[j])\n                \n                # Try to expand slightly\n                r_new = min(max_r * 0.9999, r_old * 1.001)\n                \n                if r_new > r_old:\n                    radii[i] = r_new\n                    improved = True\n            \n            if not improved:\n                break\n        \n        best_result = pack_to_vector(centers, radii)\n        best_sum = np.sum(radii)\n        print(f\"After expansion: sum = {best_sum:.6f}\")\n    \n    # Phase 4: Final ultra-precise optimization\n    print(\"Phase 4: Final polishing...\")\n    if best_result is not None:\n        result = minimize(\n            objective,\n            best_result,\n            method='trust-constr',\n            jac=objective_grad,\n            constraints=[nlc],\n            options={\n                'maxiter': 2000,\n                'gtol': 1e-14,\n                'xtol': 1e-14,\n                'verbose': 0\n            }\n        )\n        \n        if result.success:\n            current_sum = -result.fun\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_result = result.x.copy()\n                print(f\"Final polish: sum = {current_sum:.6f}\")\n    \n    # Extract final solution\n    if best_result is None:\n        # Fallback to initial configuration\n        best_result = x0\n    \n    centers, radii = vector_to_pack(best_result, n)\n    sum_radii = np.sum(radii)\n    \n    print(f\"\\nFinal sum of radii: {sum_radii:.6f}\")\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.5824357201324526,
    "target_ratio": 0.980051506691633,
    "combined_score": 0.980051506691633,
    "eval_time": 4.4410810470581055,
    "error": null
  },
  "prompt": "Second-order optimization with Hessian information.\n\nStrategy:\n1. Use trial_3_3 to get good starting point\n2. Apply second-order optimization methods:\n   - Use trust-constr which uses Hessian approximations\n   - Multiple restarts from best solution with small perturbations\n   - Very high precision (gtol=1e-12)\n3. After optimization, apply Newton-like refinement\n4. Final polishing with ultra-tight tolerances\n5. Aggressive radius expansion phase\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses second-order optimization with Hessian information.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Start from trial_3_3 configuration (5x5 grid + 1 circle)\n    def get_initial_config():\n        grid_size = 5\n        spacing = 1.0 / (grid_size + 1)\n        centers = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                x = spacing * (i + 1)\n                y = spacing * (j + 1)\n                centers.append([x, y])\n        # Add 26th circle at center\n        centers.append([0.5, 0.5])\n        centers = np.array(centers)\n        \n        # Compute initial radii\n        min_dist = np.inf\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = min(min_dist, dist)\n        \n        # Conservative initial radius\n        r_init = min_dist / 2.2\n        \n        # Check boundary constraints\n        for i in range(n):\n            r_bound = min(centers[i, 0], centers[i, 1], \n                         1 - centers[i, 0], 1 - centers[i, 1])\n            r_init = min(r_init, r_bound * 0.95)\n        \n        radii = np.full(n, r_init)\n        return centers, radii\n    \n    def pack_to_vector(centers, radii):\n        \"\"\"Convert centers and radii to optimization vector.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def vector_to_pack(x, n):\n        \"\"\"Convert optimization vector to centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii (maximize sum of radii).\"\"\"\n        _, radii = vector_to_pack(x, n)\n        return -np.sum(radii)\n    \n    def objective_grad(x):\n        \"\"\"Gradient of objective.\"\"\"\n        grad = np.zeros_like(x)\n        grad[2*n:] = -1.0  # Gradient w.r.t. radii\n        return grad\n    \n    def constraint_function(x):\n        \"\"\"All constraints as a single vector.\"\"\"\n        centers, radii = vector_to_pack(x, n)\n        constraints = []\n        \n        # Non-overlap constraints: dist(i,j) >= r_i + r_j\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Boundary constraints\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        \n        # Non-negativity of radii\n        for i in range(n):\n            constraints.append(radii[i])\n        \n        return np.array(constraints)\n    \n    def constraint_jacobian(x):\n        \"\"\"Jacobian of constraints.\"\"\"\n        centers, radii = vector_to_pack(x, n)\n        num_constraints = n*(n-1)//2 + 4*n + n\n        jac = np.zeros((num_constraints, len(x)))\n        \n        idx = 0\n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                if dist > 1e-10:\n                    # Gradient w.r.t. center_i\n                    jac[idx, 2*i:2*i+2] = diff / dist\n                    # Gradient w.r.t. center_j\n                    jac[idx, 2*j:2*j+2] = -diff / dist\n                # Gradient w.r.t. radii\n                jac[idx, 2*n + i] = -1\n                jac[idx, 2*n + j] = -1\n                idx += 1\n        \n        # Boundary constraints\n        for i in range(n):\n            # left: x_i - r_i >= 0\n            jac[idx, 2*i] = 1\n            jac[idx, 2*n + i] = -1\n            idx += 1\n            # right: 1 - x_i - r_i >= 0\n            jac[idx, 2*i] = -1\n            jac[idx, 2*n + i] = -1\n            idx += 1\n            # bottom: y_i - r_i >= 0\n            jac[idx, 2*i + 1] = 1\n            jac[idx, 2*n + i] = -1\n            idx += 1\n            # top: 1 - y_i - r_i >= 0\n            jac[idx, 2*i + 1] = -1\n            jac[idx, 2*n + i] = -1\n            idx += 1\n        \n        # Non-negativity of radii\n        for i in range(n):\n            jac[idx, 2*n + i] = 1\n            idx += 1\n        \n        return jac\n    \n    # Get initial configuration\n    centers_init, radii_init = get_initial_config()\n    x0 = pack_to_vector(centers_init, radii_init)\n    \n    # Set up nonlinear constraint\n    nlc = NonlinearConstraint(\n        constraint_function,\n        lb=0,\n        ub=np.inf,\n        jac=constraint_jacobian\n    )\n    \n    best_result = None\n    best_sum = -np.inf\n    \n    # Phase 1: Initial optimization with trust-constr\n    print(\"Phase 1: Initial second-order optimization...\")\n    result = minimize(\n        objective,\n        x0,\n        method='trust-constr',\n        jac=objective_grad,\n        constraints=[nlc],\n        options={\n            'maxiter': 5000,\n            'gtol': 1e-12,\n            'xtol': 1e-12,\n            'verbose': 0\n        }\n    )\n    \n    if result.success:\n        current_sum = -result.fun\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_result = result.x.copy()\n            print(f\"Initial optimization: sum = {current_sum:.6f}\")\n    \n    # Phase 2: Multiple restarts with small perturbations\n    print(\"Phase 2: Multiple restarts from best solution...\")\n    if best_result is not None:\n        for restart in range(5):\n            # Small random perturbation\n            perturbation = np.random.randn(len(best_result)) * 0.001\n            x_restart = best_result + perturbation\n            \n            result = minimize(\n                objective,\n                x_restart,\n                method='trust-constr',\n                jac=objective_grad,\n                constraints=[nlc],\n                options={\n                    'maxiter': 3000,\n                    'gtol': 1e-13,\n                    'xtol': 1e-13,\n                    'verbose': 0\n                }\n            )\n            \n            if result.success:\n                current_sum = -result.fun\n                if current_sum > best_sum:\n                    best_sum = current_sum\n                    best_result = result.x.copy()\n                    print(f\"Restart {restart+1}: improved to {current_sum:.6f}\")\n    \n    # Phase 3: Aggressive radius expansion\n    print(\"Phase 3: Aggressive radius expansion...\")\n    if best_result is not None:\n        centers, radii = vector_to_pack(best_result, n)\n        \n        # Try to expand each radius individually\n        for iteration in range(10):\n            improved = False\n            for i in range(n):\n                # Try to increase radius i\n                r_old = radii[i]\n                \n                # Find maximum safe radius\n                max_r = min(centers[i, 0], centers[i, 1], \n                           1 - centers[i, 0], 1 - centers[i, 1])\n                \n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        max_r = min(max_r, dist - radii[j])\n                \n                # Try to expand slightly\n                r_new = min(max_r * 0.9999, r_old * 1.001)\n                \n                if r_new > r_old:\n                    radii[i] = r_new\n                    improved = True\n            \n            if not improved:\n                break\n        \n        best_result = pack_to_vector(centers, radii)\n        best_sum = np.sum(radii)\n        print(f\"After expansion: sum = {best_sum:.6f}\")\n    \n    # Phase 4: Final ultra-precise optimization\n    print(\"Phase 4: Final polishing...\")\n    if best_result is not None:\n        result = minimize(\n            objective,\n            best_result,\n            method='trust-constr',\n            jac=objective_grad,\n            constraints=[nlc],\n            options={\n                'maxiter': 2000,\n                'gtol': 1e-14,\n                'xtol': 1e-14,\n                'verbose': 0\n            }\n        )\n        \n        if result.success:\n            current_sum = -result.fun\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_result = result.x.copy()\n                print(f\"Final polish: sum = {current_sum:.6f}\")\n    \n    # Extract final solution\n    if best_result is None:\n        # Fallback to initial configuration\n        best_result = x0\n    \n    centers, radii = vector_to_pack(best_result, n)\n    sum_radii = np.sum(radii)\n    \n    print(f\"\\nFinal sum of radii: {sum_radii:.6f}\")\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:51:06.850666",
  "cost_data": null
}