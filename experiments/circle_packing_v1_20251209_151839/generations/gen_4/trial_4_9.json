{
  "trial_id": "trial_4_9",
  "generation": 4,
  "parent_id": "trial_3_3",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using multi-scale optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Stage 1: Coarse scale - Initial high-quality solution\n    print(\"Stage 1: Coarse scale initialization...\")\n    centers, radii = coarse_scale_init(n)\n    sum_radii = np.sum(radii)\n    print(f\"Coarse scale sum: {sum_radii:.6f}\")\n    \n    # Stage 2: Medium scale - Regional optimization\n    print(\"Stage 2: Medium scale regional optimization...\")\n    centers, radii = medium_scale_optimize(centers, radii)\n    sum_radii = np.sum(radii)\n    print(f\"Medium scale sum: {sum_radii:.6f}\")\n    \n    # Stage 3: Fine scale - Individual circle optimization\n    print(\"Stage 3: Fine scale individual optimization...\")\n    centers, radii = fine_scale_optimize(centers, radii)\n    sum_radii = np.sum(radii)\n    print(f\"Fine scale sum: {sum_radii:.6f}\")\n    \n    # Stage 4: Ultra-fine scale - Micro-perturbations\n    print(\"Stage 4: Ultra-fine scale micro-perturbations...\")\n    centers, radii = ultra_fine_scale_optimize(centers, radii)\n    sum_radii = np.sum(radii)\n    print(f\"Ultra-fine scale sum: {sum_radii:.6f}\")\n    \n    # Final verification\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n    print(f\"Final sum: {sum_radii:.6f}\")\n    \n    return centers, radii, sum_radii\n\ndef compute_max_radii(centers):\n    \"\"\"Compute maximum valid radius for each circle.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Distance to boundaries\n        r_max = min(centers[i, 0], 1 - centers[i, 0], \n                   centers[i, 1], 1 - centers[i, 1])\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                r_max = min(r_max, (dist - radii[j]) / 1.0)\n        \n        radii[i] = max(0, r_max)\n    \n    return radii\n\ndef coarse_scale_init(n):\n    \"\"\"Initialize with hexagonal-inspired packing and global optimization.\"\"\"\n    \n    def objective(x):\n        centers = x.reshape(n, 2)\n        radii = compute_max_radii(centers)\n        return -np.sum(radii)\n    \n    # Start with hexagonal-inspired grid\n    cols = 6\n    rows = int(np.ceil(n / cols))\n    \n    best_sum = -np.inf\n    best_centers = None\n    \n    # Try multiple initial configurations\n    for offset_x in [0.0, 0.05, 0.1]:\n        for offset_y in [0.0, 0.05, 0.1]:\n            centers = []\n            for i in range(n):\n                row = i // cols\n                col = i % cols\n                \n                x = (col + 0.5) / cols + offset_x * (0.5 if row % 2 else 0)\n                y = (row + 0.5) / rows + offset_y\n                \n                x = np.clip(x, 0.1, 0.9)\n                y = np.clip(y, 0.1, 0.9)\n                centers.append([x, y])\n            \n            centers = np.array(centers)\n            \n            # Local optimization\n            result = minimize(\n                objective,\n                centers.flatten(),\n                method='L-BFGS-B',\n                bounds=[(0.05, 0.95)] * (2 * n),\n                options={'maxiter': 1000, 'ftol': 1e-8}\n            )\n            \n            if -result.fun > best_sum:\n                best_sum = -result.fun\n                best_centers = result.x.reshape(n, 2)\n    \n    # Global refinement with differential evolution\n    result = differential_evolution(\n        objective,\n        bounds=[(0.05, 0.95)] * (2 * n),\n        x0=best_centers.flatten(),\n        maxiter=300,\n        popsize=10,\n        atol=1e-8,\n        tol=1e-8,\n        workers=1\n    )\n    \n    centers = result.x.reshape(n, 2)\n    radii = compute_max_radii(centers)\n    \n    return centers, radii\n\ndef medium_scale_optimize(centers, radii):\n    \"\"\"Optimize by dividing into regions and optimizing each.\"\"\"\n    n = len(centers)\n    \n    # Divide into 4 quadrants\n    quadrants = [\n        (0.0, 0.5, 0.0, 0.5),  # Bottom-left\n        (0.5, 1.0, 0.0, 0.5),  # Bottom-right\n        (0.0, 0.5, 0.5, 1.0),  # Top-left\n        (0.5, 1.0, 0.5, 1.0),  # Top-right\n    ]\n    \n    best_centers = centers.copy()\n    best_sum = np.sum(radii)\n    \n    # Optimize each quadrant\n    for x_min, x_max, y_min, y_max in quadrants:\n        # Find circles in this quadrant\n        mask = ((centers[:, 0] >= x_min) & (centers[:, 0] <= x_max) &\n                (centers[:, 1] >= y_min) & (centers[:, 1] <= y_max))\n        indices = np.where(mask)[0]\n        \n        if len(indices) == 0:\n            continue\n        \n        def objective(x_local):\n            temp_centers = best_centers.copy()\n            temp_centers[indices] = x_local.reshape(-1, 2)\n            temp_radii = compute_max_radii(temp_centers)\n            return -np.sum(temp_radii)\n        \n        # Optimize circles in this quadrant\n        x0 = best_centers[indices].flatten()\n        bounds = []\n        for idx in indices:\n            bounds.extend([\n                (max(0.01, x_min), min(0.99, x_max)),\n                (max(0.01, y_min), min(0.99, y_max))\n            ])\n        \n        result = minimize(\n            objective,\n            x0,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': 500, 'ftol': 1e-9}\n        )\n        \n        temp_centers = best_centers.copy()\n        temp_centers[indices] = result.x.reshape(-1, 2)\n        temp_radii = compute_max_radii(temp_centers)\n        temp_sum = np.sum(temp_radii)\n        \n        if temp_sum > best_sum:\n            best_centers = temp_centers\n            best_sum = temp_sum\n    \n    # Optimize boundary circles\n    boundary_indices = []\n    for i in range(n):\n        x, y = best_centers[i]\n        if (0.4 <= x <= 0.6) or (0.4 <= y <= 0.6):\n            boundary_indices.append(i)\n    \n    if len(boundary_indices) > 0:\n        def objective(x_local):\n            temp_centers = best_centers.copy()\n            temp_centers[boundary_indices] = x_local.reshape(-1, 2)\n            temp_radii = compute_max_radii(temp_centers)\n            return -np.sum(temp_radii)\n        \n        x0 = best_centers[boundary_indices].flatten()\n        result = minimize(\n            objective,\n            x0,\n            method='L-BFGS-B',\n            bounds=[(0.01, 0.99)] * (2 * len(boundary_indices)),\n            options={'maxiter': 500, 'ftol': 1e-9}\n        )\n        \n        temp_centers = best_centers.copy()\n        temp_centers[boundary_indices] = result.x.reshape(-1, 2)\n        temp_radii = compute_max_radii(temp_centers)\n        temp_sum = np.sum(temp_radii)\n        \n        if temp_sum > best_sum:\n            best_centers = temp_centers\n            best_sum = temp_sum\n    \n    radii = compute_max_radii(best_centers)\n    return best_centers, radii\n\ndef fine_scale_optimize(centers, radii):\n    \"\"\"Optimize individual circles one at a time.\"\"\"\n    n = len(centers)\n    best_centers = centers.copy()\n    best_sum = np.sum(radii)\n    \n    # Multiple passes\n    for pass_num in range(3):\n        improved = False\n        \n        # Optimize each circle individually\n        for i in range(n):\n            def objective(pos):\n                temp_centers = best_centers.copy()\n                temp_centers[i] = pos\n                temp_radii = compute_max_radii(temp_centers)\n                return -np.sum(temp_radii)\n            \n            result = minimize(\n                objective,\n                best_centers[i],\n                method='L-BFGS-B',\n                bounds=[(0.01, 0.99), (0.01, 0.99)],\n                options={'maxiter': 200, 'ftol': 1e-10}\n            )\n            \n            temp_centers = best_centers.copy()\n            temp_centers[i] = result.x\n            temp_radii = compute_max_radii(temp_centers)\n            temp_sum = np.sum(temp_radii)\n            \n            if temp_sum > best_sum + 1e-10:\n                best_centers = temp_centers\n                best_sum = temp_sum\n                improved = True\n        \n        if not improved:\n            break\n    \n    radii = compute_max_radii(best_centers)\n    return best_centers, radii\n\ndef ultra_fine_scale_optimize(centers, radii):\n    \"\"\"Apply micro-perturbations to escape local optima.\"\"\"\n    n = len(centers)\n    best_centers = centers.copy()\n    best_sum = np.sum(radii)\n    \n    perturbation_sizes = [0.001, 0.0001, 0.00001]\n    \n    for perturb_size in perturbation_sizes:\n        for iteration in range(50):\n            # Try perturbing each circle\n            for i in range(n):\n                for dx in [-perturb_size, 0, perturb_size]:\n                    for dy in [-perturb_size, 0, perturb_size]:\n                        if dx == 0 and dy == 0:\n                            continue\n                        \n                        temp_centers = best_centers.copy()\n                        temp_centers[i, 0] = np.clip(temp_centers[i, 0] + dx, 0.01, 0.99)\n                        temp_centers[i, 1] = np.clip(temp_centers[i, 1] + dy, 0.01, 0.99)\n                        \n                        temp_radii = compute_max_radii(temp_centers)\n                        temp_sum = np.sum(temp_radii)\n                        \n                        if temp_sum > best_sum + 1e-12:\n                            best_centers = temp_centers\n                            best_sum = temp_sum\n            \n            # Final optimization after perturbations\n            def objective(x):\n                temp_centers = x.reshape(n, 2)\n                temp_radii = compute_max_radii(temp_centers)\n                return -np.sum(temp_radii)\n            \n            result = minimize(\n                objective,\n                best_centers.flatten(),\n                method='L-BFGS-B',\n                bounds=[(0.01, 0.99)] * (2 * n),\n                options={'maxiter': 100, 'ftol': 1e-12}\n            )\n            \n            temp_centers = result.x.reshape(n, 2)\n            temp_radii = compute_max_radii(temp_centers)\n            temp_sum = np.sum(temp_radii)\n            \n            if temp_sum > best_sum:\n                best_centers = temp_centers\n                best_sum = temp_sum\n    \n    radii = compute_max_radii(best_centers)\n    return best_centers, radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 1272.0645470619202,
    "error": "Timeout after 300s"
  },
  "prompt": "Multi-scale optimization approach.\n\nStrategy:\n1. Coarse scale: Run trial_3_3's full approach\n2. Medium scale: Take best result, divide square into 4 regions\n   - Optimize each region's circles independently\n   - Then optimize across region boundaries\n3. Fine scale: Optimize individual circles one at a time\n4. Ultra-fine scale: Micro-perturbations (\u00b10.00001)\n5. Each scale uses progressively tighter tolerances\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using multi-scale optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Stage 1: Coarse scale - Initial high-quality solution\n    print(\"Stage 1: Coarse scale initialization...\")\n    centers, radii = coarse_scale_init(n)\n    sum_radii = np.sum(radii)\n    print(f\"Coarse scale sum: {sum_radii:.6f}\")\n    \n    # Stage 2: Medium scale - Regional optimization\n    print(\"Stage 2: Medium scale regional optimization...\")\n    centers, radii = medium_scale_optimize(centers, radii)\n    sum_radii = np.sum(radii)\n    print(f\"Medium scale sum: {sum_radii:.6f}\")\n    \n    # Stage 3: Fine scale - Individual circle optimization\n    print(\"Stage 3: Fine scale individual optimization...\")\n    centers, radii = fine_scale_optimize(centers, radii)\n    sum_radii = np.sum(radii)\n    print(f\"Fine scale sum: {sum_radii:.6f}\")\n    \n    # Stage 4: Ultra-fine scale - Micro-perturbations\n    print(\"Stage 4: Ultra-fine scale micro-perturbations...\")\n    centers, radii = ultra_fine_scale_optimize(centers, radii)\n    sum_radii = np.sum(radii)\n    print(f\"Ultra-fine scale sum: {sum_radii:.6f}\")\n    \n    # Final verification\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n    print(f\"Final sum: {sum_radii:.6f}\")\n    \n    return centers, radii, sum_radii\n\ndef compute_max_radii(centers):\n    \"\"\"Compute maximum valid radius for each circle.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Distance to boundaries\n        r_max = min(centers[i, 0], 1 - centers[i, 0], \n                   centers[i, 1], 1 - centers[i, 1])\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                r_max = min(r_max, (dist - radii[j]) / 1.0)\n        \n        radii[i] = max(0, r_max)\n    \n    return radii\n\ndef coarse_scale_init(n):\n    \"\"\"Initialize with hexagonal-inspired packing and global optimization.\"\"\"\n    \n    def objective(x):\n        centers = x.reshape(n, 2)\n        radii = compute_max_radii(centers)\n        return -np.sum(radii)\n    \n    # Start with hexagonal-inspired grid\n    cols = 6\n    rows = int(np.ceil(n / cols))\n    \n    best_sum = -np.inf\n    best_centers = None\n    \n    # Try multiple initial configurations\n    for offset_x in [0.0, 0.05, 0.1]:\n        for offset_y in [0.0, 0.05, 0.1]:\n            centers = []\n            for i in range(n):\n                row = i // cols\n                col = i % cols\n                \n                x = (col + 0.5) / cols + offset_x * (0.5 if row % 2 else 0)\n                y = (row + 0.5) / rows + offset_y\n                \n                x = np.clip(x, 0.1, 0.9)\n                y = np.clip(y, 0.1, 0.9)\n                centers.append([x, y])\n            \n            centers = np.array(centers)\n            \n            # Local optimization\n            result = minimize(\n                objective,\n                centers.flatten(),\n                method='L-BFGS-B',\n                bounds=[(0.05, 0.95)] * (2 * n),\n                options={'maxiter': 1000, 'ftol': 1e-8}\n            )\n            \n            if -result.fun > best_sum:\n                best_sum = -result.fun\n                best_centers = result.x.reshape(n, 2)\n    \n    # Global refinement with differential evolution\n    result = differential_evolution(\n        objective,\n        bounds=[(0.05, 0.95)] * (2 * n),\n        x0=best_centers.flatten(),\n        maxiter=300,\n        popsize=10,\n        atol=1e-8,\n        tol=1e-8,\n        workers=1\n    )\n    \n    centers = result.x.reshape(n, 2)\n    radii = compute_max_radii(centers)\n    \n    return centers, radii\n\ndef medium_scale_optimize(centers, radii):\n    \"\"\"Optimize by dividing into regions and optimizing each.\"\"\"\n    n = len(centers)\n    \n    # Divide into 4 quadrants\n    quadrants = [\n        (0.0, 0.5, 0.0, 0.5),  # Bottom-left\n        (0.5, 1.0, 0.0, 0.5),  # Bottom-right\n        (0.0, 0.5, 0.5, 1.0),  # Top-left\n        (0.5, 1.0, 0.5, 1.0),  # Top-right\n    ]\n    \n    best_centers = centers.copy()\n    best_sum = np.sum(radii)\n    \n    # Optimize each quadrant\n    for x_min, x_max, y_min, y_max in quadrants:\n        # Find circles in this quadrant\n        mask = ((centers[:, 0] >= x_min) & (centers[:, 0] <= x_max) &\n                (centers[:, 1] >= y_min) & (centers[:, 1] <= y_max))\n        indices = np.where(mask)[0]\n        \n        if len(indices) == 0:\n            continue\n        \n        def objective(x_local):\n            temp_centers = best_centers.copy()\n            temp_centers[indices] = x_local.reshape(-1, 2)\n            temp_radii = compute_max_radii(temp_centers)\n            return -np.sum(temp_radii)\n        \n        # Optimize circles in this quadrant\n        x0 = best_centers[indices].flatten()\n        bounds = []\n        for idx in indices:\n            bounds.extend([\n                (max(0.01, x_min), min(0.99, x_max)),\n                (max(0.01, y_min), min(0.99, y_max))\n            ])\n        \n        result = minimize(\n            objective,\n            x0,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': 500, 'ftol': 1e-9}\n        )\n        \n        temp_centers = best_centers.copy()\n        temp_centers[indices] = result.x.reshape(-1, 2)\n        temp_radii = compute_max_radii(temp_centers)\n        temp_sum = np.sum(temp_radii)\n        \n        if temp_sum > best_sum:\n            best_centers = temp_centers\n            best_sum = temp_sum\n    \n    # Optimize boundary circles\n    boundary_indices = []\n    for i in range(n):\n        x, y = best_centers[i]\n        if (0.4 <= x <= 0.6) or (0.4 <= y <= 0.6):\n            boundary_indices.append(i)\n    \n    if len(boundary_indices) > 0:\n        def objective(x_local):\n            temp_centers = best_centers.copy()\n            temp_centers[boundary_indices] = x_local.reshape(-1, 2)\n            temp_radii = compute_max_radii(temp_centers)\n            return -np.sum(temp_radii)\n        \n        x0 = best_centers[boundary_indices].flatten()\n        result = minimize(\n            objective,\n            x0,\n            method='L-BFGS-B',\n            bounds=[(0.01, 0.99)] * (2 * len(boundary_indices)),\n            options={'maxiter': 500, 'ftol': 1e-9}\n        )\n        \n        temp_centers = best_centers.copy()\n        temp_centers[boundary_indices] = result.x.reshape(-1, 2)\n        temp_radii = compute_max_radii(temp_centers)\n        temp_sum = np.sum(temp_radii)\n        \n        if temp_sum > best_sum:\n            best_centers = temp_centers\n            best_sum = temp_sum\n    \n    radii = compute_max_radii(best_centers)\n    return best_centers, radii\n\ndef fine_scale_optimize(centers, radii):\n    \"\"\"Optimize individual circles one at a time.\"\"\"\n    n = len(centers)\n    best_centers = centers.copy()\n    best_sum = np.sum(radii)\n    \n    # Multiple passes\n    for pass_num in range(3):\n        improved = False\n        \n        # Optimize each circle individually\n        for i in range(n):\n            def objective(pos):\n                temp_centers = best_centers.copy()\n                temp_centers[i] = pos\n                temp_radii = compute_max_radii(temp_centers)\n                return -np.sum(temp_radii)\n            \n            result = minimize(\n                objective,\n                best_centers[i],\n                method='L-BFGS-B',\n                bounds=[(0.01, 0.99), (0.01, 0.99)],\n                options={'maxiter': 200, 'ftol': 1e-10}\n            )\n            \n            temp_centers = best_centers.copy()\n            temp_centers[i] = result.x\n            temp_radii = compute_max_radii(temp_centers)\n            temp_sum = np.sum(temp_radii)\n            \n            if temp_sum > best_sum + 1e-10:\n                best_centers = temp_centers\n                best_sum = temp_sum\n                improved = True\n        \n        if not improved:\n            break\n    \n    radii = compute_max_radii(best_centers)\n    return best_centers, radii\n\ndef ultra_fine_scale_optimize(centers, radii):\n    \"\"\"Apply micro-perturbations to escape local optima.\"\"\"\n    n = len(centers)\n    best_centers = centers.copy()\n    best_sum = np.sum(radii)\n    \n    perturbation_sizes = [0.001, 0.0001, 0.00001]\n    \n    for perturb_size in perturbation_sizes:\n        for iteration in range(50):\n            # Try perturbing each circle\n            for i in range(n):\n                for dx in [-perturb_size, 0, perturb_size]:\n                    for dy in [-perturb_size, 0, perturb_size]:\n                        if dx == 0 and dy == 0:\n                            continue\n                        \n                        temp_centers = best_centers.copy()\n                        temp_centers[i, 0] = np.clip(temp_centers[i, 0] + dx, 0.01, 0.99)\n                        temp_centers[i, 1] = np.clip(temp_centers[i, 1] + dy, 0.01, 0.99)\n                        \n                        temp_radii = compute_max_radii(temp_centers)\n                        temp_sum = np.sum(temp_radii)\n                        \n                        if temp_sum > best_sum + 1e-12:\n                            best_centers = temp_centers\n                            best_sum = temp_sum\n            \n            # Final optimization after perturbations\n            def objective(x):\n                temp_centers = x.reshape(n, 2)\n                temp_radii = compute_max_radii(temp_centers)\n                return -np.sum(temp_radii)\n            \n            result = minimize(\n                objective,\n                best_centers.flatten(),\n                method='L-BFGS-B',\n                bounds=[(0.01, 0.99)] * (2 * n),\n                options={'maxiter': 100, 'ftol': 1e-12}\n            )\n            \n            temp_centers = result.x.reshape(n, 2)\n            temp_radii = compute_max_radii(temp_centers)\n            temp_sum = np.sum(temp_radii)\n            \n            if temp_sum > best_sum:\n                best_centers = temp_centers\n                best_sum = temp_sum\n    \n    radii = compute_max_radii(best_centers)\n    return best_centers, radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T16:12:14.310826",
  "cost_data": null
}