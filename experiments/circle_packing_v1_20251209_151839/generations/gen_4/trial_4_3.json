{
  "trial_id": "trial_4_3",
  "generation": 4,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom concurrent.futures import ProcessPoolExecutor, TimeoutError\nimport time\n\ndef construct_packing():\n    \"\"\"\n    Ensemble optimizer combining multiple approaches for n=26 circles.\n    \n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    n = 26\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if packing is valid.\"\"\"\n        if np.any(radii < 0):\n            return False\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n                centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n                return False\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-6:\n                    return False\n        return True\n    \n    def compute_radii(centers):\n        \"\"\"Compute maximum radii for given centers.\"\"\"\n        radii = np.ones(n)\n        for i in range(n):\n            r = min(centers[i, 0], 1 - centers[i, 0], \n                   centers[i, 1], 1 - centers[i, 1])\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    r = min(r, dist / 2)\n            radii[i] = max(0, r)\n        return radii\n    \n    def objective(x):\n        \"\"\"Objective to minimize (negative sum of radii).\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        penalty = 0\n        for i in range(n):\n            penalty += max(0, radii[i] - centers[i, 0]) ** 2\n            penalty += max(0, radii[i] - (1 - centers[i, 0])) ** 2\n            penalty += max(0, radii[i] - centers[i, 1]) ** 2\n            penalty += max(0, radii[i] - (1 - centers[i, 1])) ** 2\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    penalty += 1000 * overlap ** 2\n        return -np.sum(radii) + penalty\n    \n    # Method 1: Adaptive Multi-Start\n    def method_1():\n        best_sum = 0\n        best_centers = None\n        best_radii = None\n        \n        # Grid initialization\n        grid_size = int(np.ceil(np.sqrt(n)))\n        spacing = 1.0 / (grid_size + 1)\n        centers = np.zeros((n, 2))\n        idx = 0\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if idx >= n:\n                    break\n                centers[idx] = [(i + 1) * spacing, (j + 1) * spacing]\n                idx += 1\n        \n        # Multiple optimization rounds\n        for iteration in range(5):\n            if iteration > 0:\n                # Perturb\n                centers += np.random.randn(n, 2) * 0.05\n                centers = np.clip(centers, 0.1, 0.9)\n            \n            result = minimize(objective, centers.flatten(), method='L-BFGS-B',\n                            bounds=[(0.05, 0.95)] * (2 * n),\n                            options={'maxiter': 1000, 'ftol': 1e-9})\n            \n            centers_new = result.x.reshape(n, 2)\n            radii_new = compute_radii(centers_new)\n            \n            if is_valid(centers_new, radii_new):\n                sum_new = np.sum(radii_new)\n                if sum_new > best_sum:\n                    best_sum = sum_new\n                    best_centers = centers_new.copy()\n                    best_radii = radii_new.copy()\n        \n        return best_centers, best_radii, best_sum\n    \n    # Method 2: Sequential Refinement with Coordinate Descent\n    def method_2():\n        # Hexagonal packing initialization\n        rows = 5\n        cols = 6\n        spacing_x = 1.0 / (cols + 0.5)\n        spacing_y = 1.0 / (rows + 1)\n        centers = np.zeros((n, 2))\n        idx = 0\n        for i in range(rows):\n            offset = 0.5 * spacing_x if i % 2 == 1 else 0\n            for j in range(cols):\n                if idx >= n:\n                    break\n                centers[idx] = [offset + (j + 1) * spacing_x, (i + 1) * spacing_y]\n                idx += 1\n        centers = np.clip(centers, 0.1, 0.9)\n        \n        # Global optimization\n        result = minimize(objective, centers.flatten(), method='L-BFGS-B',\n                         bounds=[(0.05, 0.95)] * (2 * n),\n                         options={'maxiter': 2000, 'ftol': 1e-10})\n        centers = result.x.reshape(n, 2)\n        \n        # Coordinate descent\n        for _ in range(10):\n            for i in range(n):\n                def obj_single(pos):\n                    centers_temp = centers.copy()\n                    centers_temp[i] = pos\n                    return objective(centers_temp.flatten())\n                \n                result = minimize(obj_single, centers[i], method='L-BFGS-B',\n                                bounds=[(0.05, 0.95), (0.05, 0.95)],\n                                options={'maxiter': 100, 'ftol': 1e-10})\n                centers[i] = result.x\n        \n        radii = compute_radii(centers)\n        return centers, radii, np.sum(radii)\n    \n    # Method 3: High-Precision with Tight Tolerances\n    def method_3():\n        # Start with differential evolution\n        bounds = [(0.05, 0.95)] * (2 * n)\n        result_de = differential_evolution(objective, bounds, maxiter=300, \n                                          popsize=15, tol=1e-10, seed=42)\n        centers = result_de.x.reshape(n, 2)\n        \n        # Refine with multiple local optimizations\n        for _ in range(3):\n            result = minimize(objective, centers.flatten(), method='L-BFGS-B',\n                            bounds=bounds,\n                            options={'maxiter': 3000, 'ftol': 1e-12, 'gtol': 1e-12})\n            centers = result.x.reshape(n, 2)\n        \n        radii = compute_radii(centers)\n        return centers, radii, np.sum(radii)\n    \n    # Run all methods with timeout\n    def run_with_timeout(func, timeout=30):\n        try:\n            with ProcessPoolExecutor(max_workers=1) as executor:\n                future = executor.submit(func)\n                return future.result(timeout=timeout)\n        except TimeoutError:\n            return None, None, 0\n        except Exception:\n            return None, None, 0\n    \n    # Execute methods\n    results = []\n    \n    # Try method 1\n    try:\n        c1, r1, s1 = method_1()\n        if c1 is not None and is_valid(c1, r1):\n            results.append((c1, r1, s1))\n    except Exception:\n        pass\n    \n    # Try method 2\n    try:\n        c2, r2, s2 = method_2()\n        if c2 is not None and is_valid(c2, r2):\n            results.append((c2, r2, s2))\n    except Exception:\n        pass\n    \n    # Try method 3\n    try:\n        c3, r3, s3 = method_3()\n        if c3 is not None and is_valid(c3, r3):\n            results.append((c3, r3, s3))\n    except Exception:\n        pass\n    \n    # Select best result\n    if not results:\n        # Fallback: simple grid\n        grid_size = int(np.ceil(np.sqrt(n)))\n        spacing = 1.0 / (grid_size + 1)\n        centers = np.zeros((n, 2))\n        idx = 0\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if idx >= n:\n                    break\n                centers[idx] = [(i + 1) * spacing, (j + 1) * spacing]\n                idx += 1\n        radii = compute_radii(centers)\n        return centers, radii, np.sum(radii)\n    \n    best_centers, best_radii, best_sum = max(results, key=lambda x: x[2])\n    \n    # Ultra-refinement: Combined post-processing\n    centers = best_centers.copy()\n    \n    # Phase 1: Gradient-based refinement\n    for _ in range(5):\n        result = minimize(objective, centers.flatten(), method='L-BFGS-B',\n                         bounds=[(0.05, 0.95)] * (2 * n),\n                         options={'maxiter': 2000, 'ftol': 1e-12, 'gtol': 1e-12})\n        centers = result.x.reshape(n, 2)\n    \n    # Phase 2: Individual circle optimization\n    for _ in range(5):\n        for i in range(n):\n            def obj_single(pos):\n                centers_temp = centers.copy()\n                centers_temp[i] = pos\n                return objective(centers_temp.flatten())\n            \n            result = minimize(obj_single, centers[i], method='L-BFGS-B',\n                            bounds=[(0.05, 0.95), (0.05, 0.95)],\n                            options={'maxiter': 200, 'ftol': 1e-12})\n            centers[i] = result.x\n    \n    # Phase 3: Pairwise optimization\n    for i in range(n):\n        for j in range(i + 1, min(i + 5, n)):\n            def obj_pair(x):\n                centers_temp = centers.copy()\n                centers_temp[i] = x[:2]\n                centers_temp[j] = x[2:]\n                return objective(centers_temp.flatten())\n            \n            x0 = np.concatenate([centers[i], centers[j]])\n            result = minimize(obj_pair, x0, method='L-BFGS-B',\n                            bounds=[(0.05, 0.95)] * 4,\n                            options={'maxiter': 100, 'ftol': 1e-12})\n            centers[i] = result.x[:2]\n            centers[j] = result.x[2:]\n    \n    # Final computation\n    radii = compute_radii(centers)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 1272.0656549930573,
    "error": "Timeout after 300s"
  },
  "prompt": "Create an ensemble optimizer that runs multiple methods and selects best.\n\nStrategy:\n1. Run trial_3_3's approach (adaptive multi-start)\n2. Run trial_3_5's approach (sequential refinement with coordinate descent)\n3. Run trial_3_6's approach (high-precision with tight tolerances)\n4. For each approach, save the best result\n5. Take the absolute best across all three\n6. Apply combined post-processing from all three methods\n7. Final ultra-refinement with all techniques combined\n\nUse parallel execution where possible.\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom concurrent.futures import ProcessPoolExecutor, TimeoutError\nimport time\n\ndef construct_packing():\n    \"\"\"\n    Ensemble optimizer combining multiple approaches for n=26 circles.\n    \n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    n = 26\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if packing is valid.\"\"\"\n        if np.any(radii < 0):\n            return False\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n                centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n                return False\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-6:\n                    return False\n        return True\n    \n    def compute_radii(centers):\n        \"\"\"Compute maximum radii for given centers.\"\"\"\n        radii = np.ones(n)\n        for i in range(n):\n            r = min(centers[i, 0], 1 - centers[i, 0], \n                   centers[i, 1], 1 - centers[i, 1])\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    r = min(r, dist / 2)\n            radii[i] = max(0, r)\n        return radii\n    \n    def objective(x):\n        \"\"\"Objective to minimize (negative sum of radii).\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        penalty = 0\n        for i in range(n):\n            penalty += max(0, radii[i] - centers[i, 0]) ** 2\n            penalty += max(0, radii[i] - (1 - centers[i, 0])) ** 2\n            penalty += max(0, radii[i] - centers[i, 1]) ** 2\n            penalty += max(0, radii[i] - (1 - centers[i, 1])) ** 2\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    penalty += 1000 * overlap ** 2\n        return -np.sum(radii) + penalty\n    \n    # Method 1: Adaptive Multi-Start\n    def method_1():\n        best_sum = 0\n        best_centers = None\n        best_radii = None\n        \n        # Grid initialization\n        grid_size = int(np.ceil(np.sqrt(n)))\n        spacing = 1.0 / (grid_size + 1)\n        centers = np.zeros((n, 2))\n        idx = 0\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if idx >= n:\n                    break\n                centers[idx] = [(i + 1) * spacing, (j + 1) * spacing]\n                idx += 1\n        \n        # Multiple optimization rounds\n        for iteration in range(5):\n            if iteration > 0:\n                # Perturb\n                centers += np.random.randn(n, 2) * 0.05\n                centers = np.clip(centers, 0.1, 0.9)\n            \n            result = minimize(objective, centers.flatten(), method='L-BFGS-B',\n                            bounds=[(0.05, 0.95)] * (2 * n),\n                            options={'maxiter': 1000, 'ftol': 1e-9})\n            \n            centers_new = result.x.reshape(n, 2)\n            radii_new = compute_radii(centers_new)\n            \n            if is_valid(centers_new, radii_new):\n                sum_new = np.sum(radii_new)\n                if sum_new > best_sum:\n                    best_sum = sum_new\n                    best_centers = centers_new.copy()\n                    best_radii = radii_new.copy()\n        \n        return best_centers, best_radii, best_sum\n    \n    # Method 2: Sequential Refinement with Coordinate Descent\n    def method_2():\n        # Hexagonal packing initialization\n        rows = 5\n        cols = 6\n        spacing_x = 1.0 / (cols + 0.5)\n        spacing_y = 1.0 / (rows + 1)\n        centers = np.zeros((n, 2))\n        idx = 0\n        for i in range(rows):\n            offset = 0.5 * spacing_x if i % 2 == 1 else 0\n            for j in range(cols):\n                if idx >= n:\n                    break\n                centers[idx] = [offset + (j + 1) * spacing_x, (i + 1) * spacing_y]\n                idx += 1\n        centers = np.clip(centers, 0.1, 0.9)\n        \n        # Global optimization\n        result = minimize(objective, centers.flatten(), method='L-BFGS-B',\n                         bounds=[(0.05, 0.95)] * (2 * n),\n                         options={'maxiter': 2000, 'ftol': 1e-10})\n        centers = result.x.reshape(n, 2)\n        \n        # Coordinate descent\n        for _ in range(10):\n            for i in range(n):\n                def obj_single(pos):\n                    centers_temp = centers.copy()\n                    centers_temp[i] = pos\n                    return objective(centers_temp.flatten())\n                \n                result = minimize(obj_single, centers[i], method='L-BFGS-B',\n                                bounds=[(0.05, 0.95), (0.05, 0.95)],\n                                options={'maxiter': 100, 'ftol': 1e-10})\n                centers[i] = result.x\n        \n        radii = compute_radii(centers)\n        return centers, radii, np.sum(radii)\n    \n    # Method 3: High-Precision with Tight Tolerances\n    def method_3():\n        # Start with differential evolution\n        bounds = [(0.05, 0.95)] * (2 * n)\n        result_de = differential_evolution(objective, bounds, maxiter=300, \n                                          popsize=15, tol=1e-10, seed=42)\n        centers = result_de.x.reshape(n, 2)\n        \n        # Refine with multiple local optimizations\n        for _ in range(3):\n            result = minimize(objective, centers.flatten(), method='L-BFGS-B',\n                            bounds=bounds,\n                            options={'maxiter': 3000, 'ftol': 1e-12, 'gtol': 1e-12})\n            centers = result.x.reshape(n, 2)\n        \n        radii = compute_radii(centers)\n        return centers, radii, np.sum(radii)\n    \n    # Run all methods with timeout\n    def run_with_timeout(func, timeout=30):\n        try:\n            with ProcessPoolExecutor(max_workers=1) as executor:\n                future = executor.submit(func)\n                return future.result(timeout=timeout)\n        except TimeoutError:\n            return None, None, 0\n        except Exception:\n            return None, None, 0\n    \n    # Execute methods\n    results = []\n    \n    # Try method 1\n    try:\n        c1, r1, s1 = method_1()\n        if c1 is not None and is_valid(c1, r1):\n            results.append((c1, r1, s1))\n    except Exception:\n        pass\n    \n    # Try method 2\n    try:\n        c2, r2, s2 = method_2()\n        if c2 is not None and is_valid(c2, r2):\n            results.append((c2, r2, s2))\n    except Exception:\n        pass\n    \n    # Try method 3\n    try:\n        c3, r3, s3 = method_3()\n        if c3 is not None and is_valid(c3, r3):\n            results.append((c3, r3, s3))\n    except Exception:\n        pass\n    \n    # Select best result\n    if not results:\n        # Fallback: simple grid\n        grid_size = int(np.ceil(np.sqrt(n)))\n        spacing = 1.0 / (grid_size + 1)\n        centers = np.zeros((n, 2))\n        idx = 0\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if idx >= n:\n                    break\n                centers[idx] = [(i + 1) * spacing, (j + 1) * spacing]\n                idx += 1\n        radii = compute_radii(centers)\n        return centers, radii, np.sum(radii)\n    \n    best_centers, best_radii, best_sum = max(results, key=lambda x: x[2])\n    \n    # Ultra-refinement: Combined post-processing\n    centers = best_centers.copy()\n    \n    # Phase 1: Gradient-based refinement\n    for _ in range(5):\n        result = minimize(objective, centers.flatten(), method='L-BFGS-B',\n                         bounds=[(0.05, 0.95)] * (2 * n),\n                         options={'maxiter': 2000, 'ftol': 1e-12, 'gtol': 1e-12})\n        centers = result.x.reshape(n, 2)\n    \n    # Phase 2: Individual circle optimization\n    for _ in range(5):\n        for i in range(n):\n            def obj_single(pos):\n                centers_temp = centers.copy()\n                centers_temp[i] = pos\n                return objective(centers_temp.flatten())\n            \n            result = minimize(obj_single, centers[i], method='L-BFGS-B',\n                            bounds=[(0.05, 0.95), (0.05, 0.95)],\n                            options={'maxiter': 200, 'ftol': 1e-12})\n            centers[i] = result.x\n    \n    # Phase 3: Pairwise optimization\n    for i in range(n):\n        for j in range(i + 1, min(i + 5, n)):\n            def obj_pair(x):\n                centers_temp = centers.copy()\n                centers_temp[i] = x[:2]\n                centers_temp[j] = x[2:]\n                return objective(centers_temp.flatten())\n            \n            x0 = np.concatenate([centers[i], centers[j]])\n            result = minimize(obj_pair, x0, method='L-BFGS-B',\n                            bounds=[(0.05, 0.95)] * 4,\n                            options={'maxiter': 100, 'ftol': 1e-12})\n            centers[i] = result.x[:2]\n            centers[j] = result.x[2:]\n    \n    # Final computation\n    radii = compute_radii(centers)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T16:12:12.671835",
  "cost_data": null
}