{
  "trial_id": "trial_4_14",
  "generation": 4,
  "parent_id": "trial_3_3",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses analytical gradients for fast, precise optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Start from trial_3_3's best known solution\n    initial_centers = np.array([\n        [0.09523810, 0.09523810], [0.28571429, 0.09523810], [0.47619048, 0.09523810],\n        [0.66666667, 0.09523810], [0.85714286, 0.09523810], [0.09523810, 0.28571429],\n        [0.28571429, 0.28571429], [0.47619048, 0.28571429], [0.66666667, 0.28571429],\n        [0.85714286, 0.28571429], [0.09523810, 0.47619048], [0.28571429, 0.47619048],\n        [0.47619048, 0.47619048], [0.66666667, 0.47619048], [0.85714286, 0.47619048],\n        [0.09523810, 0.66666667], [0.28571429, 0.66666667], [0.47619048, 0.66666667],\n        [0.66666667, 0.66666667], [0.85714286, 0.66666667], [0.09523810, 0.85714286],\n        [0.28571429, 0.85714286], [0.47619048, 0.85714286], [0.66666667, 0.85714286],\n        [0.85714286, 0.85714286], [0.50000000, 0.50000000]\n    ])\n    \n    initial_radii = np.full(n, 0.09523810)\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii (maximize sum).\"\"\"\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def objective_grad(x):\n        \"\"\"Analytical gradient of objective.\"\"\"\n        grad = np.zeros(3*n)\n        grad[2*n:] = -1.0  # d(-sum(r))/dr_i = -1\n        return grad\n    \n    def boundary_constraints(x):\n        \"\"\"All circles must be inside [0,1]x[0,1].\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        constraints = np.zeros(4*n)\n        # x - r >= 0\n        constraints[0*n:1*n] = centers[:, 0] - radii\n        # x + r <= 1\n        constraints[1*n:2*n] = 1.0 - centers[:, 0] - radii\n        # y - r >= 0\n        constraints[2*n:3*n] = centers[:, 1] - radii\n        # y + r <= 1\n        constraints[3*n:4*n] = 1.0 - centers[:, 1] - radii\n        \n        return constraints\n    \n    def boundary_constraints_jac(x):\n        \"\"\"Analytical Jacobian of boundary constraints.\"\"\"\n        jac = np.zeros((4*n, 3*n))\n        \n        for i in range(n):\n            # x - r >= 0: dx/dx_i = 1, dr/dr_i = -1\n            jac[i, 2*i] = 1.0\n            jac[i, 2*n + i] = -1.0\n            \n            # 1 - x - r >= 0: dx/dx_i = -1, dr/dr_i = -1\n            jac[n + i, 2*i] = -1.0\n            jac[n + i, 2*n + i] = -1.0\n            \n            # y - r >= 0: dy/dy_i = 1, dr/dr_i = -1\n            jac[2*n + i, 2*i + 1] = 1.0\n            jac[2*n + i, 2*n + i] = -1.0\n            \n            # 1 - y - r >= 0: dy/dy_i = -1, dr/dr_i = -1\n            jac[3*n + i, 2*i + 1] = -1.0\n            jac[3*n + i, 2*n + i] = -1.0\n        \n        return jac\n    \n    def overlap_constraints(x):\n        \"\"\"No two circles may overlap.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        num_pairs = n * (n - 1) // 2\n        constraints = np.zeros(num_pairs)\n        \n        idx = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                # dist - (r_i + r_j) >= 0\n                constraints[idx] = dist - radii[i] - radii[j]\n                idx += 1\n        \n        return constraints\n    \n    def overlap_constraints_jac(x):\n        \"\"\"Analytical Jacobian of overlap constraints.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        num_pairs = n * (n - 1) // 2\n        jac = np.zeros((num_pairs, 3*n))\n        \n        idx = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                \n                if dist > 1e-10:\n                    # d(dist)/dx_i = (x_i - x_j) / dist\n                    # d(dist)/dy_i = (y_i - y_j) / dist\n                    jac[idx, 2*i] = diff[0] / dist\n                    jac[idx, 2*i + 1] = diff[1] / dist\n                    jac[idx, 2*j] = -diff[0] / dist\n                    jac[idx, 2*j + 1] = -diff[1] / dist\n                \n                # d(-r_i)/dr_i = -1, d(-r_j)/dr_j = -1\n                jac[idx, 2*n + i] = -1.0\n                jac[idx, 2*n + j] = -1.0\n                \n                idx += 1\n        \n        return jac\n    \n    # Multi-stage optimization with increasing precision\n    x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n    \n    boundary_constraint = NonlinearConstraint(\n        boundary_constraints,\n        0, np.inf,\n        jac=boundary_constraints_jac\n    )\n    \n    overlap_constraint = NonlinearConstraint(\n        overlap_constraints,\n        0, np.inf,\n        jac=overlap_constraints_jac\n    )\n    \n    bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n    \n    # Stage 1: Moderate precision\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        jac=objective_grad,\n        bounds=bounds,\n        constraints=[boundary_constraint, overlap_constraint],\n        options={'ftol': 1e-9, 'maxiter': 1000}\n    )\n    \n    # Stage 2: High precision\n    result = minimize(\n        objective,\n        result.x,\n        method='SLSQP',\n        jac=objective_grad,\n        bounds=bounds,\n        constraints=[boundary_constraint, overlap_constraint],\n        options={'ftol': 1e-12, 'maxiter': 1000}\n    )\n    \n    # Stage 3: Ultra-high precision\n    result = minimize(\n        objective,\n        result.x,\n        method='SLSQP',\n        jac=objective_grad,\n        bounds=bounds,\n        constraints=[boundary_constraint, overlap_constraint],\n        options={'ftol': 1e-15, 'maxiter': 2000}\n    )\n    \n    centers = result.x[:2*n].reshape(n, 2)\n    radii = result.x[2*n:]\n    \n    # Analytical radius expansion\n    # For each circle, find maximum expansion that maintains feasibility\n    max_iterations = 50\n    for iteration in range(max_iterations):\n        improved = False\n        \n        for i in range(n):\n            # Calculate maximum possible radius for circle i\n            # Boundary constraints\n            max_r_boundary = min(\n                centers[i, 0],\n                1.0 - centers[i, 0],\n                centers[i, 1],\n                1.0 - centers[i, 1]\n            )\n            \n            # Overlap constraints\n            max_r_overlap = np.inf\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r_ij = dist - radii[j]\n                    max_r_overlap = min(max_r_overlap, max_r_ij)\n            \n            # New radius with safety margin\n            safety = 1e-10\n            new_radius = min(max_r_boundary, max_r_overlap) - safety\n            \n            if new_radius > radii[i] + 1e-12:\n                radii[i] = new_radius\n                improved = True\n        \n        if not improved:\n            break\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.6245102884063747,
    "target_ratio": 0.996019084784203,
    "combined_score": 0.996019084784203,
    "eval_time": 0.325991153717041,
    "error": null
  },
  "prompt": "Analytical gradient optimization.\n\nStrategy:\n1. Start with trial_3_3's best solution\n2. Implement analytical gradients for faster convergence:\n   - Gradient of objective (trivial: -1 for each radius)\n   - Jacobian of constraints (geometric derivatives)\n3. Use these in SLSQP optimization\n4. Multiple passes with increasing precision\n5. Final ultra-high precision pass (ftol=1e-15)\n6. Radius expansion with analytical bounds\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses analytical gradients for fast, precise optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Start from trial_3_3's best known solution\n    initial_centers = np.array([\n        [0.09523810, 0.09523810], [0.28571429, 0.09523810], [0.47619048, 0.09523810],\n        [0.66666667, 0.09523810], [0.85714286, 0.09523810], [0.09523810, 0.28571429],\n        [0.28571429, 0.28571429], [0.47619048, 0.28571429], [0.66666667, 0.28571429],\n        [0.85714286, 0.28571429], [0.09523810, 0.47619048], [0.28571429, 0.47619048],\n        [0.47619048, 0.47619048], [0.66666667, 0.47619048], [0.85714286, 0.47619048],\n        [0.09523810, 0.66666667], [0.28571429, 0.66666667], [0.47619048, 0.66666667],\n        [0.66666667, 0.66666667], [0.85714286, 0.66666667], [0.09523810, 0.85714286],\n        [0.28571429, 0.85714286], [0.47619048, 0.85714286], [0.66666667, 0.85714286],\n        [0.85714286, 0.85714286], [0.50000000, 0.50000000]\n    ])\n    \n    initial_radii = np.full(n, 0.09523810)\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii (maximize sum).\"\"\"\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def objective_grad(x):\n        \"\"\"Analytical gradient of objective.\"\"\"\n        grad = np.zeros(3*n)\n        grad[2*n:] = -1.0  # d(-sum(r))/dr_i = -1\n        return grad\n    \n    def boundary_constraints(x):\n        \"\"\"All circles must be inside [0,1]x[0,1].\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        constraints = np.zeros(4*n)\n        # x - r >= 0\n        constraints[0*n:1*n] = centers[:, 0] - radii\n        # x + r <= 1\n        constraints[1*n:2*n] = 1.0 - centers[:, 0] - radii\n        # y - r >= 0\n        constraints[2*n:3*n] = centers[:, 1] - radii\n        # y + r <= 1\n        constraints[3*n:4*n] = 1.0 - centers[:, 1] - radii\n        \n        return constraints\n    \n    def boundary_constraints_jac(x):\n        \"\"\"Analytical Jacobian of boundary constraints.\"\"\"\n        jac = np.zeros((4*n, 3*n))\n        \n        for i in range(n):\n            # x - r >= 0: dx/dx_i = 1, dr/dr_i = -1\n            jac[i, 2*i] = 1.0\n            jac[i, 2*n + i] = -1.0\n            \n            # 1 - x - r >= 0: dx/dx_i = -1, dr/dr_i = -1\n            jac[n + i, 2*i] = -1.0\n            jac[n + i, 2*n + i] = -1.0\n            \n            # y - r >= 0: dy/dy_i = 1, dr/dr_i = -1\n            jac[2*n + i, 2*i + 1] = 1.0\n            jac[2*n + i, 2*n + i] = -1.0\n            \n            # 1 - y - r >= 0: dy/dy_i = -1, dr/dr_i = -1\n            jac[3*n + i, 2*i + 1] = -1.0\n            jac[3*n + i, 2*n + i] = -1.0\n        \n        return jac\n    \n    def overlap_constraints(x):\n        \"\"\"No two circles may overlap.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        num_pairs = n * (n - 1) // 2\n        constraints = np.zeros(num_pairs)\n        \n        idx = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                # dist - (r_i + r_j) >= 0\n                constraints[idx] = dist - radii[i] - radii[j]\n                idx += 1\n        \n        return constraints\n    \n    def overlap_constraints_jac(x):\n        \"\"\"Analytical Jacobian of overlap constraints.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        num_pairs = n * (n - 1) // 2\n        jac = np.zeros((num_pairs, 3*n))\n        \n        idx = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                \n                if dist > 1e-10:\n                    # d(dist)/dx_i = (x_i - x_j) / dist\n                    # d(dist)/dy_i = (y_i - y_j) / dist\n                    jac[idx, 2*i] = diff[0] / dist\n                    jac[idx, 2*i + 1] = diff[1] / dist\n                    jac[idx, 2*j] = -diff[0] / dist\n                    jac[idx, 2*j + 1] = -diff[1] / dist\n                \n                # d(-r_i)/dr_i = -1, d(-r_j)/dr_j = -1\n                jac[idx, 2*n + i] = -1.0\n                jac[idx, 2*n + j] = -1.0\n                \n                idx += 1\n        \n        return jac\n    \n    # Multi-stage optimization with increasing precision\n    x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n    \n    boundary_constraint = NonlinearConstraint(\n        boundary_constraints,\n        0, np.inf,\n        jac=boundary_constraints_jac\n    )\n    \n    overlap_constraint = NonlinearConstraint(\n        overlap_constraints,\n        0, np.inf,\n        jac=overlap_constraints_jac\n    )\n    \n    bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n    \n    # Stage 1: Moderate precision\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        jac=objective_grad,\n        bounds=bounds,\n        constraints=[boundary_constraint, overlap_constraint],\n        options={'ftol': 1e-9, 'maxiter': 1000}\n    )\n    \n    # Stage 2: High precision\n    result = minimize(\n        objective,\n        result.x,\n        method='SLSQP',\n        jac=objective_grad,\n        bounds=bounds,\n        constraints=[boundary_constraint, overlap_constraint],\n        options={'ftol': 1e-12, 'maxiter': 1000}\n    )\n    \n    # Stage 3: Ultra-high precision\n    result = minimize(\n        objective,\n        result.x,\n        method='SLSQP',\n        jac=objective_grad,\n        bounds=bounds,\n        constraints=[boundary_constraint, overlap_constraint],\n        options={'ftol': 1e-15, 'maxiter': 2000}\n    )\n    \n    centers = result.x[:2*n].reshape(n, 2)\n    radii = result.x[2*n:]\n    \n    # Analytical radius expansion\n    # For each circle, find maximum expansion that maintains feasibility\n    max_iterations = 50\n    for iteration in range(max_iterations):\n        improved = False\n        \n        for i in range(n):\n            # Calculate maximum possible radius for circle i\n            # Boundary constraints\n            max_r_boundary = min(\n                centers[i, 0],\n                1.0 - centers[i, 0],\n                centers[i, 1],\n                1.0 - centers[i, 1]\n            )\n            \n            # Overlap constraints\n            max_r_overlap = np.inf\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r_ij = dist - radii[j]\n                    max_r_overlap = min(max_r_overlap, max_r_ij)\n            \n            # New radius with safety margin\n            safety = 1e-10\n            new_radius = min(max_r_boundary, max_r_overlap) - safety\n            \n            if new_radius > radii[i] + 1e-12:\n                radii[i] = new_radius\n                improved = True\n        \n        if not improved:\n            break\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:50:57.447261",
  "cost_data": null
}