{
  "trial_id": "trial_4_13",
  "generation": 4,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom concurrent.futures import ProcessPoolExecutor, TimeoutError\nimport multiprocessing as mp\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def pack_to_solution(x):\n        \"\"\"Convert flat array to centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def solution_to_pack(centers, radii):\n        \"\"\"Convert centers and radii to flat array.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def constraints_penalty(x):\n        \"\"\"Calculate constraint violations.\"\"\"\n        centers, radii = pack_to_solution(x)\n        penalty = 0.0\n        \n        # Boundary constraints\n        for i in range(n):\n            penalty += max(0, radii[i] - centers[i, 0])**2\n            penalty += max(0, radii[i] - centers[i, 1])**2\n            penalty += max(0, centers[i, 0] + radii[i] - 1)**2\n            penalty += max(0, centers[i, 1] + radii[i] - 1)**2\n            penalty += max(0, -radii[i])**2\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    penalty += overlap**2\n        \n        return penalty\n    \n    def objective_with_penalty(x, penalty_weight=1000):\n        \"\"\"Objective with penalty for constraint violations.\"\"\"\n        return objective(x) + penalty_weight * constraints_penalty(x)\n    \n    def is_valid(x):\n        \"\"\"Check if solution satisfies all constraints.\"\"\"\n        centers, radii = pack_to_solution(x)\n        \n        # Check boundaries\n        for i in range(n):\n            if radii[i] < 0:\n                return False\n            if centers[i, 0] - radii[i] < -1e-6 or centers[i, 0] + radii[i] > 1 + 1e-6:\n                return False\n            if centers[i, 1] - radii[i] < -1e-6 or centers[i, 1] + radii[i] > 1 + 1e-6:\n                return False\n        \n        # Check overlaps\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-6:\n                    return False\n        \n        return True\n    \n    # Method 1: Adaptive multi-start with SLSQP\n    def method1():\n        best_x = None\n        best_val = float('inf')\n        \n        for attempt in range(15):\n            # Grid-based initialization\n            grid_size = int(np.ceil(np.sqrt(n)))\n            centers_init = []\n            for i in range(n):\n                row = i // grid_size\n                col = i % grid_size\n                x = (col + 0.5 + np.random.uniform(-0.2, 0.2)) / grid_size\n                y = (row + 0.5 + np.random.uniform(-0.2, 0.2)) / grid_size\n                centers_init.append([x, y])\n            centers_init = np.array(centers_init)\n            radii_init = np.full(n, 0.08 + np.random.uniform(-0.02, 0.02))\n            x0 = solution_to_pack(centers_init, radii_init)\n            \n            # Optimize\n            result = minimize(\n                objective_with_penalty,\n                x0,\n                method='SLSQP',\n                options={'maxiter': 2000, 'ftol': 1e-9}\n            )\n            \n            if result.fun < best_val:\n                best_val = result.fun\n                best_x = result.x\n        \n        return best_x\n    \n    # Method 2: Sequential refinement\n    def method2():\n        # Start with hexagonal packing\n        centers = []\n        hex_spacing = 0.19\n        for row in range(6):\n            y = 0.1 + row * hex_spacing\n            offset = (row % 2) * hex_spacing / 2\n            for col in range(5):\n                x = 0.1 + col * hex_spacing + offset\n                if len(centers) < n:\n                    centers.append([x, y])\n        centers = np.array(centers[:n])\n        radii = np.full(n, 0.09)\n        x0 = solution_to_pack(centers, radii)\n        \n        # Multi-stage optimization\n        for stage, penalty in enumerate([10000, 5000, 2000, 1000]):\n            result = minimize(\n                lambda x: objective_with_penalty(x, penalty),\n                x0,\n                method='SLSQP',\n                options={'maxiter': 1500, 'ftol': 1e-9}\n            )\n            x0 = result.x\n        \n        return x0\n    \n    # Method 3: High-precision trust-constr\n    def method3():\n        # Tight grid initialization\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers_init = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            centers_init.append([x, y])\n        centers_init = np.array(centers_init[:n])\n        radii_init = np.full(n, 0.085)\n        x0 = solution_to_pack(centers_init, radii_init)\n        \n        result = minimize(\n            objective_with_penalty,\n            x0,\n            method='trust-constr',\n            options={'maxiter': 2000, 'gtol': 1e-9, 'xtol': 1e-9}\n        )\n        \n        return result.x\n    \n    # Method 4: Pure SLSQP with many restarts\n    def method4():\n        best_x = None\n        best_val = float('inf')\n        \n        for attempt in range(20):\n            # Random initialization\n            centers_init = np.random.uniform(0.1, 0.9, (n, 2))\n            radii_init = np.random.uniform(0.06, 0.1, n)\n            x0 = solution_to_pack(centers_init, radii_init)\n            \n            result = minimize(\n                objective_with_penalty,\n                x0,\n                method='SLSQP',\n                options={'maxiter': 1500, 'ftol': 1e-9}\n            )\n            \n            if result.fun < best_val:\n                best_val = result.fun\n                best_x = result.x\n        \n        return best_x\n    \n    # Method 5: Differential evolution followed by local refinement\n    def method5():\n        bounds = [(0.05, 0.95)] * (2*n) + [(0.01, 0.15)] * n\n        \n        result = differential_evolution(\n            objective_with_penalty,\n            bounds,\n            maxiter=300,\n            popsize=15,\n            seed=42,\n            atol=1e-9,\n            tol=1e-9\n        )\n        \n        # Refine with SLSQP\n        result2 = minimize(\n            objective_with_penalty,\n            result.x,\n            method='SLSQP',\n            options={'maxiter': 2000, 'ftol': 1e-9}\n        )\n        \n        return result2.x\n    \n    # Run all methods\n    methods = [method1, method2, method3, method4, method5]\n    results = []\n    \n    for i, method in enumerate(methods):\n        try:\n            x = method()\n            if x is not None:\n                val = objective(x)\n                results.append((x, val, i))\n        except Exception as e:\n            pass\n    \n    # Sort by objective value\n    results.sort(key=lambda r: r[1])\n    \n    # Take top 3\n    top_results = results[:min(3, len(results))]\n    \n    if not top_results:\n        # Fallback: simple grid packing\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            centers.append([x, y])\n        centers = np.array(centers)\n        radii = np.full(n, 0.08)\n        return centers, radii, np.sum(radii)\n    \n    # Cross-pollination: combine features from top 3\n    if len(top_results) >= 3:\n        x1, _, _ = top_results[0]\n        x2, _, _ = top_results[1]\n        x3, _, _ = top_results[2]\n        \n        # Weighted combination\n        x_combined = 0.5 * x1 + 0.3 * x2 + 0.2 * x3\n    else:\n        x_combined = top_results[0][0]\n    \n    # Final refinement\n    for penalty in [1000, 500, 200]:\n        result = minimize(\n            lambda x: objective_with_penalty(x, penalty),\n            x_combined,\n            method='SLSQP',\n            options={'maxiter': 2000, 'ftol': 1e-10}\n        )\n        x_combined = result.x\n    \n    # Additional refinement with trust-constr\n    result = minimize(\n        objective_with_penalty,\n        x_combined,\n        method='trust-constr',\n        options={'maxiter': 1500, 'gtol': 1e-10, 'xtol': 1e-10}\n    )\n    x_final = result.x\n    \n    # Choose best between combined and top individual\n    candidates = [x_final] + [r[0] for r in top_results]\n    best_x = min(candidates, key=lambda x: objective(x) if is_valid(x) else float('inf'))\n    \n    centers, radii = pack_to_solution(best_x)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 1272.064787864685,
    "error": "Timeout after 300s"
  },
  "prompt": "Parallel multi-method optimization.\n\nStrategy:\n1. Run 5 different optimization methods in parallel:\n   - trial_3_3's adaptive multi-start\n   - trial_3_5's sequential refinement\n   - trial_3_6's high-precision\n   - Pure SLSQP with many restarts\n   - trust-constr with tight tolerances\n2. For each method, save best result\n3. Take top 3 results\n4. Apply cross-pollination: combine features\n5. Final refinement on combined solution\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom concurrent.futures import ProcessPoolExecutor, TimeoutError\nimport multiprocessing as mp\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def pack_to_solution(x):\n        \"\"\"Convert flat array to centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def solution_to_pack(centers, radii):\n        \"\"\"Convert centers and radii to flat array.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def constraints_penalty(x):\n        \"\"\"Calculate constraint violations.\"\"\"\n        centers, radii = pack_to_solution(x)\n        penalty = 0.0\n        \n        # Boundary constraints\n        for i in range(n):\n            penalty += max(0, radii[i] - centers[i, 0])**2\n            penalty += max(0, radii[i] - centers[i, 1])**2\n            penalty += max(0, centers[i, 0] + radii[i] - 1)**2\n            penalty += max(0, centers[i, 1] + radii[i] - 1)**2\n            penalty += max(0, -radii[i])**2\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    penalty += overlap**2\n        \n        return penalty\n    \n    def objective_with_penalty(x, penalty_weight=1000):\n        \"\"\"Objective with penalty for constraint violations.\"\"\"\n        return objective(x) + penalty_weight * constraints_penalty(x)\n    \n    def is_valid(x):\n        \"\"\"Check if solution satisfies all constraints.\"\"\"\n        centers, radii = pack_to_solution(x)\n        \n        # Check boundaries\n        for i in range(n):\n            if radii[i] < 0:\n                return False\n            if centers[i, 0] - radii[i] < -1e-6 or centers[i, 0] + radii[i] > 1 + 1e-6:\n                return False\n            if centers[i, 1] - radii[i] < -1e-6 or centers[i, 1] + radii[i] > 1 + 1e-6:\n                return False\n        \n        # Check overlaps\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-6:\n                    return False\n        \n        return True\n    \n    # Method 1: Adaptive multi-start with SLSQP\n    def method1():\n        best_x = None\n        best_val = float('inf')\n        \n        for attempt in range(15):\n            # Grid-based initialization\n            grid_size = int(np.ceil(np.sqrt(n)))\n            centers_init = []\n            for i in range(n):\n                row = i // grid_size\n                col = i % grid_size\n                x = (col + 0.5 + np.random.uniform(-0.2, 0.2)) / grid_size\n                y = (row + 0.5 + np.random.uniform(-0.2, 0.2)) / grid_size\n                centers_init.append([x, y])\n            centers_init = np.array(centers_init)\n            radii_init = np.full(n, 0.08 + np.random.uniform(-0.02, 0.02))\n            x0 = solution_to_pack(centers_init, radii_init)\n            \n            # Optimize\n            result = minimize(\n                objective_with_penalty,\n                x0,\n                method='SLSQP',\n                options={'maxiter': 2000, 'ftol': 1e-9}\n            )\n            \n            if result.fun < best_val:\n                best_val = result.fun\n                best_x = result.x\n        \n        return best_x\n    \n    # Method 2: Sequential refinement\n    def method2():\n        # Start with hexagonal packing\n        centers = []\n        hex_spacing = 0.19\n        for row in range(6):\n            y = 0.1 + row * hex_spacing\n            offset = (row % 2) * hex_spacing / 2\n            for col in range(5):\n                x = 0.1 + col * hex_spacing + offset\n                if len(centers) < n:\n                    centers.append([x, y])\n        centers = np.array(centers[:n])\n        radii = np.full(n, 0.09)\n        x0 = solution_to_pack(centers, radii)\n        \n        # Multi-stage optimization\n        for stage, penalty in enumerate([10000, 5000, 2000, 1000]):\n            result = minimize(\n                lambda x: objective_with_penalty(x, penalty),\n                x0,\n                method='SLSQP',\n                options={'maxiter': 1500, 'ftol': 1e-9}\n            )\n            x0 = result.x\n        \n        return x0\n    \n    # Method 3: High-precision trust-constr\n    def method3():\n        # Tight grid initialization\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers_init = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            centers_init.append([x, y])\n        centers_init = np.array(centers_init[:n])\n        radii_init = np.full(n, 0.085)\n        x0 = solution_to_pack(centers_init, radii_init)\n        \n        result = minimize(\n            objective_with_penalty,\n            x0,\n            method='trust-constr',\n            options={'maxiter': 2000, 'gtol': 1e-9, 'xtol': 1e-9}\n        )\n        \n        return result.x\n    \n    # Method 4: Pure SLSQP with many restarts\n    def method4():\n        best_x = None\n        best_val = float('inf')\n        \n        for attempt in range(20):\n            # Random initialization\n            centers_init = np.random.uniform(0.1, 0.9, (n, 2))\n            radii_init = np.random.uniform(0.06, 0.1, n)\n            x0 = solution_to_pack(centers_init, radii_init)\n            \n            result = minimize(\n                objective_with_penalty,\n                x0,\n                method='SLSQP',\n                options={'maxiter': 1500, 'ftol': 1e-9}\n            )\n            \n            if result.fun < best_val:\n                best_val = result.fun\n                best_x = result.x\n        \n        return best_x\n    \n    # Method 5: Differential evolution followed by local refinement\n    def method5():\n        bounds = [(0.05, 0.95)] * (2*n) + [(0.01, 0.15)] * n\n        \n        result = differential_evolution(\n            objective_with_penalty,\n            bounds,\n            maxiter=300,\n            popsize=15,\n            seed=42,\n            atol=1e-9,\n            tol=1e-9\n        )\n        \n        # Refine with SLSQP\n        result2 = minimize(\n            objective_with_penalty,\n            result.x,\n            method='SLSQP',\n            options={'maxiter': 2000, 'ftol': 1e-9}\n        )\n        \n        return result2.x\n    \n    # Run all methods\n    methods = [method1, method2, method3, method4, method5]\n    results = []\n    \n    for i, method in enumerate(methods):\n        try:\n            x = method()\n            if x is not None:\n                val = objective(x)\n                results.append((x, val, i))\n        except Exception as e:\n            pass\n    \n    # Sort by objective value\n    results.sort(key=lambda r: r[1])\n    \n    # Take top 3\n    top_results = results[:min(3, len(results))]\n    \n    if not top_results:\n        # Fallback: simple grid packing\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            centers.append([x, y])\n        centers = np.array(centers)\n        radii = np.full(n, 0.08)\n        return centers, radii, np.sum(radii)\n    \n    # Cross-pollination: combine features from top 3\n    if len(top_results) >= 3:\n        x1, _, _ = top_results[0]\n        x2, _, _ = top_results[1]\n        x3, _, _ = top_results[2]\n        \n        # Weighted combination\n        x_combined = 0.5 * x1 + 0.3 * x2 + 0.2 * x3\n    else:\n        x_combined = top_results[0][0]\n    \n    # Final refinement\n    for penalty in [1000, 500, 200]:\n        result = minimize(\n            lambda x: objective_with_penalty(x, penalty),\n            x_combined,\n            method='SLSQP',\n            options={'maxiter': 2000, 'ftol': 1e-10}\n        )\n        x_combined = result.x\n    \n    # Additional refinement with trust-constr\n    result = minimize(\n        objective_with_penalty,\n        x_combined,\n        method='trust-constr',\n        options={'maxiter': 1500, 'gtol': 1e-10, 'xtol': 1e-10}\n    )\n    x_final = result.x\n    \n    # Choose best between combined and top individual\n    candidates = [x_final] + [r[0] for r in top_results]\n    best_x = min(candidates, key=lambda x: objective(x) if is_valid(x) else float('inf'))\n    \n    centers, radii = pack_to_solution(best_x)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T16:12:11.848081",
  "cost_data": null
}