{
  "trial_id": "trial_4_5",
  "generation": 4,
  "parent_id": "trial_3_3",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses boundary-aware optimization to exploit edge advantages.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Start with trial_3_3's best configuration (5x5 grid + 1 extra)\n    grid_size = 5\n    spacing = 1.0 / (grid_size + 1)\n    centers = []\n    for i in range(grid_size):\n        for j in range(grid_size):\n            x = spacing * (i + 1)\n            y = spacing * (j + 1)\n            centers.append([x, y])\n    \n    # Add the 26th circle in the center\n    centers.append([0.5, 0.5])\n    centers = np.array(centers)\n    \n    # Initial radii estimation\n    min_dist = spacing * 0.45\n    radii = np.full(n, min_dist)\n    \n    # Optimize initial configuration\n    def objective(x):\n        centers_temp = x[:2*n].reshape(n, 2)\n        radii_temp = x[2*n:]\n        return -np.sum(radii_temp)\n    \n    def constraints_func(x):\n        centers_temp = x[:2*n].reshape(n, 2)\n        radii_temp = x[2*n:]\n        \n        violations = []\n        \n        # Boundary constraints\n        for i in range(n):\n            violations.append(centers_temp[i, 0] - radii_temp[i])  # left\n            violations.append(1 - centers_temp[i, 0] - radii_temp[i])  # right\n            violations.append(centers_temp[i, 1] - radii_temp[i])  # bottom\n            violations.append(1 - centers_temp[i, 1] - radii_temp[i])  # top\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.sqrt((centers_temp[i, 0] - centers_temp[j, 0])**2 + \n                             (centers_temp[i, 1] - centers_temp[j, 1])**2)\n                violations.append(dist - radii_temp[i] - radii_temp[j])\n        \n        return np.array(violations)\n    \n    # Quick initial optimization\n    x0 = np.concatenate([centers.flatten(), radii])\n    bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n    \n    constraints = {'type': 'ineq', 'fun': constraints_func}\n    result = minimize(objective, x0, method='SLSQP', bounds=bounds, \n                     constraints=constraints, options={'maxiter': 100})\n    \n    if result.success:\n        centers = result.x[:2*n].reshape(n, 2)\n        radii = result.x[2*n:]\n    \n    # Boundary-aware optimization\n    for iteration in range(50):\n        # Identify boundary circles (within 0.15 of any edge)\n        boundary_mask = np.zeros(n, dtype=bool)\n        for i in range(n):\n            dist_to_boundaries = [\n                centers[i, 0],  # left\n                1 - centers[i, 0],  # right\n                centers[i, 1],  # bottom\n                1 - centers[i, 1]  # top\n            ]\n            if min(dist_to_boundaries) < 0.15:\n                boundary_mask[i] = True\n        \n        boundary_indices = np.where(boundary_mask)[0]\n        interior_indices = np.where(~boundary_mask)[0]\n        \n        # Phase 1: Optimize boundary circles\n        if len(boundary_indices) > 0:\n            for idx in boundary_indices:\n                # Determine which boundary is closest\n                dist_left = centers[idx, 0]\n                dist_right = 1 - centers[idx, 0]\n                dist_bottom = centers[idx, 1]\n                dist_top = 1 - centers[idx, 1]\n                \n                min_boundary_dist = min(dist_left, dist_right, dist_bottom, dist_top)\n                \n                # Try to expand radius and move toward boundary\n                best_config = (centers[idx].copy(), radii[idx])\n                best_sum = np.sum(radii)\n                \n                for dr in [0.001, 0.002, 0.005]:\n                    for dc in [-0.002, -0.001, 0, 0.001, 0.002]:\n                        new_center = centers[idx].copy()\n                        new_radius = radii[idx] + dr\n                        \n                        # Move toward closest boundary\n                        if min_boundary_dist == dist_left:\n                            new_center[0] -= abs(dc)\n                        elif min_boundary_dist == dist_right:\n                            new_center[0] += abs(dc)\n                        elif min_boundary_dist == dist_bottom:\n                            new_center[1] -= abs(dc)\n                        else:  # top\n                            new_center[1] += abs(dc)\n                        \n                        # Check feasibility\n                        if (new_center[0] - new_radius >= 0 and \n                            new_center[0] + new_radius <= 1 and\n                            new_center[1] - new_radius >= 0 and \n                            new_center[1] + new_radius <= 1):\n                            \n                            # Check overlaps\n                            valid = True\n                            for j in range(n):\n                                if j == idx:\n                                    continue\n                                dist = np.sqrt((new_center[0] - centers[j, 0])**2 + \n                                             (new_center[1] - centers[j, 1])**2)\n                                if dist < new_radius + radii[j]:\n                                    valid = False\n                                    break\n                            \n                            if valid:\n                                temp_radii = radii.copy()\n                                temp_radii[idx] = new_radius\n                                if np.sum(temp_radii) > best_sum:\n                                    best_config = (new_center, new_radius)\n                                    best_sum = np.sum(temp_radii)\n                \n                centers[idx] = best_config[0]\n                radii[idx] = best_config[1]\n        \n        # Phase 2: Optimize interior circles\n        if len(interior_indices) > 0 and iteration % 2 == 1:\n            for idx in interior_indices:\n                best_radius = radii[idx]\n                \n                # Try to expand radius\n                for dr in [0.001, 0.002, 0.005]:\n                    new_radius = radii[idx] + dr\n                    \n                    # Check feasibility\n                    if (centers[idx, 0] - new_radius >= 0 and \n                        centers[idx, 0] + new_radius <= 1 and\n                        centers[idx, 1] - new_radius >= 0 and \n                        centers[idx, 1] + new_radius <= 1):\n                        \n                        # Check overlaps\n                        valid = True\n                        for j in range(n):\n                            if j == idx:\n                                continue\n                            dist = np.sqrt((centers[idx, 0] - centers[j, 0])**2 + \n                                         (centers[idx, 1] - centers[j, 1])**2)\n                            if dist < new_radius + radii[j]:\n                                valid = False\n                                break\n                        \n                        if valid:\n                            best_radius = new_radius\n                \n                radii[idx] = best_radius\n        \n        # Phase 3: Global refinement every 10 iterations\n        if iteration % 10 == 9:\n            x0 = np.concatenate([centers.flatten(), radii])\n            result = minimize(objective, x0, method='SLSQP', bounds=bounds, \n                            constraints=constraints, options={'maxiter': 50})\n            \n            if result.success:\n                centers = result.x[:2*n].reshape(n, 2)\n                radii = result.x[2*n:]\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.5241443556394714,
    "target_ratio": 0.9579295467322473,
    "combined_score": 0.9579295467322473,
    "eval_time": 2.9792330265045166,
    "error": null
  },
  "prompt": "Boundary-aware optimization to exploit edge advantages.\n\nKey insight: Circles near boundaries can be larger. Optimize for this:\n1. Start with trial_3_3's best configuration\n2. Identify circles within 0.15 of any boundary\n3. For boundary circles, apply special optimization:\n   - Move them closer to boundary if beneficial\n   - Expand their radii more aggressively\n   - Use asymmetric perturbations (toward boundary)\n4. For interior circles, optimize for space filling\n5. Alternate between boundary and interior optimization\n6. Run 50 iterations of this specialized refinement\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses boundary-aware optimization to exploit edge advantages.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Start with trial_3_3's best configuration (5x5 grid + 1 extra)\n    grid_size = 5\n    spacing = 1.0 / (grid_size + 1)\n    centers = []\n    for i in range(grid_size):\n        for j in range(grid_size):\n            x = spacing * (i + 1)\n            y = spacing * (j + 1)\n            centers.append([x, y])\n    \n    # Add the 26th circle in the center\n    centers.append([0.5, 0.5])\n    centers = np.array(centers)\n    \n    # Initial radii estimation\n    min_dist = spacing * 0.45\n    radii = np.full(n, min_dist)\n    \n    # Optimize initial configuration\n    def objective(x):\n        centers_temp = x[:2*n].reshape(n, 2)\n        radii_temp = x[2*n:]\n        return -np.sum(radii_temp)\n    \n    def constraints_func(x):\n        centers_temp = x[:2*n].reshape(n, 2)\n        radii_temp = x[2*n:]\n        \n        violations = []\n        \n        # Boundary constraints\n        for i in range(n):\n            violations.append(centers_temp[i, 0] - radii_temp[i])  # left\n            violations.append(1 - centers_temp[i, 0] - radii_temp[i])  # right\n            violations.append(centers_temp[i, 1] - radii_temp[i])  # bottom\n            violations.append(1 - centers_temp[i, 1] - radii_temp[i])  # top\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.sqrt((centers_temp[i, 0] - centers_temp[j, 0])**2 + \n                             (centers_temp[i, 1] - centers_temp[j, 1])**2)\n                violations.append(dist - radii_temp[i] - radii_temp[j])\n        \n        return np.array(violations)\n    \n    # Quick initial optimization\n    x0 = np.concatenate([centers.flatten(), radii])\n    bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n    \n    constraints = {'type': 'ineq', 'fun': constraints_func}\n    result = minimize(objective, x0, method='SLSQP', bounds=bounds, \n                     constraints=constraints, options={'maxiter': 100})\n    \n    if result.success:\n        centers = result.x[:2*n].reshape(n, 2)\n        radii = result.x[2*n:]\n    \n    # Boundary-aware optimization\n    for iteration in range(50):\n        # Identify boundary circles (within 0.15 of any edge)\n        boundary_mask = np.zeros(n, dtype=bool)\n        for i in range(n):\n            dist_to_boundaries = [\n                centers[i, 0],  # left\n                1 - centers[i, 0],  # right\n                centers[i, 1],  # bottom\n                1 - centers[i, 1]  # top\n            ]\n            if min(dist_to_boundaries) < 0.15:\n                boundary_mask[i] = True\n        \n        boundary_indices = np.where(boundary_mask)[0]\n        interior_indices = np.where(~boundary_mask)[0]\n        \n        # Phase 1: Optimize boundary circles\n        if len(boundary_indices) > 0:\n            for idx in boundary_indices:\n                # Determine which boundary is closest\n                dist_left = centers[idx, 0]\n                dist_right = 1 - centers[idx, 0]\n                dist_bottom = centers[idx, 1]\n                dist_top = 1 - centers[idx, 1]\n                \n                min_boundary_dist = min(dist_left, dist_right, dist_bottom, dist_top)\n                \n                # Try to expand radius and move toward boundary\n                best_config = (centers[idx].copy(), radii[idx])\n                best_sum = np.sum(radii)\n                \n                for dr in [0.001, 0.002, 0.005]:\n                    for dc in [-0.002, -0.001, 0, 0.001, 0.002]:\n                        new_center = centers[idx].copy()\n                        new_radius = radii[idx] + dr\n                        \n                        # Move toward closest boundary\n                        if min_boundary_dist == dist_left:\n                            new_center[0] -= abs(dc)\n                        elif min_boundary_dist == dist_right:\n                            new_center[0] += abs(dc)\n                        elif min_boundary_dist == dist_bottom:\n                            new_center[1] -= abs(dc)\n                        else:  # top\n                            new_center[1] += abs(dc)\n                        \n                        # Check feasibility\n                        if (new_center[0] - new_radius >= 0 and \n                            new_center[0] + new_radius <= 1 and\n                            new_center[1] - new_radius >= 0 and \n                            new_center[1] + new_radius <= 1):\n                            \n                            # Check overlaps\n                            valid = True\n                            for j in range(n):\n                                if j == idx:\n                                    continue\n                                dist = np.sqrt((new_center[0] - centers[j, 0])**2 + \n                                             (new_center[1] - centers[j, 1])**2)\n                                if dist < new_radius + radii[j]:\n                                    valid = False\n                                    break\n                            \n                            if valid:\n                                temp_radii = radii.copy()\n                                temp_radii[idx] = new_radius\n                                if np.sum(temp_radii) > best_sum:\n                                    best_config = (new_center, new_radius)\n                                    best_sum = np.sum(temp_radii)\n                \n                centers[idx] = best_config[0]\n                radii[idx] = best_config[1]\n        \n        # Phase 2: Optimize interior circles\n        if len(interior_indices) > 0 and iteration % 2 == 1:\n            for idx in interior_indices:\n                best_radius = radii[idx]\n                \n                # Try to expand radius\n                for dr in [0.001, 0.002, 0.005]:\n                    new_radius = radii[idx] + dr\n                    \n                    # Check feasibility\n                    if (centers[idx, 0] - new_radius >= 0 and \n                        centers[idx, 0] + new_radius <= 1 and\n                        centers[idx, 1] - new_radius >= 0 and \n                        centers[idx, 1] + new_radius <= 1):\n                        \n                        # Check overlaps\n                        valid = True\n                        for j in range(n):\n                            if j == idx:\n                                continue\n                            dist = np.sqrt((centers[idx, 0] - centers[j, 0])**2 + \n                                         (centers[idx, 1] - centers[j, 1])**2)\n                            if dist < new_radius + radii[j]:\n                                valid = False\n                                break\n                        \n                        if valid:\n                            best_radius = new_radius\n                \n                radii[idx] = best_radius\n        \n        # Phase 3: Global refinement every 10 iterations\n        if iteration % 10 == 9:\n            x0 = np.concatenate([centers.flatten(), radii])\n            result = minimize(objective, x0, method='SLSQP', bounds=bounds, \n                            constraints=constraints, options={'maxiter': 50})\n            \n            if result.success:\n                centers = result.x[:2*n].reshape(n, 2)\n                radii = result.x[2*n:]\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:50:55.918433",
  "cost_data": null
}