{
  "trial_id": "trial_3_10",
  "generation": 3,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses boundary-maximization approach with multiple patterns.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    def compute_radii(centers):\n        \"\"\"Compute maximum non-overlapping radii for given centers.\"\"\"\n        radii = np.zeros(n)\n        for i in range(n):\n            # Distance to boundaries\n            r_max = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    r_max = min(r_max, (dist - radii[j]) / 2 if radii[j] > 0 else dist / 2)\n            \n            radii[i] = max(0, r_max)\n        return radii\n    \n    def objective(x):\n        \"\"\"Objective: minimize negative sum of radii.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        return -np.sum(radii)\n    \n    def constraints_penalty(x):\n        \"\"\"Penalty for constraint violations.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        penalty = 0\n        \n        # Boundary constraints\n        for i in range(n):\n            if centers[i, 0] - radii[i] < 0:\n                penalty += (radii[i] - centers[i, 0]) ** 2\n            if centers[i, 0] + radii[i] > 1:\n                penalty += (centers[i, 0] + radii[i] - 1) ** 2\n            if centers[i, 1] - radii[i] < 0:\n                penalty += (radii[i] - centers[i, 1]) ** 2\n            if centers[i, 1] + radii[i] > 1:\n                penalty += (centers[i, 1] + radii[i] - 1) ** 2\n        \n        # Overlap constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    penalty += overlap ** 2\n        \n        return penalty * 1000\n    \n    def objective_with_penalty(x):\n        \"\"\"Objective with penalty terms.\"\"\"\n        return objective(x) + constraints_penalty(x)\n    \n    def generate_boundary_pattern(boundary_ratio, margin_range):\n        \"\"\"Generate pattern with specified boundary emphasis.\"\"\"\n        centers = np.zeros((n, 2))\n        n_boundary = int(n * boundary_ratio)\n        n_interior = n - n_boundary\n        \n        # Place boundary circles\n        boundary_idx = 0\n        \n        # Corners (4 circles)\n        if boundary_idx < n_boundary:\n            margin = np.random.uniform(*margin_range)\n            corners = [\n                [margin, margin],\n                [1 - margin, margin],\n                [margin, 1 - margin],\n                [1 - margin, 1 - margin]\n            ]\n            for corner in corners[:min(4, n_boundary - boundary_idx)]:\n                centers[boundary_idx] = corner\n                boundary_idx += 1\n        \n        # Edges (remaining boundary circles)\n        edges = ['bottom', 'top', 'left', 'right']\n        edge_idx = 0\n        while boundary_idx < n_boundary:\n            edge = edges[edge_idx % 4]\n            margin = np.random.uniform(*margin_range)\n            pos = np.random.uniform(0.1, 0.9)\n            \n            if edge == 'bottom':\n                centers[boundary_idx] = [pos, margin]\n            elif edge == 'top':\n                centers[boundary_idx] = [pos, 1 - margin]\n            elif edge == 'left':\n                centers[boundary_idx] = [margin, pos]\n            else:  # right\n                centers[boundary_idx] = [1 - margin, pos]\n            \n            boundary_idx += 1\n            edge_idx += 1\n        \n        # Place interior circles\n        for i in range(boundary_idx, n):\n            centers[i] = np.random.uniform(0.15, 0.85, 2)\n        \n        return centers\n    \n    def optimize_pattern(initial_centers, maxiter):\n        \"\"\"Optimize a single pattern.\"\"\"\n        x0 = initial_centers.flatten()\n        \n        # Bounds\n        bounds = [(0.01, 0.99) for _ in range(2 * n)]\n        \n        # Optimize\n        result = minimize(\n            objective_with_penalty,\n            x0,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': maxiter, 'ftol': 1e-9}\n        )\n        \n        centers = result.x.reshape(n, 2)\n        radii = compute_radii(centers)\n        sum_radii = np.sum(radii)\n        \n        return centers, radii, sum_radii\n    \n    def aggressive_radius_expansion(centers, radii):\n        \"\"\"Aggressively expand radii, especially for boundary circles.\"\"\"\n        new_radii = radii.copy()\n        \n        for i in range(n):\n            # Check if near boundary\n            dist_to_boundary = min(centers[i, 0], centers[i, 1],\n                                  1 - centers[i, 0], 1 - centers[i, 1])\n            is_boundary = dist_to_boundary < 0.15\n            \n            # Try to expand\n            expansion_rate = 1.02 if is_boundary else 1.01\n            max_expansion = 20 if is_boundary else 10\n            \n            for _ in range(max_expansion):\n                test_radius = new_radii[i] * expansion_rate\n                \n                # Check boundary constraint\n                if (centers[i, 0] - test_radius < 0 or centers[i, 0] + test_radius > 1 or\n                    centers[i, 1] - test_radius < 0 or centers[i, 1] + test_radius > 1):\n                    break\n                \n                # Check overlap with other circles\n                valid = True\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        if dist < test_radius + new_radii[j]:\n                            valid = False\n                            break\n                \n                if valid:\n                    new_radii[i] = test_radius\n                else:\n                    break\n        \n        return new_radii\n    \n    # Generate and optimize multiple patterns\n    patterns = []\n    \n    print(\"Generating and optimizing patterns...\")\n    \n    # Pattern set 1: 60% boundary, 40% interior\n    for i in range(10):\n        centers = generate_boundary_pattern(0.6, (0.05, 0.08))\n        centers, radii, sum_radii = optimize_pattern(centers, 300)\n        patterns.append((centers, radii, sum_radii))\n        print(f\"Pattern 1-{i+1}: sum_radii = {sum_radii:.6f}\")\n    \n    # Pattern set 2: 50% boundary, 50% interior\n    for i in range(10):\n        centers = generate_boundary_pattern(0.5, (0.06, 0.09))\n        centers, radii, sum_radii = optimize_pattern(centers, 300)\n        patterns.append((centers, radii, sum_radii))\n        print(f\"Pattern 2-{i+1}: sum_radii = {sum_radii:.6f}\")\n    \n    # Pattern set 3: 70% boundary, 30% interior\n    for i in range(10):\n        centers = generate_boundary_pattern(0.7, (0.04, 0.07))\n        centers, radii, sum_radii = optimize_pattern(centers, 300)\n        patterns.append((centers, radii, sum_radii))\n        print(f\"Pattern 3-{i+1}: sum_radii = {sum_radii:.6f}\")\n    \n    # Sort patterns by sum of radii\n    patterns.sort(key=lambda x: x[2], reverse=True)\n    \n    print(f\"\\nTop 5 patterns before extended optimization:\")\n    for i in range(5):\n        print(f\"  Pattern {i+1}: sum_radii = {patterns[i][2]:.6f}\")\n    \n    # Extended optimization for top 5\n    print(\"\\nExtended optimization for top 5 patterns...\")\n    extended_patterns = []\n    for i in range(5):\n        centers, radii, _ = patterns[i]\n        centers, radii, sum_radii = optimize_pattern(centers, 800)\n        \n        # Aggressive radius expansion\n        radii = aggressive_radius_expansion(centers, radii)\n        sum_radii = np.sum(radii)\n        \n        extended_patterns.append((centers, radii, sum_radii))\n        print(f\"Extended pattern {i+1}: sum_radii = {sum_radii:.6f}\")\n    \n    # Select best pattern\n    extended_patterns.sort(key=lambda x: x[2], reverse=True)\n    best_centers, best_radii, best_sum = extended_patterns[0]\n    \n    print(f\"\\nBest pattern after extended optimization: sum_radii = {best_sum:.6f}\")\n    \n    # Final global optimization\n    print(\"\\nFinal global optimization...\")\n    \n    def global_objective(x):\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        \n        # Add small penalty for being too far from boundaries\n        boundary_penalty = 0\n        for i in range(n):\n            dist_to_boundary = min(centers[i, 0], centers[i, 1],\n                                  1 - centers[i, 0], 1 - centers[i, 1])\n            if dist_to_boundary > 0.2:\n                boundary_penalty += (dist_to_boundary - 0.2) * 0.1\n        \n        return -np.sum(radii) + boundary_penalty + constraints_penalty(x)\n    \n    x0 = best_centers.flatten()\n    bounds = [(0.01, 0.99) for _ in range(2 * n)]\n    \n    result = minimize(\n        global_objective,\n        x0,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 1000, 'ftol': 1e-10}\n    )\n    \n    final_centers = result.x.reshape(n, 2)\n    final_radii = compute_radii(final_centers)\n    \n    # Final aggressive expansion\n    final_radii = aggressive_radius_expansion(final_centers, final_radii)\n    final_sum = np.sum(final_radii)\n    \n    print(f\"Final sum of radii: {final_sum:.6f}\")\n    \n    return final_centers, final_radii, final_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 371.9893047809601,
    "error": "Timeout after 300s"
  },
  "prompt": "Create a boundary-maximization approach.\n\nInsight: Circles near boundaries can be larger. Exploit this:\n1. Generate 30 patterns with varying boundary emphasis:\n   - 10 patterns: 60% circles on boundary, 40% interior\n   - 10 patterns: 50% boundary, 50% interior\n   - 10 patterns: 70% boundary, 30% interior\n2. For boundary circles, place them closer to edges (margin: 0.05-0.08)\n3. Optimize each pattern (maxiter=300)\n4. Top 5 get extended optimization (maxiter=800)\n5. Add aggressive radius expansion for boundary circles\n6. Final global optimization\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses boundary-maximization approach with multiple patterns.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    def compute_radii(centers):\n        \"\"\"Compute maximum non-overlapping radii for given centers.\"\"\"\n        radii = np.zeros(n)\n        for i in range(n):\n            # Distance to boundaries\n            r_max = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    r_max = min(r_max, (dist - radii[j]) / 2 if radii[j] > 0 else dist / 2)\n            \n            radii[i] = max(0, r_max)\n        return radii\n    \n    def objective(x):\n        \"\"\"Objective: minimize negative sum of radii.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        return -np.sum(radii)\n    \n    def constraints_penalty(x):\n        \"\"\"Penalty for constraint violations.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        penalty = 0\n        \n        # Boundary constraints\n        for i in range(n):\n            if centers[i, 0] - radii[i] < 0:\n                penalty += (radii[i] - centers[i, 0]) ** 2\n            if centers[i, 0] + radii[i] > 1:\n                penalty += (centers[i, 0] + radii[i] - 1) ** 2\n            if centers[i, 1] - radii[i] < 0:\n                penalty += (radii[i] - centers[i, 1]) ** 2\n            if centers[i, 1] + radii[i] > 1:\n                penalty += (centers[i, 1] + radii[i] - 1) ** 2\n        \n        # Overlap constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    penalty += overlap ** 2\n        \n        return penalty * 1000\n    \n    def objective_with_penalty(x):\n        \"\"\"Objective with penalty terms.\"\"\"\n        return objective(x) + constraints_penalty(x)\n    \n    def generate_boundary_pattern(boundary_ratio, margin_range):\n        \"\"\"Generate pattern with specified boundary emphasis.\"\"\"\n        centers = np.zeros((n, 2))\n        n_boundary = int(n * boundary_ratio)\n        n_interior = n - n_boundary\n        \n        # Place boundary circles\n        boundary_idx = 0\n        \n        # Corners (4 circles)\n        if boundary_idx < n_boundary:\n            margin = np.random.uniform(*margin_range)\n            corners = [\n                [margin, margin],\n                [1 - margin, margin],\n                [margin, 1 - margin],\n                [1 - margin, 1 - margin]\n            ]\n            for corner in corners[:min(4, n_boundary - boundary_idx)]:\n                centers[boundary_idx] = corner\n                boundary_idx += 1\n        \n        # Edges (remaining boundary circles)\n        edges = ['bottom', 'top', 'left', 'right']\n        edge_idx = 0\n        while boundary_idx < n_boundary:\n            edge = edges[edge_idx % 4]\n            margin = np.random.uniform(*margin_range)\n            pos = np.random.uniform(0.1, 0.9)\n            \n            if edge == 'bottom':\n                centers[boundary_idx] = [pos, margin]\n            elif edge == 'top':\n                centers[boundary_idx] = [pos, 1 - margin]\n            elif edge == 'left':\n                centers[boundary_idx] = [margin, pos]\n            else:  # right\n                centers[boundary_idx] = [1 - margin, pos]\n            \n            boundary_idx += 1\n            edge_idx += 1\n        \n        # Place interior circles\n        for i in range(boundary_idx, n):\n            centers[i] = np.random.uniform(0.15, 0.85, 2)\n        \n        return centers\n    \n    def optimize_pattern(initial_centers, maxiter):\n        \"\"\"Optimize a single pattern.\"\"\"\n        x0 = initial_centers.flatten()\n        \n        # Bounds\n        bounds = [(0.01, 0.99) for _ in range(2 * n)]\n        \n        # Optimize\n        result = minimize(\n            objective_with_penalty,\n            x0,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': maxiter, 'ftol': 1e-9}\n        )\n        \n        centers = result.x.reshape(n, 2)\n        radii = compute_radii(centers)\n        sum_radii = np.sum(radii)\n        \n        return centers, radii, sum_radii\n    \n    def aggressive_radius_expansion(centers, radii):\n        \"\"\"Aggressively expand radii, especially for boundary circles.\"\"\"\n        new_radii = radii.copy()\n        \n        for i in range(n):\n            # Check if near boundary\n            dist_to_boundary = min(centers[i, 0], centers[i, 1],\n                                  1 - centers[i, 0], 1 - centers[i, 1])\n            is_boundary = dist_to_boundary < 0.15\n            \n            # Try to expand\n            expansion_rate = 1.02 if is_boundary else 1.01\n            max_expansion = 20 if is_boundary else 10\n            \n            for _ in range(max_expansion):\n                test_radius = new_radii[i] * expansion_rate\n                \n                # Check boundary constraint\n                if (centers[i, 0] - test_radius < 0 or centers[i, 0] + test_radius > 1 or\n                    centers[i, 1] - test_radius < 0 or centers[i, 1] + test_radius > 1):\n                    break\n                \n                # Check overlap with other circles\n                valid = True\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        if dist < test_radius + new_radii[j]:\n                            valid = False\n                            break\n                \n                if valid:\n                    new_radii[i] = test_radius\n                else:\n                    break\n        \n        return new_radii\n    \n    # Generate and optimize multiple patterns\n    patterns = []\n    \n    print(\"Generating and optimizing patterns...\")\n    \n    # Pattern set 1: 60% boundary, 40% interior\n    for i in range(10):\n        centers = generate_boundary_pattern(0.6, (0.05, 0.08))\n        centers, radii, sum_radii = optimize_pattern(centers, 300)\n        patterns.append((centers, radii, sum_radii))\n        print(f\"Pattern 1-{i+1}: sum_radii = {sum_radii:.6f}\")\n    \n    # Pattern set 2: 50% boundary, 50% interior\n    for i in range(10):\n        centers = generate_boundary_pattern(0.5, (0.06, 0.09))\n        centers, radii, sum_radii = optimize_pattern(centers, 300)\n        patterns.append((centers, radii, sum_radii))\n        print(f\"Pattern 2-{i+1}: sum_radii = {sum_radii:.6f}\")\n    \n    # Pattern set 3: 70% boundary, 30% interior\n    for i in range(10):\n        centers = generate_boundary_pattern(0.7, (0.04, 0.07))\n        centers, radii, sum_radii = optimize_pattern(centers, 300)\n        patterns.append((centers, radii, sum_radii))\n        print(f\"Pattern 3-{i+1}: sum_radii = {sum_radii:.6f}\")\n    \n    # Sort patterns by sum of radii\n    patterns.sort(key=lambda x: x[2], reverse=True)\n    \n    print(f\"\\nTop 5 patterns before extended optimization:\")\n    for i in range(5):\n        print(f\"  Pattern {i+1}: sum_radii = {patterns[i][2]:.6f}\")\n    \n    # Extended optimization for top 5\n    print(\"\\nExtended optimization for top 5 patterns...\")\n    extended_patterns = []\n    for i in range(5):\n        centers, radii, _ = patterns[i]\n        centers, radii, sum_radii = optimize_pattern(centers, 800)\n        \n        # Aggressive radius expansion\n        radii = aggressive_radius_expansion(centers, radii)\n        sum_radii = np.sum(radii)\n        \n        extended_patterns.append((centers, radii, sum_radii))\n        print(f\"Extended pattern {i+1}: sum_radii = {sum_radii:.6f}\")\n    \n    # Select best pattern\n    extended_patterns.sort(key=lambda x: x[2], reverse=True)\n    best_centers, best_radii, best_sum = extended_patterns[0]\n    \n    print(f\"\\nBest pattern after extended optimization: sum_radii = {best_sum:.6f}\")\n    \n    # Final global optimization\n    print(\"\\nFinal global optimization...\")\n    \n    def global_objective(x):\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        \n        # Add small penalty for being too far from boundaries\n        boundary_penalty = 0\n        for i in range(n):\n            dist_to_boundary = min(centers[i, 0], centers[i, 1],\n                                  1 - centers[i, 0], 1 - centers[i, 1])\n            if dist_to_boundary > 0.2:\n                boundary_penalty += (dist_to_boundary - 0.2) * 0.1\n        \n        return -np.sum(radii) + boundary_penalty + constraints_penalty(x)\n    \n    x0 = best_centers.flatten()\n    bounds = [(0.01, 0.99) for _ in range(2 * n)]\n    \n    result = minimize(\n        global_objective,\n        x0,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 1000, 'ftol': 1e-10}\n    )\n    \n    final_centers = result.x.reshape(n, 2)\n    final_radii = compute_radii(final_centers)\n    \n    # Final aggressive expansion\n    final_radii = aggressive_radius_expansion(final_centers, final_radii)\n    final_sum = np.sum(final_radii)\n    \n    print(f\"Final sum of radii: {final_sum:.6f}\")\n    \n    return final_centers, final_radii, final_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:48:23.658071",
  "cost_data": null
}