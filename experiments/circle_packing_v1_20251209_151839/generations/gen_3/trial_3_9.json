{
  "trial_id": "trial_3_9",
  "generation": 3,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom itertools import product\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses multi-resolution grid search with progressive optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def compute_radii(centers):\n        \"\"\"Compute maximum radii for given centers.\"\"\"\n        radii = np.ones(n) * 0.5\n        for i in range(n):\n            # Distance to boundaries\n            r_max = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    r_max = min(r_max, (dist - radii[j]) / 2 + radii[j])\n            \n            radii[i] = max(0, r_max)\n        \n        # Iterative refinement\n        for _ in range(5):\n            for i in range(n):\n                r_max = min(centers[i, 0], centers[i, 1], \n                           1 - centers[i, 0], 1 - centers[i, 1])\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        r_max = min(r_max, dist - radii[j])\n                radii[i] = max(0, r_max)\n        \n        return radii\n    \n    def objective(x):\n        \"\"\"Objective: negative sum of radii.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        return -np.sum(radii)\n    \n    def generate_grid_config(rows, cols, noise=0.0):\n        \"\"\"Generate initial grid configuration.\"\"\"\n        centers = []\n        \n        # Calculate spacing\n        x_spacing = 1.0 / (cols + 1)\n        y_spacing = 1.0 / (rows + 1)\n        \n        # Place circles on grid\n        for i in range(rows):\n            for j in range(cols):\n                if len(centers) >= n:\n                    break\n                x = (j + 1) * x_spacing\n                y = (i + 1) * y_spacing\n                \n                # Add noise\n                if noise > 0:\n                    x += np.random.uniform(-noise, noise) * x_spacing\n                    y += np.random.uniform(-noise, noise) * y_spacing\n                \n                # Clamp to valid range\n                x = np.clip(x, 0.05, 0.95)\n                y = np.clip(y, 0.05, 0.95)\n                \n                centers.append([x, y])\n            \n            if len(centers) >= n:\n                break\n        \n        return np.array(centers[:n])\n    \n    # Phase 1: Coarse grid search\n    print(\"Phase 1: Coarse grid search (100 configurations)\")\n    grid_configs = []\n    \n    # Generate different grid dimensions\n    for rows in range(3, 9):\n        for cols in range(3, 9):\n            if rows * cols >= n:\n                grid_configs.append((rows, cols))\n    \n    # Limit to 20 best grid configs (prioritize balanced grids)\n    grid_configs.sort(key=lambda x: abs(x[0] - x[1]))\n    grid_configs = grid_configs[:20]\n    \n    # Add perturbation levels\n    noise_levels = [0.0, 0.01, 0.02, 0.03, 0.04]\n    \n    candidates = []\n    \n    for (rows, cols), noise in product(grid_configs, noise_levels):\n        np.random.seed(hash((rows, cols, int(noise * 1000))) % 2**32)\n        centers = generate_grid_config(rows, cols, noise)\n        \n        # Quick optimization\n        x0 = centers.flatten()\n        bounds = [(0.02, 0.98)] * (2 * n)\n        \n        result = minimize(objective, x0, method='L-BFGS-B', \n                         bounds=bounds, options={'maxiter': 150})\n        \n        centers_opt = result.x.reshape(n, 2)\n        radii_opt = compute_radii(centers_opt)\n        sum_radii = np.sum(radii_opt)\n        \n        candidates.append((sum_radii, centers_opt, radii_opt))\n    \n    # Sort and take top 10\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    top_candidates = candidates[:10]\n    \n    print(f\"Top 10 after coarse search: {[f'{c[0]:.4f}' for c in top_candidates[:3]]}\")\n    \n    # Phase 2: Medium optimization\n    print(\"Phase 2: Medium optimization (top 10)\")\n    medium_candidates = []\n    \n    for _, centers, _ in top_candidates:\n        x0 = centers.flatten()\n        bounds = [(0.02, 0.98)] * (2 * n)\n        \n        result = minimize(objective, x0, method='L-BFGS-B',\n                         bounds=bounds, options={'maxiter': 400})\n        \n        centers_opt = result.x.reshape(n, 2)\n        radii_opt = compute_radii(centers_opt)\n        sum_radii = np.sum(radii_opt)\n        \n        medium_candidates.append((sum_radii, centers_opt, radii_opt))\n    \n    medium_candidates.sort(reverse=True, key=lambda x: x[0])\n    top_3 = medium_candidates[:3]\n    \n    print(f\"Top 3 after medium: {[f'{c[0]:.4f}' for c in top_3]}\")\n    \n    # Phase 3: Deep optimization\n    print(\"Phase 3: Deep optimization (top 3)\")\n    deep_candidates = []\n    \n    for _, centers, _ in top_3:\n        x0 = centers.flatten()\n        bounds = [(0.01, 0.99)] * (2 * n)\n        \n        result = minimize(objective, x0, method='L-BFGS-B',\n                         bounds=bounds, options={'maxiter': 1000, 'ftol': 1e-10})\n        \n        centers_opt = result.x.reshape(n, 2)\n        radii_opt = compute_radii(centers_opt)\n        sum_radii = np.sum(radii_opt)\n        \n        deep_candidates.append((sum_radii, centers_opt, radii_opt))\n    \n    deep_candidates.sort(reverse=True, key=lambda x: x[0])\n    best_sum, best_centers, best_radii = deep_candidates[0]\n    \n    print(f\"Best after deep: {best_sum:.4f}\")\n    \n    # Phase 4: Coordinate descent + radius expansion\n    print(\"Phase 4: Coordinate descent refinement\")\n    \n    def coordinate_descent(centers, radii, iterations=50):\n        \"\"\"Refine solution using coordinate descent.\"\"\"\n        centers = centers.copy()\n        \n        for iter_num in range(iterations):\n            improved = False\n            \n            for i in range(n):\n                best_pos = centers[i].copy()\n                best_r = radii[i]\n                \n                # Try small perturbations\n                step_size = 0.01 * (1.0 - iter_num / iterations)\n                \n                for dx, dy in [(step_size, 0), (-step_size, 0), \n                              (0, step_size), (0, -step_size),\n                              (step_size, step_size), (-step_size, -step_size),\n                              (step_size, -step_size), (-step_size, step_size)]:\n                    \n                    new_pos = centers[i] + np.array([dx, dy])\n                    \n                    # Check bounds\n                    if not (0.01 <= new_pos[0] <= 0.99 and 0.01 <= new_pos[1] <= 0.99):\n                        continue\n                    \n                    # Temporarily update\n                    centers[i] = new_pos\n                    new_radii = compute_radii(centers)\n                    \n                    if new_radii[i] > best_r:\n                        best_pos = new_pos.copy()\n                        best_r = new_radii[i]\n                        improved = True\n                    \n                    # Restore\n                    centers[i] = best_pos\n                \n                centers[i] = best_pos\n            \n            radii = compute_radii(centers)\n            \n            if not improved and iter_num > 10:\n                break\n        \n        return centers, radii\n    \n    # Apply coordinate descent\n    best_centers, best_radii = coordinate_descent(best_centers, best_radii, iterations=50)\n    best_sum = np.sum(best_radii)\n    \n    print(f\"Final sum of radii: {best_sum:.6f}\")\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 371.9888799190521,
    "error": "Timeout after 300s"
  },
  "prompt": "Create a multi-resolution grid search approach.\n\nStrategy:\n1. Coarse grid: Try 20 different grid configurations (4x7, 5x6, 6x5, 7x4, etc.)\n2. For each, add 5 perturbation levels (noise: 0, 0.01, 0.02, 0.03, 0.04)\n3. Quick optimize all 100 configurations (maxiter=150)\n4. Take top 10\n5. Medium optimize (maxiter=400)\n6. Take top 3\n7. Deep optimize (maxiter=1000)\n8. Best solution: coordinate descent + radius expansion\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom itertools import product\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses multi-resolution grid search with progressive optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def compute_radii(centers):\n        \"\"\"Compute maximum radii for given centers.\"\"\"\n        radii = np.ones(n) * 0.5\n        for i in range(n):\n            # Distance to boundaries\n            r_max = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    r_max = min(r_max, (dist - radii[j]) / 2 + radii[j])\n            \n            radii[i] = max(0, r_max)\n        \n        # Iterative refinement\n        for _ in range(5):\n            for i in range(n):\n                r_max = min(centers[i, 0], centers[i, 1], \n                           1 - centers[i, 0], 1 - centers[i, 1])\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        r_max = min(r_max, dist - radii[j])\n                radii[i] = max(0, r_max)\n        \n        return radii\n    \n    def objective(x):\n        \"\"\"Objective: negative sum of radii.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        return -np.sum(radii)\n    \n    def generate_grid_config(rows, cols, noise=0.0):\n        \"\"\"Generate initial grid configuration.\"\"\"\n        centers = []\n        \n        # Calculate spacing\n        x_spacing = 1.0 / (cols + 1)\n        y_spacing = 1.0 / (rows + 1)\n        \n        # Place circles on grid\n        for i in range(rows):\n            for j in range(cols):\n                if len(centers) >= n:\n                    break\n                x = (j + 1) * x_spacing\n                y = (i + 1) * y_spacing\n                \n                # Add noise\n                if noise > 0:\n                    x += np.random.uniform(-noise, noise) * x_spacing\n                    y += np.random.uniform(-noise, noise) * y_spacing\n                \n                # Clamp to valid range\n                x = np.clip(x, 0.05, 0.95)\n                y = np.clip(y, 0.05, 0.95)\n                \n                centers.append([x, y])\n            \n            if len(centers) >= n:\n                break\n        \n        return np.array(centers[:n])\n    \n    # Phase 1: Coarse grid search\n    print(\"Phase 1: Coarse grid search (100 configurations)\")\n    grid_configs = []\n    \n    # Generate different grid dimensions\n    for rows in range(3, 9):\n        for cols in range(3, 9):\n            if rows * cols >= n:\n                grid_configs.append((rows, cols))\n    \n    # Limit to 20 best grid configs (prioritize balanced grids)\n    grid_configs.sort(key=lambda x: abs(x[0] - x[1]))\n    grid_configs = grid_configs[:20]\n    \n    # Add perturbation levels\n    noise_levels = [0.0, 0.01, 0.02, 0.03, 0.04]\n    \n    candidates = []\n    \n    for (rows, cols), noise in product(grid_configs, noise_levels):\n        np.random.seed(hash((rows, cols, int(noise * 1000))) % 2**32)\n        centers = generate_grid_config(rows, cols, noise)\n        \n        # Quick optimization\n        x0 = centers.flatten()\n        bounds = [(0.02, 0.98)] * (2 * n)\n        \n        result = minimize(objective, x0, method='L-BFGS-B', \n                         bounds=bounds, options={'maxiter': 150})\n        \n        centers_opt = result.x.reshape(n, 2)\n        radii_opt = compute_radii(centers_opt)\n        sum_radii = np.sum(radii_opt)\n        \n        candidates.append((sum_radii, centers_opt, radii_opt))\n    \n    # Sort and take top 10\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    top_candidates = candidates[:10]\n    \n    print(f\"Top 10 after coarse search: {[f'{c[0]:.4f}' for c in top_candidates[:3]]}\")\n    \n    # Phase 2: Medium optimization\n    print(\"Phase 2: Medium optimization (top 10)\")\n    medium_candidates = []\n    \n    for _, centers, _ in top_candidates:\n        x0 = centers.flatten()\n        bounds = [(0.02, 0.98)] * (2 * n)\n        \n        result = minimize(objective, x0, method='L-BFGS-B',\n                         bounds=bounds, options={'maxiter': 400})\n        \n        centers_opt = result.x.reshape(n, 2)\n        radii_opt = compute_radii(centers_opt)\n        sum_radii = np.sum(radii_opt)\n        \n        medium_candidates.append((sum_radii, centers_opt, radii_opt))\n    \n    medium_candidates.sort(reverse=True, key=lambda x: x[0])\n    top_3 = medium_candidates[:3]\n    \n    print(f\"Top 3 after medium: {[f'{c[0]:.4f}' for c in top_3]}\")\n    \n    # Phase 3: Deep optimization\n    print(\"Phase 3: Deep optimization (top 3)\")\n    deep_candidates = []\n    \n    for _, centers, _ in top_3:\n        x0 = centers.flatten()\n        bounds = [(0.01, 0.99)] * (2 * n)\n        \n        result = minimize(objective, x0, method='L-BFGS-B',\n                         bounds=bounds, options={'maxiter': 1000, 'ftol': 1e-10})\n        \n        centers_opt = result.x.reshape(n, 2)\n        radii_opt = compute_radii(centers_opt)\n        sum_radii = np.sum(radii_opt)\n        \n        deep_candidates.append((sum_radii, centers_opt, radii_opt))\n    \n    deep_candidates.sort(reverse=True, key=lambda x: x[0])\n    best_sum, best_centers, best_radii = deep_candidates[0]\n    \n    print(f\"Best after deep: {best_sum:.4f}\")\n    \n    # Phase 4: Coordinate descent + radius expansion\n    print(\"Phase 4: Coordinate descent refinement\")\n    \n    def coordinate_descent(centers, radii, iterations=50):\n        \"\"\"Refine solution using coordinate descent.\"\"\"\n        centers = centers.copy()\n        \n        for iter_num in range(iterations):\n            improved = False\n            \n            for i in range(n):\n                best_pos = centers[i].copy()\n                best_r = radii[i]\n                \n                # Try small perturbations\n                step_size = 0.01 * (1.0 - iter_num / iterations)\n                \n                for dx, dy in [(step_size, 0), (-step_size, 0), \n                              (0, step_size), (0, -step_size),\n                              (step_size, step_size), (-step_size, -step_size),\n                              (step_size, -step_size), (-step_size, step_size)]:\n                    \n                    new_pos = centers[i] + np.array([dx, dy])\n                    \n                    # Check bounds\n                    if not (0.01 <= new_pos[0] <= 0.99 and 0.01 <= new_pos[1] <= 0.99):\n                        continue\n                    \n                    # Temporarily update\n                    centers[i] = new_pos\n                    new_radii = compute_radii(centers)\n                    \n                    if new_radii[i] > best_r:\n                        best_pos = new_pos.copy()\n                        best_r = new_radii[i]\n                        improved = True\n                    \n                    # Restore\n                    centers[i] = best_pos\n                \n                centers[i] = best_pos\n            \n            radii = compute_radii(centers)\n            \n            if not improved and iter_num > 10:\n                break\n        \n        return centers, radii\n    \n    # Apply coordinate descent\n    best_centers, best_radii = coordinate_descent(best_centers, best_radii, iterations=50)\n    best_sum = np.sum(best_radii)\n    \n    print(f\"Final sum of radii: {best_sum:.6f}\")\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:48:19.059733",
  "cost_data": null
}