{
  "trial_id": "trial_3_12",
  "generation": 3,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using hybrid initialization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    def generate_hexagonal_base():\n        \"\"\"Generate hexagonal-like pattern.\"\"\"\n        centers = []\n        rows = 5\n        for row in range(rows):\n            if row % 2 == 0:\n                n_cols = 6\n                offset = 0.0\n            else:\n                n_cols = 5\n                offset = 0.1\n            for col in range(n_cols):\n                x = offset + 0.2 + col * 0.15\n                y = 0.15 + row * 0.18\n                if len(centers) < n:\n                    centers.append([x, y])\n        return np.array(centers[:n])\n    \n    def generate_grid_base():\n        \"\"\"Generate grid pattern.\"\"\"\n        centers = []\n        cols = 6\n        rows = 5\n        for i in range(rows):\n            for j in range(cols):\n                if len(centers) < n:\n                    x = 0.1 + j * 0.16\n                    y = 0.1 + i * 0.2\n                    centers.append([x, y])\n        return np.array(centers[:n])\n    \n    def generate_boundary_base():\n        \"\"\"Generate boundary-focused pattern.\"\"\"\n        centers = []\n        # Corners\n        corners = [[0.08, 0.08], [0.92, 0.08], [0.08, 0.92], [0.92, 0.92]]\n        centers.extend(corners)\n        \n        # Edges\n        for i in range(4):\n            x = 0.08 + i * 0.28\n            centers.append([x, 0.08])\n            centers.append([x, 0.92])\n        for i in range(3):\n            y = 0.3 + i * 0.2\n            centers.append([0.08, y])\n            centers.append([0.92, y])\n        \n        # Interior\n        while len(centers) < n:\n            centers.append([0.3 + np.random.rand() * 0.4, 0.3 + np.random.rand() * 0.4])\n        \n        return np.array(centers[:n])\n    \n    def calculate_radii(centers):\n        \"\"\"Calculate maximum valid radii for given centers.\"\"\"\n        radii = np.ones(n)\n        for i in range(n):\n            # Distance to boundaries\n            r_max = min(centers[i, 0], 1 - centers[i, 0], \n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    r_max = min(r_max, (dist - radii[j]) / 2 + radii[j])\n            \n            radii[i] = max(0, r_max)\n        \n        # Iterative refinement\n        for _ in range(5):\n            for i in range(n):\n                r_max = min(centers[i, 0], 1 - centers[i, 0],\n                           centers[i, 1], 1 - centers[i, 1])\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        r_max = min(r_max, dist - radii[j])\n                radii[i] = max(0, r_max * 0.99)\n        \n        return radii\n    \n    def objective(x):\n        \"\"\"Objective: minimize negative sum of radii.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = calculate_radii(centers)\n        return -np.sum(radii)\n    \n    def optimize_packing(initial_centers, maxiter=200):\n        \"\"\"Optimize packing from initial configuration.\"\"\"\n        x0 = initial_centers.flatten()\n        \n        # Bounds: keep centers well within unit square\n        bounds = [(0.05, 0.95) for _ in range(2 * n)]\n        \n        result = minimize(\n            objective,\n            x0,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': maxiter, 'ftol': 1e-9}\n        )\n        \n        centers = result.x.reshape(n, 2)\n        radii = calculate_radii(centers)\n        return centers, radii, np.sum(radii)\n    \n    # Generate hybrid initializations\n    print(\"Generating hybrid initializations...\")\n    candidates = []\n    \n    # Get base patterns\n    hex_base = generate_hexagonal_base()\n    grid_base = generate_grid_base()\n    boundary_base = generate_boundary_base()\n    \n    # Type 1: Perturbed hexagonal (15 variants)\n    for i in range(15):\n        centers = hex_base.copy()\n        noise = np.random.randn(n, 2) * (0.01 + i * 0.002)\n        centers += noise\n        centers = np.clip(centers, 0.05, 0.95)\n        candidates.append(centers)\n    \n    # Type 2: Grid to hexagonal transition (10 variants)\n    for i in range(10):\n        alpha = i / 10\n        centers = (1 - alpha) * grid_base + alpha * hex_base\n        noise = np.random.randn(n, 2) * 0.01\n        centers += noise\n        centers = np.clip(centers, 0.05, 0.95)\n        candidates.append(centers)\n    \n    # Type 3: Boundary optimized interior (10 variants)\n    for i in range(10):\n        centers = boundary_base.copy()\n        # Optimize interior points\n        interior_mask = (centers[:, 0] > 0.15) & (centers[:, 0] < 0.85) & \\\n                       (centers[:, 1] > 0.15) & (centers[:, 1] < 0.85)\n        interior_indices = np.where(interior_mask)[0]\n        for idx in interior_indices:\n            centers[idx] = [0.2 + np.random.rand() * 0.6, 0.2 + np.random.rand() * 0.6]\n        candidates.append(centers)\n    \n    # Type 4: Hybrid combinations (15 variants)\n    for i in range(15):\n        centers = np.zeros((n, 2))\n        # Corners from boundary\n        centers[:4] = boundary_base[:4]\n        # Some edges from grid\n        centers[4:12] = grid_base[4:12]\n        # Interior from hexagonal\n        centers[12:] = hex_base[12:]\n        noise = np.random.randn(n, 2) * 0.015\n        centers += noise\n        centers = np.clip(centers, 0.05, 0.95)\n        candidates.append(centers)\n    \n    # Stage 1: Quick optimize all candidates\n    print(\"Stage 1: Quick optimization of 50 candidates...\")\n    results = []\n    for i, init_centers in enumerate(candidates):\n        centers, radii, sum_r = optimize_packing(init_centers, maxiter=200)\n        results.append((centers, radii, sum_r))\n        if (i + 1) % 10 == 0:\n            print(f\"  Processed {i+1}/50, best so far: {max(r[2] for r in results):.6f}\")\n    \n    # Sort by sum of radii\n    results.sort(key=lambda x: x[2], reverse=True)\n    print(f\"Stage 1 complete. Best: {results[0][2]:.6f}\")\n    \n    # Stage 2: Medium optimize top 10\n    print(\"\\nStage 2: Medium optimization of top 10...\")\n    top_10 = []\n    for i in range(10):\n        centers, radii, sum_r = optimize_packing(results[i][0], maxiter=500)\n        top_10.append((centers, radii, sum_r))\n        print(f\"  Candidate {i+1}/10: {sum_r:.6f}\")\n    \n    top_10.sort(key=lambda x: x[2], reverse=True)\n    print(f\"Stage 2 complete. Best: {top_10[0][2]:.6f}\")\n    \n    # Stage 3: Deep optimize top 3\n    print(\"\\nStage 3: Deep optimization of top 3...\")\n    top_3 = []\n    for i in range(3):\n        centers, radii, sum_r = optimize_packing(top_10[i][0], maxiter=1200)\n        top_3.append((centers, radii, sum_r))\n        print(f\"  Candidate {i+1}/3: {sum_r:.6f}\")\n    \n    top_3.sort(key=lambda x: x[2], reverse=True)\n    best_centers, best_radii, best_sum = top_3[0]\n    print(f\"Stage 3 complete. Best: {best_sum:.6f}\")\n    \n    # Stage 4: Micro-adjustments\n    print(\"\\nStage 4: Micro-adjustments...\")\n    best_improved = False\n    for iteration in range(3):\n        improved = False\n        for i in range(n):\n            original_pos = best_centers[i].copy()\n            best_local = best_sum\n            \n            # Try small perturbations\n            for dx in [-0.0005, 0, 0.0005]:\n                for dy in [-0.0005, 0, 0.0005]:\n                    if dx == 0 and dy == 0:\n                        continue\n                    \n                    test_centers = best_centers.copy()\n                    test_centers[i] = original_pos + np.array([dx, dy])\n                    \n                    # Check bounds\n                    if not (0.05 <= test_centers[i, 0] <= 0.95 and \n                           0.05 <= test_centers[i, 1] <= 0.95):\n                        continue\n                    \n                    test_radii = calculate_radii(test_centers)\n                    test_sum = np.sum(test_radii)\n                    \n                    if test_sum > best_local:\n                        best_local = test_sum\n                        best_centers[i] = test_centers[i]\n                        improved = True\n            \n            if improved:\n                best_radii = calculate_radii(best_centers)\n                best_sum = np.sum(best_radii)\n                best_improved = True\n        \n        print(f\"  Iteration {iteration+1}: {best_sum:.6f}\")\n        if not improved:\n            break\n    \n    # Stage 5: Final radius expansion\n    print(\"\\nStage 5: Final radius expansion...\")\n    best_radii = calculate_radii(best_centers)\n    \n    # Try to expand each radius slightly\n    for i in range(n):\n        for scale in [1.001, 1.0005, 1.0002]:\n            test_radii = best_radii.copy()\n            test_radii[i] *= scale\n            \n            # Check validity\n            valid = True\n            # Boundary check\n            if (best_centers[i, 0] - test_radii[i] < 0 or \n                best_centers[i, 0] + test_radii[i] > 1 or\n                best_centers[i, 1] - test_radii[i] < 0 or\n                best_centers[i, 1] + test_radii[i] > 1):\n                valid = False\n            \n            # Overlap check\n            if valid:\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(best_centers[i] - best_centers[j])\n                        if dist < test_radii[i] + test_radii[j]:\n                            valid = False\n                            break\n            \n            if valid:\n                best_radii[i] = test_radii[i]\n                break\n    \n    best_sum = np.sum(best_radii)\n    print(f\"\\nFinal result: {best_sum:.6f}\")\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 371.9841058254242,
    "error": "Timeout after 300s"
  },
  "prompt": "Create a hybrid initialization combining multiple successful patterns.\n\nStrategy:\n1. Generate 50 hybrid initializations:\n   - Take best hexagonal pattern, add random perturbations\n   - Take best grid pattern, shift to hexagonal-like positions\n   - Take best boundary pattern, optimize interior placement\n   - Combine elements: corners from one pattern, edges from another, interior from third\n2. Quick optimize all (maxiter=200)\n3. Top 10: medium optimize (maxiter=500)\n4. Top 3: deep optimize (maxiter=1200)\n5. Best: micro-adjustments (\u00b10.0005 for each circle)\n6. Final radius expansion\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using hybrid initialization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    def generate_hexagonal_base():\n        \"\"\"Generate hexagonal-like pattern.\"\"\"\n        centers = []\n        rows = 5\n        for row in range(rows):\n            if row % 2 == 0:\n                n_cols = 6\n                offset = 0.0\n            else:\n                n_cols = 5\n                offset = 0.1\n            for col in range(n_cols):\n                x = offset + 0.2 + col * 0.15\n                y = 0.15 + row * 0.18\n                if len(centers) < n:\n                    centers.append([x, y])\n        return np.array(centers[:n])\n    \n    def generate_grid_base():\n        \"\"\"Generate grid pattern.\"\"\"\n        centers = []\n        cols = 6\n        rows = 5\n        for i in range(rows):\n            for j in range(cols):\n                if len(centers) < n:\n                    x = 0.1 + j * 0.16\n                    y = 0.1 + i * 0.2\n                    centers.append([x, y])\n        return np.array(centers[:n])\n    \n    def generate_boundary_base():\n        \"\"\"Generate boundary-focused pattern.\"\"\"\n        centers = []\n        # Corners\n        corners = [[0.08, 0.08], [0.92, 0.08], [0.08, 0.92], [0.92, 0.92]]\n        centers.extend(corners)\n        \n        # Edges\n        for i in range(4):\n            x = 0.08 + i * 0.28\n            centers.append([x, 0.08])\n            centers.append([x, 0.92])\n        for i in range(3):\n            y = 0.3 + i * 0.2\n            centers.append([0.08, y])\n            centers.append([0.92, y])\n        \n        # Interior\n        while len(centers) < n:\n            centers.append([0.3 + np.random.rand() * 0.4, 0.3 + np.random.rand() * 0.4])\n        \n        return np.array(centers[:n])\n    \n    def calculate_radii(centers):\n        \"\"\"Calculate maximum valid radii for given centers.\"\"\"\n        radii = np.ones(n)\n        for i in range(n):\n            # Distance to boundaries\n            r_max = min(centers[i, 0], 1 - centers[i, 0], \n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    r_max = min(r_max, (dist - radii[j]) / 2 + radii[j])\n            \n            radii[i] = max(0, r_max)\n        \n        # Iterative refinement\n        for _ in range(5):\n            for i in range(n):\n                r_max = min(centers[i, 0], 1 - centers[i, 0],\n                           centers[i, 1], 1 - centers[i, 1])\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        r_max = min(r_max, dist - radii[j])\n                radii[i] = max(0, r_max * 0.99)\n        \n        return radii\n    \n    def objective(x):\n        \"\"\"Objective: minimize negative sum of radii.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = calculate_radii(centers)\n        return -np.sum(radii)\n    \n    def optimize_packing(initial_centers, maxiter=200):\n        \"\"\"Optimize packing from initial configuration.\"\"\"\n        x0 = initial_centers.flatten()\n        \n        # Bounds: keep centers well within unit square\n        bounds = [(0.05, 0.95) for _ in range(2 * n)]\n        \n        result = minimize(\n            objective,\n            x0,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': maxiter, 'ftol': 1e-9}\n        )\n        \n        centers = result.x.reshape(n, 2)\n        radii = calculate_radii(centers)\n        return centers, radii, np.sum(radii)\n    \n    # Generate hybrid initializations\n    print(\"Generating hybrid initializations...\")\n    candidates = []\n    \n    # Get base patterns\n    hex_base = generate_hexagonal_base()\n    grid_base = generate_grid_base()\n    boundary_base = generate_boundary_base()\n    \n    # Type 1: Perturbed hexagonal (15 variants)\n    for i in range(15):\n        centers = hex_base.copy()\n        noise = np.random.randn(n, 2) * (0.01 + i * 0.002)\n        centers += noise\n        centers = np.clip(centers, 0.05, 0.95)\n        candidates.append(centers)\n    \n    # Type 2: Grid to hexagonal transition (10 variants)\n    for i in range(10):\n        alpha = i / 10\n        centers = (1 - alpha) * grid_base + alpha * hex_base\n        noise = np.random.randn(n, 2) * 0.01\n        centers += noise\n        centers = np.clip(centers, 0.05, 0.95)\n        candidates.append(centers)\n    \n    # Type 3: Boundary optimized interior (10 variants)\n    for i in range(10):\n        centers = boundary_base.copy()\n        # Optimize interior points\n        interior_mask = (centers[:, 0] > 0.15) & (centers[:, 0] < 0.85) & \\\n                       (centers[:, 1] > 0.15) & (centers[:, 1] < 0.85)\n        interior_indices = np.where(interior_mask)[0]\n        for idx in interior_indices:\n            centers[idx] = [0.2 + np.random.rand() * 0.6, 0.2 + np.random.rand() * 0.6]\n        candidates.append(centers)\n    \n    # Type 4: Hybrid combinations (15 variants)\n    for i in range(15):\n        centers = np.zeros((n, 2))\n        # Corners from boundary\n        centers[:4] = boundary_base[:4]\n        # Some edges from grid\n        centers[4:12] = grid_base[4:12]\n        # Interior from hexagonal\n        centers[12:] = hex_base[12:]\n        noise = np.random.randn(n, 2) * 0.015\n        centers += noise\n        centers = np.clip(centers, 0.05, 0.95)\n        candidates.append(centers)\n    \n    # Stage 1: Quick optimize all candidates\n    print(\"Stage 1: Quick optimization of 50 candidates...\")\n    results = []\n    for i, init_centers in enumerate(candidates):\n        centers, radii, sum_r = optimize_packing(init_centers, maxiter=200)\n        results.append((centers, radii, sum_r))\n        if (i + 1) % 10 == 0:\n            print(f\"  Processed {i+1}/50, best so far: {max(r[2] for r in results):.6f}\")\n    \n    # Sort by sum of radii\n    results.sort(key=lambda x: x[2], reverse=True)\n    print(f\"Stage 1 complete. Best: {results[0][2]:.6f}\")\n    \n    # Stage 2: Medium optimize top 10\n    print(\"\\nStage 2: Medium optimization of top 10...\")\n    top_10 = []\n    for i in range(10):\n        centers, radii, sum_r = optimize_packing(results[i][0], maxiter=500)\n        top_10.append((centers, radii, sum_r))\n        print(f\"  Candidate {i+1}/10: {sum_r:.6f}\")\n    \n    top_10.sort(key=lambda x: x[2], reverse=True)\n    print(f\"Stage 2 complete. Best: {top_10[0][2]:.6f}\")\n    \n    # Stage 3: Deep optimize top 3\n    print(\"\\nStage 3: Deep optimization of top 3...\")\n    top_3 = []\n    for i in range(3):\n        centers, radii, sum_r = optimize_packing(top_10[i][0], maxiter=1200)\n        top_3.append((centers, radii, sum_r))\n        print(f\"  Candidate {i+1}/3: {sum_r:.6f}\")\n    \n    top_3.sort(key=lambda x: x[2], reverse=True)\n    best_centers, best_radii, best_sum = top_3[0]\n    print(f\"Stage 3 complete. Best: {best_sum:.6f}\")\n    \n    # Stage 4: Micro-adjustments\n    print(\"\\nStage 4: Micro-adjustments...\")\n    best_improved = False\n    for iteration in range(3):\n        improved = False\n        for i in range(n):\n            original_pos = best_centers[i].copy()\n            best_local = best_sum\n            \n            # Try small perturbations\n            for dx in [-0.0005, 0, 0.0005]:\n                for dy in [-0.0005, 0, 0.0005]:\n                    if dx == 0 and dy == 0:\n                        continue\n                    \n                    test_centers = best_centers.copy()\n                    test_centers[i] = original_pos + np.array([dx, dy])\n                    \n                    # Check bounds\n                    if not (0.05 <= test_centers[i, 0] <= 0.95 and \n                           0.05 <= test_centers[i, 1] <= 0.95):\n                        continue\n                    \n                    test_radii = calculate_radii(test_centers)\n                    test_sum = np.sum(test_radii)\n                    \n                    if test_sum > best_local:\n                        best_local = test_sum\n                        best_centers[i] = test_centers[i]\n                        improved = True\n            \n            if improved:\n                best_radii = calculate_radii(best_centers)\n                best_sum = np.sum(best_radii)\n                best_improved = True\n        \n        print(f\"  Iteration {iteration+1}: {best_sum:.6f}\")\n        if not improved:\n            break\n    \n    # Stage 5: Final radius expansion\n    print(\"\\nStage 5: Final radius expansion...\")\n    best_radii = calculate_radii(best_centers)\n    \n    # Try to expand each radius slightly\n    for i in range(n):\n        for scale in [1.001, 1.0005, 1.0002]:\n            test_radii = best_radii.copy()\n            test_radii[i] *= scale\n            \n            # Check validity\n            valid = True\n            # Boundary check\n            if (best_centers[i, 0] - test_radii[i] < 0 or \n                best_centers[i, 0] + test_radii[i] > 1 or\n                best_centers[i, 1] - test_radii[i] < 0 or\n                best_centers[i, 1] + test_radii[i] > 1):\n                valid = False\n            \n            # Overlap check\n            if valid:\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(best_centers[i] - best_centers[j])\n                        if dist < test_radii[i] + test_radii[j]:\n                            valid = False\n                            break\n            \n            if valid:\n                best_radii[i] = test_radii[i]\n                break\n    \n    best_sum = np.sum(best_radii)\n    print(f\"\\nFinal result: {best_sum:.6f}\")\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:48:28.463656",
  "cost_data": null
}