{
  "trial_id": "trial_0_7",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    initial_centers = np.random.rand(n, 2)\n    initial_radii = np.random.rand(n) * 0.1  # Start with smaller radii\n\n    x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n\n    def objective(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return -np.sum(radii)  # Negative because we want to maximize\n\n    def constraint(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        # Constraints:\n        # 1. Circles within the unit square:\n        square_constraints = np.concatenate([centers[:, 0] - radii,\n                                             1 - centers[:, 0] - radii,\n                                             centers[:, 1] - radii,\n                                             1 - centers[:, 1] - radii])\n\n        # 2. No overlapping circles:\n        overlap_constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap_constraints.append(dist - radii[i] - radii[j])\n\n        # 3. Radii must be positive\n        radii_constraints = radii\n\n        return np.concatenate([square_constraints, overlap_constraints, radii_constraints])\n\n    cons = ({'type': 'ineq', 'fun': constraint})\n\n    bounds = [(0, 1) for _ in range(2*n)] + [(0, 1) for _ in range(n)] # Restrict radii to [0,1] for numerical stability\n\n    result = minimize(objective, x0, method='SLSQP', constraints=cons, bounds=bounds, options={'maxiter': 500})\n\n    optimized_centers = result.x[:2*n].reshape(n, 2)\n    optimized_radii = result.x[2*n:]\n    optimized_sum_radii = np.sum(optimized_radii)\n\n    return optimized_centers, optimized_radii, optimized_sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.566091968208135,
    "target_ratio": 0.9738489442915125,
    "combined_score": 0.9738489442915125,
    "eval_time": 0.6023170948028564,
    "error": null
  },
  "prompt": "Write a circle packing algorithm that starts with randomly placed circles and then uses gradient descent to optimize their positions and radii.\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    initial_centers = np.random.rand(n, 2)\n    initial_radii = np.random.rand(n) * 0.1  # Start with smaller radii\n\n    x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n\n    def objective(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return -np.sum(radii)  # Negative because we want to maximize\n\n    def constraint(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        # Constraints:\n        # 1. Circles within the unit square:\n        square_constraints = np.concatenate([centers[:, 0] - radii,\n                                             1 - centers[:, 0] - radii,\n                                             centers[:, 1] - radii,\n                                             1 - centers[:, 1] - radii])\n\n        # 2. No overlapping circles:\n        overlap_constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap_constraints.append(dist - radii[i] - radii[j])\n\n        # 3. Radii must be positive\n        radii_constraints = radii\n\n        return np.concatenate([square_constraints, overlap_constraints, radii_constraints])\n\n    cons = ({'type': 'ineq', 'fun': constraint})\n\n    bounds = [(0, 1) for _ in range(2*n)] + [(0, 1) for _ in range(n)] # Restrict radii to [0,1] for numerical stability\n\n    result = minimize(objective, x0, method='SLSQP', constraints=cons, bounds=bounds, options={'maxiter': 500})\n\n    optimized_centers = result.x[:2*n].reshape(n, 2)\n    optimized_radii = result.x[2*n:]\n    optimized_sum_radii = np.sum(optimized_radii)\n\n    return optimized_centers, optimized_radii, optimized_sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T18:32:54.280979",
  "cost_data": null
}