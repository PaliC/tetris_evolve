{
  "trial_id": "trial_0_3",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    centers = np.random.rand(n, 2)\n    radii = np.random.rand(n) * 0.05  # Initial small radii\n\n    def energy(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        # Constraint violation penalty\n        penalty = 0\n\n        # Boundary constraints\n        penalty += np.sum(np.maximum(0, radii - centers[:, 0]))  # x > 0\n        penalty += np.sum(np.maximum(0, radii - centers[:, 1]))  # y > 0\n        penalty += np.sum(np.maximum(0, centers[:, 0] + radii - 1)) # x < 1\n        penalty += np.sum(np.maximum(0, centers[:, 1] + radii - 1)) # y < 1\n\n        # Overlap penalty\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                penalty += np.maximum(0, radii[i] + radii[j] - dist)\n        \n        # Maximize sum of radii, minimize penalty\n        return -np.sum(radii) + 1000 * penalty\n\n    # Initial guess\n    x0 = np.concatenate([centers.flatten(), radii])\n\n    # Bounds\n    bounds = [(0, 1)] * (2*n) + [(0.001, 0.5)] * n # radii must be positive\n\n    # Optimization\n    result = minimize(energy, x0, method='L-BFGS-B', bounds=bounds, options={'maxiter': 500})\n    \n    optimized_centers = result.x[:2*n].reshape(n, 2)\n    optimized_radii = result.x[2*n:]\n\n    return optimized_centers, optimized_radii, np.sum(optimized_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.0309186460098685,
    "target_ratio": 0.3912404728690203,
    "combined_score": 0.3912404728690203,
    "eval_time": 3.3605566024780273,
    "error": null
  },
  "prompt": "Write a circle packing algorithm that places circles randomly and then uses a force-based simulation to separate them.\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    centers = np.random.rand(n, 2)\n    radii = np.random.rand(n) * 0.05  # Initial small radii\n\n    def energy(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        # Constraint violation penalty\n        penalty = 0\n\n        # Boundary constraints\n        penalty += np.sum(np.maximum(0, radii - centers[:, 0]))  # x > 0\n        penalty += np.sum(np.maximum(0, radii - centers[:, 1]))  # y > 0\n        penalty += np.sum(np.maximum(0, centers[:, 0] + radii - 1)) # x < 1\n        penalty += np.sum(np.maximum(0, centers[:, 1] + radii - 1)) # y < 1\n\n        # Overlap penalty\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                penalty += np.maximum(0, radii[i] + radii[j] - dist)\n        \n        # Maximize sum of radii, minimize penalty\n        return -np.sum(radii) + 1000 * penalty\n\n    # Initial guess\n    x0 = np.concatenate([centers.flatten(), radii])\n\n    # Bounds\n    bounds = [(0, 1)] * (2*n) + [(0.001, 0.5)] * n # radii must be positive\n\n    # Optimization\n    result = minimize(energy, x0, method='L-BFGS-B', bounds=bounds, options={'maxiter': 500})\n    \n    optimized_centers = result.x[:2*n].reshape(n, 2)\n    optimized_radii = result.x[2*n:]\n\n    return optimized_centers, optimized_radii, np.sum(optimized_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T18:32:56.894641",
  "cost_data": null
}