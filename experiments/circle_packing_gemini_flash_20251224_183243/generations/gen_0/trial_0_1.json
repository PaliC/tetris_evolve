{
  "trial_id": "trial_0_1",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    def calculate_radius(center, existing_centers, existing_radii):\n        \"\"\"Calculates the maximum allowed radius for a circle at a given center.\"\"\"\n        x, y = center\n        radius = min(x, 1 - x, y, 1 - y)  # Distance to boundaries\n\n        for i in range(len(existing_centers)):\n            dist = np.linalg.norm(np.array(center) - existing_centers[i])\n            radius = min(radius, dist - existing_radii[i])\n\n        return radius\n\n    def objective_function(center, existing_centers, existing_radii):\n        \"\"\"Objective function to maximize radius.\"\"\"\n        return -calculate_radius(center, existing_centers, existing_radii)\n\n    for i in range(n):\n        if i == 0:\n            # Place the first circle in the center\n            centers[i] = [0.5, 0.5]\n            radii[i] = 0.5\n        else:\n            # Find the best position for the next circle\n            bounds = ((0, 1), (0, 1))  # Center must be within the unit square\n            initial_guess = np.random.rand(2)  # Random initial guess\n\n            result = minimize(\n                objective_function,\n                initial_guess,\n                args=(centers[:i], radii[:i]),\n                bounds=bounds,\n                method='L-BFGS-B'\n            )\n\n            centers[i] = result.x\n            radii[i] = -result.fun\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.077249906022778,
    "target_ratio": 0.4088234937467849,
    "combined_score": 0.4088234937467849,
    "eval_time": 0.42306017875671387,
    "error": null
  },
  "prompt": "Write a greedy circle packing algorithm that places circles one by one,\nchoosing positions that maximize the radius at each step. Consider the distance to all existing circles and the boundaries.\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    def calculate_radius(center, existing_centers, existing_radii):\n        \"\"\"Calculates the maximum allowed radius for a circle at a given center.\"\"\"\n        x, y = center\n        radius = min(x, 1 - x, y, 1 - y)  # Distance to boundaries\n\n        for i in range(len(existing_centers)):\n            dist = np.linalg.norm(np.array(center) - existing_centers[i])\n            radius = min(radius, dist - existing_radii[i])\n\n        return radius\n\n    def objective_function(center, existing_centers, existing_radii):\n        \"\"\"Objective function to maximize radius.\"\"\"\n        return -calculate_radius(center, existing_centers, existing_radii)\n\n    for i in range(n):\n        if i == 0:\n            # Place the first circle in the center\n            centers[i] = [0.5, 0.5]\n            radii[i] = 0.5\n        else:\n            # Find the best position for the next circle\n            bounds = ((0, 1), (0, 1))  # Center must be within the unit square\n            initial_guess = np.random.rand(2)  # Random initial guess\n\n            result = minimize(\n                objective_function,\n                initial_guess,\n                args=(centers[:i], radii[:i]),\n                bounds=bounds,\n                method='L-BFGS-B'\n            )\n\n            centers[i] = result.x\n            radii[i] = -result.fun\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T18:32:53.387812",
  "cost_data": null
}