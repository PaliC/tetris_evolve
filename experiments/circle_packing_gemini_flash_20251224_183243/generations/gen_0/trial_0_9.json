{
  "trial_id": "trial_0_9",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef check_constraints(centers, radii):\n    \"\"\"\n    Check if the circle packing satisfies the constraints.\n\n    Args:\n        centers: np.array of shape (n, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (n,) - radius of each circle\n\n    Returns:\n        bool: True if all constraints are satisfied, False otherwise\n    \"\"\"\n    n = len(centers)\n    for i in range(n):\n        # Check if circle is within the unit square\n        if not (0 <= centers[i, 0] - radii[i] and centers[i, 0] + radii[i] <= 1 and\n                0 <= centers[i, 1] - radii[i] and centers[i, 1] + radii[i] <= 1):\n            return False\n\n        # Check for overlaps with other circles\n        for j in range(i + 1, n):\n            distance = np.linalg.norm(centers[i] - centers[j])\n            if distance < radii[i] + radii[j]:\n                return False\n\n    return True\n\ndef adjust_radii(centers, radii, overlap_reduction_factor=0.99):\n    \"\"\"\n    Adjust radii to reduce overlaps until no overlaps exist.\n\n    Args:\n        centers: np.array of shape (n, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (n,) - radius of each circle\n        overlap_reduction_factor: float - factor to reduce radii by in case of overlap\n\n    Returns:\n        radii: np.array of shape (n,) - adjusted radii\n    \"\"\"\n    n = len(centers)\n    while True:\n        overlap = False\n        for i in range(n):\n            for j in range(i + 1, n):\n                distance = np.linalg.norm(centers[i] - centers[j])\n                if distance < radii[i] + radii[j]:\n                    overlap = True\n                    reduction = (radii[i] + radii[j] - distance) / 2.0\n                    radii[i] *= overlap_reduction_factor\n                    radii[j] *= overlap_reduction_factor\n        if not overlap:\n            break\n    return radii\n\ndef expand_radii(centers, radii):\n    \"\"\"\n    Expand radii until they touch the boundaries or other circles.\n\n    Args:\n        centers: np.array of shape (n, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (n,) - radius of each circle\n\n    Returns:\n        radii: np.array of shape (n,) - expanded radii\n    \"\"\"\n    n = len(centers)\n    scaling_factor = 1.0\n    while True:\n        new_radii = radii * (1.0 + 0.001) # Small increase\n        valid_expansion = True\n        for i in range(n):\n            # Check if circle is within the unit square\n            if not (0 <= centers[i, 0] - new_radii[i] and centers[i, 0] + new_radii[i] <= 1 and\n                    0 <= centers[i, 1] - new_radii[i] and centers[i, 1] + new_radii[i] <= 1):\n                valid_expansion = False\n                break\n\n            # Check for overlaps with other circles\n            for j in range(i + 1, n):\n                distance = np.linalg.norm(centers[i] - centers[j])\n                if distance < new_radii[i] + new_radii[j]:\n                    valid_expansion = False\n                    break\n            if not valid_expansion:\n                break\n        \n        if not valid_expansion:\n            break\n        else:\n            radii = new_radii\n\n    return radii\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    centers = np.random.rand(n, 2)\n    radii = np.random.rand(n) * 0.1\n    \n    radii = adjust_radii(centers, radii)\n    radii = expand_radii(centers, radii)\n\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 0.24842405319213867,
    "error": "Circle 8 at (0.39224678046896966, 0.9651959169022453) with radius 0.05681707732754226 extends outside y-bounds"
  },
  "prompt": "Write a circle packing algorithm based on iteratively reducing the radius of overlapping circles until no overlaps exist, then increasing all radii proportionally until they touch the boundaries or other circles.\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef check_constraints(centers, radii):\n    \"\"\"\n    Check if the circle packing satisfies the constraints.\n\n    Args:\n        centers: np.array of shape (n, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (n,) - radius of each circle\n\n    Returns:\n        bool: True if all constraints are satisfied, False otherwise\n    \"\"\"\n    n = len(centers)\n    for i in range(n):\n        # Check if circle is within the unit square\n        if not (0 <= centers[i, 0] - radii[i] and centers[i, 0] + radii[i] <= 1 and\n                0 <= centers[i, 1] - radii[i] and centers[i, 1] + radii[i] <= 1):\n            return False\n\n        # Check for overlaps with other circles\n        for j in range(i + 1, n):\n            distance = np.linalg.norm(centers[i] - centers[j])\n            if distance < radii[i] + radii[j]:\n                return False\n\n    return True\n\ndef adjust_radii(centers, radii, overlap_reduction_factor=0.99):\n    \"\"\"\n    Adjust radii to reduce overlaps until no overlaps exist.\n\n    Args:\n        centers: np.array of shape (n, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (n,) - radius of each circle\n        overlap_reduction_factor: float - factor to reduce radii by in case of overlap\n\n    Returns:\n        radii: np.array of shape (n,) - adjusted radii\n    \"\"\"\n    n = len(centers)\n    while True:\n        overlap = False\n        for i in range(n):\n            for j in range(i + 1, n):\n                distance = np.linalg.norm(centers[i] - centers[j])\n                if distance < radii[i] + radii[j]:\n                    overlap = True\n                    reduction = (radii[i] + radii[j] - distance) / 2.0\n                    radii[i] *= overlap_reduction_factor\n                    radii[j] *= overlap_reduction_factor\n        if not overlap:\n            break\n    return radii\n\ndef expand_radii(centers, radii):\n    \"\"\"\n    Expand radii until they touch the boundaries or other circles.\n\n    Args:\n        centers: np.array of shape (n, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (n,) - radius of each circle\n\n    Returns:\n        radii: np.array of shape (n,) - expanded radii\n    \"\"\"\n    n = len(centers)\n    scaling_factor = 1.0\n    while True:\n        new_radii = radii * (1.0 + 0.001) # Small increase\n        valid_expansion = True\n        for i in range(n):\n            # Check if circle is within the unit square\n            if not (0 <= centers[i, 0] - new_radii[i] and centers[i, 0] + new_radii[i] <= 1 and\n                    0 <= centers[i, 1] - new_radii[i] and centers[i, 1] + new_radii[i] <= 1):\n                valid_expansion = False\n                break\n\n            # Check for overlaps with other circles\n            for j in range(i + 1, n):\n                distance = np.linalg.norm(centers[i] - centers[j])\n                if distance < new_radii[i] + new_radii[j]:\n                    valid_expansion = False\n                    break\n            if not valid_expansion:\n                break\n        \n        if not valid_expansion:\n            break\n        else:\n            radii = new_radii\n\n    return radii\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    centers = np.random.rand(n, 2)\n    radii = np.random.rand(n) * 0.1\n    \n    radii = adjust_radii(centers, radii)\n    radii = expand_radii(centers, radii)\n\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T18:32:55.598606",
  "cost_data": null
}