{
  "trial_id": "trial_1_13",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    def compute_max_radii(centers):\n        \"\"\"Compute maximum valid radii for given centers.\"\"\"\n        radii = np.zeros(n)\n        for i in range(n):\n            # Distance to walls\n            max_r = min(centers[i, 0], 1 - centers[i, 0],\n                       centers[i, 1], 1 - centers[i, 1])\n            # Distance to other circles\n            for j in range(i):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_r = min(max_r, dist - radii[j])\n            radii[i] = max(0, max_r)\n        return radii\n    \n    def objective(x):\n        \"\"\"Negative sum of radii.\"\"\"\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def create_constraints():\n        constraints = []\n        \n        # Boundary constraints: r <= x, r <= 1-x, r <= y, r <= 1-y\n        for i in range(n):\n            constraints.append({'type': 'ineq', \n                'fun': lambda x, i=i: x[2*i] - x[2*n+i]})  # x >= r\n            constraints.append({'type': 'ineq', \n                'fun': lambda x, i=i: 1 - x[2*i] - x[2*n+i]})  # 1-x >= r\n            constraints.append({'type': 'ineq', \n                'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]})  # y >= r\n            constraints.append({'type': 'ineq', \n                'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]})  # 1-y >= r\n        \n        # Non-overlap constraints: dist(i,j) >= r_i + r_j\n        for i in range(n):\n            for j in range(i+1, n):\n                constraints.append({'type': 'ineq',\n                    'fun': lambda x, i=i, j=j: (\n                        (x[2*i] - x[2*j])**2 + (x[2*i+1] - x[2*j+1])**2 \n                        - (x[2*n+i] + x[2*n+j])**2\n                    )})\n        \n        return constraints\n    \n    def generate_initializations():\n        inits = []\n        \n        # 1. Random initializations\n        for seed in range(5):\n            np.random.seed(seed + 42)\n            centers = np.random.uniform(0.1, 0.9, (n, 2))\n            inits.append(centers)\n        \n        # 2. Hexagonal pattern\n        centers = []\n        row = 0\n        while len(centers) < n:\n            y = 0.1 + row * 0.16\n            if y > 0.9:\n                break\n            offset = 0.08 if row % 2 else 0\n            x = 0.1 + offset\n            while x < 0.95 and len(centers) < n:\n                centers.append([x, y])\n                x += 0.16\n            row += 1\n        while len(centers) < n:\n            centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n        inits.append(np.array(centers[:n]))\n        \n        # 3. Grid patterns with variations\n        for spacing in [0.18, 0.19, 0.20]:\n            centers = []\n            for i in range(6):\n                for j in range(6):\n                    if len(centers) < n:\n                        centers.append([0.1 + i * spacing, 0.1 + j * spacing])\n            inits.append(np.array(centers[:n]))\n        \n        # 4. Concentric pattern\n        centers = [[0.5, 0.5]]\n        for ring in range(1, 5):\n            r = ring * 0.15\n            num_in_ring = min(6 * ring, n - len(centers))\n            for k in range(num_in_ring):\n                angle = 2 * np.pi * k / (6 * ring)\n                centers.append([0.5 + r * np.cos(angle), 0.5 + r * np.sin(angle)])\n                if len(centers) >= n:\n                    break\n            if len(centers) >= n:\n                break\n        while len(centers) < n:\n            centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n        inits.append(np.array(centers[:n]))\n        \n        # 5. Perturbed good patterns\n        for seed in range(5):\n            np.random.seed(seed + 100)\n            base = inits[5].copy()  # hex pattern\n            perturbed = base + np.random.uniform(-0.05, 0.05, (n, 2))\n            perturbed = np.clip(perturbed, 0.05, 0.95)\n            inits.append(perturbed)\n        \n        # 6. Diagonal patterns\n        centers = []\n        for i in range(n):\n            t = i / (n - 1)\n            x = 0.1 + 0.8 * t + np.random.uniform(-0.1, 0.1)\n            y = 0.1 + 0.8 * (i % 5) / 4 + np.random.uniform(-0.05, 0.05)\n            centers.append([np.clip(x, 0.05, 0.95), np.clip(y, 0.05, 0.95)])\n        inits.append(np.array(centers))\n        \n        return inits\n    \n    constraints = create_constraints()\n    bounds = [(0.01, 0.99)] * (2*n) + [(0.001, 0.5)] * n\n    \n    initializations = generate_initializations()\n    \n    for init_idx, init_centers in enumerate(initializations):\n        try:\n            # Compute initial radii\n            init_radii = compute_max_radii(init_centers)\n            \n            # Pack into x0\n            x0 = np.zeros(3*n)\n            x0[:2*n] = init_centers.flatten()\n            x0[2*n:] = init_radii * 0.9  # Slightly smaller to be safe\n            \n            # Optimize\n            result = minimize(objective, x0, method='SLSQP',\n                            bounds=bounds, constraints=constraints,\n                            options={'maxiter': 500, 'ftol': 1e-9})\n            \n            if result.success or True:  # Check even if not \"successful\"\n                centers = result.x[:2*n].reshape(n, 2)\n                radii = result.x[2*n:]\n                \n                # Validate solution\n                valid = True\n                for i in range(n):\n                    if radii[i] < 0:\n                        valid = False\n                        break\n                    if centers[i, 0] - radii[i] < -1e-6 or centers[i, 0] + radii[i] > 1 + 1e-6:\n                        valid = False\n                        break\n                    if centers[i, 1] - radii[i] < -1e-6 or centers[i, 1] + radii[i] > 1 + 1e-6:\n                        valid = False\n                        break\n                    for j in range(i+1, n):\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        if dist < radii[i] + radii[j] - 1e-6:\n                            valid = False\n                            break\n                    if not valid:\n                        break\n                \n                if valid:\n                    total = np.sum(radii)\n                    if total > best_sum:\n                        best_sum = total\n                        best_centers = centers.copy()\n                        best_radii = radii.copy()\n        except Exception:\n            continue\n    \n    # Final refinement of best solution\n    if best_centers is not None:\n        x0 = np.zeros(3*n)\n        x0[:2*n] = best_centers.flatten()\n        x0[2*n:] = best_radii\n        \n        result = minimize(objective, x0, method='SLSQP',\n                        bounds=bounds, constraints=constraints,\n                        options={'maxiter': 1000, 'ftol': 1e-12})\n        \n        centers = result.x[:2*n].reshape(n, 2)\n        radii = result.x[2*n:]\n        \n        if np.sum(radii) > best_sum:\n            best_centers = centers\n            best_radii = radii\n            best_sum = np.sum(radii)\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.5959954233381337,
    "eval_time": 28.26184892654419,
    "error": null
  },
  "prompt": "Create a very high quality circle packing for 26 circles in unit square [0,1]x[0,1].\n\nMETHOD: MULTI-START SLSQP with diverse initializations\n\n1. Generate 20 different initial configurations:\n   - Random uniform\n   - Grid patterns (5x5+1, 6x5-4, etc.)\n   - Hexagonal patterns\n   - Corner-biased patterns\n   \n2. For each initialization:\n   - Compute greedy radii\n   - Run SLSQP to local optimum\n   \n3. Return best valid solution found\n\nTarget: 2.636. Return complete code with construct_packing().",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    def compute_max_radii(centers):\n        \"\"\"Compute maximum valid radii for given centers.\"\"\"\n        radii = np.zeros(n)\n        for i in range(n):\n            # Distance to walls\n            max_r = min(centers[i, 0], 1 - centers[i, 0],\n                       centers[i, 1], 1 - centers[i, 1])\n            # Distance to other circles\n            for j in range(i):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_r = min(max_r, dist - radii[j])\n            radii[i] = max(0, max_r)\n        return radii\n    \n    def objective(x):\n        \"\"\"Negative sum of radii.\"\"\"\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def create_constraints():\n        constraints = []\n        \n        # Boundary constraints: r <= x, r <= 1-x, r <= y, r <= 1-y\n        for i in range(n):\n            constraints.append({'type': 'ineq', \n                'fun': lambda x, i=i: x[2*i] - x[2*n+i]})  # x >= r\n            constraints.append({'type': 'ineq', \n                'fun': lambda x, i=i: 1 - x[2*i] - x[2*n+i]})  # 1-x >= r\n            constraints.append({'type': 'ineq', \n                'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]})  # y >= r\n            constraints.append({'type': 'ineq', \n                'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]})  # 1-y >= r\n        \n        # Non-overlap constraints: dist(i,j) >= r_i + r_j\n        for i in range(n):\n            for j in range(i+1, n):\n                constraints.append({'type': 'ineq',\n                    'fun': lambda x, i=i, j=j: (\n                        (x[2*i] - x[2*j])**2 + (x[2*i+1] - x[2*j+1])**2 \n                        - (x[2*n+i] + x[2*n+j])**2\n                    )})\n        \n        return constraints\n    \n    def generate_initializations():\n        inits = []\n        \n        # 1. Random initializations\n        for seed in range(5):\n            np.random.seed(seed + 42)\n            centers = np.random.uniform(0.1, 0.9, (n, 2))\n            inits.append(centers)\n        \n        # 2. Hexagonal pattern\n        centers = []\n        row = 0\n        while len(centers) < n:\n            y = 0.1 + row * 0.16\n            if y > 0.9:\n                break\n            offset = 0.08 if row % 2 else 0\n            x = 0.1 + offset\n            while x < 0.95 and len(centers) < n:\n                centers.append([x, y])\n                x += 0.16\n            row += 1\n        while len(centers) < n:\n            centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n        inits.append(np.array(centers[:n]))\n        \n        # 3. Grid patterns with variations\n        for spacing in [0.18, 0.19, 0.20]:\n            centers = []\n            for i in range(6):\n                for j in range(6):\n                    if len(centers) < n:\n                        centers.append([0.1 + i * spacing, 0.1 + j * spacing])\n            inits.append(np.array(centers[:n]))\n        \n        # 4. Concentric pattern\n        centers = [[0.5, 0.5]]\n        for ring in range(1, 5):\n            r = ring * 0.15\n            num_in_ring = min(6 * ring, n - len(centers))\n            for k in range(num_in_ring):\n                angle = 2 * np.pi * k / (6 * ring)\n                centers.append([0.5 + r * np.cos(angle), 0.5 + r * np.sin(angle)])\n                if len(centers) >= n:\n                    break\n            if len(centers) >= n:\n                break\n        while len(centers) < n:\n            centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n        inits.append(np.array(centers[:n]))\n        \n        # 5. Perturbed good patterns\n        for seed in range(5):\n            np.random.seed(seed + 100)\n            base = inits[5].copy()  # hex pattern\n            perturbed = base + np.random.uniform(-0.05, 0.05, (n, 2))\n            perturbed = np.clip(perturbed, 0.05, 0.95)\n            inits.append(perturbed)\n        \n        # 6. Diagonal patterns\n        centers = []\n        for i in range(n):\n            t = i / (n - 1)\n            x = 0.1 + 0.8 * t + np.random.uniform(-0.1, 0.1)\n            y = 0.1 + 0.8 * (i % 5) / 4 + np.random.uniform(-0.05, 0.05)\n            centers.append([np.clip(x, 0.05, 0.95), np.clip(y, 0.05, 0.95)])\n        inits.append(np.array(centers))\n        \n        return inits\n    \n    constraints = create_constraints()\n    bounds = [(0.01, 0.99)] * (2*n) + [(0.001, 0.5)] * n\n    \n    initializations = generate_initializations()\n    \n    for init_idx, init_centers in enumerate(initializations):\n        try:\n            # Compute initial radii\n            init_radii = compute_max_radii(init_centers)\n            \n            # Pack into x0\n            x0 = np.zeros(3*n)\n            x0[:2*n] = init_centers.flatten()\n            x0[2*n:] = init_radii * 0.9  # Slightly smaller to be safe\n            \n            # Optimize\n            result = minimize(objective, x0, method='SLSQP',\n                            bounds=bounds, constraints=constraints,\n                            options={'maxiter': 500, 'ftol': 1e-9})\n            \n            if result.success or True:  # Check even if not \"successful\"\n                centers = result.x[:2*n].reshape(n, 2)\n                radii = result.x[2*n:]\n                \n                # Validate solution\n                valid = True\n                for i in range(n):\n                    if radii[i] < 0:\n                        valid = False\n                        break\n                    if centers[i, 0] - radii[i] < -1e-6 or centers[i, 0] + radii[i] > 1 + 1e-6:\n                        valid = False\n                        break\n                    if centers[i, 1] - radii[i] < -1e-6 or centers[i, 1] + radii[i] > 1 + 1e-6:\n                        valid = False\n                        break\n                    for j in range(i+1, n):\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        if dist < radii[i] + radii[j] - 1e-6:\n                            valid = False\n                            break\n                    if not valid:\n                        break\n                \n                if valid:\n                    total = np.sum(radii)\n                    if total > best_sum:\n                        best_sum = total\n                        best_centers = centers.copy()\n                        best_radii = radii.copy()\n        except Exception:\n            continue\n    \n    # Final refinement of best solution\n    if best_centers is not None:\n        x0 = np.zeros(3*n)\n        x0[:2*n] = best_centers.flatten()\n        x0[2*n:] = best_radii\n        \n        result = minimize(objective, x0, method='SLSQP',\n                        bounds=bounds, constraints=constraints,\n                        options={'maxiter': 1000, 'ftol': 1e-12})\n        \n        centers = result.x[:2*n].reshape(n, 2)\n        radii = result.x[2*n:]\n        \n        if np.sum(radii) > best_sum:\n            best_centers = centers\n            best_radii = radii\n            best_sum = np.sum(radii)\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-31T00:02:23.799311",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-opus-4.5",
    "temperature": 0.4
  }
}