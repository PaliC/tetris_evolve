{
  "trial_id": "trial_1_6",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    High-performance circle packing for 26 circles in unit square.\n    Uses initial configuration based on known good patterns, then optimizes.\n    \"\"\"\n    n = 26\n    \n    # Initial configuration based on approximate optimal packing\n    # Strategy: 4 corners + edge circles + internal hexagonal arrangement\n    \n    def create_initial_config():\n        centers = []\n        radii = []\n        \n        # Corner radius (approximate)\n        r_corner = 0.146\n        \n        # 4 corner circles\n        corners = [\n            (r_corner, r_corner),\n            (1 - r_corner, r_corner),\n            (r_corner, 1 - r_corner),\n            (1 - r_corner, 1 - r_corner)\n        ]\n        for c in corners:\n            centers.append(c)\n            radii.append(r_corner)\n        \n        # Edge circles (2 per edge, 8 total)\n        r_edge = 0.135\n        edge_positions = [\n            # Bottom edge\n            (0.33, r_edge),\n            (0.67, r_edge),\n            # Top edge\n            (0.33, 1 - r_edge),\n            (0.67, 1 - r_edge),\n            # Left edge\n            (r_edge, 0.33),\n            (r_edge, 0.67),\n            # Right edge\n            (1 - r_edge, 0.33),\n            (1 - r_edge, 0.67),\n        ]\n        for c in edge_positions:\n            centers.append(c)\n            radii.append(r_edge)\n        \n        # Internal circles (14 remaining)\n        # Use hexagonal-like grid pattern\n        r_internal = 0.095\n        \n        # Create a grid-like pattern in the interior\n        internal_positions = [\n            (0.25, 0.25), (0.5, 0.25), (0.75, 0.25),\n            (0.25, 0.5), (0.5, 0.5), (0.75, 0.5),\n            (0.25, 0.75), (0.5, 0.75), (0.75, 0.75),\n            (0.375, 0.375), (0.625, 0.375),\n            (0.375, 0.625), (0.625, 0.625),\n            (0.5, 0.15),\n        ]\n        \n        for c in internal_positions:\n            centers.append(c)\n            radii.append(r_internal)\n        \n        return np.array(centers), np.array(radii)\n    \n    centers_init, radii_init = create_initial_config()\n    \n    # Pack into optimization vector: [x1, y1, r1, x2, y2, r2, ...]\n    x0 = np.zeros(3 * n)\n    for i in range(n):\n        x0[3*i] = centers_init[i, 0]\n        x0[3*i + 1] = centers_init[i, 1]\n        x0[3*i + 2] = radii_init[i]\n    \n    # Objective: maximize sum of radii = minimize negative sum\n    def objective(x):\n        radii = x[2::3]\n        return -np.sum(radii)\n    \n    # Constraints\n    constraints = []\n    \n    # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n    for i in range(n):\n        # r_i <= x_i\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: x[3*i] - x[3*i + 2]\n        })\n        # r_i <= 1 - x_i\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: 1 - x[3*i] - x[3*i + 2]\n        })\n        # r_i <= y_i\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: x[3*i + 1] - x[3*i + 2]\n        })\n        # r_i <= 1 - y_i\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: 1 - x[3*i + 1] - x[3*i + 2]\n        })\n    \n    # Non-overlap constraints: dist(i,j) >= r_i + r_j\n    for i in range(n):\n        for j in range(i + 1, n):\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i, j=j: np.sqrt(\n                    (x[3*i] - x[3*j])**2 + (x[3*i + 1] - x[3*j + 1])**2\n                ) - x[3*i + 2] - x[3*j + 2]\n            })\n    \n    # Bounds: x, y in [0, 1], r >= 0\n    bounds = []\n    for i in range(n):\n        bounds.append((0, 1))  # x_i\n        bounds.append((0, 1))  # y_i\n        bounds.append((0, 0.5))  # r_i (max possible radius is 0.5)\n    \n    # Optimize\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': 2000, 'ftol': 1e-9}\n    )\n    \n    # Extract solution\n    x_opt = result.x\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        centers[i, 0] = x_opt[3*i]\n        centers[i, 1] = x_opt[3*i + 1]\n        radii[i] = x_opt[3*i + 2]\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.5904831482545507,
    "eval_time": 1.0154938697814941,
    "error": null
  },
  "prompt": "Create a HIGH-PERFORMANCE circle packing solution for 26 circles in unit square. Target: 2.636.\n\nApproach: Start from a GOOD KNOWN CONFIGURATION, then optimize.\n\nInitial configuration (approximate optimal positions for 26 circles):\n- 4 corner circles: r \u2248 0.146, centers at (r, r), (1-r, r), (r, 1-r), (1-r, 1-r)\n- 4 edge-midpoint circles along each edge\n- Fill remaining with hexagonal-like internal arrangement\n\nThen apply scipy.optimize.minimize with SLSQP or trust-constr.\n\nConstraints:\n- r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i (boundary)\n- sqrt((x_i-x_j)^2+(y_i-y_j)^2) >= r_i + r_j (no overlap)\n\nReturn complete code with construct_packing() returning (centers, radii, sum_radii).",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    High-performance circle packing for 26 circles in unit square.\n    Uses initial configuration based on known good patterns, then optimizes.\n    \"\"\"\n    n = 26\n    \n    # Initial configuration based on approximate optimal packing\n    # Strategy: 4 corners + edge circles + internal hexagonal arrangement\n    \n    def create_initial_config():\n        centers = []\n        radii = []\n        \n        # Corner radius (approximate)\n        r_corner = 0.146\n        \n        # 4 corner circles\n        corners = [\n            (r_corner, r_corner),\n            (1 - r_corner, r_corner),\n            (r_corner, 1 - r_corner),\n            (1 - r_corner, 1 - r_corner)\n        ]\n        for c in corners:\n            centers.append(c)\n            radii.append(r_corner)\n        \n        # Edge circles (2 per edge, 8 total)\n        r_edge = 0.135\n        edge_positions = [\n            # Bottom edge\n            (0.33, r_edge),\n            (0.67, r_edge),\n            # Top edge\n            (0.33, 1 - r_edge),\n            (0.67, 1 - r_edge),\n            # Left edge\n            (r_edge, 0.33),\n            (r_edge, 0.67),\n            # Right edge\n            (1 - r_edge, 0.33),\n            (1 - r_edge, 0.67),\n        ]\n        for c in edge_positions:\n            centers.append(c)\n            radii.append(r_edge)\n        \n        # Internal circles (14 remaining)\n        # Use hexagonal-like grid pattern\n        r_internal = 0.095\n        \n        # Create a grid-like pattern in the interior\n        internal_positions = [\n            (0.25, 0.25), (0.5, 0.25), (0.75, 0.25),\n            (0.25, 0.5), (0.5, 0.5), (0.75, 0.5),\n            (0.25, 0.75), (0.5, 0.75), (0.75, 0.75),\n            (0.375, 0.375), (0.625, 0.375),\n            (0.375, 0.625), (0.625, 0.625),\n            (0.5, 0.15),\n        ]\n        \n        for c in internal_positions:\n            centers.append(c)\n            radii.append(r_internal)\n        \n        return np.array(centers), np.array(radii)\n    \n    centers_init, radii_init = create_initial_config()\n    \n    # Pack into optimization vector: [x1, y1, r1, x2, y2, r2, ...]\n    x0 = np.zeros(3 * n)\n    for i in range(n):\n        x0[3*i] = centers_init[i, 0]\n        x0[3*i + 1] = centers_init[i, 1]\n        x0[3*i + 2] = radii_init[i]\n    \n    # Objective: maximize sum of radii = minimize negative sum\n    def objective(x):\n        radii = x[2::3]\n        return -np.sum(radii)\n    \n    # Constraints\n    constraints = []\n    \n    # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n    for i in range(n):\n        # r_i <= x_i\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: x[3*i] - x[3*i + 2]\n        })\n        # r_i <= 1 - x_i\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: 1 - x[3*i] - x[3*i + 2]\n        })\n        # r_i <= y_i\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: x[3*i + 1] - x[3*i + 2]\n        })\n        # r_i <= 1 - y_i\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: 1 - x[3*i + 1] - x[3*i + 2]\n        })\n    \n    # Non-overlap constraints: dist(i,j) >= r_i + r_j\n    for i in range(n):\n        for j in range(i + 1, n):\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i, j=j: np.sqrt(\n                    (x[3*i] - x[3*j])**2 + (x[3*i + 1] - x[3*j + 1])**2\n                ) - x[3*i + 2] - x[3*j + 2]\n            })\n    \n    # Bounds: x, y in [0, 1], r >= 0\n    bounds = []\n    for i in range(n):\n        bounds.append((0, 1))  # x_i\n        bounds.append((0, 1))  # y_i\n        bounds.append((0, 0.5))  # r_i (max possible radius is 0.5)\n    \n    # Optimize\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': 2000, 'ftol': 1e-9}\n    )\n    \n    # Extract solution\n    x_opt = result.x\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        centers[i, 0] = x_opt[3*i]\n        centers[i, 1] = x_opt[3*i + 1]\n        radii[i] = x_opt[3*i + 2]\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-31T00:01:44.721881",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.4
  }
}