{
  "trial_id": "trial_1_1",
  "generation": 1,
  "parent_id": "trial_0_12",
  "code": "",
  "metrics": {},
  "prompt": "Combine these two approaches for circle packing:\n\nAPPROACH 1 - Best initialization (score 2.6153):\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    # 1. Initial configuration: 5x5 grid + 1 extra circle\n    # Equal radius for 25 circles is 0.1. For 26, we start slightly smaller.\n    r_init = 0.092\n    centers = []\n    for i in range(5):\n        for j in range(5):\n            centers.append([0.1 + i*0.2, 0.1 + j*0.2])\n    # Add the 26th circle near the center with a small offset\n    centers.append([0.5, 0.5])\n    centers = np.array(centers)\n    \n    # Add small random noise to break symmetry for the optimizer\n    np.random.seed(42)\n    centers += np.random.uniform(-0.01, 0.01, size=(n, 2))\n    radii = np.full(n, r_init)\n\n    # Flatten parameters for optimization: [x0, y0, ..., x25, y25, r0, ..., r25]\n    initial_params = np.concatenate([centers.flatten(), radii])\n\n    def objective(params):\n        # We want to maximize sum(radii), so minimize -sum(radii)\n        r = params[2*n:]\n        return -np.sum(r)\n\n    def constraints(params):\n        c = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        cons = []\n        \n        # Boundary constraints: r_i <= x_i <= 1-r_i\n        for i in range(n):\n            cons.append(c[i, 0] - r[i])          # x - r >= 0\n            cons.append(1.0 - (c[i, 0] + r[i]))  # 1 - (x + r) >= 0\n            cons.append(c[i, 1] - r[i])          # y - r >= 0\n            cons.append(1.0 - (c[i, 1] + r[i]))  # 1 - (y + r) >= 0\n        \n        # Non-overlapping constraints: dist(ci, cj) >= ri + rj\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist_sq = np.sum((c[i] - c[j])**2)\n                cons.append(np.sqrt(dist_sq + 1e-9) - (r[i] + r[j]))\n        \n        return np.array(cons)\n\n    # Bounds for coordinates and radii\n    bounds = []\n    for _ in range(2 * n):\n        bounds.append((0, 1))\n    for _ in range(n):\n        bounds.append((0, 0.5))\n\n    # Optimization\n    res = minimize(\n        objective,\n        initial_params,\n        method='SLSQP',\n        constraints={'type': 'ineq', 'fun': constraints},\n        bounds=bounds,\n        options={'maxiter': 100, 'ftol': 1e-6}\n    )\n\n    final_params = res.x\n    final_centers = final_params[:2*n].reshape((n, 2))\n    final_radii = final_params[2*n:]\n    \n    # Ensure physical validity (clip to square)\n    for i in range(n):\n        final_radii[i] = min(final_radii[i], final_centers[i, 0], 1 - final_centers[i, 0], \n                             final_centers[i, 1], 1 - final_centers[i, 1])\n\n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    return construct_packing()\n\nAPPROACH 2 - Penalty method optimization (score 2.6032):\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    np.random.seed(42)\n    n_circles = 26\n    \n    def compute_penalties(x, penalty_weight):\n        \"\"\"Compute overlap and boundary violation penalties\"\"\"\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        # Penalty for circles outside unit square\n        boundary_penalty = 0.0\n        for i in range(n_circles):\n            cx, cy = centers[i]\n            r = radii[i]\n            # Distance from boundary (negative if outside)\n            boundary_penalty += max(0, r - cx)**2  # left\n            boundary_penalty += max(0, r - cy)**2  # bottom\n            boundary_penalty += max(0, cx + r - 1)**2  # right\n            boundary_penalty += max(0, cy + r - 1)**2  # top\n        \n        # Penalty for overlapping circles\n        overlap_penalty = 0.0\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist:\n                    overlap_penalty += (min_dist - dist)**2\n        \n        # Penalty for negative radii\n        negative_radii_penalty = np.sum(np.maximum(0, -radii)**2)\n        \n        total_penalty = boundary_penalty + overlap_penalty + negative_radii_penalty\n        return total_penalty\n    \n    def objective(x, penalty_weight):\n        \"\"\"Objective: maximize sum of radii with penalties\"\"\"\n        radii = x[2*n_circles:]\n        sum_radii = np.sum(radii)\n        penalty = compute_penalties(x, penalty_weight)\n        return -sum_radii + penalty_weight * penalty\n    \n    # Initialize with grid layout\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    initial_centers = []\n    for i in range(n_circles):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        initial_centers.append([x, y])\n    \n    initial_centers = np.array(initial_centers)\n    initial_radii = np.full(n_circles, 0.05)\n    \n    x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n    \n    # Penalty method: gradually increase penalty\n    penalty_schedule = [1.0, 10.0, 100.0, 1000.0, 10000.0]\n    \n    best_x = x0.copy()\n    \n    for penalty_weight in penalty_schedule:\n        result = minimize(\n            objective,\n            best_x,\n            args=(penalty_weight,),\n            method='L-BFGS-B',\n            bounds=[(0, 1)]*(2*n_circles) + [(0, 0.5)]*n_circles,\n            options={'maxiter': 2000, 'ftol': 1e-9}\n        )\n        best_x = result.x\n    \n    # Final refinement with very high penalty\n    for penalty_weight in [50000.0, 100000.0]:\n        result = minimize(\n            objective,\n            best_x,\n            args=(penalty_weight,),\n            method='L-BFGS-B',\n            bounds=[(0, 1)]*(2*n_circles) + [(0, 0.5)]*n_circles,\n            options={'maxiter': 3000, 'ftol': 1e-10}\n        )\n        best_x = result.x\n    \n    # Extract final solution\n    centers = best_x[:2*n_circles].reshape(n_circles, 2)\n    radii = best_x[2*n_circles:]\n    \n    # Post-processing: ensure all constraints are satisfied\n    # Clip to boundaries\n    for i in range(n_circles):\n        cx, cy = centers[i]\n        r = radii[i]\n        # Adjust radius if outside boundaries\n        max_r = min(cx, cy, 1-cx, 1-cy)\n        if r > max_r:\n            radii[i] = max(0, max_r * 0.999)\n    \n    # Check and fix overlaps by slightly reducing radii\n    max_iterations = 100\n    for iteration in range(max_iterations):\n        overlap_found = False\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist - 1e-6:\n                    # Reduce both radii proportionally\n                    overlap_found = True\n                    reduction = (min_dist - dist) / 2 * 1.01\n                    radii[i] = max(0, radii[i] - reduction)\n                    radii[j] = max(0, radii[j] - reduction)\n        if not overlap_found:\n            break\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n\nCreate a HYBRID that:\n1. Uses the equal-radii grid initialization from APPROACH 1\n2. Then applies the penalty method optimization from APPROACH 2\n3. Run multiple restarts and keep the best\n\nTarget: Beat 2.6153 by combining the strengths of both approaches.\n\nReturn in the required format.",
  "response": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    def compute_penalties(x, penalty_weight):\n        \"\"\"Compute overlap and boundary violation penalties\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        # Penalty for circles outside unit square\n        boundary_penalty = 0.0\n        for i in range(n):\n            cx, cy = centers[i]\n            r = radii[i]\n            boundary_penalty += max(0, r - cx)**2\n            boundary_penalty += max(0, r - cy)**2\n            boundary_penalty += max(0, cx + r - 1)**2\n            boundary_penalty += max(0, cy + r - 1)**2\n        \n        # Penalty for overlapping circles\n        overlap_penalty = 0.0\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist:\n                    overlap_penalty += (min_dist - dist)**2\n        \n        # Penalty for negative radii\n        negative_radii_penalty = np.sum(np.maximum(0, -radii)**2)\n        \n        return boundary_penalty + overlap_penalty + negative_radii_penalty\n    \n    def objective(x, penalty_weight):\n        radii = x[2*n:]\n        sum_radii = np.sum(radii)\n        penalty = compute_penalties(x, penalty_weight)\n        return -sum_radii + penalty_weight * penalty\n    \n    def create_grid_init(seed, noise_scale=0.01):\n        \"\"\"Create 5x5 grid + 1 extra circle initialization\"\"\"\n        np.random.seed(seed)\n        centers = []\n        for i in range(5):\n            for j in range(5):\n                centers.append([0.1 + i*0.2, 0.1 + j*0.2])\n        # Add 26th circle at various positions based on seed\n        extra_positions = [[0.5, 0.5], [0.3, 0.3], [0.7, 0.7], [0.3, 0.7], [0.7, 0.3]]\n        centers.append(extra_positions[seed % len(extra_positions)])\n        centers = np.array(centers)\n        centers += np.random.uniform(-noise_scale, noise_scale, size=(n, 2))\n        centers = np.clip(centers, 0.05, 0.95)\n        radii = np.full(n, 0.092)\n        return np.concatenate([centers.flatten(), radii])\n    \n    def optimize_with_penalty(x0):\n        \"\"\"Run penalty method optimization\"\"\"\n        best_x = x0.copy()\n        \n        # Progressive penalty schedule\n        penalty_schedule = [1.0, 10.0, 100.0, 1000.0, 5000.0, 10000.0, 50000.0]\n        \n        for penalty_weight in penalty_schedule:\n            result = minimize(\n                objective,\n                best_x,\n                args=(penalty_weight,),\n                method='L-BFGS-B',\n                bounds=[(0, 1)]*(2*n) + [(0, 0.5)]*n,\n                options={'maxiter': 2000, 'ftol': 1e-10}\n            )\n            best_x = result.x\n        \n        return best_x\n    \n    def fix_constraints(centers, radii):\n        \"\"\"Post-processing to ensure valid solution\"\"\"\n        # Clip to boundaries\n        for i in range(n):\n            max_r = min(centers[i,0], centers[i,1], 1-centers[i,0], 1-centers[i,1])\n            radii[i] = min(radii[i], max_r * 0.9999)\n        \n        # Fix overlaps\n        for _ in range(200):\n            overlap_found = False\n            for i in range(n):\n                for j in range(i+1, n):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    min_dist = radii[i] + radii[j]\n                    if dist < min_dist - 1e-9:\n                        overlap_found = True\n                        reduction = (min_dist - dist) / 2 * 1.001\n                        radii[i] = max(0, radii[i] - reduction)\n                        radii[j] = max(0, radii[j] - reduction)\n            if not overlap_found:\n                break\n        \n        return centers, radii\n    \n    # Multiple restarts with different seeds\n    for seed in range(20):\n        x0 = create_grid_init(seed, noise_scale=0.015)\n        final_x = optimize_with_penalty(x0)\n        \n        centers = final_x[:2*n].reshape(n, 2)\n        radii = final_x[2*n:]\n        centers, radii = fix_constraints(centers, radii)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    return construct_packing()",
  "reasoning": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    def compute_penalties(x, penalty_weight):\n        \"\"\"Compute overlap and boundary violation penalties\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        # Penalty for circles outside unit square\n        boundary_penalty = 0.0\n        for i in range(n):\n            cx, cy = centers[i]\n            r = radii[i]\n            boundary_penalty += max(0, r - cx)**2\n            boundary_penalty += max(0, r - cy)**2\n            boundary_penalty += max(0, cx + r - 1)**2\n            boundary_penalty += max(0, cy + r - 1)**2\n        \n        # Penalty for overlapping circles\n        overlap_penalty = 0.0\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist:\n                    overlap_penalty += (min_dist - dist)**2\n        \n        # Penalty for negative radii\n        negative_radii_penalty = np.sum(np.maximum(0, -radii)**2)\n        \n        return boundary_penalty + overlap_penalty + negative_radii_penalty\n    \n    def objective(x, penalty_weight):\n        radii = x[2*n:]\n        sum_radii = np.sum(radii)\n        penalty = compute_penalties(x, penalty_weight)\n        return -sum_radii + penalty_weight * penalty\n    \n    def create_grid_init(seed, noise_scale=0.01):\n        \"\"\"Create 5x5 grid + 1 extra circle initialization\"\"\"\n        np.random.seed(seed)\n        centers = []\n        for i in range(5):\n            for j in range(5):\n                centers.append([0.1 + i*0.2, 0.1 + j*0.2])\n        # Add 26th circle at various positions based on seed\n        extra_positions = [[0.5, 0.5], [0.3, 0.3], [0.7, 0.7], [0.3, 0.7], [0.7, 0.3]]\n        centers.append(extra_positions[seed % len(extra_positions)])\n        centers = np.array(centers)\n        centers += np.random.uniform(-noise_scale, noise_scale, size=(n, 2))\n        centers = np.clip(centers, 0.05, 0.95)\n        radii = np.full(n, 0.092)\n        return np.concatenate([centers.flatten(), radii])\n    \n    def optimize_with_penalty(x0):\n        \"\"\"Run penalty method optimization\"\"\"\n        best_x = x0.copy()\n        \n        # Progressive penalty schedule\n        penalty_schedule = [1.0, 10.0, 100.0, 1000.0, 5000.0, 10000.0, 50000.0]\n        \n        for penalty_weight in penalty_schedule:\n            result = minimize(\n                objective,\n                best_x,\n                args=(penalty_weight,),\n                method='L-BFGS-B',\n                bounds=[(0, 1)]*(2*n) + [(0, 0.5)]*n,\n                options={'maxiter': 2000, 'ftol': 1e-10}\n            )\n            best_x = result.x\n        \n        return best_x\n    \n    def fix_constraints(centers, radii):\n        \"\"\"Post-processing to ensure valid solution\"\"\"\n        # Clip to boundaries\n        for i in range(n):\n            max_r = min(centers[i,0], centers[i,1], 1-centers[i,0], 1-centers[i,1])\n            radii[i] = min(radii[i], max_r * 0.9999)\n        \n        # Fix overlaps\n        for _ in range(200):\n            overlap_found = False\n            for i in range(n):\n                for j in range(i+1, n):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    min_dist = radii[i] + radii[j]\n                    if dist < min_dist - 1e-9:\n                        overlap_found = True\n                        reduction = (min_dist - dist) / 2 * 1.001\n                        radii[i] = max(0, radii[i] - reduction)\n                        radii[j] = max(0, radii[j] - reduction)\n            if not overlap_found:\n                break\n        \n        return centers, radii\n    \n    # Multiple restarts with different seeds\n    for seed in range(20):\n        x0 = create_grid_init(seed, noise_scale=0.015)\n        final_x = optimize_with_penalty(x0)\n        \n        centers = final_x[:2*n].reshape(n, 2)\n        radii = final_x[2*n:]\n        centers, radii = fix_constraints(centers, radii)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    return construct_packing()",
  "timestamp": "2025-12-31T16:46:18.543386",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-opus-4.5",
    "temperature": 0.4
  }
}