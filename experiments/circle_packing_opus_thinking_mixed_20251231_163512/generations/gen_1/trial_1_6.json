{
  "trial_id": "trial_1_6",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef compute_optimal_radii(centers, n_circles):\n    \"\"\"\n    Given fixed centers, compute optimal radii using iterative approach.\n    For each circle, radius is limited by:\n    1. Distance to each wall\n    2. Distance to other circles minus their radii\n    \"\"\"\n    n = n_circles\n    radii = np.zeros(n)\n    \n    # Initialize with wall constraints only\n    for i in range(n):\n        wall_dist = min(centers[i, 0], 1 - centers[i, 0], \n                       centers[i, 1], 1 - centers[i, 1])\n        radii[i] = max(0, wall_dist)\n    \n    # Compute pairwise distances\n    if n > 1:\n        dist_matrix = squareform(pdist(centers))\n        np.fill_diagonal(dist_matrix, np.inf)\n    \n    # Iterative refinement (Gauss-Seidel style)\n    for _ in range(50):\n        old_radii = radii.copy()\n        for i in range(n):\n            # Wall constraint\n            wall_dist = min(centers[i, 0], 1 - centers[i, 0], \n                           centers[i, 1], 1 - centers[i, 1])\n            \n            # Other circles constraint\n            if n > 1:\n                circle_constraints = dist_matrix[i, :] - radii\n                circle_constraints[i] = np.inf\n                min_circle_dist = np.min(circle_constraints)\n            else:\n                min_circle_dist = np.inf\n            \n            radii[i] = max(0, min(wall_dist, min_circle_dist))\n        \n        if np.max(np.abs(radii - old_radii)) < 1e-12:\n            break\n    \n    return radii\n\ndef objective(centers_flat, n_circles):\n    \"\"\"Negative sum of radii (for minimization).\"\"\"\n    centers = centers_flat.reshape(n_circles, 2)\n    radii = compute_optimal_radii(centers, n_circles)\n    return -np.sum(radii)\n\ndef objective_with_grad(centers_flat, n_circles):\n    \"\"\"Objective with numerical gradient.\"\"\"\n    return objective(centers_flat, n_circles)\n\ndef generate_initial_centers(n_circles, method='grid'):\n    \"\"\"Generate initial center positions.\"\"\"\n    if method == 'grid':\n        # Create a grid that fits n_circles\n        side = int(np.ceil(np.sqrt(n_circles)))\n        spacing = 1.0 / (side + 1)\n        centers = []\n        for i in range(side):\n            for j in range(side):\n                if len(centers) < n_circles:\n                    centers.append([(i + 1) * spacing, (j + 1) * spacing])\n        return np.array(centers)\n    \n    elif method == 'hex':\n        # Hexagonal packing\n        centers = []\n        row = 0\n        y_spacing = 1.0 / 7\n        while len(centers) < n_circles:\n            if row % 2 == 0:\n                x_positions = np.linspace(0.1, 0.9, 6)\n            else:\n                x_positions = np.linspace(0.15, 0.85, 5)\n            y = (row + 1) * y_spacing\n            if y > 0.95:\n                break\n            for x in x_positions:\n                if len(centers) < n_circles:\n                    centers.append([x, y])\n            row += 1\n        while len(centers) < n_circles:\n            centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n        return np.array(centers[:n_circles])\n    \n    elif method == 'random':\n        return np.random.uniform(0.1, 0.9, (n_circles, 2))\n    \n    elif method == 'optimized_grid':\n        # 5x5 grid + 1 extra, optimized spacing\n        centers = []\n        for i in range(5):\n            for j in range(5):\n                x = 0.1 + i * 0.2\n                y = 0.1 + j * 0.2\n                centers.append([x, y])\n        # Add extra circle\n        centers.append([0.5, 0.5])\n        return np.array(centers[:n_circles])\n\ndef run_optimization(n_circles, initial_centers, maxiter=1000):\n    \"\"\"Run L-BFGS-B optimization.\"\"\"\n    bounds = [(0.001, 0.999)] * (2 * n_circles)\n    \n    result = minimize(\n        objective_with_grad,\n        initial_centers.flatten(),\n        args=(n_circles,),\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': maxiter, 'ftol': 1e-12, 'gtol': 1e-10}\n    )\n    \n    centers = result.x.reshape(n_circles, 2)\n    radii = compute_optimal_radii(centers, n_circles)\n    return centers, radii, np.sum(radii)\n\ndef construct_packing():\n    n_circles = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Try multiple initialization strategies\n    methods = ['grid', 'hex', 'optimized_grid'] + ['random'] * 10\n    \n    for method in methods:\n        try:\n            initial = generate_initial_centers(n_circles, method)\n            centers, radii, sum_radii = run_optimization(n_circles, initial, maxiter=2000)\n            \n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        except:\n            continue\n    \n    # Local refinement with perturbations\n    for _ in range(20):\n        perturbed = best_centers + np.random.normal(0, 0.02, best_centers.shape)\n        perturbed = np.clip(perturbed, 0.001, 0.999)\n        centers, radii, sum_radii = run_optimization(n_circles, perturbed, maxiter=2000)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.5809838660368443,
    "eval_time": 98.3652868270874,
    "error": null
  },
  "prompt": "Create a BILEVEL optimization for circle packing:\n\nOuter level: optimize 26 center positions (52 variables)\nInner level: for given centers, compute optimal radii\n\nKey insight: Given centers c_1,...,c_26, the optimal radius for circle i is:\nr_i = min(c_i[0], 1-c_i[0], c_i[1], 1-c_i[1], min over j\u2260i of (dist(c_i, c_j) - r_j))\n\nThis creates a system that can be solved iteratively (like Gauss-Seidel).\n\nUse scipy.optimize.minimize with L-BFGS-B on the centers, with the objective being sum of computed radii.\n\nUse good initialization (5x5 grid + 1 extra) and multiple restarts.\n\nTarget: Beat 2.6153.\n\nReturn in the required format.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef compute_optimal_radii(centers, n_circles):\n    \"\"\"\n    Given fixed centers, compute optimal radii using iterative approach.\n    For each circle, radius is limited by:\n    1. Distance to each wall\n    2. Distance to other circles minus their radii\n    \"\"\"\n    n = n_circles\n    radii = np.zeros(n)\n    \n    # Initialize with wall constraints only\n    for i in range(n):\n        wall_dist = min(centers[i, 0], 1 - centers[i, 0], \n                       centers[i, 1], 1 - centers[i, 1])\n        radii[i] = max(0, wall_dist)\n    \n    # Compute pairwise distances\n    if n > 1:\n        dist_matrix = squareform(pdist(centers))\n        np.fill_diagonal(dist_matrix, np.inf)\n    \n    # Iterative refinement (Gauss-Seidel style)\n    for _ in range(50):\n        old_radii = radii.copy()\n        for i in range(n):\n            # Wall constraint\n            wall_dist = min(centers[i, 0], 1 - centers[i, 0], \n                           centers[i, 1], 1 - centers[i, 1])\n            \n            # Other circles constraint\n            if n > 1:\n                circle_constraints = dist_matrix[i, :] - radii\n                circle_constraints[i] = np.inf\n                min_circle_dist = np.min(circle_constraints)\n            else:\n                min_circle_dist = np.inf\n            \n            radii[i] = max(0, min(wall_dist, min_circle_dist))\n        \n        if np.max(np.abs(radii - old_radii)) < 1e-12:\n            break\n    \n    return radii\n\ndef objective(centers_flat, n_circles):\n    \"\"\"Negative sum of radii (for minimization).\"\"\"\n    centers = centers_flat.reshape(n_circles, 2)\n    radii = compute_optimal_radii(centers, n_circles)\n    return -np.sum(radii)\n\ndef objective_with_grad(centers_flat, n_circles):\n    \"\"\"Objective with numerical gradient.\"\"\"\n    return objective(centers_flat, n_circles)\n\ndef generate_initial_centers(n_circles, method='grid'):\n    \"\"\"Generate initial center positions.\"\"\"\n    if method == 'grid':\n        # Create a grid that fits n_circles\n        side = int(np.ceil(np.sqrt(n_circles)))\n        spacing = 1.0 / (side + 1)\n        centers = []\n        for i in range(side):\n            for j in range(side):\n                if len(centers) < n_circles:\n                    centers.append([(i + 1) * spacing, (j + 1) * spacing])\n        return np.array(centers)\n    \n    elif method == 'hex':\n        # Hexagonal packing\n        centers = []\n        row = 0\n        y_spacing = 1.0 / 7\n        while len(centers) < n_circles:\n            if row % 2 == 0:\n                x_positions = np.linspace(0.1, 0.9, 6)\n            else:\n                x_positions = np.linspace(0.15, 0.85, 5)\n            y = (row + 1) * y_spacing\n            if y > 0.95:\n                break\n            for x in x_positions:\n                if len(centers) < n_circles:\n                    centers.append([x, y])\n            row += 1\n        while len(centers) < n_circles:\n            centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n        return np.array(centers[:n_circles])\n    \n    elif method == 'random':\n        return np.random.uniform(0.1, 0.9, (n_circles, 2))\n    \n    elif method == 'optimized_grid':\n        # 5x5 grid + 1 extra, optimized spacing\n        centers = []\n        for i in range(5):\n            for j in range(5):\n                x = 0.1 + i * 0.2\n                y = 0.1 + j * 0.2\n                centers.append([x, y])\n        # Add extra circle\n        centers.append([0.5, 0.5])\n        return np.array(centers[:n_circles])\n\ndef run_optimization(n_circles, initial_centers, maxiter=1000):\n    \"\"\"Run L-BFGS-B optimization.\"\"\"\n    bounds = [(0.001, 0.999)] * (2 * n_circles)\n    \n    result = minimize(\n        objective_with_grad,\n        initial_centers.flatten(),\n        args=(n_circles,),\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': maxiter, 'ftol': 1e-12, 'gtol': 1e-10}\n    )\n    \n    centers = result.x.reshape(n_circles, 2)\n    radii = compute_optimal_radii(centers, n_circles)\n    return centers, radii, np.sum(radii)\n\ndef construct_packing():\n    n_circles = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Try multiple initialization strategies\n    methods = ['grid', 'hex', 'optimized_grid'] + ['random'] * 10\n    \n    for method in methods:\n        try:\n            initial = generate_initial_centers(n_circles, method)\n            centers, radii, sum_radii = run_optimization(n_circles, initial, maxiter=2000)\n            \n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        except:\n            continue\n    \n    # Local refinement with perturbations\n    for _ in range(20):\n        perturbed = best_centers + np.random.normal(0, 0.02, best_centers.shape)\n        perturbed = np.clip(perturbed, 0.001, 0.999)\n        centers, radii, sum_radii = run_optimization(n_circles, perturbed, maxiter=2000)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-31T16:48:02.301331",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-opus-4.5",
    "temperature": 0.5
  }
}