{
  "trial_id": "trial_7_9",
  "generation": 7,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    np.random.seed(42)\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if packing is valid\"\"\"\n        n = len(centers)\n        # Check boundaries\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n                centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n                return False\n        \n        # Check overlaps\n        dists = cdist(centers, centers)\n        for i in range(n):\n            for j in range(i+1, n):\n                if dists[i, j] < radii[i] + radii[j] - 1e-9:\n                    return False\n        return True\n    \n    def compute_radii(centers):\n        \"\"\"Compute maximum radii for given centers\"\"\"\n        n = len(centers)\n        radii = np.zeros(n)\n        \n        for i in range(n):\n            # Distance to boundaries\n            max_r = min(centers[i, 0], 1 - centers[i, 0], \n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, (dist - radii[j]) / 2 if radii[j] > 0 else dist / 2)\n            \n            radii[i] = max(0, max_r)\n        \n        return radii\n    \n    def optimize_radii(centers):\n        \"\"\"Optimize radii using iterative approach\"\"\"\n        radii = compute_radii(centers)\n        \n        for _ in range(50):\n            old_radii = radii.copy()\n            for i in range(len(centers)):\n                max_r = min(centers[i, 0], 1 - centers[i, 0],\n                           centers[i, 1], 1 - centers[i, 1])\n                \n                for j in range(len(centers)):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        max_r = min(max_r, dist - radii[j])\n                \n                radii[i] = max(0, max_r)\n            \n            if np.allclose(radii, old_radii, atol=1e-10):\n                break\n        \n        return radii\n    \n    def vns_optimize(init_centers, max_iter=8000):\n        \"\"\"Variable Neighborhood Search\"\"\"\n        best_centers = init_centers.copy()\n        best_radii = optimize_radii(best_centers)\n        best_score = np.sum(best_radii)\n        \n        current_centers = best_centers.copy()\n        \n        for iteration in range(max_iter):\n            # Determine neighborhood size\n            k = 1 + (iteration % 5)\n            \n            # Shake: perturb k random circles\n            new_centers = current_centers.copy()\n            indices = np.random.choice(26, size=min(k, 26), replace=False)\n            \n            for idx in indices:\n                perturbation = np.random.randn(2) * 0.05 * (1 - iteration / max_iter)\n                new_centers[idx] += perturbation\n                new_centers[idx] = np.clip(new_centers[idx], 0.02, 0.98)\n            \n            # Local search\n            new_radii = optimize_radii(new_centers)\n            \n            if is_valid(new_centers, new_radii):\n                new_score = np.sum(new_radii)\n                \n                # Accept if better\n                if new_score > best_score:\n                    best_centers = new_centers.copy()\n                    best_radii = new_radii.copy()\n                    best_score = new_score\n                    current_centers = new_centers.copy()\n                elif new_score > np.sum(optimize_radii(current_centers)):\n                    current_centers = new_centers.copy()\n            \n            # Restart from best with small perturbation every 1000 iterations\n            if iteration % 1000 == 999:\n                current_centers = best_centers + np.random.randn(26, 2) * 0.01\n                current_centers = np.clip(current_centers, 0.02, 0.98)\n        \n        return best_centers, best_radii, best_score\n    \n    # Initialization 1: Hexagonal packing\n    def hexagonal_init():\n        centers = []\n        rows = 5\n        spacing = 1.0 / (rows + 1)\n        \n        for row in range(rows):\n            y = (row + 1) * spacing\n            cols = 6 if row % 2 == 0 else 5\n            x_spacing = 1.0 / (cols + 1)\n            offset = 0 if row % 2 == 0 else x_spacing / 2\n            \n            for col in range(cols):\n                x = offset + (col + 1) * x_spacing\n                centers.append([x, y])\n        \n        # Add one more to reach 26\n        centers.append([0.5, 0.95])\n        \n        return np.array(centers[:26])\n    \n    # Initialization 2: Random\n    def random_init():\n        return np.random.uniform(0.1, 0.9, size=(26, 2))\n    \n    # Initialization 3: 6x5-4 grid\n    def grid_init():\n        centers = []\n        # 6 rows of 5 circles = 30, remove 4\n        for i in range(6):\n            for j in range(5):\n                x = (j + 1) / 6\n                y = (i + 1) / 7\n                centers.append([x, y])\n        \n        # Remove 4 circles (corners)\n        centers = centers[:-4]\n        \n        return np.array(centers[:26])\n    \n    # Run VNS with all three initializations\n    results = []\n    \n    print(\"Running hexagonal initialization...\")\n    init1 = hexagonal_init()\n    centers1, radii1, score1 = vns_optimize(init1, max_iter=8000)\n    results.append((centers1, radii1, score1))\n    print(f\"Hexagonal score: {score1}\")\n    \n    print(\"Running random initialization...\")\n    init2 = random_init()\n    centers2, radii2, score2 = vns_optimize(init2, max_iter=8000)\n    results.append((centers2, radii2, score2))\n    print(f\"Random score: {score2}\")\n    \n    print(\"Running grid initialization...\")\n    init3 = grid_init()\n    centers3, radii3, score3 = vns_optimize(init3, max_iter=8000)\n    results.append((centers3, radii3, score3))\n    print(f\"Grid score: {score3}\")\n    \n    # Select best result\n    best_idx = np.argmax([score1, score2, score3])\n    best_centers, best_radii, best_score = results[best_idx]\n    \n    print(f\"\\nBest score: {best_score}\")\n    \n    return best_centers, best_radii, best_score\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.4312189886548907,
    "eval_time": 169.64531183242798,
    "error": null
  },
  "prompt": "Fresh VNS using same structure as trial_3_0:\n\nImport the ALGORITHM from trial_3_0 but try different initializations:\n1. Hexagonal init\n2. Random init  \n3. 6x5-4 grid init\n\nFor each, run VNS 8000 iterations with seed=42.\nKeep best of 3.\n\nReturn proper Python code block.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    np.random.seed(42)\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if packing is valid\"\"\"\n        n = len(centers)\n        # Check boundaries\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n                centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n                return False\n        \n        # Check overlaps\n        dists = cdist(centers, centers)\n        for i in range(n):\n            for j in range(i+1, n):\n                if dists[i, j] < radii[i] + radii[j] - 1e-9:\n                    return False\n        return True\n    \n    def compute_radii(centers):\n        \"\"\"Compute maximum radii for given centers\"\"\"\n        n = len(centers)\n        radii = np.zeros(n)\n        \n        for i in range(n):\n            # Distance to boundaries\n            max_r = min(centers[i, 0], 1 - centers[i, 0], \n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, (dist - radii[j]) / 2 if radii[j] > 0 else dist / 2)\n            \n            radii[i] = max(0, max_r)\n        \n        return radii\n    \n    def optimize_radii(centers):\n        \"\"\"Optimize radii using iterative approach\"\"\"\n        radii = compute_radii(centers)\n        \n        for _ in range(50):\n            old_radii = radii.copy()\n            for i in range(len(centers)):\n                max_r = min(centers[i, 0], 1 - centers[i, 0],\n                           centers[i, 1], 1 - centers[i, 1])\n                \n                for j in range(len(centers)):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        max_r = min(max_r, dist - radii[j])\n                \n                radii[i] = max(0, max_r)\n            \n            if np.allclose(radii, old_radii, atol=1e-10):\n                break\n        \n        return radii\n    \n    def vns_optimize(init_centers, max_iter=8000):\n        \"\"\"Variable Neighborhood Search\"\"\"\n        best_centers = init_centers.copy()\n        best_radii = optimize_radii(best_centers)\n        best_score = np.sum(best_radii)\n        \n        current_centers = best_centers.copy()\n        \n        for iteration in range(max_iter):\n            # Determine neighborhood size\n            k = 1 + (iteration % 5)\n            \n            # Shake: perturb k random circles\n            new_centers = current_centers.copy()\n            indices = np.random.choice(26, size=min(k, 26), replace=False)\n            \n            for idx in indices:\n                perturbation = np.random.randn(2) * 0.05 * (1 - iteration / max_iter)\n                new_centers[idx] += perturbation\n                new_centers[idx] = np.clip(new_centers[idx], 0.02, 0.98)\n            \n            # Local search\n            new_radii = optimize_radii(new_centers)\n            \n            if is_valid(new_centers, new_radii):\n                new_score = np.sum(new_radii)\n                \n                # Accept if better\n                if new_score > best_score:\n                    best_centers = new_centers.copy()\n                    best_radii = new_radii.copy()\n                    best_score = new_score\n                    current_centers = new_centers.copy()\n                elif new_score > np.sum(optimize_radii(current_centers)):\n                    current_centers = new_centers.copy()\n            \n            # Restart from best with small perturbation every 1000 iterations\n            if iteration % 1000 == 999:\n                current_centers = best_centers + np.random.randn(26, 2) * 0.01\n                current_centers = np.clip(current_centers, 0.02, 0.98)\n        \n        return best_centers, best_radii, best_score\n    \n    # Initialization 1: Hexagonal packing\n    def hexagonal_init():\n        centers = []\n        rows = 5\n        spacing = 1.0 / (rows + 1)\n        \n        for row in range(rows):\n            y = (row + 1) * spacing\n            cols = 6 if row % 2 == 0 else 5\n            x_spacing = 1.0 / (cols + 1)\n            offset = 0 if row % 2 == 0 else x_spacing / 2\n            \n            for col in range(cols):\n                x = offset + (col + 1) * x_spacing\n                centers.append([x, y])\n        \n        # Add one more to reach 26\n        centers.append([0.5, 0.95])\n        \n        return np.array(centers[:26])\n    \n    # Initialization 2: Random\n    def random_init():\n        return np.random.uniform(0.1, 0.9, size=(26, 2))\n    \n    # Initialization 3: 6x5-4 grid\n    def grid_init():\n        centers = []\n        # 6 rows of 5 circles = 30, remove 4\n        for i in range(6):\n            for j in range(5):\n                x = (j + 1) / 6\n                y = (i + 1) / 7\n                centers.append([x, y])\n        \n        # Remove 4 circles (corners)\n        centers = centers[:-4]\n        \n        return np.array(centers[:26])\n    \n    # Run VNS with all three initializations\n    results = []\n    \n    print(\"Running hexagonal initialization...\")\n    init1 = hexagonal_init()\n    centers1, radii1, score1 = vns_optimize(init1, max_iter=8000)\n    results.append((centers1, radii1, score1))\n    print(f\"Hexagonal score: {score1}\")\n    \n    print(\"Running random initialization...\")\n    init2 = random_init()\n    centers2, radii2, score2 = vns_optimize(init2, max_iter=8000)\n    results.append((centers2, radii2, score2))\n    print(f\"Random score: {score2}\")\n    \n    print(\"Running grid initialization...\")\n    init3 = grid_init()\n    centers3, radii3, score3 = vns_optimize(init3, max_iter=8000)\n    results.append((centers3, radii3, score3))\n    print(f\"Grid score: {score3}\")\n    \n    # Select best result\n    best_idx = np.argmax([score1, score2, score3])\n    best_centers, best_radii, best_score = results[best_idx]\n    \n    print(f\"\\nBest score: {best_score}\")\n    \n    return best_centers, best_radii, best_score\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-31T17:30:20.364569",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.5
  }
}