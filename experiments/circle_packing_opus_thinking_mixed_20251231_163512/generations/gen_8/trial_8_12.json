{
  "trial_id": "trial_8_12",
  "generation": 8,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    np.random.seed(42)\n    n = 26\n    \n    # Start with a strategic configuration\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Place 4 corner circles first (touching both walls)\n    # For corner (0,0): center at (r,r), must satisfy r \u2264 0.5\n    r_corner = 0.13\n    corners = [\n        (r_corner, r_corner),           # bottom-left\n        (1-r_corner, r_corner),         # bottom-right\n        (r_corner, 1-r_corner),         # top-left\n        (1-r_corner, 1-r_corner)        # top-right\n    ]\n    \n    for i in range(4):\n        centers[i] = corners[i]\n        radii[i] = r_corner\n    \n    # Place edge circles between corners (8 circles on edges)\n    edge_r = 0.09\n    idx = 4\n    # Bottom edge\n    centers[idx] = [0.5, edge_r]; radii[idx] = edge_r; idx += 1\n    # Top edge\n    centers[idx] = [0.5, 1-edge_r]; radii[idx] = edge_r; idx += 1\n    # Left edge\n    centers[idx] = [edge_r, 0.5]; radii[idx] = edge_r; idx += 1\n    # Right edge\n    centers[idx] = [1-edge_r, 0.5]; radii[idx] = edge_r; idx += 1\n    \n    # Additional edge circles\n    for pos in [0.3, 0.7]:\n        centers[idx] = [pos, edge_r]; radii[idx] = edge_r; idx += 1\n        centers[idx] = [pos, 1-edge_r]; radii[idx] = edge_r; idx += 1\n    \n    # Fill interior with remaining circles\n    interior_r = 0.08\n    grid_positions = [\n        (0.3, 0.3), (0.5, 0.3), (0.7, 0.3),\n        (0.3, 0.5), (0.5, 0.5), (0.7, 0.5),\n        (0.3, 0.7), (0.5, 0.7), (0.7, 0.7),\n        (0.4, 0.4), (0.6, 0.4), (0.4, 0.6), (0.6, 0.6)\n    ]\n    \n    for i in range(min(len(grid_positions), n - idx)):\n        centers[idx] = grid_positions[i]\n        radii[idx] = interior_r\n        idx += 1\n    \n    # VNS optimization\n    for iteration in range(4000):\n        # Select random circle to perturb\n        i = np.random.randint(n)\n        \n        # Save old state\n        old_center = centers[i].copy()\n        old_radius = radii[i]\n        \n        # Perturbation strategy\n        if np.random.rand() < 0.5:\n            # Move center\n            centers[i] += np.random.randn(2) * 0.02\n        else:\n            # Adjust radius\n            radii[i] *= (1 + np.random.randn() * 0.1)\n        \n        # Try to expand radius greedily\n        max_r = min(centers[i][0], centers[i][1], \n                   1-centers[i][0], 1-centers[i][1])\n        \n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_r = min(max_r, dist - radii[j])\n        \n        if max_r > 0:\n            radii[i] = min(radii[i] * 1.01, max_r * 0.99)\n        \n        # Check feasibility\n        feasible = True\n        if (centers[i][0] - radii[i] < 0 or centers[i][0] + radii[i] > 1 or\n            centers[i][1] - radii[i] < 0 or centers[i][1] + radii[i] > 1 or\n            radii[i] < 0):\n            feasible = False\n        \n        if feasible:\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    if dist < radii[i] + radii[j] - 1e-9:\n                        feasible = False\n                        break\n        \n        # Accept or reject\n        if not feasible:\n            centers[i] = old_center\n            radii[i] = old_radius\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 0.20394970991237174,
    "eval_time": 0.47426581382751465,
    "error": null
  },
  "prompt": "Pack corners maximally first:\n\nnp.random.seed(42)\n1. Place 4 circles in corners touching both walls\n   Corner (0,0): center at (r, r), radius r \u2248 0.13\n2. Place edge circles between corners\n3. Fill interior with remaining circles\n4. Apply 4000 VNS iterations\n\nReturn proper Python code block.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    np.random.seed(42)\n    n = 26\n    \n    # Start with a strategic configuration\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Place 4 corner circles first (touching both walls)\n    # For corner (0,0): center at (r,r), must satisfy r \u2264 0.5\n    r_corner = 0.13\n    corners = [\n        (r_corner, r_corner),           # bottom-left\n        (1-r_corner, r_corner),         # bottom-right\n        (r_corner, 1-r_corner),         # top-left\n        (1-r_corner, 1-r_corner)        # top-right\n    ]\n    \n    for i in range(4):\n        centers[i] = corners[i]\n        radii[i] = r_corner\n    \n    # Place edge circles between corners (8 circles on edges)\n    edge_r = 0.09\n    idx = 4\n    # Bottom edge\n    centers[idx] = [0.5, edge_r]; radii[idx] = edge_r; idx += 1\n    # Top edge\n    centers[idx] = [0.5, 1-edge_r]; radii[idx] = edge_r; idx += 1\n    # Left edge\n    centers[idx] = [edge_r, 0.5]; radii[idx] = edge_r; idx += 1\n    # Right edge\n    centers[idx] = [1-edge_r, 0.5]; radii[idx] = edge_r; idx += 1\n    \n    # Additional edge circles\n    for pos in [0.3, 0.7]:\n        centers[idx] = [pos, edge_r]; radii[idx] = edge_r; idx += 1\n        centers[idx] = [pos, 1-edge_r]; radii[idx] = edge_r; idx += 1\n    \n    # Fill interior with remaining circles\n    interior_r = 0.08\n    grid_positions = [\n        (0.3, 0.3), (0.5, 0.3), (0.7, 0.3),\n        (0.3, 0.5), (0.5, 0.5), (0.7, 0.5),\n        (0.3, 0.7), (0.5, 0.7), (0.7, 0.7),\n        (0.4, 0.4), (0.6, 0.4), (0.4, 0.6), (0.6, 0.6)\n    ]\n    \n    for i in range(min(len(grid_positions), n - idx)):\n        centers[idx] = grid_positions[i]\n        radii[idx] = interior_r\n        idx += 1\n    \n    # VNS optimization\n    for iteration in range(4000):\n        # Select random circle to perturb\n        i = np.random.randint(n)\n        \n        # Save old state\n        old_center = centers[i].copy()\n        old_radius = radii[i]\n        \n        # Perturbation strategy\n        if np.random.rand() < 0.5:\n            # Move center\n            centers[i] += np.random.randn(2) * 0.02\n        else:\n            # Adjust radius\n            radii[i] *= (1 + np.random.randn() * 0.1)\n        \n        # Try to expand radius greedily\n        max_r = min(centers[i][0], centers[i][1], \n                   1-centers[i][0], 1-centers[i][1])\n        \n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_r = min(max_r, dist - radii[j])\n        \n        if max_r > 0:\n            radii[i] = min(radii[i] * 1.01, max_r * 0.99)\n        \n        # Check feasibility\n        feasible = True\n        if (centers[i][0] - radii[i] < 0 or centers[i][0] + radii[i] > 1 or\n            centers[i][1] - radii[i] < 0 or centers[i][1] + radii[i] > 1 or\n            radii[i] < 0):\n            feasible = False\n        \n        if feasible:\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    if dist < radii[i] + radii[j] - 1e-9:\n                        feasible = False\n                        break\n        \n        # Accept or reject\n        if not feasible:\n            centers[i] = old_center\n            radii[i] = old_radius\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-31T17:34:44.458715",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.4
  }
}