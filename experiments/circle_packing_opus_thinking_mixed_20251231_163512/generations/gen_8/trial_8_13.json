{
  "trial_id": "trial_8_13",
  "generation": 8,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    np.random.seed(42)\n    \n    # Initialize 26 centers in a 5x5+1 grid pattern\n    centers_init = []\n    for i in range(5):\n        for j in range(5):\n            centers_init.append([0.1 + i * 0.2, 0.1 + j * 0.2])\n    centers_init.append([0.5, 0.5])  # 26th circle\n    centers_init = np.array(centers_init[:26])\n    \n    def compute_radii(centers):\n        \"\"\"Compute maximum radii for given centers\"\"\"\n        radii = np.full(26, 1.0)  # Start with large radii\n        \n        # Boundary constraints\n        for i in range(26):\n            radii[i] = min(radii[i], centers[i, 0], 1 - centers[i, 0],\n                          centers[i, 1], 1 - centers[i, 1])\n        \n        # Non-overlap constraints\n        for i in range(26):\n            for j in range(i + 1, 26):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_r = dist / 2\n                radii[i] = min(radii[i], max_r)\n                radii[j] = min(radii[j], max_r)\n        \n        return np.maximum(radii, 0)\n    \n    def objective(x):\n        centers = x.reshape(26, 2)\n        radii = compute_radii(centers)\n        return -np.sum(radii)\n    \n    def constraint_boundary(x):\n        \"\"\"All centers must be inside [0,1]^2 with their radii\"\"\"\n        centers = x.reshape(26, 2)\n        radii = compute_radii(centers)\n        constraints = []\n        for i in range(26):\n            constraints.extend([\n                centers[i, 0] - radii[i],  # left\n                1 - centers[i, 0] - radii[i],  # right\n                centers[i, 1] - radii[i],  # bottom\n                1 - centers[i, 1] - radii[i]  # top\n            ])\n        return np.array(constraints)\n    \n    def constraint_nonoverlap(x):\n        \"\"\"No overlaps between circles\"\"\"\n        centers = x.reshape(26, 2)\n        radii = compute_radii(centers)\n        constraints = []\n        for i in range(26):\n            for j in range(i + 1, 26):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    constraints = [\n        {'type': 'ineq', 'fun': constraint_boundary},\n        {'type': 'ineq', 'fun': constraint_nonoverlap}\n    ]\n    \n    bounds = [(0, 1) for _ in range(52)]\n    \n    result = minimize(\n        objective,\n        centers_init.flatten(),\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': 500, 'ftol': 1e-9}\n    )\n    \n    centers = result.x.reshape(26, 2)\n    radii = compute_radii(centers)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.399996913424458,
    "eval_time": 3.7638847827911377,
    "error": null
  },
  "prompt": "Pure SLSQP optimization:\n\nfrom scipy.optimize import minimize\n\nnp.random.seed(42)\n1. Init: 5x5+1 grid centers\n2. Variables: 52 floats (26 x,y pairs)\n3. Objective: -sum_radii (computed from centers)\n4. Constraints: non-overlap inequalities, boundary constraints\n5. SLSQP with maxiter=500\n\nKeep it simple. Return proper Python code block.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    np.random.seed(42)\n    \n    # Initialize 26 centers in a 5x5+1 grid pattern\n    centers_init = []\n    for i in range(5):\n        for j in range(5):\n            centers_init.append([0.1 + i * 0.2, 0.1 + j * 0.2])\n    centers_init.append([0.5, 0.5])  # 26th circle\n    centers_init = np.array(centers_init[:26])\n    \n    def compute_radii(centers):\n        \"\"\"Compute maximum radii for given centers\"\"\"\n        radii = np.full(26, 1.0)  # Start with large radii\n        \n        # Boundary constraints\n        for i in range(26):\n            radii[i] = min(radii[i], centers[i, 0], 1 - centers[i, 0],\n                          centers[i, 1], 1 - centers[i, 1])\n        \n        # Non-overlap constraints\n        for i in range(26):\n            for j in range(i + 1, 26):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_r = dist / 2\n                radii[i] = min(radii[i], max_r)\n                radii[j] = min(radii[j], max_r)\n        \n        return np.maximum(radii, 0)\n    \n    def objective(x):\n        centers = x.reshape(26, 2)\n        radii = compute_radii(centers)\n        return -np.sum(radii)\n    \n    def constraint_boundary(x):\n        \"\"\"All centers must be inside [0,1]^2 with their radii\"\"\"\n        centers = x.reshape(26, 2)\n        radii = compute_radii(centers)\n        constraints = []\n        for i in range(26):\n            constraints.extend([\n                centers[i, 0] - radii[i],  # left\n                1 - centers[i, 0] - radii[i],  # right\n                centers[i, 1] - radii[i],  # bottom\n                1 - centers[i, 1] - radii[i]  # top\n            ])\n        return np.array(constraints)\n    \n    def constraint_nonoverlap(x):\n        \"\"\"No overlaps between circles\"\"\"\n        centers = x.reshape(26, 2)\n        radii = compute_radii(centers)\n        constraints = []\n        for i in range(26):\n            for j in range(i + 1, 26):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    constraints = [\n        {'type': 'ineq', 'fun': constraint_boundary},\n        {'type': 'ineq', 'fun': constraint_nonoverlap}\n    ]\n    \n    bounds = [(0, 1) for _ in range(52)]\n    \n    result = minimize(\n        objective,\n        centers_init.flatten(),\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': 500, 'ftol': 1e-9}\n    )\n    \n    centers = result.x.reshape(26, 2)\n    radii = compute_radii(centers)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-31T17:34:42.943014",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.3
  }
}