{
  "trial_id": "trial_8_0",
  "generation": 8,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    np.random.seed(42)\n    n = 26\n    \n    # Initial configuration: 4 large corner circles + 22 smaller circles\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # 4 corner circles\n    corner_r = 0.12\n    corners = [\n        (corner_r, corner_r),\n        (1 - corner_r, corner_r),\n        (corner_r, 1 - corner_r),\n        (1 - corner_r, 1 - corner_r)\n    ]\n    \n    for i in range(4):\n        centers[i] = corners[i]\n        radii[i] = corner_r\n    \n    # Distribute remaining 22 circles in a grid-like pattern with perturbation\n    remaining = 22\n    grid_size = 5  # 5x5 grid minus corners\n    idx = 4\n    \n    for i in range(grid_size):\n        for j in range(grid_size):\n            if idx >= n:\n                break\n            # Place in grid avoiding corners\n            x = 0.2 + i * 0.15 + np.random.uniform(-0.03, 0.03)\n            y = 0.2 + j * 0.15 + np.random.uniform(-0.03, 0.03)\n            centers[idx] = [np.clip(x, 0.05, 0.95), np.clip(y, 0.05, 0.95)]\n            radii[idx] = 0.05\n            idx += 1\n    \n    # Optimization\n    def pack_to_vector(centers, radii):\n        return np.concatenate([centers.flatten(), radii])\n    \n    def vector_to_pack(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        _, radii = vector_to_pack(x)\n        return -np.sum(radii)  # Maximize sum of radii\n    \n    def constraints_func(x):\n        centers, radii = vector_to_pack(x)\n        constraints = []\n        \n        # Circles inside square\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        \n        # No overlaps\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - radii[i] - radii[j])\n        \n        return np.array(constraints)\n    \n    # Bounds\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n    \n    # Initial vector\n    x0 = pack_to_vector(centers, radii)\n    \n    # Optimize\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraints_func},\n        options={'maxiter': 300, 'ftol': 1e-6}\n    )\n    \n    centers, radii = vector_to_pack(result.x)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.5789945988646577,
    "eval_time": 0.49889397621154785,
    "error": null
  },
  "prompt": "Try asymmetric configuration with 4 large corner circles:\n\nOptimal packings often have larger circles in corners. Try:\n1. 4 corner circles at (0.12, 0.12), etc. with r=0.12\n2. Remaining 22 circles distributed non-uniformly\n3. Use scipy.optimize.minimize (SLSQP) with maxiter=300\n\nCRITICAL: Total computation must complete in under 60 seconds.\nUse np.random.seed(42).\n\nReturn proper Python code block.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    np.random.seed(42)\n    n = 26\n    \n    # Initial configuration: 4 large corner circles + 22 smaller circles\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # 4 corner circles\n    corner_r = 0.12\n    corners = [\n        (corner_r, corner_r),\n        (1 - corner_r, corner_r),\n        (corner_r, 1 - corner_r),\n        (1 - corner_r, 1 - corner_r)\n    ]\n    \n    for i in range(4):\n        centers[i] = corners[i]\n        radii[i] = corner_r\n    \n    # Distribute remaining 22 circles in a grid-like pattern with perturbation\n    remaining = 22\n    grid_size = 5  # 5x5 grid minus corners\n    idx = 4\n    \n    for i in range(grid_size):\n        for j in range(grid_size):\n            if idx >= n:\n                break\n            # Place in grid avoiding corners\n            x = 0.2 + i * 0.15 + np.random.uniform(-0.03, 0.03)\n            y = 0.2 + j * 0.15 + np.random.uniform(-0.03, 0.03)\n            centers[idx] = [np.clip(x, 0.05, 0.95), np.clip(y, 0.05, 0.95)]\n            radii[idx] = 0.05\n            idx += 1\n    \n    # Optimization\n    def pack_to_vector(centers, radii):\n        return np.concatenate([centers.flatten(), radii])\n    \n    def vector_to_pack(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        _, radii = vector_to_pack(x)\n        return -np.sum(radii)  # Maximize sum of radii\n    \n    def constraints_func(x):\n        centers, radii = vector_to_pack(x)\n        constraints = []\n        \n        # Circles inside square\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        \n        # No overlaps\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - radii[i] - radii[j])\n        \n        return np.array(constraints)\n    \n    # Bounds\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n    \n    # Initial vector\n    x0 = pack_to_vector(centers, radii)\n    \n    # Optimize\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraints_func},\n        options={'maxiter': 300, 'ftol': 1e-6}\n    )\n    \n    centers, radii = vector_to_pack(result.x)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-31T17:34:41.009920",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.5
  }
}