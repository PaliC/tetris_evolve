{
  "trial_id": "trial_0_7",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef construct_packing():\n    np.random.seed(42)\n    \n    N_CIRCLES = 26\n    POP_SIZE = 100\n    GENERATIONS = 500\n    TOURNAMENT_SIZE = 5\n    ELITE_SIZE = 5\n    MUTATION_RATE = 0.3\n    MUTATION_STRENGTH = 0.05\n    \n    def compute_max_radii(centers):\n        \"\"\"Given centers, compute maximum valid radii\"\"\"\n        radii = np.zeros(N_CIRCLES)\n        \n        for i in range(N_CIRCLES):\n            # Distance to boundaries\n            min_dist_boundary = min(\n                centers[i, 0],  # left\n                1 - centers[i, 0],  # right\n                centers[i, 1],  # bottom\n                1 - centers[i, 1]  # top\n            )\n            \n            # Distance to other circles\n            min_dist_circles = float('inf')\n            for j in range(N_CIRCLES):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    # Available radius considering other circle's radius\n                    available = dist - radii[j]\n                    min_dist_circles = min(min_dist_circles, available)\n            \n            # Maximum radius is minimum of constraints\n            radii[i] = max(0, min(min_dist_boundary, min_dist_circles))\n        \n        return radii\n    \n    def fitness(centers):\n        \"\"\"Fitness is sum of radii\"\"\"\n        radii = compute_max_radii(centers)\n        return np.sum(radii)\n    \n    def create_individual():\n        \"\"\"Create random individual with centers in [0,1]x[0,1]\"\"\"\n        return np.random.rand(N_CIRCLES, 2)\n    \n    def tournament_selection(population, fitnesses):\n        \"\"\"Select individual via tournament\"\"\"\n        indices = np.random.choice(len(population), TOURNAMENT_SIZE, replace=False)\n        best_idx = indices[np.argmax(fitnesses[indices])]\n        return population[best_idx].copy()\n    \n    def crossover(parent1, parent2):\n        \"\"\"Blend crossover\"\"\"\n        alpha = np.random.rand(N_CIRCLES, 2)\n        child = alpha * parent1 + (1 - alpha) * parent2\n        return np.clip(child, 0, 1)\n    \n    def mutate(individual):\n        \"\"\"Gaussian mutation\"\"\"\n        if np.random.rand() < MUTATION_RATE:\n            mutation = np.random.randn(N_CIRCLES, 2) * MUTATION_STRENGTH\n            individual = individual + mutation\n            individual = np.clip(individual, 0, 1)\n        return individual\n    \n    # Initialize population\n    population = [create_individual() for _ in range(POP_SIZE)]\n    \n    best_individual = None\n    best_fitness = -float('inf')\n    \n    # Evolution\n    for gen in range(GENERATIONS):\n        # Evaluate fitness\n        fitnesses = np.array([fitness(ind) for ind in population])\n        \n        # Track best\n        gen_best_idx = np.argmax(fitnesses)\n        if fitnesses[gen_best_idx] > best_fitness:\n            best_fitness = fitnesses[gen_best_idx]\n            best_individual = population[gen_best_idx].copy()\n        \n        # Create new population\n        new_population = []\n        \n        # Elitism - keep best individuals\n        elite_indices = np.argsort(fitnesses)[-ELITE_SIZE:]\n        for idx in elite_indices:\n            new_population.append(population[idx].copy())\n        \n        # Generate offspring\n        while len(new_population) < POP_SIZE:\n            parent1 = tournament_selection(population, fitnesses)\n            parent2 = tournament_selection(population, fitnesses)\n            child = crossover(parent1, parent2)\n            child = mutate(child)\n            new_population.append(child)\n        \n        population = new_population\n        \n        # Progress indicator\n        if (gen + 1) % 100 == 0:\n            print(f\"Generation {gen+1}: Best fitness = {best_fitness:.6f}\")\n    \n    # Local refinement on best solution\n    def objective(x):\n        centers = x.reshape(N_CIRCLES, 2)\n        return -fitness(centers)\n    \n    def constraint_bounds(x):\n        centers = x.reshape(N_CIRCLES, 2)\n        radii = compute_max_radii(centers)\n        violations = []\n        \n        # Check all circles are inside\n        for i in range(N_CIRCLES):\n            violations.append(centers[i, 0] - radii[i])  # left\n            violations.append(centers[i, 1] - radii[i])  # bottom\n            violations.append(1 - centers[i, 0] - radii[i])  # right\n            violations.append(1 - centers[i, 1] - radii[i])  # top\n        \n        # Check no overlaps\n        for i in range(N_CIRCLES):\n            for j in range(i+1, N_CIRCLES):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                violations.append(dist - radii[i] - radii[j])\n        \n        return np.array(violations)\n    \n    # Try local optimization\n    try:\n        result = minimize(\n            objective,\n            best_individual.flatten(),\n            method='SLSQP',\n            bounds=[(0, 1)] * (N_CIRCLES * 2),\n            options={'maxiter': 200, 'ftol': 1e-9}\n        )\n        \n        if result.success and -result.fun > best_fitness:\n            best_individual = result.x.reshape(N_CIRCLES, 2)\n            best_fitness = -result.fun\n    except:\n        pass\n    \n    # Final solution\n    centers = best_individual\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 1.8622789187995756,
    "eval_time": 63.226298809051514,
    "error": null
  },
  "prompt": "Create a circle packing algorithm using a GENETIC ALGORITHM.\n\n1. Population: each individual is 26 (x,y) centers\n2. Fitness: sum of optimal radii for those centers\n3. Selection: tournament or roulette wheel\n4. Crossover: blend centers from two parents\n5. Mutation: perturb centers randomly\n6. Run for many generations\n\nFor fitness evaluation, given centers, compute max valid radii iteratively.\n\nReturn the best individual found.\n\nReturn centers, radii, and sum_radii following the required format.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef construct_packing():\n    np.random.seed(42)\n    \n    N_CIRCLES = 26\n    POP_SIZE = 100\n    GENERATIONS = 500\n    TOURNAMENT_SIZE = 5\n    ELITE_SIZE = 5\n    MUTATION_RATE = 0.3\n    MUTATION_STRENGTH = 0.05\n    \n    def compute_max_radii(centers):\n        \"\"\"Given centers, compute maximum valid radii\"\"\"\n        radii = np.zeros(N_CIRCLES)\n        \n        for i in range(N_CIRCLES):\n            # Distance to boundaries\n            min_dist_boundary = min(\n                centers[i, 0],  # left\n                1 - centers[i, 0],  # right\n                centers[i, 1],  # bottom\n                1 - centers[i, 1]  # top\n            )\n            \n            # Distance to other circles\n            min_dist_circles = float('inf')\n            for j in range(N_CIRCLES):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    # Available radius considering other circle's radius\n                    available = dist - radii[j]\n                    min_dist_circles = min(min_dist_circles, available)\n            \n            # Maximum radius is minimum of constraints\n            radii[i] = max(0, min(min_dist_boundary, min_dist_circles))\n        \n        return radii\n    \n    def fitness(centers):\n        \"\"\"Fitness is sum of radii\"\"\"\n        radii = compute_max_radii(centers)\n        return np.sum(radii)\n    \n    def create_individual():\n        \"\"\"Create random individual with centers in [0,1]x[0,1]\"\"\"\n        return np.random.rand(N_CIRCLES, 2)\n    \n    def tournament_selection(population, fitnesses):\n        \"\"\"Select individual via tournament\"\"\"\n        indices = np.random.choice(len(population), TOURNAMENT_SIZE, replace=False)\n        best_idx = indices[np.argmax(fitnesses[indices])]\n        return population[best_idx].copy()\n    \n    def crossover(parent1, parent2):\n        \"\"\"Blend crossover\"\"\"\n        alpha = np.random.rand(N_CIRCLES, 2)\n        child = alpha * parent1 + (1 - alpha) * parent2\n        return np.clip(child, 0, 1)\n    \n    def mutate(individual):\n        \"\"\"Gaussian mutation\"\"\"\n        if np.random.rand() < MUTATION_RATE:\n            mutation = np.random.randn(N_CIRCLES, 2) * MUTATION_STRENGTH\n            individual = individual + mutation\n            individual = np.clip(individual, 0, 1)\n        return individual\n    \n    # Initialize population\n    population = [create_individual() for _ in range(POP_SIZE)]\n    \n    best_individual = None\n    best_fitness = -float('inf')\n    \n    # Evolution\n    for gen in range(GENERATIONS):\n        # Evaluate fitness\n        fitnesses = np.array([fitness(ind) for ind in population])\n        \n        # Track best\n        gen_best_idx = np.argmax(fitnesses)\n        if fitnesses[gen_best_idx] > best_fitness:\n            best_fitness = fitnesses[gen_best_idx]\n            best_individual = population[gen_best_idx].copy()\n        \n        # Create new population\n        new_population = []\n        \n        # Elitism - keep best individuals\n        elite_indices = np.argsort(fitnesses)[-ELITE_SIZE:]\n        for idx in elite_indices:\n            new_population.append(population[idx].copy())\n        \n        # Generate offspring\n        while len(new_population) < POP_SIZE:\n            parent1 = tournament_selection(population, fitnesses)\n            parent2 = tournament_selection(population, fitnesses)\n            child = crossover(parent1, parent2)\n            child = mutate(child)\n            new_population.append(child)\n        \n        population = new_population\n        \n        # Progress indicator\n        if (gen + 1) % 100 == 0:\n            print(f\"Generation {gen+1}: Best fitness = {best_fitness:.6f}\")\n    \n    # Local refinement on best solution\n    def objective(x):\n        centers = x.reshape(N_CIRCLES, 2)\n        return -fitness(centers)\n    \n    def constraint_bounds(x):\n        centers = x.reshape(N_CIRCLES, 2)\n        radii = compute_max_radii(centers)\n        violations = []\n        \n        # Check all circles are inside\n        for i in range(N_CIRCLES):\n            violations.append(centers[i, 0] - radii[i])  # left\n            violations.append(centers[i, 1] - radii[i])  # bottom\n            violations.append(1 - centers[i, 0] - radii[i])  # right\n            violations.append(1 - centers[i, 1] - radii[i])  # top\n        \n        # Check no overlaps\n        for i in range(N_CIRCLES):\n            for j in range(i+1, N_CIRCLES):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                violations.append(dist - radii[i] - radii[j])\n        \n        return np.array(violations)\n    \n    # Try local optimization\n    try:\n        result = minimize(\n            objective,\n            best_individual.flatten(),\n            method='SLSQP',\n            bounds=[(0, 1)] * (N_CIRCLES * 2),\n            options={'maxiter': 200, 'ftol': 1e-9}\n        )\n        \n        if result.success and -result.fun > best_fitness:\n            best_individual = result.x.reshape(N_CIRCLES, 2)\n            best_fitness = -result.fun\n    except:\n        pass\n    \n    # Final solution\n    centers = best_individual\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-31T16:40:09.638469",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.5
  }
}