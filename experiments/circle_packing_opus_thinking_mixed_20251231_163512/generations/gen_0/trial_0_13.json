{
  "trial_id": "trial_0_13",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    np.random.seed(42)\n    n_circles = 26\n    \n    def compute_penalties(x, penalty_weight):\n        \"\"\"Compute overlap and boundary violation penalties\"\"\"\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        # Penalty for circles outside unit square\n        boundary_penalty = 0.0\n        for i in range(n_circles):\n            cx, cy = centers[i]\n            r = radii[i]\n            # Distance from boundary (negative if outside)\n            boundary_penalty += max(0, r - cx)**2  # left\n            boundary_penalty += max(0, r - cy)**2  # bottom\n            boundary_penalty += max(0, cx + r - 1)**2  # right\n            boundary_penalty += max(0, cy + r - 1)**2  # top\n        \n        # Penalty for overlapping circles\n        overlap_penalty = 0.0\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist:\n                    overlap_penalty += (min_dist - dist)**2\n        \n        # Penalty for negative radii\n        negative_radii_penalty = np.sum(np.maximum(0, -radii)**2)\n        \n        total_penalty = boundary_penalty + overlap_penalty + negative_radii_penalty\n        return total_penalty\n    \n    def objective(x, penalty_weight):\n        \"\"\"Objective: maximize sum of radii with penalties\"\"\"\n        radii = x[2*n_circles:]\n        sum_radii = np.sum(radii)\n        penalty = compute_penalties(x, penalty_weight)\n        return -sum_radii + penalty_weight * penalty\n    \n    # Initialize with grid layout\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    initial_centers = []\n    for i in range(n_circles):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        initial_centers.append([x, y])\n    \n    initial_centers = np.array(initial_centers)\n    initial_radii = np.full(n_circles, 0.05)\n    \n    x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n    \n    # Penalty method: gradually increase penalty\n    penalty_schedule = [1.0, 10.0, 100.0, 1000.0, 10000.0]\n    \n    best_x = x0.copy()\n    \n    for penalty_weight in penalty_schedule:\n        result = minimize(\n            objective,\n            best_x,\n            args=(penalty_weight,),\n            method='L-BFGS-B',\n            bounds=[(0, 1)]*(2*n_circles) + [(0, 0.5)]*n_circles,\n            options={'maxiter': 2000, 'ftol': 1e-9}\n        )\n        best_x = result.x\n    \n    # Final refinement with very high penalty\n    for penalty_weight in [50000.0, 100000.0]:\n        result = minimize(\n            objective,\n            best_x,\n            args=(penalty_weight,),\n            method='L-BFGS-B',\n            bounds=[(0, 1)]*(2*n_circles) + [(0, 0.5)]*n_circles,\n            options={'maxiter': 3000, 'ftol': 1e-10}\n        )\n        best_x = result.x\n    \n    # Extract final solution\n    centers = best_x[:2*n_circles].reshape(n_circles, 2)\n    radii = best_x[2*n_circles:]\n    \n    # Post-processing: ensure all constraints are satisfied\n    # Clip to boundaries\n    for i in range(n_circles):\n        cx, cy = centers[i]\n        r = radii[i]\n        # Adjust radius if outside boundaries\n        max_r = min(cx, cy, 1-cx, 1-cy)\n        if r > max_r:\n            radii[i] = max(0, max_r * 0.999)\n    \n    # Check and fix overlaps by slightly reducing radii\n    max_iterations = 100\n    for iteration in range(max_iterations):\n        overlap_found = False\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist - 1e-6:\n                    # Reduce both radii proportionally\n                    overlap_found = True\n                    reduction = (min_dist - dist) / 2 * 1.01\n                    radii[i] = max(0, radii[i] - reduction)\n                    radii[j] = max(0, radii[j] - reduction)\n        if not overlap_found:\n            break\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.6031795923674017,
    "eval_time": 54.25270700454712,
    "error": null
  },
  "prompt": "Create a circle packing algorithm using PENALTY METHOD optimization.\n\nInstead of hard constraints, use soft penalties:\n- Objective = sum(radii) - penalty * (overlap_amount + outside_amount)\n- Start with small penalty, gradually increase\n- Use scipy.optimize.minimize with BFGS or L-BFGS-B\n\nOptimize both centers AND radii jointly (52 + 26 = 78 variables).\n\nReturn centers, radii, and sum_radii following the required format.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    np.random.seed(42)\n    n_circles = 26\n    \n    def compute_penalties(x, penalty_weight):\n        \"\"\"Compute overlap and boundary violation penalties\"\"\"\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        # Penalty for circles outside unit square\n        boundary_penalty = 0.0\n        for i in range(n_circles):\n            cx, cy = centers[i]\n            r = radii[i]\n            # Distance from boundary (negative if outside)\n            boundary_penalty += max(0, r - cx)**2  # left\n            boundary_penalty += max(0, r - cy)**2  # bottom\n            boundary_penalty += max(0, cx + r - 1)**2  # right\n            boundary_penalty += max(0, cy + r - 1)**2  # top\n        \n        # Penalty for overlapping circles\n        overlap_penalty = 0.0\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist:\n                    overlap_penalty += (min_dist - dist)**2\n        \n        # Penalty for negative radii\n        negative_radii_penalty = np.sum(np.maximum(0, -radii)**2)\n        \n        total_penalty = boundary_penalty + overlap_penalty + negative_radii_penalty\n        return total_penalty\n    \n    def objective(x, penalty_weight):\n        \"\"\"Objective: maximize sum of radii with penalties\"\"\"\n        radii = x[2*n_circles:]\n        sum_radii = np.sum(radii)\n        penalty = compute_penalties(x, penalty_weight)\n        return -sum_radii + penalty_weight * penalty\n    \n    # Initialize with grid layout\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    initial_centers = []\n    for i in range(n_circles):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        initial_centers.append([x, y])\n    \n    initial_centers = np.array(initial_centers)\n    initial_radii = np.full(n_circles, 0.05)\n    \n    x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n    \n    # Penalty method: gradually increase penalty\n    penalty_schedule = [1.0, 10.0, 100.0, 1000.0, 10000.0]\n    \n    best_x = x0.copy()\n    \n    for penalty_weight in penalty_schedule:\n        result = minimize(\n            objective,\n            best_x,\n            args=(penalty_weight,),\n            method='L-BFGS-B',\n            bounds=[(0, 1)]*(2*n_circles) + [(0, 0.5)]*n_circles,\n            options={'maxiter': 2000, 'ftol': 1e-9}\n        )\n        best_x = result.x\n    \n    # Final refinement with very high penalty\n    for penalty_weight in [50000.0, 100000.0]:\n        result = minimize(\n            objective,\n            best_x,\n            args=(penalty_weight,),\n            method='L-BFGS-B',\n            bounds=[(0, 1)]*(2*n_circles) + [(0, 0.5)]*n_circles,\n            options={'maxiter': 3000, 'ftol': 1e-10}\n        )\n        best_x = result.x\n    \n    # Extract final solution\n    centers = best_x[:2*n_circles].reshape(n_circles, 2)\n    radii = best_x[2*n_circles:]\n    \n    # Post-processing: ensure all constraints are satisfied\n    # Clip to boundaries\n    for i in range(n_circles):\n        cx, cy = centers[i]\n        r = radii[i]\n        # Adjust radius if outside boundaries\n        max_r = min(cx, cy, 1-cx, 1-cy)\n        if r > max_r:\n            radii[i] = max(0, max_r * 0.999)\n    \n    # Check and fix overlaps by slightly reducing radii\n    max_iterations = 100\n    for iteration in range(max_iterations):\n        overlap_found = False\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist - 1e-6:\n                    # Reduce both radii proportionally\n                    overlap_found = True\n                    reduction = (min_dist - dist) / 2 * 1.01\n                    radii[i] = max(0, radii[i] - reduction)\n                    radii[j] = max(0, radii[j] - reduction)\n        if not overlap_found:\n            break\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-31T16:40:09.328117",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.5
  }
}