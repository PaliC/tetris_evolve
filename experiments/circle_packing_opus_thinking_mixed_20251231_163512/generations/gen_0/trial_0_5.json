{
  "trial_id": "trial_0_5",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef compute_optimal_radii(centers, n_circles):\n    \"\"\"Given fixed centers, compute optimal radii iteratively.\"\"\"\n    radii = np.zeros(n_circles)\n    \n    # Compute pairwise distances\n    if n_circles > 1:\n        dist_matrix = squareform(pdist(centers))\n    else:\n        dist_matrix = np.array([[0.0]])\n    \n    # Iteratively compute radii\n    for _ in range(100):  # Usually converges quickly\n        old_radii = radii.copy()\n        for i in range(n_circles):\n            # Distance to walls\n            wall_dist = min(centers[i, 0], 1 - centers[i, 0], \n                           centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            if n_circles > 1:\n                other_constraints = []\n                for j in range(n_circles):\n                    if i != j:\n                        max_r = dist_matrix[i, j] - radii[j]\n                        other_constraints.append(max_r)\n                min_other = min(other_constraints) if other_constraints else float('inf')\n            else:\n                min_other = float('inf')\n            \n            radii[i] = max(0, min(wall_dist, min_other))\n        \n        if np.allclose(radii, old_radii, atol=1e-12):\n            break\n    \n    return radii\n\ndef objective(flat_centers, n_circles):\n    \"\"\"Negative sum of radii (to minimize).\"\"\"\n    centers = flat_centers.reshape(n_circles, 2)\n    radii = compute_optimal_radii(centers, n_circles)\n    return -np.sum(radii)\n\ndef run_local_optimization(initial_centers, n_circles):\n    \"\"\"Run local optimization from given starting point.\"\"\"\n    bounds = [(0.01, 0.99)] * (2 * n_circles)\n    \n    result = minimize(\n        objective,\n        initial_centers.flatten(),\n        args=(n_circles,),\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 500, 'ftol': 1e-10}\n    )\n    \n    centers = result.x.reshape(n_circles, 2)\n    radii = compute_optimal_radii(centers, n_circles)\n    return centers, radii, np.sum(radii)\n\ndef generate_grid_start(n_circles):\n    \"\"\"Generate a grid-based starting configuration.\"\"\"\n    n_side = int(np.ceil(np.sqrt(n_circles)))\n    spacing = 1.0 / (n_side + 1)\n    centers = []\n    for i in range(n_side):\n        for j in range(n_side):\n            if len(centers) < n_circles:\n                centers.append([(i + 1) * spacing, (j + 1) * spacing])\n    return np.array(centers)\n\ndef generate_hexagonal_start(n_circles):\n    \"\"\"Generate a hexagonal-based starting configuration.\"\"\"\n    centers = []\n    row = 0\n    while len(centers) < n_circles:\n        n_in_row = int(np.sqrt(n_circles)) + 1\n        y = 0.1 + row * 0.15\n        if y > 0.9:\n            y = 0.1 + (row % 6) * 0.13\n        for i in range(n_in_row):\n            if len(centers) >= n_circles:\n                break\n            x = 0.1 + i * 0.16\n            if row % 2 == 1:\n                x += 0.08\n            if x < 0.95 and y < 0.95:\n                centers.append([x, y])\n        row += 1\n    centers = np.array(centers[:n_circles])\n    # Add noise\n    centers += np.random.uniform(-0.02, 0.02, centers.shape)\n    centers = np.clip(centers, 0.02, 0.98)\n    return centers\n\ndef construct_packing():\n    n_circles = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    np.random.seed(42)\n    \n    # Strategy 1: Grid-based starts with perturbations\n    for _ in range(15):\n        centers = generate_grid_start(n_circles)\n        centers += np.random.uniform(-0.05, 0.05, centers.shape)\n        centers = np.clip(centers, 0.02, 0.98)\n        c, r, s = run_local_optimization(centers, n_circles)\n        if s > best_sum:\n            best_sum, best_centers, best_radii = s, c, r\n    \n    # Strategy 2: Hexagonal starts\n    for _ in range(15):\n        centers = generate_hexagonal_start(n_circles)\n        c, r, s = run_local_optimization(centers, n_circles)\n        if s > best_sum:\n            best_sum, best_centers, best_radii = s, c, r\n    \n    # Strategy 3: Pure random starts\n    for _ in range(40):\n        centers = np.random.uniform(0.05, 0.95, (n_circles, 2))\n        c, r, s = run_local_optimization(centers, n_circles)\n        if s > best_sum:\n            best_sum, best_centers, best_radii = s, c, r\n    \n    # Strategy 4: Refine best solution with basin hopping\n    for _ in range(20):\n        perturbed = best_centers + np.random.uniform(-0.03, 0.03, best_centers.shape)\n        perturbed = np.clip(perturbed, 0.02, 0.98)\n        c, r, s = run_local_optimization(perturbed, n_circles)\n        if s > best_sum:\n            best_sum, best_centers, best_radii = s, c, r\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 300.0061490535736,
    "error": "Timeout after 300s"
  },
  "prompt": "Create a circle packing algorithm using BASIN HOPPING (multiple random restarts with local optimization).\n\nFor each restart:\n1. Generate random initial centers\n2. Run local optimization (gradient descent or scipy minimize) on center positions\n3. Compute optimal radii given centers\n4. Record the sum of radii\n\nDo many restarts and return the best configuration.\n\nThe key is that given fixed centers, the optimal radius for circle i is:\n  r_i = min(x_i, 1-x_i, y_i, 1-y_i, min over j\u2260i of (dist(i,j) - r_j)/2)\n  \nThis can be solved iteratively.\n\nReturn centers, radii, and sum_radii following the required format.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef compute_optimal_radii(centers, n_circles):\n    \"\"\"Given fixed centers, compute optimal radii iteratively.\"\"\"\n    radii = np.zeros(n_circles)\n    \n    # Compute pairwise distances\n    if n_circles > 1:\n        dist_matrix = squareform(pdist(centers))\n    else:\n        dist_matrix = np.array([[0.0]])\n    \n    # Iteratively compute radii\n    for _ in range(100):  # Usually converges quickly\n        old_radii = radii.copy()\n        for i in range(n_circles):\n            # Distance to walls\n            wall_dist = min(centers[i, 0], 1 - centers[i, 0], \n                           centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            if n_circles > 1:\n                other_constraints = []\n                for j in range(n_circles):\n                    if i != j:\n                        max_r = dist_matrix[i, j] - radii[j]\n                        other_constraints.append(max_r)\n                min_other = min(other_constraints) if other_constraints else float('inf')\n            else:\n                min_other = float('inf')\n            \n            radii[i] = max(0, min(wall_dist, min_other))\n        \n        if np.allclose(radii, old_radii, atol=1e-12):\n            break\n    \n    return radii\n\ndef objective(flat_centers, n_circles):\n    \"\"\"Negative sum of radii (to minimize).\"\"\"\n    centers = flat_centers.reshape(n_circles, 2)\n    radii = compute_optimal_radii(centers, n_circles)\n    return -np.sum(radii)\n\ndef run_local_optimization(initial_centers, n_circles):\n    \"\"\"Run local optimization from given starting point.\"\"\"\n    bounds = [(0.01, 0.99)] * (2 * n_circles)\n    \n    result = minimize(\n        objective,\n        initial_centers.flatten(),\n        args=(n_circles,),\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 500, 'ftol': 1e-10}\n    )\n    \n    centers = result.x.reshape(n_circles, 2)\n    radii = compute_optimal_radii(centers, n_circles)\n    return centers, radii, np.sum(radii)\n\ndef generate_grid_start(n_circles):\n    \"\"\"Generate a grid-based starting configuration.\"\"\"\n    n_side = int(np.ceil(np.sqrt(n_circles)))\n    spacing = 1.0 / (n_side + 1)\n    centers = []\n    for i in range(n_side):\n        for j in range(n_side):\n            if len(centers) < n_circles:\n                centers.append([(i + 1) * spacing, (j + 1) * spacing])\n    return np.array(centers)\n\ndef generate_hexagonal_start(n_circles):\n    \"\"\"Generate a hexagonal-based starting configuration.\"\"\"\n    centers = []\n    row = 0\n    while len(centers) < n_circles:\n        n_in_row = int(np.sqrt(n_circles)) + 1\n        y = 0.1 + row * 0.15\n        if y > 0.9:\n            y = 0.1 + (row % 6) * 0.13\n        for i in range(n_in_row):\n            if len(centers) >= n_circles:\n                break\n            x = 0.1 + i * 0.16\n            if row % 2 == 1:\n                x += 0.08\n            if x < 0.95 and y < 0.95:\n                centers.append([x, y])\n        row += 1\n    centers = np.array(centers[:n_circles])\n    # Add noise\n    centers += np.random.uniform(-0.02, 0.02, centers.shape)\n    centers = np.clip(centers, 0.02, 0.98)\n    return centers\n\ndef construct_packing():\n    n_circles = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    np.random.seed(42)\n    \n    # Strategy 1: Grid-based starts with perturbations\n    for _ in range(15):\n        centers = generate_grid_start(n_circles)\n        centers += np.random.uniform(-0.05, 0.05, centers.shape)\n        centers = np.clip(centers, 0.02, 0.98)\n        c, r, s = run_local_optimization(centers, n_circles)\n        if s > best_sum:\n            best_sum, best_centers, best_radii = s, c, r\n    \n    # Strategy 2: Hexagonal starts\n    for _ in range(15):\n        centers = generate_hexagonal_start(n_circles)\n        c, r, s = run_local_optimization(centers, n_circles)\n        if s > best_sum:\n            best_sum, best_centers, best_radii = s, c, r\n    \n    # Strategy 3: Pure random starts\n    for _ in range(40):\n        centers = np.random.uniform(0.05, 0.95, (n_circles, 2))\n        c, r, s = run_local_optimization(centers, n_circles)\n        if s > best_sum:\n            best_sum, best_centers, best_radii = s, c, r\n    \n    # Strategy 4: Refine best solution with basin hopping\n    for _ in range(20):\n        perturbed = best_centers + np.random.uniform(-0.03, 0.03, best_centers.shape)\n        perturbed = np.clip(perturbed, 0.02, 0.98)\n        c, r, s = run_local_optimization(perturbed, n_circles)\n        if s > best_sum:\n            best_sum, best_centers, best_radii = s, c, r\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-31T16:44:02.514789",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-opus-4.5",
    "temperature": 0.5
  }
}