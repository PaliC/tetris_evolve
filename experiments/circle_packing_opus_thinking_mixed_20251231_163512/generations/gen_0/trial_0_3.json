{
  "trial_id": "trial_0_3",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    np.random.seed(42)\n    \n    def compute_optimal_radii(centers):\n        \"\"\"Given centers, compute optimal radii using linear programming.\"\"\"\n        n = len(centers)\n        \n        # Maximize sum of radii: minimize -sum(r)\n        c = -np.ones(n)\n        \n        # Inequality constraints: A_ub @ r <= b_ub\n        A_ub = []\n        b_ub = []\n        \n        # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n        for i in range(n):\n            x, y = centers[i]\n            # r_i <= x_i\n            row = np.zeros(n)\n            row[i] = 1\n            A_ub.append(row.copy())\n            b_ub.append(x)\n            # r_i <= 1 - x_i\n            A_ub.append(row.copy())\n            b_ub.append(1 - x)\n            # r_i <= y_i\n            A_ub.append(row.copy())\n            b_ub.append(y)\n            # r_i <= 1 - y_i\n            A_ub.append(row.copy())\n            b_ub.append(1 - y)\n        \n        # Non-overlap constraints: r_i + r_j <= dist(i, j)\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                row = np.zeros(n)\n                row[i] = 1\n                row[j] = 1\n                A_ub.append(row)\n                b_ub.append(dist)\n        \n        A_ub = np.array(A_ub)\n        b_ub = np.array(b_ub)\n        \n        # Bounds: r_i >= 0\n        bounds = [(0, None) for _ in range(n)]\n        \n        result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if result.success:\n            return result.x, -result.fun\n        else:\n            return np.zeros(n), 0.0\n    \n    def initialize_centers(n):\n        \"\"\"Initialize centers using a grid-based approach with perturbation.\"\"\"\n        # Use a grid layout\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers = []\n        margin = 0.1\n        step = (1 - 2 * margin) / (grid_size - 1) if grid_size > 1 else 0\n        \n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(centers) < n:\n                    x = margin + i * step + np.random.uniform(-0.02, 0.02)\n                    y = margin + j * step + np.random.uniform(-0.02, 0.02)\n                    x = np.clip(x, 0.01, 0.99)\n                    y = np.clip(y, 0.01, 0.99)\n                    centers.append([x, y])\n        \n        return np.array(centers)\n    \n    def perturb_centers(centers, temperature, move_type=None):\n        \"\"\"Make a small random perturbation to centers.\"\"\"\n        new_centers = centers.copy()\n        n = len(centers)\n        \n        if move_type is None:\n            move_type = np.random.choice(['single', 'swap', 'shift'])\n        \n        if move_type == 'single':\n            # Move a single center\n            idx = np.random.randint(n)\n            scale = 0.1 * temperature\n            delta = np.random.randn(2) * scale\n            new_centers[idx] = np.clip(new_centers[idx] + delta, 0.01, 0.99)\n        \n        elif move_type == 'swap':\n            # Swap two centers\n            i, j = np.random.choice(n, 2, replace=False)\n            new_centers[i], new_centers[j] = new_centers[j].copy(), new_centers[i].copy()\n        \n        elif move_type == 'shift':\n            # Shift all centers slightly\n            scale = 0.02 * temperature\n            delta = np.random.randn(n, 2) * scale\n            new_centers = np.clip(new_centers + delta, 0.01, 0.99)\n        \n        return new_centers\n    \n    # Simulated annealing parameters\n    n_circles = 26\n    T_initial = 1.0\n    T_final = 1e-6\n    n_iterations = 15000\n    cooling_rate = (T_final / T_initial) ** (1.0 / n_iterations)\n    \n    # Initialize\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    # Try multiple random starts\n    n_restarts = 3\n    \n    for restart in range(n_restarts):\n        if restart == 0:\n            centers = initialize_centers(n_circles)\n        else:\n            # Random initialization\n            centers = np.random.uniform(0.1, 0.9, (n_circles, 2))\n        \n        radii, current_sum = compute_optimal_radii(centers)\n        \n        local_best_centers = centers.copy()\n        local_best_radii = radii.copy()\n        local_best_sum = current_sum\n        \n        T = T_initial\n        \n        for iteration in range(n_iterations):\n            # Perturb centers\n            new_centers = perturb_centers(centers, T)\n            new_radii, new_sum = compute_optimal_radii(new_centers)\n            \n            # Acceptance criterion\n            delta = new_sum - current_sum\n            \n            if delta > 0 or np.random.random() < np.exp(delta / T):\n                centers = new_centers\n                radii = new_radii\n                current_sum = new_sum\n                \n                if current_sum > local_best_sum:\n                    local_best_centers = centers.copy()\n                    local_best_radii = radii.copy()\n                    local_best_sum = current_sum\n            \n            # Cool down\n            T *= cooling_rate\n        \n        # Update global best\n        if local_best_sum > best_sum:\n            best_centers = local_best_centers.copy()\n            best_radii = local_best_radii.copy()\n            best_sum = local_best_sum\n    \n    # Local refinement using coordinate descent\n    centers = best_centers.copy()\n    \n    for _ in range(500):\n        improved = False\n        for i in range(n_circles):\n            for dx, dy in [(0.001, 0), (-0.001, 0), (0, 0.001), (0, -0.001),\n                           (0.0005, 0.0005), (-0.0005, 0.0005), \n                           (0.0005, -0.0005), (-0.0005, -0.0005)]:\n                new_centers = centers.copy()\n                new_centers[i, 0] = np.clip(new_centers[i, 0] + dx, 0.01, 0.99)\n                new_centers[i, 1] = np.clip(new_centers[i, 1] + dy, 0.01, 0.99)\n                \n                new_radii, new_sum = compute_optimal_radii(new_centers)\n                \n                if new_sum > best_sum:\n                    centers = new_centers\n                    best_centers = new_centers.copy()\n                    best_radii = new_radii.copy()\n                    best_sum = new_sum\n                    improved = True\n                    break\n            if improved:\n                break\n        if not improved:\n            break\n    \n    return best_centers, best_radii, best_sum\n\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.1028489188135153,
    "eval_time": 93.07089710235596,
    "error": null
  },
  "prompt": "Create a circle packing algorithm for 26 circles using SIMULATED ANNEALING.\n\n1. Start with random valid configuration\n2. At each step, make a small random change (move a center, swap radii)\n3. Accept improvements always, accept worse solutions with probability exp(-delta/T)\n4. Slowly decrease temperature T\n5. After each move, recompute optimal radii for the new centers\n\nRun for many iterations. Return the best configuration found.\n\nReturn centers, radii, and sum_radii following the required format.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    np.random.seed(42)\n    \n    def compute_optimal_radii(centers):\n        \"\"\"Given centers, compute optimal radii using linear programming.\"\"\"\n        n = len(centers)\n        \n        # Maximize sum of radii: minimize -sum(r)\n        c = -np.ones(n)\n        \n        # Inequality constraints: A_ub @ r <= b_ub\n        A_ub = []\n        b_ub = []\n        \n        # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n        for i in range(n):\n            x, y = centers[i]\n            # r_i <= x_i\n            row = np.zeros(n)\n            row[i] = 1\n            A_ub.append(row.copy())\n            b_ub.append(x)\n            # r_i <= 1 - x_i\n            A_ub.append(row.copy())\n            b_ub.append(1 - x)\n            # r_i <= y_i\n            A_ub.append(row.copy())\n            b_ub.append(y)\n            # r_i <= 1 - y_i\n            A_ub.append(row.copy())\n            b_ub.append(1 - y)\n        \n        # Non-overlap constraints: r_i + r_j <= dist(i, j)\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                row = np.zeros(n)\n                row[i] = 1\n                row[j] = 1\n                A_ub.append(row)\n                b_ub.append(dist)\n        \n        A_ub = np.array(A_ub)\n        b_ub = np.array(b_ub)\n        \n        # Bounds: r_i >= 0\n        bounds = [(0, None) for _ in range(n)]\n        \n        result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if result.success:\n            return result.x, -result.fun\n        else:\n            return np.zeros(n), 0.0\n    \n    def initialize_centers(n):\n        \"\"\"Initialize centers using a grid-based approach with perturbation.\"\"\"\n        # Use a grid layout\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers = []\n        margin = 0.1\n        step = (1 - 2 * margin) / (grid_size - 1) if grid_size > 1 else 0\n        \n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(centers) < n:\n                    x = margin + i * step + np.random.uniform(-0.02, 0.02)\n                    y = margin + j * step + np.random.uniform(-0.02, 0.02)\n                    x = np.clip(x, 0.01, 0.99)\n                    y = np.clip(y, 0.01, 0.99)\n                    centers.append([x, y])\n        \n        return np.array(centers)\n    \n    def perturb_centers(centers, temperature, move_type=None):\n        \"\"\"Make a small random perturbation to centers.\"\"\"\n        new_centers = centers.copy()\n        n = len(centers)\n        \n        if move_type is None:\n            move_type = np.random.choice(['single', 'swap', 'shift'])\n        \n        if move_type == 'single':\n            # Move a single center\n            idx = np.random.randint(n)\n            scale = 0.1 * temperature\n            delta = np.random.randn(2) * scale\n            new_centers[idx] = np.clip(new_centers[idx] + delta, 0.01, 0.99)\n        \n        elif move_type == 'swap':\n            # Swap two centers\n            i, j = np.random.choice(n, 2, replace=False)\n            new_centers[i], new_centers[j] = new_centers[j].copy(), new_centers[i].copy()\n        \n        elif move_type == 'shift':\n            # Shift all centers slightly\n            scale = 0.02 * temperature\n            delta = np.random.randn(n, 2) * scale\n            new_centers = np.clip(new_centers + delta, 0.01, 0.99)\n        \n        return new_centers\n    \n    # Simulated annealing parameters\n    n_circles = 26\n    T_initial = 1.0\n    T_final = 1e-6\n    n_iterations = 15000\n    cooling_rate = (T_final / T_initial) ** (1.0 / n_iterations)\n    \n    # Initialize\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    # Try multiple random starts\n    n_restarts = 3\n    \n    for restart in range(n_restarts):\n        if restart == 0:\n            centers = initialize_centers(n_circles)\n        else:\n            # Random initialization\n            centers = np.random.uniform(0.1, 0.9, (n_circles, 2))\n        \n        radii, current_sum = compute_optimal_radii(centers)\n        \n        local_best_centers = centers.copy()\n        local_best_radii = radii.copy()\n        local_best_sum = current_sum\n        \n        T = T_initial\n        \n        for iteration in range(n_iterations):\n            # Perturb centers\n            new_centers = perturb_centers(centers, T)\n            new_radii, new_sum = compute_optimal_radii(new_centers)\n            \n            # Acceptance criterion\n            delta = new_sum - current_sum\n            \n            if delta > 0 or np.random.random() < np.exp(delta / T):\n                centers = new_centers\n                radii = new_radii\n                current_sum = new_sum\n                \n                if current_sum > local_best_sum:\n                    local_best_centers = centers.copy()\n                    local_best_radii = radii.copy()\n                    local_best_sum = current_sum\n            \n            # Cool down\n            T *= cooling_rate\n        \n        # Update global best\n        if local_best_sum > best_sum:\n            best_centers = local_best_centers.copy()\n            best_radii = local_best_radii.copy()\n            best_sum = local_best_sum\n    \n    # Local refinement using coordinate descent\n    centers = best_centers.copy()\n    \n    for _ in range(500):\n        improved = False\n        for i in range(n_circles):\n            for dx, dy in [(0.001, 0), (-0.001, 0), (0, 0.001), (0, -0.001),\n                           (0.0005, 0.0005), (-0.0005, 0.0005), \n                           (0.0005, -0.0005), (-0.0005, -0.0005)]:\n                new_centers = centers.copy()\n                new_centers[i, 0] = np.clip(new_centers[i, 0] + dx, 0.01, 0.99)\n                new_centers[i, 1] = np.clip(new_centers[i, 1] + dy, 0.01, 0.99)\n                \n                new_radii, new_sum = compute_optimal_radii(new_centers)\n                \n                if new_sum > best_sum:\n                    centers = new_centers\n                    best_centers = new_centers.copy()\n                    best_radii = new_radii.copy()\n                    best_sum = new_sum\n                    improved = True\n                    break\n            if improved:\n                break\n        if not improved:\n            break\n    \n    return best_centers, best_radii, best_sum\n\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-31T16:40:39.552601",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-opus-4.5",
    "temperature": 0.4
  }
}