{
  "trial_id": "trial_6_12",
  "generation": 6,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"Ensemble of three optimization methods, return best result.\"\"\"\n    \n    def check_feasibility(centers, radii):\n        \"\"\"Check if packing is feasible.\"\"\"\n        # Check bounds\n        if np.any(centers - radii[:, None] < 0) or np.any(centers + radii[:, None] > 1):\n            return False\n        # Check overlaps\n        dists = cdist(centers, centers)\n        np.fill_diagonal(dists, np.inf)\n        min_dists = radii[:, None] + radii[None, :]\n        if np.any(dists < min_dists - 1e-9):\n            return False\n        return True\n    \n    def compute_max_radii(centers):\n        \"\"\"Compute maximum feasible radii for given centers.\"\"\"\n        n = len(centers)\n        radii = np.ones(n)\n        \n        for i in range(n):\n            # Distance to boundaries\n            r_max = min(centers[i, 0], 1 - centers[i, 0], \n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    r_max = min(r_max, dist - radii[j])\n            \n            radii[i] = max(0, r_max)\n        \n        return radii\n    \n    def optimize_radii_iterative(centers, max_iter=100):\n        \"\"\"Iteratively optimize radii.\"\"\"\n        n = len(centers)\n        radii = np.zeros(n)\n        \n        for _ in range(max_iter):\n            old_radii = radii.copy()\n            for i in range(n):\n                r_max = min(centers[i, 0], 1 - centers[i, 0],\n                           centers[i, 1], 1 - centers[i, 1])\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        r_max = min(r_max, dist - radii[j])\n                radii[i] = max(0, r_max)\n            \n            if np.allclose(radii, old_radii, atol=1e-10):\n                break\n        \n        return radii\n    \n    def method_vns(seed=42, iterations=10000):\n        \"\"\"Variable Neighborhood Search.\"\"\"\n        np.random.seed(seed)\n        \n        # Initialize with 5x5+1 grid\n        centers = []\n        for i in range(5):\n            for j in range(5):\n                centers.append([0.1 + i * 0.2, 0.1 + j * 0.2])\n        centers.append([0.5, 0.5])\n        centers = np.array(centers)\n        \n        radii = optimize_radii_iterative(centers)\n        best_sum = np.sum(radii)\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n        \n        for it in range(iterations):\n            # Variable neighborhood: different perturbation sizes\n            k = (it % 5) + 1\n            shake_size = 0.01 * k\n            \n            # Shake: perturb random subset\n            new_centers = centers.copy()\n            n_perturb = min(k * 2, 26)\n            indices = np.random.choice(26, n_perturb, replace=False)\n            new_centers[indices] += np.random.randn(n_perturb, 2) * shake_size\n            new_centers = np.clip(new_centers, 0.05, 0.95)\n            \n            # Local search: optimize radii\n            new_radii = optimize_radii_iterative(new_centers)\n            new_sum = np.sum(new_radii)\n            \n            # Accept if better\n            if new_sum > best_sum:\n                best_sum = new_sum\n                best_centers = new_centers.copy()\n                best_radii = new_radii.copy()\n                centers = new_centers.copy()\n                radii = new_radii.copy()\n            elif new_sum > np.sum(radii):\n                centers = new_centers.copy()\n                radii = new_radii.copy()\n        \n        return best_centers, best_radii, best_sum\n    \n    def method_sa(seed=43, iterations=10000):\n        \"\"\"Simulated Annealing.\"\"\"\n        np.random.seed(seed)\n        \n        # Initialize with 5x5+1 grid\n        centers = []\n        for i in range(5):\n            for j in range(5):\n                centers.append([0.1 + i * 0.2, 0.1 + j * 0.2])\n        centers.append([0.5, 0.5])\n        centers = np.array(centers)\n        \n        radii = optimize_radii_iterative(centers)\n        current_sum = np.sum(radii)\n        best_sum = current_sum\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n        \n        T = 0.1\n        T_min = 1e-6\n        alpha = (T_min / T) ** (1.0 / iterations)\n        \n        for it in range(iterations):\n            # Perturb\n            new_centers = centers.copy()\n            idx = np.random.randint(26)\n            new_centers[idx] += np.random.randn(2) * 0.02\n            new_centers = np.clip(new_centers, 0.05, 0.95)\n            \n            new_radii = optimize_radii_iterative(new_centers)\n            new_sum = np.sum(new_radii)\n            \n            # Accept or reject\n            delta = new_sum - current_sum\n            if delta > 0 or np.random.rand() < np.exp(delta / T):\n                centers = new_centers.copy()\n                radii = new_radii.copy()\n                current_sum = new_sum\n                \n                if new_sum > best_sum:\n                    best_sum = new_sum\n                    best_centers = new_centers.copy()\n                    best_radii = new_radii.copy()\n            \n            T *= alpha\n        \n        return best_centers, best_radii, best_sum\n    \n    def method_coordinate_descent(seed=44, iterations=10000):\n        \"\"\"Coordinate Descent.\"\"\"\n        np.random.seed(seed)\n        \n        # Initialize with 5x5+1 grid\n        centers = []\n        for i in range(5):\n            for j in range(5):\n                centers.append([0.1 + i * 0.2, 0.1 + j * 0.2])\n        centers.append([0.5, 0.5])\n        centers = np.array(centers)\n        \n        radii = optimize_radii_iterative(centers)\n        best_sum = np.sum(radii)\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n        \n        step_size = 0.02\n        \n        for it in range(iterations):\n            improved = False\n            idx = it % 26\n            \n            # Try moving in each direction\n            for dx, dy in [(step_size, 0), (-step_size, 0), \n                          (0, step_size), (0, -step_size)]:\n                new_centers = centers.copy()\n                new_centers[idx] += [dx, dy]\n                \n                if (new_centers[idx, 0] < 0.05 or new_centers[idx, 0] > 0.95 or\n                    new_centers[idx, 1] < 0.05 or new_centers[idx, 1] > 0.95):\n                    continue\n                \n                new_radii = optimize_radii_iterative(new_centers)\n                new_sum = np.sum(new_radii)\n                \n                if new_sum > best_sum:\n                    best_sum = new_sum\n                    best_centers = new_centers.copy()\n                    best_radii = new_radii.copy()\n                    centers = new_centers.copy()\n                    radii = new_radii.copy()\n                    improved = True\n                    break\n            \n            # Decay step size\n            if it % 260 == 259 and not improved:\n                step_size *= 0.9\n        \n        return best_centers, best_radii, best_sum\n    \n    # Run all three methods\n    results = []\n    results.append(method_vns(seed=42, iterations=10000))\n    results.append(method_sa(seed=43, iterations=10000))\n    results.append(method_coordinate_descent(seed=44, iterations=10000))\n    \n    # Return best\n    best_idx = np.argmax([r[2] for r in results])\n    centers, radii, sum_radii = results[best_idx]\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.5069273601249407,
    "eval_time": 127.66307306289673,
    "error": null
  },
  "prompt": "Ensemble of multiple methods:\n\nRun 3 different methods, keep best:\n\nMethod 1: VNS with seed=42, 10000 iterations\nMethod 2: SA with seed=43, 10000 iterations  \nMethod 3: Coordinate descent with seed=44, 10000 iterations\n\nAll start from 5x5+1 grid. Return best of 3.\n\nReturn proper Python code block.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"Ensemble of three optimization methods, return best result.\"\"\"\n    \n    def check_feasibility(centers, radii):\n        \"\"\"Check if packing is feasible.\"\"\"\n        # Check bounds\n        if np.any(centers - radii[:, None] < 0) or np.any(centers + radii[:, None] > 1):\n            return False\n        # Check overlaps\n        dists = cdist(centers, centers)\n        np.fill_diagonal(dists, np.inf)\n        min_dists = radii[:, None] + radii[None, :]\n        if np.any(dists < min_dists - 1e-9):\n            return False\n        return True\n    \n    def compute_max_radii(centers):\n        \"\"\"Compute maximum feasible radii for given centers.\"\"\"\n        n = len(centers)\n        radii = np.ones(n)\n        \n        for i in range(n):\n            # Distance to boundaries\n            r_max = min(centers[i, 0], 1 - centers[i, 0], \n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    r_max = min(r_max, dist - radii[j])\n            \n            radii[i] = max(0, r_max)\n        \n        return radii\n    \n    def optimize_radii_iterative(centers, max_iter=100):\n        \"\"\"Iteratively optimize radii.\"\"\"\n        n = len(centers)\n        radii = np.zeros(n)\n        \n        for _ in range(max_iter):\n            old_radii = radii.copy()\n            for i in range(n):\n                r_max = min(centers[i, 0], 1 - centers[i, 0],\n                           centers[i, 1], 1 - centers[i, 1])\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        r_max = min(r_max, dist - radii[j])\n                radii[i] = max(0, r_max)\n            \n            if np.allclose(radii, old_radii, atol=1e-10):\n                break\n        \n        return radii\n    \n    def method_vns(seed=42, iterations=10000):\n        \"\"\"Variable Neighborhood Search.\"\"\"\n        np.random.seed(seed)\n        \n        # Initialize with 5x5+1 grid\n        centers = []\n        for i in range(5):\n            for j in range(5):\n                centers.append([0.1 + i * 0.2, 0.1 + j * 0.2])\n        centers.append([0.5, 0.5])\n        centers = np.array(centers)\n        \n        radii = optimize_radii_iterative(centers)\n        best_sum = np.sum(radii)\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n        \n        for it in range(iterations):\n            # Variable neighborhood: different perturbation sizes\n            k = (it % 5) + 1\n            shake_size = 0.01 * k\n            \n            # Shake: perturb random subset\n            new_centers = centers.copy()\n            n_perturb = min(k * 2, 26)\n            indices = np.random.choice(26, n_perturb, replace=False)\n            new_centers[indices] += np.random.randn(n_perturb, 2) * shake_size\n            new_centers = np.clip(new_centers, 0.05, 0.95)\n            \n            # Local search: optimize radii\n            new_radii = optimize_radii_iterative(new_centers)\n            new_sum = np.sum(new_radii)\n            \n            # Accept if better\n            if new_sum > best_sum:\n                best_sum = new_sum\n                best_centers = new_centers.copy()\n                best_radii = new_radii.copy()\n                centers = new_centers.copy()\n                radii = new_radii.copy()\n            elif new_sum > np.sum(radii):\n                centers = new_centers.copy()\n                radii = new_radii.copy()\n        \n        return best_centers, best_radii, best_sum\n    \n    def method_sa(seed=43, iterations=10000):\n        \"\"\"Simulated Annealing.\"\"\"\n        np.random.seed(seed)\n        \n        # Initialize with 5x5+1 grid\n        centers = []\n        for i in range(5):\n            for j in range(5):\n                centers.append([0.1 + i * 0.2, 0.1 + j * 0.2])\n        centers.append([0.5, 0.5])\n        centers = np.array(centers)\n        \n        radii = optimize_radii_iterative(centers)\n        current_sum = np.sum(radii)\n        best_sum = current_sum\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n        \n        T = 0.1\n        T_min = 1e-6\n        alpha = (T_min / T) ** (1.0 / iterations)\n        \n        for it in range(iterations):\n            # Perturb\n            new_centers = centers.copy()\n            idx = np.random.randint(26)\n            new_centers[idx] += np.random.randn(2) * 0.02\n            new_centers = np.clip(new_centers, 0.05, 0.95)\n            \n            new_radii = optimize_radii_iterative(new_centers)\n            new_sum = np.sum(new_radii)\n            \n            # Accept or reject\n            delta = new_sum - current_sum\n            if delta > 0 or np.random.rand() < np.exp(delta / T):\n                centers = new_centers.copy()\n                radii = new_radii.copy()\n                current_sum = new_sum\n                \n                if new_sum > best_sum:\n                    best_sum = new_sum\n                    best_centers = new_centers.copy()\n                    best_radii = new_radii.copy()\n            \n            T *= alpha\n        \n        return best_centers, best_radii, best_sum\n    \n    def method_coordinate_descent(seed=44, iterations=10000):\n        \"\"\"Coordinate Descent.\"\"\"\n        np.random.seed(seed)\n        \n        # Initialize with 5x5+1 grid\n        centers = []\n        for i in range(5):\n            for j in range(5):\n                centers.append([0.1 + i * 0.2, 0.1 + j * 0.2])\n        centers.append([0.5, 0.5])\n        centers = np.array(centers)\n        \n        radii = optimize_radii_iterative(centers)\n        best_sum = np.sum(radii)\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n        \n        step_size = 0.02\n        \n        for it in range(iterations):\n            improved = False\n            idx = it % 26\n            \n            # Try moving in each direction\n            for dx, dy in [(step_size, 0), (-step_size, 0), \n                          (0, step_size), (0, -step_size)]:\n                new_centers = centers.copy()\n                new_centers[idx] += [dx, dy]\n                \n                if (new_centers[idx, 0] < 0.05 or new_centers[idx, 0] > 0.95 or\n                    new_centers[idx, 1] < 0.05 or new_centers[idx, 1] > 0.95):\n                    continue\n                \n                new_radii = optimize_radii_iterative(new_centers)\n                new_sum = np.sum(new_radii)\n                \n                if new_sum > best_sum:\n                    best_sum = new_sum\n                    best_centers = new_centers.copy()\n                    best_radii = new_radii.copy()\n                    centers = new_centers.copy()\n                    radii = new_radii.copy()\n                    improved = True\n                    break\n            \n            # Decay step size\n            if it % 260 == 259 and not improved:\n                step_size *= 0.9\n        \n        return best_centers, best_radii, best_sum\n    \n    # Run all three methods\n    results = []\n    results.append(method_vns(seed=42, iterations=10000))\n    results.append(method_sa(seed=43, iterations=10000))\n    results.append(method_coordinate_descent(seed=44, iterations=10000))\n    \n    # Return best\n    best_idx = np.argmax([r[2] for r in results])\n    centers, radii, sum_radii = results[best_idx]\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-31T17:22:58.079307",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.4
  }
}