{
  "trial_id": "trial_5_8",
  "generation": 5,
  "parent_id": null,
  "code": "import numpy as np\n\ndef construct_packing():\n    np.random.seed(42)\n    \n    n_circles = 26\n    n_particles = 30\n    n_iterations = 200\n    n_dims = n_circles * 2  # x, y coordinates for each circle\n    \n    # PSO parameters\n    w = 0.7  # inertia weight\n    c1 = 1.5  # cognitive parameter\n    c2 = 1.5  # social parameter\n    \n    def calculate_radii(centers):\n        \"\"\"Calculate maximum radii for given centers\"\"\"\n        radii = np.ones(n_circles) * 0.5  # Start with large radii\n        \n        # Iteratively reduce radii to satisfy constraints\n        for _ in range(100):\n            # Distance to boundaries\n            min_dist_to_boundary = np.minimum(\n                np.minimum(centers[:, 0], 1 - centers[:, 0]),\n                np.minimum(centers[:, 1], 1 - centers[:, 1])\n            )\n            radii = np.minimum(radii, min_dist_to_boundary)\n            \n            # Distance between circles\n            for i in range(n_circles):\n                for j in range(i + 1, n_circles):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = dist / 2.0\n                    if radii[i] + radii[j] > dist:\n                        # Reduce both radii proportionally\n                        scale = max_r / (radii[i] + radii[j])\n                        radii[i] *= scale * 0.99\n                        radii[j] *= scale * 0.99\n        \n        return np.maximum(radii, 0)\n    \n    def evaluate_fitness(position):\n        \"\"\"Evaluate fitness (sum of radii) for a particle position\"\"\"\n        centers = position.reshape(n_circles, 2)\n        \n        # Clip to valid range\n        centers = np.clip(centers, 0.01, 0.99)\n        \n        radii = calculate_radii(centers)\n        return np.sum(radii)\n    \n    # Initialize particles with strategic positions\n    particles = np.zeros((n_particles, n_dims))\n    velocities = np.zeros((n_particles, n_dims))\n    \n    for p in range(n_particles):\n        if p == 0:\n            # Grid-based initialization\n            grid_size = int(np.ceil(np.sqrt(n_circles)))\n            centers = []\n            for i in range(n_circles):\n                row = i // grid_size\n                col = i % grid_size\n                x = (col + 0.5) / grid_size\n                y = (row + 0.5) / grid_size\n                centers.append([x, y])\n            particles[p] = np.array(centers).flatten()\n        elif p == 1:\n            # Hexagonal packing inspired\n            centers = []\n            rows = 5\n            for row in range(rows):\n                n_in_row = 6 if row % 2 == 0 else 5\n                for col in range(n_in_row):\n                    if len(centers) >= n_circles:\n                        break\n                    x = (col + 0.5) / 6 + (0.08 if row % 2 == 1 else 0)\n                    y = (row + 0.5) / 6\n                    centers.append([x, y])\n                if len(centers) >= n_circles:\n                    break\n            particles[p] = np.array(centers[:n_circles]).flatten()\n        else:\n            # Random initialization with some structure\n            particles[p] = np.random.uniform(0.1, 0.9, n_dims)\n        \n        velocities[p] = np.random.uniform(-0.1, 0.1, n_dims)\n    \n    # Initialize personal and global bests\n    personal_best_positions = particles.copy()\n    personal_best_scores = np.array([evaluate_fitness(p) for p in particles])\n    \n    global_best_idx = np.argmax(personal_best_scores)\n    global_best_position = personal_best_positions[global_best_idx].copy()\n    global_best_score = personal_best_scores[global_best_idx]\n    \n    # PSO main loop\n    for iteration in range(n_iterations):\n        for p in range(n_particles):\n            # Update velocity\n            r1 = np.random.random(n_dims)\n            r2 = np.random.random(n_dims)\n            \n            cognitive = c1 * r1 * (personal_best_positions[p] - particles[p])\n            social = c2 * r2 * (global_best_position - particles[p])\n            \n            velocities[p] = w * velocities[p] + cognitive + social\n            \n            # Limit velocity\n            velocities[p] = np.clip(velocities[p], -0.2, 0.2)\n            \n            # Update position\n            particles[p] = particles[p] + velocities[p]\n            particles[p] = np.clip(particles[p], 0.01, 0.99)\n            \n            # Evaluate fitness\n            fitness = evaluate_fitness(particles[p])\n            \n            # Update personal best\n            if fitness > personal_best_scores[p]:\n                personal_best_scores[p] = fitness\n                personal_best_positions[p] = particles[p].copy()\n                \n                # Update global best\n                if fitness > global_best_score:\n                    global_best_score = fitness\n                    global_best_position = particles[p].copy()\n        \n        # Adaptive inertia weight\n        w = 0.9 - 0.5 * (iteration / n_iterations)\n    \n    # Extract best solution\n    best_centers = global_best_position.reshape(n_circles, 2)\n    best_radii = calculate_radii(best_centers)\n    sum_radii = np.sum(best_radii)\n    \n    return best_centers, best_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 1.5872921516190135,
    "eval_time": 249.5548222064972,
    "error": null
  },
  "prompt": "Implement particle swarm optimization for circle packing:\n\nPSO setup:\n1. 30 particles, each a complete packing (52 coordinates)\n2. Velocity update with inertia, cognitive, social components\n3. Evaluate sum_of_radii for each particle\n4. Run for 200 generations\n5. Track global best\n\nPSO is good at exploring and avoiding local optima.\n\nReturn proper Python code block.",
  "response": "```python\nimport numpy as np\n\ndef construct_packing():\n    np.random.seed(42)\n    \n    n_circles = 26\n    n_particles = 30\n    n_iterations = 200\n    n_dims = n_circles * 2  # x, y coordinates for each circle\n    \n    # PSO parameters\n    w = 0.7  # inertia weight\n    c1 = 1.5  # cognitive parameter\n    c2 = 1.5  # social parameter\n    \n    def calculate_radii(centers):\n        \"\"\"Calculate maximum radii for given centers\"\"\"\n        radii = np.ones(n_circles) * 0.5  # Start with large radii\n        \n        # Iteratively reduce radii to satisfy constraints\n        for _ in range(100):\n            # Distance to boundaries\n            min_dist_to_boundary = np.minimum(\n                np.minimum(centers[:, 0], 1 - centers[:, 0]),\n                np.minimum(centers[:, 1], 1 - centers[:, 1])\n            )\n            radii = np.minimum(radii, min_dist_to_boundary)\n            \n            # Distance between circles\n            for i in range(n_circles):\n                for j in range(i + 1, n_circles):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = dist / 2.0\n                    if radii[i] + radii[j] > dist:\n                        # Reduce both radii proportionally\n                        scale = max_r / (radii[i] + radii[j])\n                        radii[i] *= scale * 0.99\n                        radii[j] *= scale * 0.99\n        \n        return np.maximum(radii, 0)\n    \n    def evaluate_fitness(position):\n        \"\"\"Evaluate fitness (sum of radii) for a particle position\"\"\"\n        centers = position.reshape(n_circles, 2)\n        \n        # Clip to valid range\n        centers = np.clip(centers, 0.01, 0.99)\n        \n        radii = calculate_radii(centers)\n        return np.sum(radii)\n    \n    # Initialize particles with strategic positions\n    particles = np.zeros((n_particles, n_dims))\n    velocities = np.zeros((n_particles, n_dims))\n    \n    for p in range(n_particles):\n        if p == 0:\n            # Grid-based initialization\n            grid_size = int(np.ceil(np.sqrt(n_circles)))\n            centers = []\n            for i in range(n_circles):\n                row = i // grid_size\n                col = i % grid_size\n                x = (col + 0.5) / grid_size\n                y = (row + 0.5) / grid_size\n                centers.append([x, y])\n            particles[p] = np.array(centers).flatten()\n        elif p == 1:\n            # Hexagonal packing inspired\n            centers = []\n            rows = 5\n            for row in range(rows):\n                n_in_row = 6 if row % 2 == 0 else 5\n                for col in range(n_in_row):\n                    if len(centers) >= n_circles:\n                        break\n                    x = (col + 0.5) / 6 + (0.08 if row % 2 == 1 else 0)\n                    y = (row + 0.5) / 6\n                    centers.append([x, y])\n                if len(centers) >= n_circles:\n                    break\n            particles[p] = np.array(centers[:n_circles]).flatten()\n        else:\n            # Random initialization with some structure\n            particles[p] = np.random.uniform(0.1, 0.9, n_dims)\n        \n        velocities[p] = np.random.uniform(-0.1, 0.1, n_dims)\n    \n    # Initialize personal and global bests\n    personal_best_positions = particles.copy()\n    personal_best_scores = np.array([evaluate_fitness(p) for p in particles])\n    \n    global_best_idx = np.argmax(personal_best_scores)\n    global_best_position = personal_best_positions[global_best_idx].copy()\n    global_best_score = personal_best_scores[global_best_idx]\n    \n    # PSO main loop\n    for iteration in range(n_iterations):\n        for p in range(n_particles):\n            # Update velocity\n            r1 = np.random.random(n_dims)\n            r2 = np.random.random(n_dims)\n            \n            cognitive = c1 * r1 * (personal_best_positions[p] - particles[p])\n            social = c2 * r2 * (global_best_position - particles[p])\n            \n            velocities[p] = w * velocities[p] + cognitive + social\n            \n            # Limit velocity\n            velocities[p] = np.clip(velocities[p], -0.2, 0.2)\n            \n            # Update position\n            particles[p] = particles[p] + velocities[p]\n            particles[p] = np.clip(particles[p], 0.01, 0.99)\n            \n            # Evaluate fitness\n            fitness = evaluate_fitness(particles[p])\n            \n            # Update personal best\n            if fitness > personal_best_scores[p]:\n                personal_best_scores[p] = fitness\n                personal_best_positions[p] = particles[p].copy()\n                \n                # Update global best\n                if fitness > global_best_score:\n                    global_best_score = fitness\n                    global_best_position = particles[p].copy()\n        \n        # Adaptive inertia weight\n        w = 0.9 - 0.5 * (iteration / n_iterations)\n    \n    # Extract best solution\n    best_centers = global_best_position.reshape(n_circles, 2)\n    best_radii = calculate_radii(best_centers)\n    sum_radii = np.sum(best_radii)\n    \n    return best_centers, best_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-31T17:17:18.151939",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.5
  }
}