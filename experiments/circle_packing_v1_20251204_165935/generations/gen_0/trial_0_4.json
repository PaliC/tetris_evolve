{
  "trial_id": "trial_0_4",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Random search circle packing for 26 circles in [0,1]x[0,1]\n    Uses random sampling with improvements to find good packings.\n    \"\"\"\n    np.random.seed(42)\n    \n    n_circles = 26\n    best_sum_radii = 0\n    best_centers = None\n    best_radii = None\n    \n    # Number of random attempts\n    n_attempts = 10000\n    \n    for attempt in range(n_attempts):\n        # Strategy: Mix grid initialization with random perturbations\n        if attempt % 3 == 0:\n            # Grid-based initialization\n            grid_size = int(np.ceil(np.sqrt(n_circles)))\n            centers = []\n            for i in range(n_circles):\n                row = i // grid_size\n                col = i % grid_size\n                x = (col + 0.5 + np.random.uniform(-0.3, 0.3)) / grid_size\n                y = (row + 0.5 + np.random.uniform(-0.3, 0.3)) / grid_size\n                centers.append([x, y])\n            centers = np.array(centers)\n        else:\n            # Pure random initialization\n            centers = np.random.rand(n_circles, 2)\n        \n        # Calculate maximum radius for each circle\n        radii = np.zeros(n_circles)\n        \n        for i in range(n_circles):\n            # Maximum radius constrained by boundaries\n            max_r = min(\n                centers[i, 0],           # left boundary\n                1 - centers[i, 0],       # right boundary\n                centers[i, 1],           # bottom boundary\n                1 - centers[i, 1]        # top boundary\n            )\n            \n            # Maximum radius constrained by other circles\n            for j in range(n_circles):\n                if i != j:\n                    dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                    # Available space is distance minus other circle's radius\n                    max_r = min(max_r, dist - radii[j])\n            \n            radii[i] = max(0, max_r)\n        \n        # Calculate sum of radii\n        sum_radii = np.sum(radii)\n        \n        # Keep best configuration\n        if sum_radii > best_sum_radii:\n            best_sum_radii = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    # Refinement step: try to improve by local optimization\n    for refinement in range(100):\n        # Try moving each circle slightly\n        for i in range(n_circles):\n            original_center = best_centers[i].copy()\n            \n            # Try small random moves\n            for _ in range(10):\n                delta = np.random.randn(2) * 0.01\n                new_center = original_center + delta\n                \n                # Check if still in bounds\n                if not (0 < new_center[0] < 1 and 0 < new_center[1] < 1):\n                    continue\n                \n                # Temporarily update center\n                best_centers[i] = new_center\n                \n                # Recalculate radii\n                new_radii = np.zeros(n_circles)\n                for j in range(n_circles):\n                    max_r = min(\n                        best_centers[j, 0],\n                        1 - best_centers[j, 0],\n                        best_centers[j, 1],\n                        1 - best_centers[j, 1]\n                    )\n                    \n                    for k in range(n_circles):\n                        if j != k:\n                            dist = np.sqrt(np.sum((best_centers[j] - best_centers[k])**2))\n                            max_r = min(max_r, dist - new_radii[k])\n                    \n                    new_radii[j] = max(0, max_r)\n                \n                new_sum = np.sum(new_radii)\n                \n                if new_sum > best_sum_radii:\n                    best_sum_radii = new_sum\n                    best_radii = new_radii.copy()\n                    break\n                else:\n                    # Revert\n                    best_centers[i] = original_center\n    \n    return best_centers, best_radii, float(best_sum_radii)\n\ndef run_packing():\n    return construct_packing()\n\n# Test the packing\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    # Verify constraints\n    print(\"\\nVerifying constraints:\")\n    \n    # Check all circles are inside [0,1]x[0,1]\n    inside = np.all((centers - radii[:, None] >= 0) & (centers + radii[:, None] <= 1))\n    print(f\"All circles inside bounds: {inside}\")\n    \n    # Check no overlaps\n    no_overlap = True\n    for i in range(26):\n        for j in range(i+1, 26):\n            dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n            if dist < radii[i] + radii[j] - 1e-10:\n                no_overlap = False\n                break\n    print(f\"No overlaps: {no_overlap}\")",
  "metrics": {
    "valid": true,
    "sum_radii": 2.4267518683131524,
    "target_ratio": 0.9209684509727334,
    "combined_score": 0.9209684509727334,
    "eval_time": 44.513705015182495,
    "error": null
  },
  "prompt": "Write a random search circle packing for 26 circles in [0,1]x[0,1].\n\nUse random sampling with improvements to find good packings.\n\nRequirements:\n- Pack exactly 26 circles\n- All circles must be entirely inside [0,1]x[0,1]\n- No overlaps between circles\n- Maximize the sum of radii\n\nStrategy:\n1. Generate multiple random configurations\n2. For each configuration, calculate maximum radii\n3. Keep the best configuration found\n4. Use smart initialization (e.g., start from grid)\n\nInclude these functions:\n```python\nimport numpy as np\n\ndef construct_packing():\n    # Your random search implementation\n    centers = np.array(...)  # shape (26, 2)\n    radii = np.array(...)    # shape (26,)\n    sum_radii = float(np.sum(radii))\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "response": "```python\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Random search circle packing for 26 circles in [0,1]x[0,1]\n    Uses random sampling with improvements to find good packings.\n    \"\"\"\n    np.random.seed(42)\n    \n    n_circles = 26\n    best_sum_radii = 0\n    best_centers = None\n    best_radii = None\n    \n    # Number of random attempts\n    n_attempts = 10000\n    \n    for attempt in range(n_attempts):\n        # Strategy: Mix grid initialization with random perturbations\n        if attempt % 3 == 0:\n            # Grid-based initialization\n            grid_size = int(np.ceil(np.sqrt(n_circles)))\n            centers = []\n            for i in range(n_circles):\n                row = i // grid_size\n                col = i % grid_size\n                x = (col + 0.5 + np.random.uniform(-0.3, 0.3)) / grid_size\n                y = (row + 0.5 + np.random.uniform(-0.3, 0.3)) / grid_size\n                centers.append([x, y])\n            centers = np.array(centers)\n        else:\n            # Pure random initialization\n            centers = np.random.rand(n_circles, 2)\n        \n        # Calculate maximum radius for each circle\n        radii = np.zeros(n_circles)\n        \n        for i in range(n_circles):\n            # Maximum radius constrained by boundaries\n            max_r = min(\n                centers[i, 0],           # left boundary\n                1 - centers[i, 0],       # right boundary\n                centers[i, 1],           # bottom boundary\n                1 - centers[i, 1]        # top boundary\n            )\n            \n            # Maximum radius constrained by other circles\n            for j in range(n_circles):\n                if i != j:\n                    dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                    # Available space is distance minus other circle's radius\n                    max_r = min(max_r, dist - radii[j])\n            \n            radii[i] = max(0, max_r)\n        \n        # Calculate sum of radii\n        sum_radii = np.sum(radii)\n        \n        # Keep best configuration\n        if sum_radii > best_sum_radii:\n            best_sum_radii = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    # Refinement step: try to improve by local optimization\n    for refinement in range(100):\n        # Try moving each circle slightly\n        for i in range(n_circles):\n            original_center = best_centers[i].copy()\n            \n            # Try small random moves\n            for _ in range(10):\n                delta = np.random.randn(2) * 0.01\n                new_center = original_center + delta\n                \n                # Check if still in bounds\n                if not (0 < new_center[0] < 1 and 0 < new_center[1] < 1):\n                    continue\n                \n                # Temporarily update center\n                best_centers[i] = new_center\n                \n                # Recalculate radii\n                new_radii = np.zeros(n_circles)\n                for j in range(n_circles):\n                    max_r = min(\n                        best_centers[j, 0],\n                        1 - best_centers[j, 0],\n                        best_centers[j, 1],\n                        1 - best_centers[j, 1]\n                    )\n                    \n                    for k in range(n_circles):\n                        if j != k:\n                            dist = np.sqrt(np.sum((best_centers[j] - best_centers[k])**2))\n                            max_r = min(max_r, dist - new_radii[k])\n                    \n                    new_radii[j] = max(0, max_r)\n                \n                new_sum = np.sum(new_radii)\n                \n                if new_sum > best_sum_radii:\n                    best_sum_radii = new_sum\n                    best_radii = new_radii.copy()\n                    break\n                else:\n                    # Revert\n                    best_centers[i] = original_center\n    \n    return best_centers, best_radii, float(best_sum_radii)\n\ndef run_packing():\n    return construct_packing()\n\n# Test the packing\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    # Verify constraints\n    print(\"\\nVerifying constraints:\")\n    \n    # Check all circles are inside [0,1]x[0,1]\n    inside = np.all((centers - radii[:, None] >= 0) & (centers + radii[:, None] <= 1))\n    print(f\"All circles inside bounds: {inside}\")\n    \n    # Check no overlaps\n    no_overlap = True\n    for i in range(26):\n        for j in range(i+1, 26):\n            dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n            if dist < radii[i] + radii[j] - 1e-10:\n                no_overlap = False\n                break\n    print(f\"No overlaps: {no_overlap}\")\n```",
  "reasoning": "",
  "timestamp": "2025-12-04T17:01:07.561100",
  "cost_data": null
}