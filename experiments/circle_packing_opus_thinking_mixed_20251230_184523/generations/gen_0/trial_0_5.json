{
  "trial_id": "trial_0_5",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    \n    # Initialize with hexagonal packing\n    def hex_init(n):\n        centers = []\n        rows = int(np.ceil(np.sqrt(n)))\n        spacing = 1.0 / (rows + 1)\n        \n        for i in range(rows):\n            cols = int(np.ceil(n / rows))\n            offset = (i % 2) * spacing / 2\n            for j in range(cols):\n                if len(centers) >= n:\n                    break\n                x = (j + 1) * spacing + offset\n                y = (i + 1) * spacing\n                if x <= 1.0 and y <= 1.0:\n                    centers.append([x, y])\n        \n        while len(centers) < n:\n            centers.append([np.random.rand(), np.random.rand()])\n        \n        return np.array(centers[:n])\n    \n    centers_init = hex_init(n)\n    \n    # Initial radii estimate\n    r_init = 0.05\n    \n    # Pack variables: [x1, y1, ..., xn, yn, r1, ..., rn]\n    x0 = np.concatenate([centers_init.flatten(), np.full(n, r_init)])\n    \n    def objective(x):\n        radii = x[2*n:]\n        return -np.sum(radii)  # Minimize negative sum = maximize sum\n    \n    def get_centers_radii(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    # Constraints\n    constraints = []\n    \n    # Wall constraints: r_i <= x_i, r_i <= y_i, r_i <= 1-x_i, r_i <= 1-y_i\n    for i in range(n):\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: x[2*i] - x[2*n+i]  # x_i - r_i >= 0\n        })\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]  # y_i - r_i >= 0\n        })\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: 1 - x[2*i] - x[2*n+i]  # 1 - x_i - r_i >= 0\n        })\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]  # 1 - y_i - r_i >= 0\n        })\n    \n    # Non-overlap constraints: dist(i,j) >= r_i + r_j\n    for i in range(n):\n        for j in range(i+1, n):\n            def overlap_constraint(x, i=i, j=j):\n                centers, radii = get_centers_radii(x)\n                dist = np.linalg.norm(centers[i] - centers[j])\n                return dist - radii[i] - radii[j]\n            \n            constraints.append({\n                'type': 'ineq',\n                'fun': overlap_constraint\n            })\n    \n    # Bounds\n    bounds = [(0, 1) for _ in range(2*n)] + [(0, 0.5) for _ in range(n)]\n    \n    # Optimize\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n    \n    centers, radii = get_centers_radii(result.x)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.6180682559647788,
    "eval_time": 1.7471427917480469,
    "error": null
  },
  "prompt": "Pack 26 circles into unit square [0,1]x[0,1] to maximize sum of radii.\n\nReturn format: (np.array shape (26,2), np.array shape (26,), float)\n\nUse scipy.optimize.minimize method='SLSQP' with explicit inequality constraints for walls and non-overlap. Initialize hexagonally.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    \n    # Initialize with hexagonal packing\n    def hex_init(n):\n        centers = []\n        rows = int(np.ceil(np.sqrt(n)))\n        spacing = 1.0 / (rows + 1)\n        \n        for i in range(rows):\n            cols = int(np.ceil(n / rows))\n            offset = (i % 2) * spacing / 2\n            for j in range(cols):\n                if len(centers) >= n:\n                    break\n                x = (j + 1) * spacing + offset\n                y = (i + 1) * spacing\n                if x <= 1.0 and y <= 1.0:\n                    centers.append([x, y])\n        \n        while len(centers) < n:\n            centers.append([np.random.rand(), np.random.rand()])\n        \n        return np.array(centers[:n])\n    \n    centers_init = hex_init(n)\n    \n    # Initial radii estimate\n    r_init = 0.05\n    \n    # Pack variables: [x1, y1, ..., xn, yn, r1, ..., rn]\n    x0 = np.concatenate([centers_init.flatten(), np.full(n, r_init)])\n    \n    def objective(x):\n        radii = x[2*n:]\n        return -np.sum(radii)  # Minimize negative sum = maximize sum\n    \n    def get_centers_radii(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    # Constraints\n    constraints = []\n    \n    # Wall constraints: r_i <= x_i, r_i <= y_i, r_i <= 1-x_i, r_i <= 1-y_i\n    for i in range(n):\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: x[2*i] - x[2*n+i]  # x_i - r_i >= 0\n        })\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]  # y_i - r_i >= 0\n        })\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: 1 - x[2*i] - x[2*n+i]  # 1 - x_i - r_i >= 0\n        })\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]  # 1 - y_i - r_i >= 0\n        })\n    \n    # Non-overlap constraints: dist(i,j) >= r_i + r_j\n    for i in range(n):\n        for j in range(i+1, n):\n            def overlap_constraint(x, i=i, j=j):\n                centers, radii = get_centers_radii(x)\n                dist = np.linalg.norm(centers[i] - centers[j])\n                return dist - radii[i] - radii[j]\n            \n            constraints.append({\n                'type': 'ineq',\n                'fun': overlap_constraint\n            })\n    \n    # Bounds\n    bounds = [(0, 1) for _ in range(2*n)] + [(0, 0.5) for _ in range(n)]\n    \n    # Optimize\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n    \n    centers, radii = get_centers_radii(result.x)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-30T18:50:23.819832",
  "cost_data": null
}