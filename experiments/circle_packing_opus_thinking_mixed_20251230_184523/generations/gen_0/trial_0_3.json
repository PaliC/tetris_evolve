{
  "trial_id": "trial_0_3",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    np.random.seed(42)\n    \n    # Strategy: Place large circles in corners, then edges, then fill interior\n    # Corner circles can touch 2 walls, edge circles touch 1 wall\n    \n    def get_max_corner_radius(cx, cy):\n        \"\"\"Max radius for corner circle at (cx, cy)\"\"\"\n        return min(cx, 1-cx, cy, 1-cy)\n    \n    def get_max_edge_radius(cx, cy):\n        \"\"\"Max radius for edge circle\"\"\"\n        if cx < 0.01:  # left edge\n            return min(cx, 1-cy, cy)\n        elif cx > 0.99:  # right edge\n            return min(1-cx, 1-cy, cy)\n        elif cy < 0.01:  # bottom edge\n            return min(cy, 1-cx, cx)\n        else:  # top edge\n            return min(1-cy, 1-cx, cx)\n    \n    # Initial configuration\n    n = 26\n    \n    # Start with a grid-based initialization with corner bias\n    # 4 corners + 8 edges + 14 interior\n    centers = []\n    radii = []\n    \n    # Corner circles (4) - can be larger\n    corner_offset = 0.15\n    corners = [\n        (corner_offset, corner_offset),\n        (1-corner_offset, corner_offset),\n        (corner_offset, 1-corner_offset),\n        (1-corner_offset, 1-corner_offset)\n    ]\n    for cx, cy in corners:\n        centers.append([cx, cy])\n        radii.append(corner_offset * 0.95)\n    \n    # Edge circles (8) - 2 per edge\n    edge_positions = [\n        (0.15, 0.5), (0.85, 0.5),  # left, right\n        (0.5, 0.15), (0.5, 0.85),  # bottom, top\n        (0.35, 0.15), (0.65, 0.15),  # bottom edge\n        (0.35, 0.85), (0.65, 0.85),  # top edge\n    ]\n    for cx, cy in edge_positions:\n        centers.append([cx, cy])\n        radii.append(0.10)\n    \n    # Interior circles (14) - fill remaining space\n    interior_grid = []\n    for i in range(4):\n        for j in range(4):\n            cx = 0.3 + i * 0.15\n            cy = 0.3 + j * 0.15\n            if len(interior_grid) < 14:\n                interior_grid.append([cx, cy])\n    \n    for cx, cy in interior_grid:\n        centers.append([cx, cy])\n        radii.append(0.08)\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    \n    # Optimization function\n    def objective(x):\n        # Minimize negative sum of radii\n        r = x[2*n:]\n        return -np.sum(r)\n    \n    def constraints_func(x):\n        c = x[:2*n].reshape(n, 2)\n        r = x[2*n:]\n        \n        violations = []\n        \n        # Boundary constraints\n        for i in range(n):\n            violations.append(c[i, 0] - r[i])  # left\n            violations.append(1 - c[i, 0] - r[i])  # right\n            violations.append(c[i, 1] - r[i])  # bottom\n            violations.append(1 - c[i, 1] - r[i])  # top\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.sqrt((c[i, 0] - c[j, 0])**2 + (c[i, 1] - c[j, 1])**2)\n                violations.append(dist - r[i] - r[j])\n        \n        return np.array(violations)\n    \n    # Pack into single vector\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    # Bounds\n    bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n    \n    # Constraints\n    constraints = {'type': 'ineq', 'fun': constraints_func}\n    \n    # Optimize with multiple attempts\n    best_result = None\n    best_sum = 0\n    \n    for attempt in range(3):\n        if attempt > 0:\n            # Add small random perturbation\n            x0_perturbed = x0 + np.random.randn(len(x0)) * 0.01\n            x0_perturbed = np.clip(x0_perturbed, [b[0] for b in bounds], [b[1] for b in bounds])\n        else:\n            x0_perturbed = x0\n        \n        result = minimize(\n            objective,\n            x0_perturbed,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-9}\n        )\n        \n        if result.success or True:  # Accept even if not fully converged\n            r_result = result.x[2*n:]\n            sum_r = np.sum(r_result)\n            if sum_r > best_sum:\n                best_sum = sum_r\n                best_result = result\n    \n    if best_result is not None:\n        centers = best_result.x[:2*n].reshape(n, 2)\n        radii = best_result.x[2*n:]\n        sum_radii = np.sum(radii)\n    else:\n        sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.576799974291139,
    "eval_time": 0.997307300567627,
    "error": null
  },
  "prompt": "Pack 26 circles into unit square [0,1]x[0,1] to maximize sum of radii.\n\nReturn (centers, radii, sum_radii) where centers is np.array(26,2), radii is np.array(26).\n\nInsight: Corner circles can be largest (touch 2 walls). Place 4 large corner circles first, then edges, then interior. Use scipy.optimize to refine.",
  "response": "I'll create a solution that strategically places circles starting from corners, then edges, then interior, and uses optimization to refine the packing.\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    np.random.seed(42)\n    \n    # Strategy: Place large circles in corners, then edges, then fill interior\n    # Corner circles can touch 2 walls, edge circles touch 1 wall\n    \n    def get_max_corner_radius(cx, cy):\n        \"\"\"Max radius for corner circle at (cx, cy)\"\"\"\n        return min(cx, 1-cx, cy, 1-cy)\n    \n    def get_max_edge_radius(cx, cy):\n        \"\"\"Max radius for edge circle\"\"\"\n        if cx < 0.01:  # left edge\n            return min(cx, 1-cy, cy)\n        elif cx > 0.99:  # right edge\n            return min(1-cx, 1-cy, cy)\n        elif cy < 0.01:  # bottom edge\n            return min(cy, 1-cx, cx)\n        else:  # top edge\n            return min(1-cy, 1-cx, cx)\n    \n    # Initial configuration\n    n = 26\n    \n    # Start with a grid-based initialization with corner bias\n    # 4 corners + 8 edges + 14 interior\n    centers = []\n    radii = []\n    \n    # Corner circles (4) - can be larger\n    corner_offset = 0.15\n    corners = [\n        (corner_offset, corner_offset),\n        (1-corner_offset, corner_offset),\n        (corner_offset, 1-corner_offset),\n        (1-corner_offset, 1-corner_offset)\n    ]\n    for cx, cy in corners:\n        centers.append([cx, cy])\n        radii.append(corner_offset * 0.95)\n    \n    # Edge circles (8) - 2 per edge\n    edge_positions = [\n        (0.15, 0.5), (0.85, 0.5),  # left, right\n        (0.5, 0.15), (0.5, 0.85),  # bottom, top\n        (0.35, 0.15), (0.65, 0.15),  # bottom edge\n        (0.35, 0.85), (0.65, 0.85),  # top edge\n    ]\n    for cx, cy in edge_positions:\n        centers.append([cx, cy])\n        radii.append(0.10)\n    \n    # Interior circles (14) - fill remaining space\n    interior_grid = []\n    for i in range(4):\n        for j in range(4):\n            cx = 0.3 + i * 0.15\n            cy = 0.3 + j * 0.15\n            if len(interior_grid) < 14:\n                interior_grid.append([cx, cy])\n    \n    for cx, cy in interior_grid:\n        centers.append([cx, cy])\n        radii.append(0.08)\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    \n    # Optimization function\n    def objective(x):\n        # Minimize negative sum of radii\n        r = x[2*n:]\n        return -np.sum(r)\n    \n    def constraints_func(x):\n        c = x[:2*n].reshape(n, 2)\n        r = x[2*n:]\n        \n        violations = []\n        \n        # Boundary constraints\n        for i in range(n):\n            violations.append(c[i, 0] - r[i])  # left\n            violations.append(1 - c[i, 0] - r[i])  # right\n            violations.append(c[i, 1] - r[i])  # bottom\n            violations.append(1 - c[i, 1] - r[i])  # top\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.sqrt((c[i, 0] - c[j, 0])**2 + (c[i, 1] - c[j, 1])**2)\n                violations.append(dist - r[i] - r[j])\n        \n        return np.array(violations)\n    \n    # Pack into single vector\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    # Bounds\n    bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n    \n    # Constraints\n    constraints = {'type': 'ineq', 'fun': constraints_func}\n    \n    # Optimize with multiple attempts\n    best_result = None\n    best_sum = 0\n    \n    for attempt in range(3):\n        if attempt > 0:\n            # Add small random perturbation\n            x0_perturbed = x0 + np.random.randn(len(x0)) * 0.01\n            x0_perturbed = np.clip(x0_perturbed, [b[0] for b in bounds], [b[1] for b in bounds])\n        else:\n            x0_perturbed = x0\n        \n        result = minimize(\n            objective,\n            x0_perturbed,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-9}\n        )\n        \n        if result.success or True:  # Accept even if not fully converged\n            r_result = result.x[2*n:]\n            sum_r = np.sum(r_result)\n            if sum_r > best_sum:\n                best_sum = sum_r\n                best_result = result\n    \n    if best_result is not None:\n        centers = best_result.x[:2*n].reshape(n, 2)\n        radii = best_result.x[2*n:]\n        sum_radii = np.sum(radii)\n    else:\n        sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```\n\nThis solution:\n1. **Strategic initialization**: Places 4 large circles in corners, 8 on edges, and 14 in interior\n2. **Corner advantage**: Corner circles can touch 2 walls, allowing larger radii\n3. **Optimization**: Uses SLSQP to refine positions and radii while respecting all constraints\n4. **Multiple attempts**: Tries with small perturbations to escape local minima\n5. **Constraint handling**: Ensures no overlaps and all circles stay within bounds\n\nThe optimization maximizes the sum of radii while maintaining feasibility.",
  "reasoning": "I'll create a solution that strategically places circles starting from corners, then edges, then interior, and uses optimization to refine the packing.\n\nThis solution:\n1. **Strategic initialization**: Places 4 large circles in corners, 8 on edges, and 14 in interior\n2. **Corner advantage**: Corner circles can touch 2 walls, allowing larger radii\n3. **Optimization**: Uses SLSQP to refine positions and radii while respecting all constraints\n4. **Multiple attempts**: Tries with small perturbations to escape local minima\n5. **Constraint handling**: Ensures no overlaps and all circles stay within bounds\n\nThe optimization maximizes the sum of radii while maintaining feasibility.",
  "timestamp": "2025-12-30T18:50:32.121096",
  "cost_data": null
}