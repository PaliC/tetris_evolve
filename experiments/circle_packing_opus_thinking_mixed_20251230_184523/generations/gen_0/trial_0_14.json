{
  "trial_id": "trial_0_14",
  "generation": 0,
  "parent_id": null,
  "code": "",
  "metrics": {},
  "prompt": "Pack 26 circles into unit square [0,1]x[0,1] to maximize sum of radii. Target: 2.635983099011548\n\nReturn (np.array(26,2), np.array(26), float).\n\nBuild configuration systematically: 4 corner circles of radius r1, 8 edge circles radius r2 (2 per edge), 14 interior circles in hexagonal pattern radius r3. Optimize r1,r2,r3 and exact positions with scipy.",
  "response": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    # Start with a good initial configuration\n    # Use a mix of different sized circles arranged strategically\n    \n    n = 26\n    \n    # Initial configuration: place circles in a structured pattern\n    # 4 corners (larger), edges, and interior\n    \n    def pack_energy(x):\n        \"\"\"Energy function to minimize (negative sum of radii + penalties)\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        # Penalty for negative radii\n        penalty = 0.0\n        penalty += np.sum(np.maximum(0, -radii) ** 2) * 1e6\n        \n        # Penalty for circles outside bounds\n        for i in range(n):\n            penalty += np.maximum(0, radii[i] - centers[i, 0]) ** 2 * 1e6\n            penalty += np.maximum(0, radii[i] - centers[i, 1]) ** 2 * 1e6\n            penalty += np.maximum(0, centers[i, 0] + radii[i] - 1) ** 2 * 1e6\n            penalty += np.maximum(0, centers[i, 1] + radii[i] - 1) ** 2 * 1e6\n        \n        # Penalty for overlaps\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.sqrt((centers[i,0]-centers[j,0])**2 + (centers[i,1]-centers[j,1])**2)\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    penalty += overlap ** 2 * 1e6\n        \n        return -np.sum(radii) + penalty\n    \n    # Initialize with a hexagonal-like pattern\n    # Create initial positions on a grid\n    centers_init = []\n    \n    # Use approximately 5x5 + 1 arrangement\n    rows = [5, 5, 6, 5, 5]\n    y_positions = [0.1, 0.3, 0.5, 0.7, 0.9]\n    \n    for row_idx, (num_in_row, y) in enumerate(zip(rows, y_positions)):\n        offset = 0.5 / num_in_row if row_idx % 2 == 1 else 0.5 / num_in_row\n        for i in range(num_in_row):\n            x = (i + 0.5) / num_in_row\n            centers_init.append([x, y])\n    \n    centers_init = np.array(centers_init[:n])\n    \n    # Initial radii - start small\n    radii_init = np.ones(n) * 0.08\n    \n    x0 = np.concatenate([centers_init.flatten(), radii_init])\n    \n    # Optimize\n    result = minimize(pack_energy, x0, method='L-BFGS-B', \n                     options={'maxiter': 5000, 'ftol': 1e-12})\n    \n    # Try multiple random restarts to find better solution\n    best_x = result.x\n    best_sum = -pack_energy(result.x) if pack_energy(result.x) < 0 else 0\n    \n    for trial in range(20):\n        np.random.seed(trial + 42)\n        # Random perturbation\n        centers_try = centers_init + np.random.randn(n, 2) * 0.05\n        centers_try = np.clip(centers_try, 0.1, 0.9)\n        radii_try = np.ones(n) * 0.07 + np.random.rand(n) * 0.03\n        \n        x0_try = np.concatenate([centers_try.flatten(), radii_try])\n        result_try = minimize(pack_energy, x0_try, method='L-BFGS-B',\n                            options={'maxiter': 3000, 'ftol': 1e-12})\n        \n        if pack_energy(result_try.x) < pack_energy(best_x):\n            best_x = result_try.x\n    \n    # Final refinement\n    result_final = minimize(pack_energy, best_x, method='L-BFGS-B',\n                           options={'maxiter': 10000, 'ftol': 1e-15})\n    \n    centers = result_final.x[:2*n].reshape(n, 2)\n    radii = result_final.x[2*n:]\n    radii = np.maximum(radii, 0)\n    \n    # Ensure constraints are satisfied\n    for i in range(n):\n        radii[i] = min(radii[i], centers[i,0], centers[i,1], \n                       1-centers[i,0], 1-centers[i,1])\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist:\n                scale = dist / (radii[i] + radii[j]) * 0.9999\n                radii[i] *= scale\n                radii[j] *= scale\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "reasoning": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    # Start with a good initial configuration\n    # Use a mix of different sized circles arranged strategically\n    \n    n = 26\n    \n    # Initial configuration: place circles in a structured pattern\n    # 4 corners (larger), edges, and interior\n    \n    def pack_energy(x):\n        \"\"\"Energy function to minimize (negative sum of radii + penalties)\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        # Penalty for negative radii\n        penalty = 0.0\n        penalty += np.sum(np.maximum(0, -radii) ** 2) * 1e6\n        \n        # Penalty for circles outside bounds\n        for i in range(n):\n            penalty += np.maximum(0, radii[i] - centers[i, 0]) ** 2 * 1e6\n            penalty += np.maximum(0, radii[i] - centers[i, 1]) ** 2 * 1e6\n            penalty += np.maximum(0, centers[i, 0] + radii[i] - 1) ** 2 * 1e6\n            penalty += np.maximum(0, centers[i, 1] + radii[i] - 1) ** 2 * 1e6\n        \n        # Penalty for overlaps\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.sqrt((centers[i,0]-centers[j,0])**2 + (centers[i,1]-centers[j,1])**2)\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    penalty += overlap ** 2 * 1e6\n        \n        return -np.sum(radii) + penalty\n    \n    # Initialize with a hexagonal-like pattern\n    # Create initial positions on a grid\n    centers_init = []\n    \n    # Use approximately 5x5 + 1 arrangement\n    rows = [5, 5, 6, 5, 5]\n    y_positions = [0.1, 0.3, 0.5, 0.7, 0.9]\n    \n    for row_idx, (num_in_row, y) in enumerate(zip(rows, y_positions)):\n        offset = 0.5 / num_in_row if row_idx % 2 == 1 else 0.5 / num_in_row\n        for i in range(num_in_row):\n            x = (i + 0.5) / num_in_row\n            centers_init.append([x, y])\n    \n    centers_init = np.array(centers_init[:n])\n    \n    # Initial radii - start small\n    radii_init = np.ones(n) * 0.08\n    \n    x0 = np.concatenate([centers_init.flatten(), radii_init])\n    \n    # Optimize\n    result = minimize(pack_energy, x0, method='L-BFGS-B', \n                     options={'maxiter': 5000, 'ftol': 1e-12})\n    \n    # Try multiple random restarts to find better solution\n    best_x = result.x\n    best_sum = -pack_energy(result.x) if pack_energy(result.x) < 0 else 0\n    \n    for trial in range(20):\n        np.random.seed(trial + 42)\n        # Random perturbation\n        centers_try = centers_init + np.random.randn(n, 2) * 0.05\n        centers_try = np.clip(centers_try, 0.1, 0.9)\n        radii_try = np.ones(n) * 0.07 + np.random.rand(n) * 0.03\n        \n        x0_try = np.concatenate([centers_try.flatten(), radii_try])\n        result_try = minimize(pack_energy, x0_try, method='L-BFGS-B',\n                            options={'maxiter': 3000, 'ftol': 1e-12})\n        \n        if pack_energy(result_try.x) < pack_energy(best_x):\n            best_x = result_try.x\n    \n    # Final refinement\n    result_final = minimize(pack_energy, best_x, method='L-BFGS-B',\n                           options={'maxiter': 10000, 'ftol': 1e-15})\n    \n    centers = result_final.x[:2*n].reshape(n, 2)\n    radii = result_final.x[2*n:]\n    radii = np.maximum(radii, 0)\n    \n    # Ensure constraints are satisfied\n    for i in range(n):\n        radii[i] = min(radii[i], centers[i,0], centers[i,1], \n                       1-centers[i,0], 1-centers[i,1])\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist:\n                scale = dist / (radii[i] + radii[j]) * 0.9999\n                radii[i] *= scale\n                radii[j] *= scale\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "timestamp": "2025-12-30T18:50:34.013000",
  "cost_data": null
}