{
  "trial_id": "trial_1_3",
  "generation": 1,
  "parent_id": "trial_0_3",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Constructs a circle packing for n=26 circles using a force-directed \n    initialization followed by SLSQP optimization to maximize sum of radii.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # 1. Initialization: Grid-like start with noise\n    grid_size = int(np.ceil(np.sqrt(n)))\n    x = np.linspace(0.1, 0.9, grid_size)\n    y = np.linspace(0.1, 0.9, grid_size)\n    xv, yv = np.meshgrid(x, y)\n    initial_centers = np.stack([xv.ravel()[:n], yv.ravel()[:n]], axis=1)\n    \n    # 2. Force-Directed Pre-processing\n    # We treat circles as particles with a repulsive potential\n    centers = initial_centers.copy()\n    lr = 0.05\n    r_est = 1.0 / (np.sqrt(n) * 2) # Target radius for force calc\n    \n    for _ in range(300):\n        diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + 1e-9)\n        \n        # Repulsion force\n        overlap = (2 * r_est) - dist\n        mask = (overlap > 0) & (dist > 0)\n        \n        force_dir = diff / dist[:, :, np.newaxis]\n        push = force_dir * overlap[:, :, np.newaxis]\n        \n        move = np.sum(push * mask[:, :, np.newaxis], axis=1)\n        centers += move * lr\n        \n        # Stay in bounds\n        centers = np.clip(centers, r_est, 1.0 - r_est)\n        lr *= 0.99\n\n    # 3. Local Optimization using SLSQP\n    # Variables: [x1, y1, r1, x2, y2, r2, ...]\n    # Objective: Maximize sum(r_i) => Minimize -sum(r_i)\n    \n    initial_radii = np.full(n, 0.05)\n    x0 = np.hstack([centers.flatten(), initial_radii])\n    \n    def objective(vars):\n        radii = vars[2*n:]\n        return -np.sum(radii)\n\n    def constraints(vars):\n        pts = vars[:2*n].reshape((n, 2))\n        radii = vars[2*n:]\n        cons = []\n        \n        # Pairwise non-overlap: dist(ci, cj) - (ri + rj) >= 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.sqrt(np.sum((pts[i] - pts[j])**2) + 1e-12)\n                cons.append(d - (radii[i] + radii[j]))\n        \n        # Boundary constraints: x - r >= 0, 1 - (x + r) >= 0\n        for i in range(n):\n            cons.append(pts[i, 0] - radii[i])\n            cons.append(1.0 - (pts[i, 0] + radii[i]))\n            cons.append(pts[i, 1] - radii[i])\n            cons.append(1.0 - (pts[i, 1] + radii[i]))\n            \n        return np.array(cons)\n\n    # Bounds for variables\n    bounds = []\n    for _ in range(n):\n        bounds.append((0, 1)) # x\n        bounds.append((0, 1)) # y\n    for _ in range(n):\n        bounds.append((0, 0.5)) # r\n\n    # Run optimization\n    res = minimize(\n        objective, \n        x0, \n        method='SLSQP', \n        constraints={'type': 'ineq', 'fun': constraints},\n        bounds=bounds,\n        options={'maxiter': 100, 'ftol': 1e-6}\n    )\n    \n    # Extract results\n    final_vars = res.x\n    final_centers = final_vars[:2*n].reshape((n, 2))\n    final_radii = final_vars[2*n:]\n    \n    # Final safety check: ensure no overlaps (shrink if necessary)\n    # This ensures the output is always valid even if SLSQP has tolerances\n    for i in range(n):\n        final_radii[i] = min(final_radii[i], final_centers[i, 0], 1.0 - final_centers[i, 0],\n                             final_centers[i, 1], 1.0 - final_centers[i, 1])\n        for j in range(i + 1, n):\n            d = np.linalg.norm(final_centers[i] - final_centers[j])\n            if final_radii[i] + final_radii[j] > d:\n                diff = (final_radii[i] + final_radii[j]) - d\n                final_radii[i] -= diff / 2\n                final_radii[j] -= diff / 2\n    \n    final_radii = np.maximum(final_radii, 0)\n    sum_radii = np.sum(final_radii)\n    \n    return final_centers, final_radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.5455742440463323,
    "eval_time": 0.6324667930603027,
    "error": null
  },
  "prompt": "Hybridize the Force-Directed approach from trial_0_3 with local optimization.\nCurrent code: {{import numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Constructs a circle packing for n=26 circles using a force-directed \n    simulation followed by a greedy radius maximization.\n    \"\"\"\n    n = 26\n    # Seed for reproducibility\n    np.random.seed(42)\n    \n    # Initialize centers randomly in the unit square\n    centers = np.random.uniform(0.1, 0.9, (n, 2))\n    \n    # Simulation parameters\n    iterations = 1000\n    learning_rate = 0.02\n    \n    for i in range(iterations):\n        # Calculate pairwise distances\n        diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + 1e-9)\n        \n        # Approximate radii for force calculation\n        # In a sum-of-radii objective, circles tend towards similar sizes\n        # if the space is packed efficiently.\n        r_est = 1.0 / (2 * np.sqrt(n))\n        \n        # Repulsion force between circles\n        overlap = 2 * r_est - dist\n        mask = (overlap > 0) & (dist > 0)\n        \n        force_dir = diff / dist[:, :, np.newaxis]\n        push = force_dir * overlap[:, :, np.newaxis]\n        \n        # Sum forces for each particle\n        move = np.sum(push * mask[:, :, np.newaxis], axis=1)\n        centers += move * learning_rate\n        \n        # Boundary constraints: keep centers within [r_est, 1-r_est]\n        centers = np.clip(centers, r_est, 1.0 - r_est)\n        \n        # Annealing learning rate\n        learning_rate *= 0.995\n\n    # After stabilization, calculate maximum possible radii for these centers\n    # To maximize sum(r_i), we solve the constraint: r_i + r_j <= dist(c_i, c_j)\n    # A simple but effective heuristic for sum of radii is to set r_i \n    # based on the distance to the nearest constraint.\n    \n    radii = np.zeros(n)\n    # Start with a small uniform radius\n    r = np.zeros(n) + 0.01\n    \n    # Refine radii: For sum of radii, we can iterate and expand radii \n    # until they hit a boundary or another circle.\n    for _ in range(50):\n        for i in range(n):\n            # Distance to walls\n            dist_to_walls = np.min([\n                centers[i, 0], 1.0 - centers[i, 0],\n                centers[i, 1], 1.0 - centers[i, 1]\n            ])\n            \n            # Distance to other circles\n            dists = np.sqrt(np.sum((centers - centers[i])**2, axis=1))\n            dists[i] = np.inf\n            dist_to_circles = np.min(dists - r)\n            \n            # Update radius i to fill available space\n            new_r = max(0, min(dist_to_walls, dist_to_circles))\n            r[i] = new_r\n\n    # Final check and adjustment to ensure no overlaps due to precision\n    for i in range(n):\n        # Wall constraints\n        r[i] = min(r[i], centers[i, 0], 1.0 - centers[i, 0], \n                   centers[i, 1], 1.0 - centers[i, 1])\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            if r[i] + r[j] > d:\n                # Shrink both proportionally to resolve overlap\n                excess = (r[i] + r[j] - d) + 1e-10\n                r[i] -= excess / 2\n                r[j] -= excess / 2\n    \n    r = np.maximum(r, 0)\n    sum_radii = np.sum(r)\n    \n    return centers, r, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()}}\n\nImprovements:\n1. Use the force-directed simulation as a 'pre-processing' step to find a good layout of centers.\n2. Once the forces stabilize, feed the resulting centers into `scipy.optimize.minimize` (SLSQP) to maximize the sum of radii while strictly enforcing the non-overlap and boundary constraints.\n3. Adjust the force laws to allow radii to grow dynamically during the simulation.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Constructs a circle packing for n=26 circles using a force-directed \n    initialization followed by SLSQP optimization to maximize sum of radii.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # 1. Initialization: Grid-like start with noise\n    grid_size = int(np.ceil(np.sqrt(n)))\n    x = np.linspace(0.1, 0.9, grid_size)\n    y = np.linspace(0.1, 0.9, grid_size)\n    xv, yv = np.meshgrid(x, y)\n    initial_centers = np.stack([xv.ravel()[:n], yv.ravel()[:n]], axis=1)\n    \n    # 2. Force-Directed Pre-processing\n    # We treat circles as particles with a repulsive potential\n    centers = initial_centers.copy()\n    lr = 0.05\n    r_est = 1.0 / (np.sqrt(n) * 2) # Target radius for force calc\n    \n    for _ in range(300):\n        diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + 1e-9)\n        \n        # Repulsion force\n        overlap = (2 * r_est) - dist\n        mask = (overlap > 0) & (dist > 0)\n        \n        force_dir = diff / dist[:, :, np.newaxis]\n        push = force_dir * overlap[:, :, np.newaxis]\n        \n        move = np.sum(push * mask[:, :, np.newaxis], axis=1)\n        centers += move * lr\n        \n        # Stay in bounds\n        centers = np.clip(centers, r_est, 1.0 - r_est)\n        lr *= 0.99\n\n    # 3. Local Optimization using SLSQP\n    # Variables: [x1, y1, r1, x2, y2, r2, ...]\n    # Objective: Maximize sum(r_i) => Minimize -sum(r_i)\n    \n    initial_radii = np.full(n, 0.05)\n    x0 = np.hstack([centers.flatten(), initial_radii])\n    \n    def objective(vars):\n        radii = vars[2*n:]\n        return -np.sum(radii)\n\n    def constraints(vars):\n        pts = vars[:2*n].reshape((n, 2))\n        radii = vars[2*n:]\n        cons = []\n        \n        # Pairwise non-overlap: dist(ci, cj) - (ri + rj) >= 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.sqrt(np.sum((pts[i] - pts[j])**2) + 1e-12)\n                cons.append(d - (radii[i] + radii[j]))\n        \n        # Boundary constraints: x - r >= 0, 1 - (x + r) >= 0\n        for i in range(n):\n            cons.append(pts[i, 0] - radii[i])\n            cons.append(1.0 - (pts[i, 0] + radii[i]))\n            cons.append(pts[i, 1] - radii[i])\n            cons.append(1.0 - (pts[i, 1] + radii[i]))\n            \n        return np.array(cons)\n\n    # Bounds for variables\n    bounds = []\n    for _ in range(n):\n        bounds.append((0, 1)) # x\n        bounds.append((0, 1)) # y\n    for _ in range(n):\n        bounds.append((0, 0.5)) # r\n\n    # Run optimization\n    res = minimize(\n        objective, \n        x0, \n        method='SLSQP', \n        constraints={'type': 'ineq', 'fun': constraints},\n        bounds=bounds,\n        options={'maxiter': 100, 'ftol': 1e-6}\n    )\n    \n    # Extract results\n    final_vars = res.x\n    final_centers = final_vars[:2*n].reshape((n, 2))\n    final_radii = final_vars[2*n:]\n    \n    # Final safety check: ensure no overlaps (shrink if necessary)\n    # This ensures the output is always valid even if SLSQP has tolerances\n    for i in range(n):\n        final_radii[i] = min(final_radii[i], final_centers[i, 0], 1.0 - final_centers[i, 0],\n                             final_centers[i, 1], 1.0 - final_centers[i, 1])\n        for j in range(i + 1, n):\n            d = np.linalg.norm(final_centers[i] - final_centers[j])\n            if final_radii[i] + final_radii[j] > d:\n                diff = (final_radii[i] + final_radii[j]) - d\n                final_radii[i] -= diff / 2\n                final_radii[j] -= diff / 2\n    \n    final_radii = np.maximum(final_radii, 0)\n    sum_radii = np.sum(final_radii)\n    \n    return final_centers, final_radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T22:22:36.719370",
  "cost_data": null
}