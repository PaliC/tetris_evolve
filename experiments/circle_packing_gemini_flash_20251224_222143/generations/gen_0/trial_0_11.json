{
  "trial_id": "trial_0_11",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses a coordinate descent approach with local optimization to maximize sum of radii.\n    \"\"\"\n    n = 26\n    # Initialize in a grid pattern\n    grid_size = int(np.ceil(np.sqrt(n)))\n    x = np.linspace(0.1, 0.9, grid_size)\n    y = np.linspace(0.1, 0.9, grid_size)\n    xv, yv = np.meshgrid(x, y)\n    \n    centers = np.stack([xv.ravel()[:n], yv.ravel()[:n]], axis=1)\n    # Initial radii: small enough to be valid\n    radii = np.full(n, 1.0 / (2 * grid_size))\n\n    def get_max_radius(idx, current_centers, current_radii):\n        \"\"\"Finds the maximum possible radius for circle idx given others are fixed.\"\"\"\n        cx, cy = current_centers[idx]\n        \n        # Distance to boundaries\n        max_r = min(cx, 1.0 - cx, cy, 1.0 - cy)\n        \n        # Distance to other circles\n        for i in range(len(current_centers)):\n            if i == idx:\n                continue\n            dist = np.linalg.norm(current_centers[idx] - current_centers[i])\n            # dist >= r_idx + r_i  =>  r_idx <= dist - r_i\n            max_r = min(max_r, dist - current_radii[i])\n        \n        return max(0.0, max_r)\n\n    # Iterative refinement (Coordinate Descent)\n    for _ in range(15):  # Multiple passes to converge\n        for i in range(n):\n            # 1. Optimize Position (Local Search)\n            def obj(coords):\n                # We want to move the center to a place that allows a larger radius\n                c_test = coords\n                r_allowed = min(c_test[0], 1.0 - c_test[0], c_test[1], 1.0 - c_test[1])\n                for j in range(n):\n                    if i == j: continue\n                    d = np.linalg.norm(c_test - centers[j])\n                    r_allowed = min(r_allowed, d - radii[j])\n                return -r_allowed # Maximize radius\n\n            res = minimize(obj, centers[i], bounds=[(0, 1), (0, 1)], method='L-BFGS-B')\n            if res.success:\n                centers[i] = res.x\n            \n            # 2. Update Radius\n            radii[i] = get_max_radius(i, centers, radii)\n\n    # Final global scaling/adjustment to ensure strict feasibility\n    # Small epsilon to prevent precision issues with boundaries\n    eps = 1e-9\n    centers = np.clip(centers, eps, 1.0 - eps)\n    \n    # Re-calculate radii one last time to ensure no overlap\n    final_radii = np.zeros(n)\n    for i in range(n):\n        r = min(centers[i, 0], 1.0 - centers[i, 0], centers[i, 1], 1.0 - centers[i, 1])\n        for j in range(i):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            r = min(r, dist - final_radii[j])\n        final_radii[i] = max(0, r - eps)\n\n    return centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.210159368645373,
    "eval_time": 2.0480000972747803,
    "error": null
  },
  "prompt": "Write a circle packing algorithm for 26 circles in a unit square [0,1]x[0,1] to maximize the sum of radii.\nStrategy: Coordinate Descent.\n1. Initialize 26 circles in a grid.\n2. One by one, optimize each circle's (x, y, r) while keeping others fixed.\n3. Cycle through all circles multiple times until the sum of radii converges.\n",
  "response": "To maximize the sum of radii for 26 circles in a unit square, we employ a coordinate descent strategy combined with a non-linear optimization approach. In this configuration, circles tend to \"push\" against each other and the boundaries. Since the objective is the sum of radii, the optimal configuration often involves a mix of larger and smaller circles filling gaps.\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses a coordinate descent approach with local optimization to maximize sum of radii.\n    \"\"\"\n    n = 26\n    # Initialize in a grid pattern\n    grid_size = int(np.ceil(np.sqrt(n)))\n    x = np.linspace(0.1, 0.9, grid_size)\n    y = np.linspace(0.1, 0.9, grid_size)\n    xv, yv = np.meshgrid(x, y)\n    \n    centers = np.stack([xv.ravel()[:n], yv.ravel()[:n]], axis=1)\n    # Initial radii: small enough to be valid\n    radii = np.full(n, 1.0 / (2 * grid_size))\n\n    def get_max_radius(idx, current_centers, current_radii):\n        \"\"\"Finds the maximum possible radius for circle idx given others are fixed.\"\"\"\n        cx, cy = current_centers[idx]\n        \n        # Distance to boundaries\n        max_r = min(cx, 1.0 - cx, cy, 1.0 - cy)\n        \n        # Distance to other circles\n        for i in range(len(current_centers)):\n            if i == idx:\n                continue\n            dist = np.linalg.norm(current_centers[idx] - current_centers[i])\n            # dist >= r_idx + r_i  =>  r_idx <= dist - r_i\n            max_r = min(max_r, dist - current_radii[i])\n        \n        return max(0.0, max_r)\n\n    # Iterative refinement (Coordinate Descent)\n    for _ in range(15):  # Multiple passes to converge\n        for i in range(n):\n            # 1. Optimize Position (Local Search)\n            def obj(coords):\n                # We want to move the center to a place that allows a larger radius\n                c_test = coords\n                r_allowed = min(c_test[0], 1.0 - c_test[0], c_test[1], 1.0 - c_test[1])\n                for j in range(n):\n                    if i == j: continue\n                    d = np.linalg.norm(c_test - centers[j])\n                    r_allowed = min(r_allowed, d - radii[j])\n                return -r_allowed # Maximize radius\n\n            res = minimize(obj, centers[i], bounds=[(0, 1), (0, 1)], method='L-BFGS-B')\n            if res.success:\n                centers[i] = res.x\n            \n            # 2. Update Radius\n            radii[i] = get_max_radius(i, centers, radii)\n\n    # Final global scaling/adjustment to ensure strict feasibility\n    # Small epsilon to prevent precision issues with boundaries\n    eps = 1e-9\n    centers = np.clip(centers, eps, 1.0 - eps)\n    \n    # Re-calculate radii one last time to ensure no overlap\n    final_radii = np.zeros(n)\n    for i in range(n):\n        r = min(centers[i, 0], 1.0 - centers[i, 0], centers[i, 1], 1.0 - centers[i, 1])\n        for j in range(i):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            r = min(r, dist - final_radii[j])\n        final_radii[i] = max(0, r - eps)\n\n    return centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "To maximize the sum of radii for 26 circles in a unit square, we employ a coordinate descent strategy combined with a non-linear optimization approach. In this configuration, circles tend to \"push\" against each other and the boundaries. Since the objective is the sum of radii, the optimal configuration often involves a mix of larger and smaller circles filling gaps.",
  "timestamp": "2025-12-24T22:22:13.019825",
  "cost_data": null
}