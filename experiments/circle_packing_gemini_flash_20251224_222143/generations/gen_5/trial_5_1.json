{
  "trial_id": "trial_5_1",
  "generation": 5,
  "parent_id": "trial_4_2",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses a 'Topological Shake' meta-heuristic combined with SLSQP optimization.\n    \"\"\"\n    n = 26\n    \n    # 1. Initial Guess: 5x5 grid + 1 extra\n    side = 5\n    x = np.linspace(0.1, 0.9, side)\n    y = np.linspace(0.1, 0.9, side)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.ravel(), yv.ravel()], axis=1)\n    extra_circle = np.array([[0.5, 0.5]])\n    centers = np.vstack([centers, extra_circle])\n    radii = np.full(n, 1.0 / (2 * side))\n\n    def get_objective(params):\n        r = params[2*n:]\n        return -np.sum(r)\n\n    def get_constraints(params):\n        c = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        num_overlap = n * (n - 1) // 2\n        cons = np.zeros(4 * n + num_overlap)\n        \n        idx = 0\n        for i in range(n):\n            cons[idx] = c[i, 0] - r[i]\n            cons[idx+1] = 1.0 - (c[i, 0] + r[i])\n            cons[idx+2] = c[i, 1] - r[i]\n            cons[idx+3] = 1.0 - (c[i, 1] + r[i])\n            idx += 4\n            \n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((c[i] - c[j])**2) + 1e-12)\n                cons[idx] = dist - (r[i] + r[j])\n                idx += 1\n        return cons\n\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n\n    def optimize_layout(curr_centers, curr_radii, iterations=60):\n        init_p = np.concatenate([curr_centers.flatten(), curr_radii])\n        res = minimize(\n            get_objective, \n            init_p, \n            method='SLSQP', \n            bounds=bounds,\n            constraints={'type': 'ineq', 'fun': get_constraints},\n            options={'maxiter': iterations, 'ftol': 1e-6}\n        )\n        p = res.x\n        return p[:2*n].reshape((n, 2)), p[2*n:], -res.fun\n\n    # Initial optimization to establish baseline\n    centers, radii, best_sum = optimize_layout(centers, radii, iterations=100)\n    best_centers, best_radii = centers.copy(), radii.copy()\n\n    # Meta-heuristic Loop\n    for _ in range(5):\n        # Topological Shake: Randomly relocate 3 circles\n        new_centers = centers.copy()\n        indices_to_shake = np.random.choice(n, 3, replace=False)\n        new_centers[indices_to_shake] = np.random.rand(3, 2)\n        \n        # Local optimization for new topology\n        temp_centers, temp_radii, temp_sum = optimize_layout(new_centers, radii, iterations=50)\n        \n        # Acceptance criteria: Better than best or within 95% to allow escape\n        if temp_sum > best_sum:\n            best_sum = temp_sum\n            best_centers, best_radii = temp_centers.copy(), temp_radii.copy()\n            centers, radii = temp_centers, temp_radii\n        elif temp_sum > best_sum * 0.95:\n            centers, radii = temp_centers, temp_radii\n\n    # Final Polish\n    final_centers, final_radii, final_sum = optimize_layout(best_centers, best_radii, iterations=150)\n\n    # --- Post-processing: Rigorous Feasibility Enforcement ---\n    final_centers = np.clip(final_centers, 0, 1)\n    for _ in range(100):\n        changed = False\n        for i in range(n):\n            max_r = min(final_centers[i, 0], 1 - final_centers[i, 0], final_centers[i, 1], 1 - final_centers[i, 1])\n            if final_radii[i] > max_r:\n                final_radii[i] = max_r\n                changed = True\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(final_centers[i] - final_centers[j])\n                if dist < (final_radii[i] + final_radii[j]):\n                    overlap = (final_radii[i] + final_radii[j]) - dist\n                    shrink = overlap / 2.0 + 1e-12\n                    final_radii[i] -= shrink\n                    final_radii[j] -= shrink\n                    changed = True\n        final_radii = np.maximum(final_radii, 0)\n        if not changed: break\n\n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.6066017337744323,
    "eval_time": 4.4830968379974365,
    "error": null
  },
  "prompt": "Refine the 'Circle Swapping' strategy from trial_4_2.\n{{import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Implements a 'Cluster-to-Gap' relocation meta-heuristic combined with \n    SLSQP optimization to maximize the sum of radii.\n    \"\"\"\n    n = 26\n    \n    # 1. Initial Guess: Optimized Grid-like Layout\n    # Benchmark best known for n=26 sum(r) is ~2.635.\n    # We start with a 5x5 grid + 1 extra circle.\n    side = 5\n    x = np.linspace(0.1, 0.9, side)\n    y = np.linspace(0.1, 0.9, side)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.ravel(), yv.ravel()], axis=1)\n    # Place the 26th circle in a likely gap\n    extra_circle = np.array([[0.5, 0.5]])\n    centers = np.vstack([centers, extra_circle])\n    radii = np.full(n, 1.0 / (2 * side))\n    \n    def get_objective(params):\n        r = params[2*n:]\n        return -np.sum(r)\n\n    def get_constraints(params):\n        c = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        \n        # Boundary constraints: c - r >= 0 and c + r <= 1\n        # Non-overlapping: dist - (r_i + r_j) >= 0\n        num_overlap = n * (n - 1) // 2\n        cons = np.zeros(4 * n + num_overlap)\n        \n        idx = 0\n        for i in range(n):\n            cons[idx] = c[i, 0] - r[i]\n            cons[idx+1] = 1.0 - (c[i, 0] + r[i])\n            cons[idx+2] = c[i, 1] - r[i]\n            cons[idx+3] = 1.0 - (c[i, 1] + r[i])\n            idx += 4\n            \n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((c[i] - c[j])**2) + 1e-12)\n                cons[idx] = dist - (r[i] + r[j])\n                idx += 1\n        return cons\n\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n\n    def optimize_layout(current_centers, current_radii, iterations=50):\n        init_p = np.concatenate([current_centers.flatten(), current_radii])\n        res = minimize(\n            get_objective, \n            init_p, \n            method='SLSQP', \n            bounds=bounds,\n            constraints={'type': 'ineq', 'fun': get_constraints},\n            options={'maxiter': iterations, 'ftol': 1e-5}\n        )\n        p = res.x\n        return p[:2*n].reshape((n, 2)), p[2*n:], -res.fun\n\n    # Initial optimization to establish baseline\n    centers, radii, best_sum = optimize_layout(centers, radii, iterations=100)\n\n    # 2. Meta-heuristic: Cluster-to-Gap Relocation\n    for _ in range(8):\n        # Identify the 'tightest' circle (smallest sum of distances to 3 nearest neighbors)\n        dists = np.zeros(n)\n        for i in range(n):\n            d = np.linalg.norm(centers - centers[i], axis=1)\n            d.sort()\n            dists[i] = np.sum(d[1:4]) # sum of distances to 3 nearest\n        \n        tightest_idx = np.argmin(dists)\n        \n        # Identify the 'loosest' area using a simple grid search for the largest empty space\n        grid_res = 10\n        gx, gy = np.meshgrid(np.linspace(0.1, 0.9, grid_res), np.linspace(0.1, 0.9, grid_res))\n        grid_pts = np.stack([gx.ravel(), gy.ravel()], axis=1)\n        \n        min_dists_to_centers = []\n        for gp in grid_pts:\n            min_dists_to_centers.append(np.min(np.linalg.norm(centers - gp, axis=1)))\n        \n        loosest_pos = grid_pts[np.argmax(min_dists_to_centers)]\n        \n        # Relocate\n        new_centers = centers.copy()\n        new_centers[tightest_idx] = loosest_pos\n        \n        # Local optimization for new topology\n        temp_centers, temp_radii, temp_sum = optimize_layout(new_centers, radii, iterations=40)\n        \n        if temp_sum > best_sum:\n            centers, radii, best_sum = temp_centers, temp_radii, temp_sum\n\n    # Final Polishing with high precision\n    centers, radii, best_sum = optimize_layout(centers, radii, iterations=200)\n\n    # --- Post-processing: Rigorous Feasibility Enforcement ---\n    # Ensure centers are within [0,1]\n    centers = np.clip(centers, 0, 1)\n    \n    # Iterative shrinkage to ensure no overlaps and boundary compliance\n    for _ in range(200):\n        changed = False\n        # Boundary check\n        for i in range(n):\n            max_r = min(centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n            if radii[i] > max_r:\n                radii[i] = max_r\n                changed = True\n        \n        # Overlap check\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < (radii[i] + radii[j]):\n                    overlap = (radii[i] + radii[j]) - dist\n                    # Shrink both slightly more than half to handle precision\n                    shrink = overlap / 2.0 + 1e-10\n                    radii[i] -= shrink\n                    radii[j] -= shrink\n                    changed = True\n        \n        # Ensure radii don't go negative\n        radii = np.maximum(radii, 0)\n        if not changed:\n            break\n\n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()}}\n\n1. Instead of starting from a random grid, start the swapping process from the best known configuration: {{import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses a combination of a grid-based start and SLSQP optimization\n    to maximize the sum of radii while ensuring non-overlap and \n    boundary constraints.\n    \"\"\"\n    n = 26\n    \n    # 1. Improved Initial Guess: 5x5 grid + 1 extra\n    # We use a slightly jittered grid to break symmetry early.\n    side = 5\n    x = np.linspace(0.15, 0.85, side)\n    y = np.linspace(0.15, 0.85, side)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.ravel(), yv.ravel()], axis=1)\n    # Add the 26th circle near the center with a small offset\n    extra_circle = np.array([[0.51, 0.51]])\n    centers = np.vstack([centers, extra_circle])\n    \n    # Initial radii: slightly smaller than the grid gap\n    radii = np.full(n, 1.0 / (2 * side))\n    \n    # Flatten parameters: [x0, y0, ..., xn, yn, r0, ..., rn]\n    initial_params = np.concatenate([centers.flatten(), radii])\n\n    def objective(params):\n        # Maximize sum(radii) -> Minimize -sum(radii)\n        # We also add a very small penalty for large radii variance to \n        # encourage all circles to grow, which helps the solver early on.\n        r = params[2*n:]\n        return -np.sum(r)\n\n    def constraints(params):\n        c = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        \n        # Pre-allocate constraint array\n        # 4 boundary per circle + n*(n-1)/2 overlap\n        num_overlap = n * (n - 1) // 2\n        cons = np.zeros(4 * n + num_overlap)\n        \n        idx = 0\n        # Boundary constraints: c - r >= 0 and c + r <= 1\n        for i in range(n):\n            cons[idx] = c[i, 0] - r[i]\n            cons[idx+1] = 1.0 - (c[i, 0] + r[i])\n            cons[idx+2] = c[i, 1] - r[i]\n            cons[idx+3] = 1.0 - (c[i, 1] + r[i])\n            idx += 4\n            \n        # Non-overlapping: dist - (r_i + r_j) >= 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Use squared distance for smoother gradients if possible, \n                # but standard norm is clearer for SLSQP.\n                dist = np.sqrt(np.sum((c[i] - c[j])**2) + 1e-12)\n                cons[idx] = dist - (r[i] + r[j])\n                idx += 1\n        return cons\n\n    # Bounds: Centers in [0, 1], Radii in [0.001, 0.5]\n    bounds = [(0, 1)] * (2 * n) + [(0.001, 0.5)] * n\n\n    # Optimization\n    res = minimize(\n        objective, \n        initial_params, \n        method='SLSQP', \n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraints},\n        options={'maxiter': 150, 'ftol': 1e-7, 'disp': False}\n    )\n\n    final_params = res.x\n    centers = final_params[:2*n].reshape((n, 2))\n    radii = final_params[2*n:]\n    \n    # --- Post-processing: Rigorous Feasibility Enforcement ---\n    # 1. Clamp centers to [0,1]\n    centers = np.clip(centers, 0, 1)\n    \n    # 2. Iteratively shrink radii to satisfy all constraints exactly\n    for _ in range(50):\n        changed = False\n        # Boundary check\n        for i in range(n):\n            max_r = min(centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n            if radii[i] > max_r:\n                radii[i] = max_r\n                changed = True\n        \n        # Overlap check\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j]:\n                    overlap = (radii[i] + radii[j]) - dist\n                    # Reduce radii slightly more than half overlap to ensure separation\n                    shrink = overlap / 2.0 + 1e-10\n                    radii[i] -= shrink\n                    radii[j] -= shrink\n                    changed = True\n        if not changed:\n            break\n\n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()}}.\n2. Implement a 'Topological Shake': randomly pick 3 circles and move them to completely new random locations in the square.\n3. Re-run the Voronoi smoothing and then SLSQP.\n4. If the new sum of radii is within 95% of the best, keep it for the next iteration (to allow escaping local optima). If it's better, update the global best.\n5. Run this loop for as many iterations as time allows.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses a 'Topological Shake' meta-heuristic combined with SLSQP optimization.\n    \"\"\"\n    n = 26\n    \n    # 1. Initial Guess: 5x5 grid + 1 extra\n    side = 5\n    x = np.linspace(0.1, 0.9, side)\n    y = np.linspace(0.1, 0.9, side)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.ravel(), yv.ravel()], axis=1)\n    extra_circle = np.array([[0.5, 0.5]])\n    centers = np.vstack([centers, extra_circle])\n    radii = np.full(n, 1.0 / (2 * side))\n\n    def get_objective(params):\n        r = params[2*n:]\n        return -np.sum(r)\n\n    def get_constraints(params):\n        c = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        num_overlap = n * (n - 1) // 2\n        cons = np.zeros(4 * n + num_overlap)\n        \n        idx = 0\n        for i in range(n):\n            cons[idx] = c[i, 0] - r[i]\n            cons[idx+1] = 1.0 - (c[i, 0] + r[i])\n            cons[idx+2] = c[i, 1] - r[i]\n            cons[idx+3] = 1.0 - (c[i, 1] + r[i])\n            idx += 4\n            \n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((c[i] - c[j])**2) + 1e-12)\n                cons[idx] = dist - (r[i] + r[j])\n                idx += 1\n        return cons\n\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n\n    def optimize_layout(curr_centers, curr_radii, iterations=60):\n        init_p = np.concatenate([curr_centers.flatten(), curr_radii])\n        res = minimize(\n            get_objective, \n            init_p, \n            method='SLSQP', \n            bounds=bounds,\n            constraints={'type': 'ineq', 'fun': get_constraints},\n            options={'maxiter': iterations, 'ftol': 1e-6}\n        )\n        p = res.x\n        return p[:2*n].reshape((n, 2)), p[2*n:], -res.fun\n\n    # Initial optimization to establish baseline\n    centers, radii, best_sum = optimize_layout(centers, radii, iterations=100)\n    best_centers, best_radii = centers.copy(), radii.copy()\n\n    # Meta-heuristic Loop\n    for _ in range(5):\n        # Topological Shake: Randomly relocate 3 circles\n        new_centers = centers.copy()\n        indices_to_shake = np.random.choice(n, 3, replace=False)\n        new_centers[indices_to_shake] = np.random.rand(3, 2)\n        \n        # Local optimization for new topology\n        temp_centers, temp_radii, temp_sum = optimize_layout(new_centers, radii, iterations=50)\n        \n        # Acceptance criteria: Better than best or within 95% to allow escape\n        if temp_sum > best_sum:\n            best_sum = temp_sum\n            best_centers, best_radii = temp_centers.copy(), temp_radii.copy()\n            centers, radii = temp_centers, temp_radii\n        elif temp_sum > best_sum * 0.95:\n            centers, radii = temp_centers, temp_radii\n\n    # Final Polish\n    final_centers, final_radii, final_sum = optimize_layout(best_centers, best_radii, iterations=150)\n\n    # --- Post-processing: Rigorous Feasibility Enforcement ---\n    final_centers = np.clip(final_centers, 0, 1)\n    for _ in range(100):\n        changed = False\n        for i in range(n):\n            max_r = min(final_centers[i, 0], 1 - final_centers[i, 0], final_centers[i, 1], 1 - final_centers[i, 1])\n            if final_radii[i] > max_r:\n                final_radii[i] = max_r\n                changed = True\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(final_centers[i] - final_centers[j])\n                if dist < (final_radii[i] + final_radii[j]):\n                    overlap = (final_radii[i] + final_radii[j]) - dist\n                    shrink = overlap / 2.0 + 1e-12\n                    final_radii[i] -= shrink\n                    final_radii[j] -= shrink\n                    changed = True\n        final_radii = np.maximum(final_radii, 0)\n        if not changed: break\n\n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T22:24:32.098493",
  "cost_data": null
}