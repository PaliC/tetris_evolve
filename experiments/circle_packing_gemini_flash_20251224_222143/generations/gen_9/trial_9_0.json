{
  "trial_id": "trial_9_0",
  "generation": 9,
  "parent_id": "trial_8_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_radii_lp(centers):\n    \"\"\"Calculates maximal radii for fixed centers using Linear Programming.\"\"\"\n    n = len(centers)\n    # Objective: Maximize sum of radii\n    c_obj = -np.ones(n)\n    \n    # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n    bounds_r = []\n    for i in range(n):\n        max_possible = np.min([centers[i, 0], 1.0 - centers[i, 0], centers[i, 1], 1.0 - centers[i, 1]])\n        bounds_r.append((0, max(1e-10, max_possible)))\n    \n    # Pairwise distance constraints: r_i + r_j <= dist(c_i, c_j)\n    A_ub = []\n    b_ub = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            dist = np.linalg.norm(centers[i] - centers[j])\n            A_ub.append(row)\n            b_ub.append(dist)\n    \n    res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds_r, method='highs')\n    if res.success:\n        return res.x\n    return np.full(n, 1e-9)\n\ndef construct_packing():\n    n = 26\n    # Initial Layout: 5x5 grid + 1 extra\n    side = 5\n    x = np.linspace(0.12, 0.88, side)\n    y = np.linspace(0.12, 0.88, side)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.flatten(), yv.flatten()], axis=1)\n    centers = np.vstack([centers, [0.5, 0.5]])[:n]\n    \n    def lloyd_step(c, iterations=15):\n        for _ in range(iterations):\n            for i in range(n):\n                diffs = c - c[i]\n                dists = np.linalg.norm(diffs, axis=1)\n                dists[i] = np.inf\n                nearest = np.argmin(dists)\n                if dists[nearest] < 0.18:\n                    force = diffs[nearest] / (dists[nearest]**2 + 1e-4)\n                    c[i] -= 0.015 * force\n            c = np.clip(c, 0.01, 0.99)\n        return c\n\n    def refine_slsqp(c_init, r_init, epsilon, high_precision=False):\n        def objective(params):\n            r = params[2*n:]\n            if high_precision:\n                return -np.sum(r)\n            # Barrier method to keep radii from collapsing\n            return -np.sum(r) - epsilon * np.sum(np.log(r + 1e-9))\n\n        def constraints(params):\n            c = params[:2*n].reshape((n, 2))\n            r = params[2*n:]\n            # Boundaries: c - r >= 0 and c + r <= 1\n            # Pairwise: dist - (ri + rj) >= 0\n            cons = []\n            cons.extend(c.flatten() - r.repeat(2))\n            cons.extend(1.0 - (c.flatten() + r.repeat(2)))\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist = np.sqrt(np.sum((c[i] - c[j])**2))\n                    cons.append(dist - (r[i] + r[j]))\n            return np.array(cons)\n\n        x0 = np.concatenate([c_init.flatten(), r_init])\n        opts = {'maxiter': 5000, 'ftol': 1e-16} if high_precision else {'maxiter': 100, 'disp': False}\n        res = minimize(objective, x0, method='SLSQP', \n                       constraints={'type': 'ineq', 'fun': constraints},\n                       options=opts)\n        \n        if res.success or high_precision:\n            return res.x[:2*n].reshape((n, 2)), res.x[2*n:]\n        return c_init, r_init\n\n    # Optimization Loop\n    best_c = centers\n    best_r = solve_radii_lp(centers)\n    best_sum = np.sum(best_r)\n    curr_c, curr_r = np.copy(best_c), np.copy(best_r)\n    \n    epsilons = [0.1, 0.05, 0.02, 0.01, 0.005, 0.002, 0.001, 0.0005, 0.0001]\n    eps_idx = 0\n\n    # Basin Hopping iterations\n    for k in range(250):\n        temp_c = np.copy(curr_c)\n        # Micro-jitter\n        temp_c += np.random.normal(0, 0.0001, temp_c.shape)\n        \n        prob = np.random.rand()\n        if prob < 0.4: # Move 2 smallest\n            idx = np.argsort(curr_r)[:2]\n            temp_c[idx] = np.random.rand(2, 2) * 0.8 + 0.1\n        elif prob < 0.7: # Move 1 random\n            idx = np.random.randint(0, n)\n            temp_c[idx] = np.random.rand(2) * 0.8 + 0.1\n        else: # Large perturbation\n            temp_c += np.random.normal(0, 0.02, temp_c.shape)\n            \n        temp_c = lloyd_step(temp_c, 10)\n        temp_r = solve_radii_lp(temp_c)\n        \n        # Local search with current epsilon\n        eps = epsilons[min(eps_idx, len(epsilons)-1)]\n        temp_c, temp_r = refine_slsqp(temp_c, temp_r, eps)\n        temp_sum = np.sum(temp_r)\n        \n        if temp_sum > best_sum:\n            best_sum = temp_sum\n            best_c, best_r = np.copy(temp_c), np.copy(temp_r)\n            curr_c, curr_r = np.copy(temp_c), np.copy(temp_r)\n            eps_idx += 1 # Advance schedule on improvement\n        elif temp_sum > best_sum * 0.98:\n            curr_c, curr_r = np.copy(temp_c), np.copy(temp_r)\n\n    # Final High-Precision Polish\n    final_c, final_r = refine_slsqp(best_c, best_r, 0, high_precision=True)\n    \n    # Final LP to ensure strictly valid radii and maximize sum\n    final_r = solve_radii_lp(final_c)\n    final_sum = np.sum(final_r)\n    \n    return final_c, final_r, final_sum\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.635328412488767,
    "eval_time": 119.11275911331177,
    "error": null
  },
  "prompt": "The current best score is 2.6323 from trial_8_0.\n{{import numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_radii_lp(centers):\n    \"\"\"Calculates maximal radii for fixed centers using Linear Programming.\"\"\"\n    n = len(centers)\n    # Objective: Maximize sum of radii\n    c_obj = -np.ones(n)\n    \n    # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, etc.\n    bounds_r = []\n    for i in range(n):\n        max_possible = np.min([centers[i, 0], 1.0 - centers[i, 0], centers[i, 1], 1.0 - centers[i, 1]])\n        bounds_r.append((0, max(1e-9, max_possible)))\n    \n    # Pairwise distance constraints: r_i + r_j <= dist(c_i, c_j)\n    A_ub = []\n    b_ub = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            dist = np.linalg.norm(centers[i] - centers[j])\n            A_ub.append(row)\n            b_ub.append(dist)\n    \n    res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds_r, method='highs')\n    if res.success:\n        return res.x\n    return np.full(n, 1e-9)\n\ndef construct_packing():\n    n = 26\n    # Initial Layout: 5x5 grid + 1 extra\n    side = 5\n    x = np.linspace(0.15, 0.85, side)\n    y = np.linspace(0.15, 0.85, side)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.flatten(), yv.flatten()], axis=1)\n    centers = np.vstack([centers, [0.5, 0.5]])[:n]\n    \n    def lloyd_step(c, iterations=20):\n        for _ in range(iterations):\n            for i in range(n):\n                diffs = c - c[i]\n                dists = np.linalg.norm(diffs, axis=1)\n                dists[i] = np.inf\n                nearest = np.argmin(dists)\n                if dists[nearest] < 0.18:\n                    force = diffs[nearest] / (dists[nearest]**2 + 1e-4)\n                    c[i] -= 0.01 * force\n            c = np.clip(c, 0.02, 0.98)\n        return c\n\n    def refine_slsqp(c_init, r_init, epsilon, high_precision=False):\n        def objective(params):\n            r = params[2*n:]\n            if high_precision:\n                return -np.sum(r)\n            return -np.sum(r) - epsilon * np.sum(np.log(r + 1e-8))\n\n        def constraints(params):\n            c = params[:2*n].reshape((n, 2))\n            r = params[2*n:]\n            cons = []\n            # Boundaries: c - r >= 0 and c + r <= 1\n            cons.extend(c.flatten() - r.repeat(2))\n            cons.extend(1.0 - (c.flatten() + r.repeat(2)))\n            # No overlap: dist^2 - (r1+r2)^2 >= 0\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist_sq = np.sum((c[i] - c[j])**2)\n                    cons.append(dist_sq - (r[i] + r[j])**2)\n            return np.array(cons)\n\n        x0 = np.concatenate([c_init.flatten(), r_init])\n        opts = {'maxiter': 2000, 'ftol': 1e-15} if high_precision else {'maxiter': 60, 'disp': False}\n        res = minimize(objective, x0, method='SLSQP', \n                       constraints={'type': 'ineq', 'fun': constraints},\n                       options=opts)\n        \n        if res.success:\n            return res.x[:2*n].reshape((n, 2)), res.x[2*n:]\n        return c_init, r_init\n\n    # Optimization Loop variables\n    best_c = centers\n    best_r = solve_radii_lp(centers)\n    best_sum = np.sum(best_r)\n    curr_c, curr_r = np.copy(best_c), np.copy(best_r)\n    epsilon = 0.1\n\n    # Basin Hopping\n    for _ in range(150):\n        temp_c = np.copy(curr_c)\n        prob = np.random.rand()\n        \n        if prob < 0.5: # Move 2 smallest\n            idx = np.argsort(curr_r)[:2]\n            temp_c[idx] = np.random.rand(2, 2) * 0.8 + 0.1\n        elif prob < 0.8: # Move 1 random\n            idx = np.random.randint(0, n)\n            temp_c[idx] = np.random.rand(2) * 0.8 + 0.1\n        else: # Swap largest and smallest\n            i_min, i_max = np.argmin(curr_r), np.argmax(curr_r)\n            temp_c[i_min], temp_c[i_max] = temp_c[i_max].copy(), temp_c[i_min].copy()\n            \n        temp_c = lloyd_step(temp_c, 15)\n        temp_r = solve_radii_lp(temp_c)\n        temp_c, temp_r = refine_slsqp(temp_c, temp_r, epsilon)\n        temp_sum = np.sum(temp_r)\n        \n        if temp_sum > best_sum:\n            best_sum = temp_sum\n            best_c, best_r = np.copy(temp_c), np.copy(temp_r)\n            curr_c, curr_r = np.copy(temp_c), np.copy(temp_r)\n            epsilon *= 0.5 # Cooling schedule\n        elif temp_sum > best_sum * 0.95:\n            curr_c, curr_r = np.copy(temp_c), np.copy(temp_r)\n\n    # Final Polish\n    final_c, final_r = refine_slsqp(best_c, best_r, 0, high_precision=True)\n    \n    # Final validation and feasibility fix\n    final_r = solve_radii_lp(final_c)\n    final_sum = np.sum(final_r)\n    \n    return final_c, final_r, final_sum\n\ndef run_packing():\n    return construct_packing()}}\n\nMaximize the potential of this 'Probabilistic Shake' + 'Logarithmic Barrier' approach for the final push:\n1. Increase the search budget: Run for 250 iterations of Basin Hopping.\n2. Fine-tune the 'Shake': In addition to moving the 2 smallest circles, add a 'Micro-Jitter' where all centers are nudged by a tiny random amount (std=0.0001) in every iteration to help the SLSQP escape very shallow local optima.\n3. Optimize the Barrier: Use a more granular epsilon schedule: [0.1, 0.05, 0.02, 0.01, 0.005, 0.002, 0.001, 0.0005, 0.0001].\n4. Final Polish: In the very last step, use `scipy.optimize.minimize` with `method='SLSQP'`, `ftol=1e-16`, and `maxiter=5000` to squeeze out the last bits of radius sum.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_radii_lp(centers):\n    \"\"\"Calculates maximal radii for fixed centers using Linear Programming.\"\"\"\n    n = len(centers)\n    # Objective: Maximize sum of radii\n    c_obj = -np.ones(n)\n    \n    # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n    bounds_r = []\n    for i in range(n):\n        max_possible = np.min([centers[i, 0], 1.0 - centers[i, 0], centers[i, 1], 1.0 - centers[i, 1]])\n        bounds_r.append((0, max(1e-10, max_possible)))\n    \n    # Pairwise distance constraints: r_i + r_j <= dist(c_i, c_j)\n    A_ub = []\n    b_ub = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            dist = np.linalg.norm(centers[i] - centers[j])\n            A_ub.append(row)\n            b_ub.append(dist)\n    \n    res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds_r, method='highs')\n    if res.success:\n        return res.x\n    return np.full(n, 1e-9)\n\ndef construct_packing():\n    n = 26\n    # Initial Layout: 5x5 grid + 1 extra\n    side = 5\n    x = np.linspace(0.12, 0.88, side)\n    y = np.linspace(0.12, 0.88, side)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.flatten(), yv.flatten()], axis=1)\n    centers = np.vstack([centers, [0.5, 0.5]])[:n]\n    \n    def lloyd_step(c, iterations=15):\n        for _ in range(iterations):\n            for i in range(n):\n                diffs = c - c[i]\n                dists = np.linalg.norm(diffs, axis=1)\n                dists[i] = np.inf\n                nearest = np.argmin(dists)\n                if dists[nearest] < 0.18:\n                    force = diffs[nearest] / (dists[nearest]**2 + 1e-4)\n                    c[i] -= 0.015 * force\n            c = np.clip(c, 0.01, 0.99)\n        return c\n\n    def refine_slsqp(c_init, r_init, epsilon, high_precision=False):\n        def objective(params):\n            r = params[2*n:]\n            if high_precision:\n                return -np.sum(r)\n            # Barrier method to keep radii from collapsing\n            return -np.sum(r) - epsilon * np.sum(np.log(r + 1e-9))\n\n        def constraints(params):\n            c = params[:2*n].reshape((n, 2))\n            r = params[2*n:]\n            # Boundaries: c - r >= 0 and c + r <= 1\n            # Pairwise: dist - (ri + rj) >= 0\n            cons = []\n            cons.extend(c.flatten() - r.repeat(2))\n            cons.extend(1.0 - (c.flatten() + r.repeat(2)))\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist = np.sqrt(np.sum((c[i] - c[j])**2))\n                    cons.append(dist - (r[i] + r[j]))\n            return np.array(cons)\n\n        x0 = np.concatenate([c_init.flatten(), r_init])\n        opts = {'maxiter': 5000, 'ftol': 1e-16} if high_precision else {'maxiter': 100, 'disp': False}\n        res = minimize(objective, x0, method='SLSQP', \n                       constraints={'type': 'ineq', 'fun': constraints},\n                       options=opts)\n        \n        if res.success or high_precision:\n            return res.x[:2*n].reshape((n, 2)), res.x[2*n:]\n        return c_init, r_init\n\n    # Optimization Loop\n    best_c = centers\n    best_r = solve_radii_lp(centers)\n    best_sum = np.sum(best_r)\n    curr_c, curr_r = np.copy(best_c), np.copy(best_r)\n    \n    epsilons = [0.1, 0.05, 0.02, 0.01, 0.005, 0.002, 0.001, 0.0005, 0.0001]\n    eps_idx = 0\n\n    # Basin Hopping iterations\n    for k in range(250):\n        temp_c = np.copy(curr_c)\n        # Micro-jitter\n        temp_c += np.random.normal(0, 0.0001, temp_c.shape)\n        \n        prob = np.random.rand()\n        if prob < 0.4: # Move 2 smallest\n            idx = np.argsort(curr_r)[:2]\n            temp_c[idx] = np.random.rand(2, 2) * 0.8 + 0.1\n        elif prob < 0.7: # Move 1 random\n            idx = np.random.randint(0, n)\n            temp_c[idx] = np.random.rand(2) * 0.8 + 0.1\n        else: # Large perturbation\n            temp_c += np.random.normal(0, 0.02, temp_c.shape)\n            \n        temp_c = lloyd_step(temp_c, 10)\n        temp_r = solve_radii_lp(temp_c)\n        \n        # Local search with current epsilon\n        eps = epsilons[min(eps_idx, len(epsilons)-1)]\n        temp_c, temp_r = refine_slsqp(temp_c, temp_r, eps)\n        temp_sum = np.sum(temp_r)\n        \n        if temp_sum > best_sum:\n            best_sum = temp_sum\n            best_c, best_r = np.copy(temp_c), np.copy(temp_r)\n            curr_c, curr_r = np.copy(temp_c), np.copy(temp_r)\n            eps_idx += 1 # Advance schedule on improvement\n        elif temp_sum > best_sum * 0.98:\n            curr_c, curr_r = np.copy(temp_c), np.copy(temp_r)\n\n    # Final High-Precision Polish\n    final_c, final_r = refine_slsqp(best_c, best_r, 0, high_precision=True)\n    \n    # Final LP to ensure strictly valid radii and maximize sum\n    final_r = solve_radii_lp(final_c)\n    final_sum = np.sum(final_r)\n    \n    return final_c, final_r, final_sum\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T22:29:43.952645",
  "cost_data": null
}