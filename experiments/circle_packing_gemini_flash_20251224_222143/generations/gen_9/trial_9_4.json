{
  "trial_id": "trial_9_4",
  "generation": 9,
  "parent_id": "trial_8_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_radii_lp(centers):\n    \"\"\"Calculates maximal radii for fixed centers using Linear Programming.\"\"\"\n    n = len(centers)\n    # Objective: Maximize sum of radii\n    c_obj = -np.ones(n)\n    \n    # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, etc.\n    bounds_r = []\n    for i in range(n):\n        max_possible = np.min([centers[i, 0], 1.0 - centers[i, 0], centers[i, 1], 1.0 - centers[i, 1]])\n        bounds_r.append((0, max(1e-9, max_possible)))\n    \n    # Pairwise distance constraints: r_i + r_j <= dist(c_i, c_j)\n    A_ub = []\n    b_ub = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            dist = np.linalg.norm(centers[i] - centers[j])\n            A_ub.append(row)\n            b_ub.append(dist)\n    \n    res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds_r, method='highs')\n    if res.success:\n        return res.x\n    return np.full(n, 1e-9)\n\ndef refine_slsqp(c_init, r_init, n, high_precision=False):\n    def objective(params):\n        r = params[2*n:]\n        return -np.sum(r)\n\n    def constraints(params):\n        c = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        cons = []\n        # Boundaries\n        cons.extend(c.flatten() - r.repeat(2))\n        cons.extend(1.0 - (c.flatten() + r.repeat(2)))\n        # No overlap\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((c[i] - c[j])**2))\n                cons.append(dist - (r[i] + r[j]))\n        return np.array(cons)\n\n    x0 = np.concatenate([c_init.flatten(), r_init])\n    opts = {'maxiter': 100, 'ftol': 1e-9} if high_precision else {'maxiter': 30}\n    res = minimize(objective, x0, method='SLSQP', \n                   constraints={'type': 'ineq', 'fun': constraints},\n                   options=opts)\n    \n    if res.success:\n        return res.x[:2*n].reshape((n, 2)), res.x[2*n:]\n    return c_init, r_init\n\ndef construct_packing():\n    n = 26\n    # 1. Improved Initial Layout (Staggered Grid)\n    rows, cols = 5, 5\n    x = np.linspace(0.1, 0.9, cols)\n    y = np.linspace(0.1, 0.9, rows)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.flatten(), yv.flatten()], axis=1)\n    centers = np.vstack([centers, [0.5, 0.5]])[:n]\n    \n    # Jitter to break symmetry\n    centers += np.random.normal(0, 0.01, centers.shape)\n    centers = np.clip(centers, 0.1, 0.9)\n    \n    radii = solve_radii_lp(centers)\n    best_c, best_r = refine_slsqp(centers, radii, n)\n    best_sum = np.sum(best_r)\n\n    # 2. Coordinate Descent / Local Grid Search Refinement\n    for _ in range(3): # Outer loops of refinement\n        improved = False\n        for i in range(n):\n            current_pos = np.copy(best_c[i])\n            # Search in a small 5x5 grid around current center\n            step_size = 0.01\n            grid_range = np.linspace(-step_size, step_size, 5)\n            \n            local_best_pos = current_pos\n            local_best_sum = best_sum\n            \n            for dx in grid_range:\n                for dy in grid_range:\n                    test_centers = np.copy(best_c)\n                    test_centers[i] = np.clip(current_pos + [dx, dy], 0.0, 1.0)\n                    test_radii = solve_radii_lp(test_centers)\n                    test_sum = np.sum(test_radii)\n                    \n                    if test_sum > local_best_sum + 1e-6:\n                        local_best_sum = test_sum\n                        local_best_pos = test_centers[i]\n                        improved = True\n            \n            if improved:\n                best_c[i] = local_best_pos\n                best_r = solve_radii_lp(best_c)\n                best_sum = np.sum(best_r)\n        \n        # Intermediate SLSQP to polish the grid search gains\n        best_c, best_r = refine_slsqp(best_c, best_r, n, high_precision=False)\n        best_sum = np.sum(best_r)\n        if not improved: break\n\n    # Final High Precision Polish\n    final_c, final_r = refine_slsqp(best_c, best_r, n, high_precision=True)\n    # Ensure strict feasibility\n    final_r = solve_radii_lp(final_c)\n    \n    return final_c, final_r, np.sum(final_r)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.621719112727447,
    "eval_time": 1.7551259994506836,
    "error": null
  },
  "prompt": "Implement a 'Coordinate Descent' refinement on top of trial_8_0.\n{{import numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_radii_lp(centers):\n    \"\"\"Calculates maximal radii for fixed centers using Linear Programming.\"\"\"\n    n = len(centers)\n    # Objective: Maximize sum of radii\n    c_obj = -np.ones(n)\n    \n    # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, etc.\n    bounds_r = []\n    for i in range(n):\n        max_possible = np.min([centers[i, 0], 1.0 - centers[i, 0], centers[i, 1], 1.0 - centers[i, 1]])\n        bounds_r.append((0, max(1e-9, max_possible)))\n    \n    # Pairwise distance constraints: r_i + r_j <= dist(c_i, c_j)\n    A_ub = []\n    b_ub = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            dist = np.linalg.norm(centers[i] - centers[j])\n            A_ub.append(row)\n            b_ub.append(dist)\n    \n    res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds_r, method='highs')\n    if res.success:\n        return res.x\n    return np.full(n, 1e-9)\n\ndef construct_packing():\n    n = 26\n    # Initial Layout: 5x5 grid + 1 extra\n    side = 5\n    x = np.linspace(0.15, 0.85, side)\n    y = np.linspace(0.15, 0.85, side)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.flatten(), yv.flatten()], axis=1)\n    centers = np.vstack([centers, [0.5, 0.5]])[:n]\n    \n    def lloyd_step(c, iterations=20):\n        for _ in range(iterations):\n            for i in range(n):\n                diffs = c - c[i]\n                dists = np.linalg.norm(diffs, axis=1)\n                dists[i] = np.inf\n                nearest = np.argmin(dists)\n                if dists[nearest] < 0.18:\n                    force = diffs[nearest] / (dists[nearest]**2 + 1e-4)\n                    c[i] -= 0.01 * force\n            c = np.clip(c, 0.02, 0.98)\n        return c\n\n    def refine_slsqp(c_init, r_init, epsilon, high_precision=False):\n        def objective(params):\n            r = params[2*n:]\n            if high_precision:\n                return -np.sum(r)\n            return -np.sum(r) - epsilon * np.sum(np.log(r + 1e-8))\n\n        def constraints(params):\n            c = params[:2*n].reshape((n, 2))\n            r = params[2*n:]\n            cons = []\n            # Boundaries: c - r >= 0 and c + r <= 1\n            cons.extend(c.flatten() - r.repeat(2))\n            cons.extend(1.0 - (c.flatten() + r.repeat(2)))\n            # No overlap: dist^2 - (r1+r2)^2 >= 0\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist_sq = np.sum((c[i] - c[j])**2)\n                    cons.append(dist_sq - (r[i] + r[j])**2)\n            return np.array(cons)\n\n        x0 = np.concatenate([c_init.flatten(), r_init])\n        opts = {'maxiter': 2000, 'ftol': 1e-15} if high_precision else {'maxiter': 60, 'disp': False}\n        res = minimize(objective, x0, method='SLSQP', \n                       constraints={'type': 'ineq', 'fun': constraints},\n                       options=opts)\n        \n        if res.success:\n            return res.x[:2*n].reshape((n, 2)), res.x[2*n:]\n        return c_init, r_init\n\n    # Optimization Loop variables\n    best_c = centers\n    best_r = solve_radii_lp(centers)\n    best_sum = np.sum(best_r)\n    curr_c, curr_r = np.copy(best_c), np.copy(best_r)\n    epsilon = 0.1\n\n    # Basin Hopping\n    for _ in range(150):\n        temp_c = np.copy(curr_c)\n        prob = np.random.rand()\n        \n        if prob < 0.5: # Move 2 smallest\n            idx = np.argsort(curr_r)[:2]\n            temp_c[idx] = np.random.rand(2, 2) * 0.8 + 0.1\n        elif prob < 0.8: # Move 1 random\n            idx = np.random.randint(0, n)\n            temp_c[idx] = np.random.rand(2) * 0.8 + 0.1\n        else: # Swap largest and smallest\n            i_min, i_max = np.argmin(curr_r), np.argmax(curr_r)\n            temp_c[i_min], temp_c[i_max] = temp_c[i_max].copy(), temp_c[i_min].copy()\n            \n        temp_c = lloyd_step(temp_c, 15)\n        temp_r = solve_radii_lp(temp_c)\n        temp_c, temp_r = refine_slsqp(temp_c, temp_r, epsilon)\n        temp_sum = np.sum(temp_r)\n        \n        if temp_sum > best_sum:\n            best_sum = temp_sum\n            best_c, best_r = np.copy(temp_c), np.copy(temp_r)\n            curr_c, curr_r = np.copy(temp_c), np.copy(temp_r)\n            epsilon *= 0.5 # Cooling schedule\n        elif temp_sum > best_sum * 0.95:\n            curr_c, curr_r = np.copy(temp_c), np.copy(temp_r)\n\n    # Final Polish\n    final_c, final_r = refine_slsqp(best_c, best_r, 0, high_precision=True)\n    \n    # Final validation and feasibility fix\n    final_r = solve_radii_lp(final_c)\n    final_sum = np.sum(final_r)\n    \n    return final_c, final_r, final_sum\n\ndef run_packing():\n    return construct_packing()}}\n\n1. Take the best result from trial_8_0.\n2. For each circle individually (1 to 26), try to move its center in a small 10x10 local grid to see if its radius (and thus the total sum, after adjusting neighbors) can be increased.\n3. If an improvement is found, update the center and immediately run a quick SLSQP refinement.\n4. This 'greedy local search' can often find small improvements that gradient-based methods miss when many constraints are active simultaneously.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_radii_lp(centers):\n    \"\"\"Calculates maximal radii for fixed centers using Linear Programming.\"\"\"\n    n = len(centers)\n    # Objective: Maximize sum of radii\n    c_obj = -np.ones(n)\n    \n    # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, etc.\n    bounds_r = []\n    for i in range(n):\n        max_possible = np.min([centers[i, 0], 1.0 - centers[i, 0], centers[i, 1], 1.0 - centers[i, 1]])\n        bounds_r.append((0, max(1e-9, max_possible)))\n    \n    # Pairwise distance constraints: r_i + r_j <= dist(c_i, c_j)\n    A_ub = []\n    b_ub = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            dist = np.linalg.norm(centers[i] - centers[j])\n            A_ub.append(row)\n            b_ub.append(dist)\n    \n    res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds_r, method='highs')\n    if res.success:\n        return res.x\n    return np.full(n, 1e-9)\n\ndef refine_slsqp(c_init, r_init, n, high_precision=False):\n    def objective(params):\n        r = params[2*n:]\n        return -np.sum(r)\n\n    def constraints(params):\n        c = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        cons = []\n        # Boundaries\n        cons.extend(c.flatten() - r.repeat(2))\n        cons.extend(1.0 - (c.flatten() + r.repeat(2)))\n        # No overlap\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((c[i] - c[j])**2))\n                cons.append(dist - (r[i] + r[j]))\n        return np.array(cons)\n\n    x0 = np.concatenate([c_init.flatten(), r_init])\n    opts = {'maxiter': 100, 'ftol': 1e-9} if high_precision else {'maxiter': 30}\n    res = minimize(objective, x0, method='SLSQP', \n                   constraints={'type': 'ineq', 'fun': constraints},\n                   options=opts)\n    \n    if res.success:\n        return res.x[:2*n].reshape((n, 2)), res.x[2*n:]\n    return c_init, r_init\n\ndef construct_packing():\n    n = 26\n    # 1. Improved Initial Layout (Staggered Grid)\n    rows, cols = 5, 5\n    x = np.linspace(0.1, 0.9, cols)\n    y = np.linspace(0.1, 0.9, rows)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.flatten(), yv.flatten()], axis=1)\n    centers = np.vstack([centers, [0.5, 0.5]])[:n]\n    \n    # Jitter to break symmetry\n    centers += np.random.normal(0, 0.01, centers.shape)\n    centers = np.clip(centers, 0.1, 0.9)\n    \n    radii = solve_radii_lp(centers)\n    best_c, best_r = refine_slsqp(centers, radii, n)\n    best_sum = np.sum(best_r)\n\n    # 2. Coordinate Descent / Local Grid Search Refinement\n    for _ in range(3): # Outer loops of refinement\n        improved = False\n        for i in range(n):\n            current_pos = np.copy(best_c[i])\n            # Search in a small 5x5 grid around current center\n            step_size = 0.01\n            grid_range = np.linspace(-step_size, step_size, 5)\n            \n            local_best_pos = current_pos\n            local_best_sum = best_sum\n            \n            for dx in grid_range:\n                for dy in grid_range:\n                    test_centers = np.copy(best_c)\n                    test_centers[i] = np.clip(current_pos + [dx, dy], 0.0, 1.0)\n                    test_radii = solve_radii_lp(test_centers)\n                    test_sum = np.sum(test_radii)\n                    \n                    if test_sum > local_best_sum + 1e-6:\n                        local_best_sum = test_sum\n                        local_best_pos = test_centers[i]\n                        improved = True\n            \n            if improved:\n                best_c[i] = local_best_pos\n                best_r = solve_radii_lp(best_c)\n                best_sum = np.sum(best_r)\n        \n        # Intermediate SLSQP to polish the grid search gains\n        best_c, best_r = refine_slsqp(best_c, best_r, n, high_precision=False)\n        best_sum = np.sum(best_r)\n        if not improved: break\n\n    # Final High Precision Polish\n    final_c, final_r = refine_slsqp(best_c, best_r, n, high_precision=True)\n    # Ensure strict feasibility\n    final_r = solve_radii_lp(final_c)\n    \n    return final_c, final_r, np.sum(final_r)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T22:27:42.228794",
  "cost_data": null
}