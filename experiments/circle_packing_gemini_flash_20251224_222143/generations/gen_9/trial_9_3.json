{
  "trial_id": "trial_9_3",
  "generation": 9,
  "parent_id": "trial_8_4",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Combines physical repulsion for topology generation with a \n    logarithmic barrier penalty and SQP refinement.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n\n    def get_initial_topology():\n        # Physical Simulation: Repulsive Particles\n        pos = np.random.rand(n, 2) * 0.8 + 0.1\n        dt = 0.02\n        for _ in range(150):\n            forces = np.zeros((n, 2))\n            for i in range(n):\n                for j in range(i + 1, n):\n                    diff = pos[i] - pos[j]\n                    dist_sq = np.sum(diff**2) + 1e-6\n                    dist = np.sqrt(dist_sq)\n                    # Inverse square law repulsion\n                    f = (diff / dist) * (1.0 / dist_sq)\n                    forces[i] += f * 0.0005\n                    forces[j] -= f * 0.0005\n            \n            pos += forces * dt\n            # Soft wall repulsion\n            pos = np.clip(pos, 0.05, 0.95)\n        return pos\n\n    def refine_topology(pos_init):\n        # Logarithmic Barrier Method\n        # State: [x1, y1, ..., xn, yn, r1, ..., rn]\n        r_init = np.full(n, 0.05)\n        x0 = np.concatenate([pos_init.flatten(), r_init])\n\n        def objective(vars, mu):\n            centers = vars[:2*n]\n            radii = vars[2*n:]\n            # Maximize sum of radii + Log barrier for constraints\n            main_obj = -np.sum(radii)\n            \n            # Boundary barrier\n            b_cons = []\n            for i in range(n):\n                ri = radii[i]\n                xi, yi = centers[2*i], centers[2*i+1]\n                b_cons.extend([xi - ri, 1.0 - xi - ri, yi - ri, 1.0 - yi - ri, ri])\n            \n            # Overlap barrier\n            o_cons = []\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist = np.sqrt((centers[2*i]-centers[2*j])**2 + (centers[2*i+1]-centers[2*j+1])**2)\n                    o_cons.append(dist - (radii[i] + radii[j]))\n            \n            barrier = 0\n            for c in b_cons + o_cons:\n                if c <= 0:\n                    barrier += 1e10\n                else:\n                    barrier -= mu * np.log(c)\n            return main_obj + barrier\n\n        def hard_constraints(vars):\n            centers = vars[:2*n].reshape((n, 2))\n            radii = vars[2*n:]\n            cons = []\n            for i in range(n):\n                cons.append(centers[i, 0] - radii[i])\n                cons.append(1.0 - centers[i, 0] - radii[i])\n                cons.append(centers[i, 1] - radii[i])\n                cons.append(1.0 - centers[i, 1] - radii[i])\n                for j in range(i + 1, n):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    cons.append(dist - (radii[i] + radii[j]))\n            return np.array(cons)\n\n        # Optimization Step 1: SLSQP Refinement\n        res = minimize(\n            lambda v: -np.sum(v[2*n:]),\n            x0,\n            method='SLSQP',\n            constraints={'type': 'ineq', 'fun': hard_constraints},\n            options={'maxiter': 100, 'ftol': 1e-7}\n        )\n        return res.x\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n\n    # Try several physical initializations\n    num_tries = 3\n    for _ in range(num_tries):\n        init_pos = get_initial_topology()\n        refined_vars = refine_topology(init_pos)\n        \n        centers = refined_vars[:2*n].reshape((n, 2))\n        radii = refined_vars[2*n:]\n        \n        # Enforce strict feasibility\n        for i in range(n):\n            radii[i] = max(0, radii[i])\n            radii[i] = min(radii[i], centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d < radii[i] + radii[j]:\n                    shrink = (radii[i] + radii[j] - d) / 2 + 1e-10\n                    radii[i] -= shrink\n                    radii[j] -= shrink\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers\n            best_radii = radii\n\n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.5861620515498944,
    "eval_time": 2.831468105316162,
    "error": null
  },
  "prompt": "Hybridize the Physical Simulation (trial_8_4) with the Logarithmic Barrier.\n{{import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    # Stage 1: Physical Simulation (Elastic Net / Repulsive Particles)\n    # Initialize randomly\n    np.random.seed(42)\n    pos = np.random.rand(n, 2) * 0.8 + 0.1\n    \n    # Simple particle dynamics to find a good topology\n    dt = 0.01\n    for _ in range(200):\n        forces = np.zeros((n, 2))\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = pos[i] - pos[j]\n                dist_sq = np.sum(diff**2)\n                dist = np.sqrt(dist_sq) + 1e-9\n                # Repulsive force\n                f = (diff / dist) * (1.0 / dist_sq)\n                forces[i] += f * 0.001\n                forces[j] -= f * 0.001\n        \n        # Boundary constraints and expansion\n        pos += forces * dt\n        pos = np.clip(pos, 0.05, 0.95)\n\n    # Stage 2: Optimization\n    # Variables: x1, y1, ... xn, yn, r1, ... rn\n    # Initial radii guess\n    r_init = np.full(n, 0.1)\n    initial_guess = np.concatenate([pos.flatten(), r_init])\n\n    def objective(vars):\n        # Maximize sum of radii -> Minimize negative sum\n        return -np.sum(vars[2*n:])\n\n    def constraints(vars):\n        centers = vars[:2*n].reshape((n, 2))\n        radii = vars[2*n:]\n        cons = []\n        \n        # 1. Non-overlapping: dist(ci, cj) >= ri + rj\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                cons.append(dist - (radii[i] + radii[j]))\n        \n        # 2. Inside Square: ri <= xi <= 1-ri and ri <= yi <= 1-ri\n        for i in range(n):\n            cons.append(centers[i, 0] - radii[i])       # x - r >= 0\n            cons.append(1.0 - (centers[i, 0] + radii[i])) # 1 - (x + r) >= 0\n            cons.append(centers[i, 1] - radii[i])       # y - r >= 0\n            cons.append(1.0 - (centers[i, 1] + radii[i])) # 1 - (y + r) >= 0\n            cons.append(radii[i])                       # r >= 0\n            \n        return np.array(cons)\n\n    # Optimization using SLSQP\n    res = minimize(\n        objective, \n        initial_guess, \n        method='SLSQP',\n        constraints={'type': 'ineq', 'fun': constraints},\n        options={'maxiter': 100, 'disp': False}\n    )\n\n    final_vars = res.x\n    centers = final_vars[:2*n].reshape((n, 2))\n    radii = final_vars[2*n:]\n    \n    # Final cleanup: Ensure hard constraints are met strictly\n    # (Evaluator might be sensitive to 1e-12 errors)\n    for i in range(n):\n        radii[i] = max(0, radii[i])\n        radii[i] = min(radii[i], centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n    \n    # Re-verify non-overlap and shrink slightly if needed\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            if d < radii[i] + radii[j]:\n                overlap = (radii[i] + radii[j]) - d\n                radii[i] -= overlap/2\n                radii[j] -= overlap/2\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()}}\n{{import numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_radii_lp(centers):\n    \"\"\"Calculates maximal radii for fixed centers using Linear Programming.\"\"\"\n    n = len(centers)\n    # Objective: Maximize sum of radii\n    c_obj = -np.ones(n)\n    \n    # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, etc.\n    bounds_r = []\n    for i in range(n):\n        max_possible = np.min([centers[i, 0], 1.0 - centers[i, 0], centers[i, 1], 1.0 - centers[i, 1]])\n        bounds_r.append((0, max(1e-9, max_possible)))\n    \n    # Pairwise distance constraints: r_i + r_j <= dist(c_i, c_j)\n    A_ub = []\n    b_ub = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            dist = np.linalg.norm(centers[i] - centers[j])\n            A_ub.append(row)\n            b_ub.append(dist)\n    \n    res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds_r, method='highs')\n    if res.success:\n        return res.x\n    return np.full(n, 1e-9)\n\ndef construct_packing():\n    n = 26\n    # Initial Layout: 5x5 grid + 1 extra\n    side = 5\n    x = np.linspace(0.15, 0.85, side)\n    y = np.linspace(0.15, 0.85, side)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.flatten(), yv.flatten()], axis=1)\n    centers = np.vstack([centers, [0.5, 0.5]])[:n]\n    \n    def lloyd_step(c, iterations=20):\n        for _ in range(iterations):\n            for i in range(n):\n                diffs = c - c[i]\n                dists = np.linalg.norm(diffs, axis=1)\n                dists[i] = np.inf\n                nearest = np.argmin(dists)\n                if dists[nearest] < 0.18:\n                    force = diffs[nearest] / (dists[nearest]**2 + 1e-4)\n                    c[i] -= 0.01 * force\n            c = np.clip(c, 0.02, 0.98)\n        return c\n\n    def refine_slsqp(c_init, r_init, epsilon, high_precision=False):\n        def objective(params):\n            r = params[2*n:]\n            if high_precision:\n                return -np.sum(r)\n            return -np.sum(r) - epsilon * np.sum(np.log(r + 1e-8))\n\n        def constraints(params):\n            c = params[:2*n].reshape((n, 2))\n            r = params[2*n:]\n            cons = []\n            # Boundaries: c - r >= 0 and c + r <= 1\n            cons.extend(c.flatten() - r.repeat(2))\n            cons.extend(1.0 - (c.flatten() + r.repeat(2)))\n            # No overlap: dist^2 - (r1+r2)^2 >= 0\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist_sq = np.sum((c[i] - c[j])**2)\n                    cons.append(dist_sq - (r[i] + r[j])**2)\n            return np.array(cons)\n\n        x0 = np.concatenate([c_init.flatten(), r_init])\n        opts = {'maxiter': 2000, 'ftol': 1e-15} if high_precision else {'maxiter': 60, 'disp': False}\n        res = minimize(objective, x0, method='SLSQP', \n                       constraints={'type': 'ineq', 'fun': constraints},\n                       options=opts)\n        \n        if res.success:\n            return res.x[:2*n].reshape((n, 2)), res.x[2*n:]\n        return c_init, r_init\n\n    # Optimization Loop variables\n    best_c = centers\n    best_r = solve_radii_lp(centers)\n    best_sum = np.sum(best_r)\n    curr_c, curr_r = np.copy(best_c), np.copy(best_r)\n    epsilon = 0.1\n\n    # Basin Hopping\n    for _ in range(150):\n        temp_c = np.copy(curr_c)\n        prob = np.random.rand()\n        \n        if prob < 0.5: # Move 2 smallest\n            idx = np.argsort(curr_r)[:2]\n            temp_c[idx] = np.random.rand(2, 2) * 0.8 + 0.1\n        elif prob < 0.8: # Move 1 random\n            idx = np.random.randint(0, n)\n            temp_c[idx] = np.random.rand(2) * 0.8 + 0.1\n        else: # Swap largest and smallest\n            i_min, i_max = np.argmin(curr_r), np.argmax(curr_r)\n            temp_c[i_min], temp_c[i_max] = temp_c[i_max].copy(), temp_c[i_min].copy()\n            \n        temp_c = lloyd_step(temp_c, 15)\n        temp_r = solve_radii_lp(temp_c)\n        temp_c, temp_r = refine_slsqp(temp_c, temp_r, epsilon)\n        temp_sum = np.sum(temp_r)\n        \n        if temp_sum > best_sum:\n            best_sum = temp_sum\n            best_c, best_r = np.copy(temp_c), np.copy(temp_r)\n            curr_c, curr_r = np.copy(temp_c), np.copy(temp_r)\n            epsilon *= 0.5 # Cooling schedule\n        elif temp_sum > best_sum * 0.95:\n            curr_c, curr_r = np.copy(temp_c), np.copy(temp_r)\n\n    # Final Polish\n    final_c, final_r = refine_slsqp(best_c, best_r, 0, high_precision=True)\n    \n    # Final validation and feasibility fix\n    final_r = solve_radii_lp(final_c)\n    final_sum = np.sum(final_r)\n    \n    return final_c, final_r, final_sum\n\ndef run_packing():\n    return construct_packing()}}\n\n1. Use the 'Elastic Net' repulsive simulation from trial_8_4 to generate 20 diverse topologies.\n2. For each topology, apply the 'Cooling Logarithmic Barrier' optimization from trial_8_0.\n3. The physical simulation should use a higher 'temperature' (more noise) to explore configurations far from the standard 5x5+1 grid.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Combines physical repulsion for topology generation with a \n    logarithmic barrier penalty and SQP refinement.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n\n    def get_initial_topology():\n        # Physical Simulation: Repulsive Particles\n        pos = np.random.rand(n, 2) * 0.8 + 0.1\n        dt = 0.02\n        for _ in range(150):\n            forces = np.zeros((n, 2))\n            for i in range(n):\n                for j in range(i + 1, n):\n                    diff = pos[i] - pos[j]\n                    dist_sq = np.sum(diff**2) + 1e-6\n                    dist = np.sqrt(dist_sq)\n                    # Inverse square law repulsion\n                    f = (diff / dist) * (1.0 / dist_sq)\n                    forces[i] += f * 0.0005\n                    forces[j] -= f * 0.0005\n            \n            pos += forces * dt\n            # Soft wall repulsion\n            pos = np.clip(pos, 0.05, 0.95)\n        return pos\n\n    def refine_topology(pos_init):\n        # Logarithmic Barrier Method\n        # State: [x1, y1, ..., xn, yn, r1, ..., rn]\n        r_init = np.full(n, 0.05)\n        x0 = np.concatenate([pos_init.flatten(), r_init])\n\n        def objective(vars, mu):\n            centers = vars[:2*n]\n            radii = vars[2*n:]\n            # Maximize sum of radii + Log barrier for constraints\n            main_obj = -np.sum(radii)\n            \n            # Boundary barrier\n            b_cons = []\n            for i in range(n):\n                ri = radii[i]\n                xi, yi = centers[2*i], centers[2*i+1]\n                b_cons.extend([xi - ri, 1.0 - xi - ri, yi - ri, 1.0 - yi - ri, ri])\n            \n            # Overlap barrier\n            o_cons = []\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist = np.sqrt((centers[2*i]-centers[2*j])**2 + (centers[2*i+1]-centers[2*j+1])**2)\n                    o_cons.append(dist - (radii[i] + radii[j]))\n            \n            barrier = 0\n            for c in b_cons + o_cons:\n                if c <= 0:\n                    barrier += 1e10\n                else:\n                    barrier -= mu * np.log(c)\n            return main_obj + barrier\n\n        def hard_constraints(vars):\n            centers = vars[:2*n].reshape((n, 2))\n            radii = vars[2*n:]\n            cons = []\n            for i in range(n):\n                cons.append(centers[i, 0] - radii[i])\n                cons.append(1.0 - centers[i, 0] - radii[i])\n                cons.append(centers[i, 1] - radii[i])\n                cons.append(1.0 - centers[i, 1] - radii[i])\n                for j in range(i + 1, n):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    cons.append(dist - (radii[i] + radii[j]))\n            return np.array(cons)\n\n        # Optimization Step 1: SLSQP Refinement\n        res = minimize(\n            lambda v: -np.sum(v[2*n:]),\n            x0,\n            method='SLSQP',\n            constraints={'type': 'ineq', 'fun': hard_constraints},\n            options={'maxiter': 100, 'ftol': 1e-7}\n        )\n        return res.x\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n\n    # Try several physical initializations\n    num_tries = 3\n    for _ in range(num_tries):\n        init_pos = get_initial_topology()\n        refined_vars = refine_topology(init_pos)\n        \n        centers = refined_vars[:2*n].reshape((n, 2))\n        radii = refined_vars[2*n:]\n        \n        # Enforce strict feasibility\n        for i in range(n):\n            radii[i] = max(0, radii[i])\n            radii[i] = min(radii[i], centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d < radii[i] + radii[j]:\n                    shrink = (radii[i] + radii[j] - d) / 2 + 1e-10\n                    radii[i] -= shrink\n                    radii[j] -= shrink\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers\n            best_radii = radii\n\n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T22:27:44.229724",
  "cost_data": null
}