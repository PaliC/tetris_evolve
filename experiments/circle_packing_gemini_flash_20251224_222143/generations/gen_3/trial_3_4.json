{
  "trial_id": "trial_3_4",
  "generation": 3,
  "parent_id": "trial_1_2",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses a 'Circle Swapping' meta-heuristic combined with SLSQP optimization\n    to maximize the sum of radii.\n    \"\"\"\n    n = 26\n    \n    # 1. Initial Guess: 5x5 grid + 1 extra\n    side = 5\n    x = np.linspace(0.12, 0.88, side)\n    y = np.linspace(0.12, 0.88, side)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.ravel(), yv.ravel()], axis=1)\n    # Add the 26th circle\n    extra_circle = np.array([[0.5, 0.5]])\n    centers = np.vstack([centers, extra_circle])\n    radii = np.full(n, 1.0 / (2 * side))\n    \n    def get_objective(params):\n        r = params[2*n:]\n        return -np.sum(r)\n\n    def get_constraints(params):\n        c = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        \n        num_overlap = n * (n - 1) // 2\n        cons = np.zeros(4 * n + num_overlap)\n        \n        idx = 0\n        # Boundary constraints: c - r >= 0 and c + r <= 1\n        for i in range(n):\n            cons[idx] = c[i, 0] - r[i]\n            cons[idx+1] = 1.0 - (c[i, 0] + r[i])\n            cons[idx+2] = c[i, 1] - r[i]\n            cons[idx+3] = 1.0 - (c[i, 1] + r[i])\n            idx += 4\n            \n        # Non-overlapping: dist - (r_i + r_j) >= 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((c[i] - c[j])**2) + 1e-12)\n                cons[idx] = dist - (r[i] + r[j])\n                idx += 1\n        return cons\n\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n\n    def optimize_layout(current_centers, current_radii, iterations=60):\n        init_p = np.concatenate([current_centers.flatten(), current_radii])\n        res = minimize(\n            get_objective, \n            init_p, \n            method='SLSQP', \n            bounds=bounds,\n            constraints={'type': 'ineq', 'fun': get_constraints},\n            options={'maxiter': iterations, 'ftol': 1e-6}\n        )\n        p = res.x\n        return p[:2*n].reshape((n, 2)), p[2*n:], -res.fun\n\n    # Initial optimization\n    centers, radii, best_sum = optimize_layout(centers, radii, iterations=100)\n\n    # 2. Meta-heuristic: Circle Swapping\n    # We perform a few swaps to try and escape local minima\n    for _ in range(5):\n        # Pick two random indices to swap\n        idx1, idx2 = np.random.choice(n, 2, replace=False)\n        new_centers = centers.copy()\n        new_centers[[idx1, idx2]] = new_centers[[idx2, idx1]]\n        \n        # Quick optimization to see if swap is promising\n        temp_centers, temp_radii, temp_sum = optimize_layout(new_centers, radii, iterations=40)\n        \n        if temp_sum > best_sum:\n            centers, radii, best_sum = temp_centers, temp_radii, temp_sum\n\n    # Final Polishing\n    centers, radii, best_sum = optimize_layout(centers, radii, iterations=150)\n\n    # --- Post-processing: Rigorous Feasibility Enforcement ---\n    centers = np.clip(centers, 0, 1)\n    for _ in range(100):\n        changed = False\n        for i in range(n):\n            max_r = min(centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n            if radii[i] > max_r:\n                radii[i] = max_r\n                changed = True\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < (radii[i] + radii[j]):\n                    overlap = (radii[i] + radii[j]) - dist\n                    shrink = overlap / 2.0 + 1e-12\n                    radii[i] -= shrink\n                    radii[j] -= shrink\n                    changed = True\n        if not changed:\n            break\n\n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.520922557696783,
    "eval_time": 11.412139177322388,
    "error": null
  },
  "prompt": "Try a 'Circle Swapping' meta-heuristic on the best configuration.\n1. Take the final centers from {{import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses a combination of a grid-based start and SLSQP optimization\n    to maximize the sum of radii while ensuring non-overlap and \n    boundary constraints.\n    \"\"\"\n    n = 26\n    \n    # 1. Improved Initial Guess: 5x5 grid + 1 extra\n    # We use a slightly jittered grid to break symmetry early.\n    side = 5\n    x = np.linspace(0.15, 0.85, side)\n    y = np.linspace(0.15, 0.85, side)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.ravel(), yv.ravel()], axis=1)\n    # Add the 26th circle near the center with a small offset\n    extra_circle = np.array([[0.51, 0.51]])\n    centers = np.vstack([centers, extra_circle])\n    \n    # Initial radii: slightly smaller than the grid gap\n    radii = np.full(n, 1.0 / (2 * side))\n    \n    # Flatten parameters: [x0, y0, ..., xn, yn, r0, ..., rn]\n    initial_params = np.concatenate([centers.flatten(), radii])\n\n    def objective(params):\n        # Maximize sum(radii) -> Minimize -sum(radii)\n        # We also add a very small penalty for large radii variance to \n        # encourage all circles to grow, which helps the solver early on.\n        r = params[2*n:]\n        return -np.sum(r)\n\n    def constraints(params):\n        c = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        \n        # Pre-allocate constraint array\n        # 4 boundary per circle + n*(n-1)/2 overlap\n        num_overlap = n * (n - 1) // 2\n        cons = np.zeros(4 * n + num_overlap)\n        \n        idx = 0\n        # Boundary constraints: c - r >= 0 and c + r <= 1\n        for i in range(n):\n            cons[idx] = c[i, 0] - r[i]\n            cons[idx+1] = 1.0 - (c[i, 0] + r[i])\n            cons[idx+2] = c[i, 1] - r[i]\n            cons[idx+3] = 1.0 - (c[i, 1] + r[i])\n            idx += 4\n            \n        # Non-overlapping: dist - (r_i + r_j) >= 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Use squared distance for smoother gradients if possible, \n                # but standard norm is clearer for SLSQP.\n                dist = np.sqrt(np.sum((c[i] - c[j])**2) + 1e-12)\n                cons[idx] = dist - (r[i] + r[j])\n                idx += 1\n        return cons\n\n    # Bounds: Centers in [0, 1], Radii in [0.001, 0.5]\n    bounds = [(0, 1)] * (2 * n) + [(0.001, 0.5)] * n\n\n    # Optimization\n    res = minimize(\n        objective, \n        initial_params, \n        method='SLSQP', \n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraints},\n        options={'maxiter': 150, 'ftol': 1e-7, 'disp': False}\n    )\n\n    final_params = res.x\n    centers = final_params[:2*n].reshape((n, 2))\n    radii = final_params[2*n:]\n    \n    # --- Post-processing: Rigorous Feasibility Enforcement ---\n    # 1. Clamp centers to [0,1]\n    centers = np.clip(centers, 0, 1)\n    \n    # 2. Iteratively shrink radii to satisfy all constraints exactly\n    for _ in range(50):\n        changed = False\n        # Boundary check\n        for i in range(n):\n            max_r = min(centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n            if radii[i] > max_r:\n                radii[i] = max_r\n                changed = True\n        \n        # Overlap check\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j]:\n                    overlap = (radii[i] + radii[j]) - dist\n                    # Reduce radii slightly more than half overlap to ensure separation\n                    shrink = overlap / 2.0 + 1e-10\n                    radii[i] -= shrink\n                    radii[j] -= shrink\n                    changed = True\n        if not changed:\n            break\n\n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()}}.\n2. Implement a loop: \n   a. Randomly select two circles and swap their (x, y) coordinates.\n   b. Run a quick SLSQP optimization.\n   c. If the sum of radii is better than the previous best, keep the swap. Otherwise, revert.\n3. This helps explore different topological arrangements of the same circles.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses a 'Circle Swapping' meta-heuristic combined with SLSQP optimization\n    to maximize the sum of radii.\n    \"\"\"\n    n = 26\n    \n    # 1. Initial Guess: 5x5 grid + 1 extra\n    side = 5\n    x = np.linspace(0.12, 0.88, side)\n    y = np.linspace(0.12, 0.88, side)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.ravel(), yv.ravel()], axis=1)\n    # Add the 26th circle\n    extra_circle = np.array([[0.5, 0.5]])\n    centers = np.vstack([centers, extra_circle])\n    radii = np.full(n, 1.0 / (2 * side))\n    \n    def get_objective(params):\n        r = params[2*n:]\n        return -np.sum(r)\n\n    def get_constraints(params):\n        c = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        \n        num_overlap = n * (n - 1) // 2\n        cons = np.zeros(4 * n + num_overlap)\n        \n        idx = 0\n        # Boundary constraints: c - r >= 0 and c + r <= 1\n        for i in range(n):\n            cons[idx] = c[i, 0] - r[i]\n            cons[idx+1] = 1.0 - (c[i, 0] + r[i])\n            cons[idx+2] = c[i, 1] - r[i]\n            cons[idx+3] = 1.0 - (c[i, 1] + r[i])\n            idx += 4\n            \n        # Non-overlapping: dist - (r_i + r_j) >= 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((c[i] - c[j])**2) + 1e-12)\n                cons[idx] = dist - (r[i] + r[j])\n                idx += 1\n        return cons\n\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n\n    def optimize_layout(current_centers, current_radii, iterations=60):\n        init_p = np.concatenate([current_centers.flatten(), current_radii])\n        res = minimize(\n            get_objective, \n            init_p, \n            method='SLSQP', \n            bounds=bounds,\n            constraints={'type': 'ineq', 'fun': get_constraints},\n            options={'maxiter': iterations, 'ftol': 1e-6}\n        )\n        p = res.x\n        return p[:2*n].reshape((n, 2)), p[2*n:], -res.fun\n\n    # Initial optimization\n    centers, radii, best_sum = optimize_layout(centers, radii, iterations=100)\n\n    # 2. Meta-heuristic: Circle Swapping\n    # We perform a few swaps to try and escape local minima\n    for _ in range(5):\n        # Pick two random indices to swap\n        idx1, idx2 = np.random.choice(n, 2, replace=False)\n        new_centers = centers.copy()\n        new_centers[[idx1, idx2]] = new_centers[[idx2, idx1]]\n        \n        # Quick optimization to see if swap is promising\n        temp_centers, temp_radii, temp_sum = optimize_layout(new_centers, radii, iterations=40)\n        \n        if temp_sum > best_sum:\n            centers, radii, best_sum = temp_centers, temp_radii, temp_sum\n\n    # Final Polishing\n    centers, radii, best_sum = optimize_layout(centers, radii, iterations=150)\n\n    # --- Post-processing: Rigorous Feasibility Enforcement ---\n    centers = np.clip(centers, 0, 1)\n    for _ in range(100):\n        changed = False\n        for i in range(n):\n            max_r = min(centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n            if radii[i] > max_r:\n                radii[i] = max_r\n                changed = True\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < (radii[i] + radii[j]):\n                    overlap = (radii[i] + radii[j]) - dist\n                    shrink = overlap / 2.0 + 1e-12\n                    radii[i] -= shrink\n                    radii[j] -= shrink\n                    changed = True\n        if not changed:\n            break\n\n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T22:23:33.040623",
  "cost_data": null
}