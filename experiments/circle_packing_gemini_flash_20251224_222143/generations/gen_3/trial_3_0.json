{
  "trial_id": "trial_3_0",
  "generation": 3,
  "parent_id": "trial_1_2",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses multi-start optimization with jittering and high-precision SLSQP.\n    \"\"\"\n    n = 26\n    best_sum_radii = -1.0\n    best_centers = None\n    best_radii = None\n\n    def objective(params):\n        # Maximize sum(radii)\n        r = params[2*n:]\n        return -np.sum(r)\n\n    def constraints(params):\n        c = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        \n        # 4 boundary constraints per circle + n*(n-1)/2 overlap constraints\n        num_overlap = n * (n - 1) // 2\n        cons = np.zeros(4 * n + num_overlap)\n        \n        idx = 0\n        for i in range(n):\n            cons[idx] = c[i, 0] - r[i]\n            cons[idx+1] = 1.0 - (c[i, 0] + r[i])\n            cons[idx+2] = c[i, 1] - r[i]\n            cons[idx+3] = 1.0 - (c[i, 1] + r[i])\n            idx += 4\n            \n        for i in range(n):\n            for j in range(i + 1, n):\n                # Distance constraint: ||ci - cj|| - (ri + rj) >= 0\n                dist = np.sqrt(np.sum((c[i] - c[j])**2) + 1e-15)\n                cons[idx] = dist - (r[i] + r[j])\n                idx += 1\n        return cons\n\n    # Multi-start strategy: 20 initializations\n    num_starts = 20\n    seeds = [\n        # Grid-based seed\n        np.linspace(0.1, 0.9, 5),\n        # Random seeds will be generated in loop\n    ]\n\n    for s in range(num_starts):\n        if s == 0:\n            # 5x5 grid + 1 central circle\n            side = 5\n            x = np.linspace(0.15, 0.85, side)\n            y = np.linspace(0.15, 0.85, side)\n            xv, yv = np.meshgrid(x, y)\n            c_init = np.vstack([np.stack([xv.ravel(), yv.ravel()], axis=1), [0.5, 0.5]])\n        else:\n            # Random uniform initialization\n            c_init = np.random.uniform(0.1, 0.9, (n, 2))\n        \n        r_init = np.full(n, 0.03)\n        params_init = np.concatenate([c_init.flatten(), r_init])\n\n        # Optimization runs: Base and Jittered\n        to_try = [params_init]\n        if s == 0: # Add jitter for the grid start specifically\n            jitter = (np.random.rand(2 * n + n) - 0.5) * 0.001\n            to_try.append(params_init + jitter)\n\n        for p_start in to_try:\n            res = minimize(\n                objective, \n                p_start, \n                method='SLSQP', \n                bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                constraints={'type': 'ineq', 'fun': constraints},\n                options={'maxiter': 2000, 'ftol': 1e-12}\n            )\n\n            if res.success or res.fun < 0:\n                current_sum = -res.fun\n                if current_sum > best_sum_radii:\n                    # Final feasibility check/adjustment\n                    curr_p = res.x\n                    curr_c = curr_p[:2*n].reshape((n, 2))\n                    curr_r = curr_p[2*n:]\n                    \n                    # Strict enforcement\n                    for _ in range(10):\n                        for i in range(n):\n                            curr_r[i] = min(curr_r[i], curr_c[i,0], 1-curr_c[i,0], curr_c[i,1], 1-curr_c[i,1])\n                        for i in range(n):\n                            for j in range(i + 1, n):\n                                d = np.linalg.norm(curr_c[i] - curr_c[j])\n                                if d < curr_r[i] + curr_r[j]:\n                                    diff = (curr_r[i] + curr_r[j] - d) / 2.0 + 1e-14\n                                    curr_r[i] -= diff\n                                    curr_r[j] -= diff\n                    \n                    final_sum = np.sum(curr_r)\n                    if final_sum > best_sum_radii:\n                        best_sum_radii = final_sum\n                        best_centers = curr_c\n                        best_radii = curr_r\n\n    return best_centers, best_radii, best_sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.616609281753822,
    "eval_time": 22.18300485610962,
    "error": null
  },
  "prompt": "The current best algorithm is trial_1_2 with a score of 2.6245. \n{{import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses a combination of a grid-based start and SLSQP optimization\n    to maximize the sum of radii while ensuring non-overlap and \n    boundary constraints.\n    \"\"\"\n    n = 26\n    \n    # 1. Improved Initial Guess: 5x5 grid + 1 extra\n    # We use a slightly jittered grid to break symmetry early.\n    side = 5\n    x = np.linspace(0.15, 0.85, side)\n    y = np.linspace(0.15, 0.85, side)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.ravel(), yv.ravel()], axis=1)\n    # Add the 26th circle near the center with a small offset\n    extra_circle = np.array([[0.51, 0.51]])\n    centers = np.vstack([centers, extra_circle])\n    \n    # Initial radii: slightly smaller than the grid gap\n    radii = np.full(n, 1.0 / (2 * side))\n    \n    # Flatten parameters: [x0, y0, ..., xn, yn, r0, ..., rn]\n    initial_params = np.concatenate([centers.flatten(), radii])\n\n    def objective(params):\n        # Maximize sum(radii) -> Minimize -sum(radii)\n        # We also add a very small penalty for large radii variance to \n        # encourage all circles to grow, which helps the solver early on.\n        r = params[2*n:]\n        return -np.sum(r)\n\n    def constraints(params):\n        c = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        \n        # Pre-allocate constraint array\n        # 4 boundary per circle + n*(n-1)/2 overlap\n        num_overlap = n * (n - 1) // 2\n        cons = np.zeros(4 * n + num_overlap)\n        \n        idx = 0\n        # Boundary constraints: c - r >= 0 and c + r <= 1\n        for i in range(n):\n            cons[idx] = c[i, 0] - r[i]\n            cons[idx+1] = 1.0 - (c[i, 0] + r[i])\n            cons[idx+2] = c[i, 1] - r[i]\n            cons[idx+3] = 1.0 - (c[i, 1] + r[i])\n            idx += 4\n            \n        # Non-overlapping: dist - (r_i + r_j) >= 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Use squared distance for smoother gradients if possible, \n                # but standard norm is clearer for SLSQP.\n                dist = np.sqrt(np.sum((c[i] - c[j])**2) + 1e-12)\n                cons[idx] = dist - (r[i] + r[j])\n                idx += 1\n        return cons\n\n    # Bounds: Centers in [0, 1], Radii in [0.001, 0.5]\n    bounds = [(0, 1)] * (2 * n) + [(0.001, 0.5)] * n\n\n    # Optimization\n    res = minimize(\n        objective, \n        initial_params, \n        method='SLSQP', \n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraints},\n        options={'maxiter': 150, 'ftol': 1e-7, 'disp': False}\n    )\n\n    final_params = res.x\n    centers = final_params[:2*n].reshape((n, 2))\n    radii = final_params[2*n:]\n    \n    # --- Post-processing: Rigorous Feasibility Enforcement ---\n    # 1. Clamp centers to [0,1]\n    centers = np.clip(centers, 0, 1)\n    \n    # 2. Iteratively shrink radii to satisfy all constraints exactly\n    for _ in range(50):\n        changed = False\n        # Boundary check\n        for i in range(n):\n            max_r = min(centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n            if radii[i] > max_r:\n                radii[i] = max_r\n                changed = True\n        \n        # Overlap check\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j]:\n                    overlap = (radii[i] + radii[j]) - dist\n                    # Reduce radii slightly more than half overlap to ensure separation\n                    shrink = overlap / 2.0 + 1e-10\n                    radii[i] -= shrink\n                    radii[j] -= shrink\n                    changed = True\n        if not changed:\n            break\n\n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()}}\n\nImprove this by:\n1. Increasing the number of random multi-start initializations for the Voronoi/Power Diagram phase from 5 to 20.\n2. In the final SLSQP optimization, set `ftol` to 1e-12 and `maxiter` to 2000 for maximum precision.\n3. Add a 'jitter' step: after the Voronoi phase, slightly perturb the centers (by 0.001) and run SLSQP from both the perturbed and unperturbed positions, keeping the best.\n4. Ensure the objective function is exactly the sum of radii.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses multi-start optimization with jittering and high-precision SLSQP.\n    \"\"\"\n    n = 26\n    best_sum_radii = -1.0\n    best_centers = None\n    best_radii = None\n\n    def objective(params):\n        # Maximize sum(radii)\n        r = params[2*n:]\n        return -np.sum(r)\n\n    def constraints(params):\n        c = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        \n        # 4 boundary constraints per circle + n*(n-1)/2 overlap constraints\n        num_overlap = n * (n - 1) // 2\n        cons = np.zeros(4 * n + num_overlap)\n        \n        idx = 0\n        for i in range(n):\n            cons[idx] = c[i, 0] - r[i]\n            cons[idx+1] = 1.0 - (c[i, 0] + r[i])\n            cons[idx+2] = c[i, 1] - r[i]\n            cons[idx+3] = 1.0 - (c[i, 1] + r[i])\n            idx += 4\n            \n        for i in range(n):\n            for j in range(i + 1, n):\n                # Distance constraint: ||ci - cj|| - (ri + rj) >= 0\n                dist = np.sqrt(np.sum((c[i] - c[j])**2) + 1e-15)\n                cons[idx] = dist - (r[i] + r[j])\n                idx += 1\n        return cons\n\n    # Multi-start strategy: 20 initializations\n    num_starts = 20\n    seeds = [\n        # Grid-based seed\n        np.linspace(0.1, 0.9, 5),\n        # Random seeds will be generated in loop\n    ]\n\n    for s in range(num_starts):\n        if s == 0:\n            # 5x5 grid + 1 central circle\n            side = 5\n            x = np.linspace(0.15, 0.85, side)\n            y = np.linspace(0.15, 0.85, side)\n            xv, yv = np.meshgrid(x, y)\n            c_init = np.vstack([np.stack([xv.ravel(), yv.ravel()], axis=1), [0.5, 0.5]])\n        else:\n            # Random uniform initialization\n            c_init = np.random.uniform(0.1, 0.9, (n, 2))\n        \n        r_init = np.full(n, 0.03)\n        params_init = np.concatenate([c_init.flatten(), r_init])\n\n        # Optimization runs: Base and Jittered\n        to_try = [params_init]\n        if s == 0: # Add jitter for the grid start specifically\n            jitter = (np.random.rand(2 * n + n) - 0.5) * 0.001\n            to_try.append(params_init + jitter)\n\n        for p_start in to_try:\n            res = minimize(\n                objective, \n                p_start, \n                method='SLSQP', \n                bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                constraints={'type': 'ineq', 'fun': constraints},\n                options={'maxiter': 2000, 'ftol': 1e-12}\n            )\n\n            if res.success or res.fun < 0:\n                current_sum = -res.fun\n                if current_sum > best_sum_radii:\n                    # Final feasibility check/adjustment\n                    curr_p = res.x\n                    curr_c = curr_p[:2*n].reshape((n, 2))\n                    curr_r = curr_p[2*n:]\n                    \n                    # Strict enforcement\n                    for _ in range(10):\n                        for i in range(n):\n                            curr_r[i] = min(curr_r[i], curr_c[i,0], 1-curr_c[i,0], curr_c[i,1], 1-curr_c[i,1])\n                        for i in range(n):\n                            for j in range(i + 1, n):\n                                d = np.linalg.norm(curr_c[i] - curr_c[j])\n                                if d < curr_r[i] + curr_r[j]:\n                                    diff = (curr_r[i] + curr_r[j] - d) / 2.0 + 1e-14\n                                    curr_r[i] -= diff\n                                    curr_r[j] -= diff\n                    \n                    final_sum = np.sum(curr_r)\n                    if final_sum > best_sum_radii:\n                        best_sum_radii = final_sum\n                        best_centers = curr_c\n                        best_radii = curr_r\n\n    return best_centers, best_radii, best_sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T22:23:44.455307",
  "cost_data": null
}