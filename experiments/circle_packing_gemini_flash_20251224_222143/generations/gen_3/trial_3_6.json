{
  "trial_id": "trial_3_6",
  "generation": 3,
  "parent_id": "trial_1_2",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using PSO\n    followed by SLSQP refinement.\n    \"\"\"\n    n = 26\n    \n    def get_radii(centers_flat):\n        centers = centers_flat.reshape(n, 2)\n        # Distance to boundaries (x, 1-x, y, 1-y)\n        d_bounds = np.minimum(np.minimum(centers[:, 0], 1 - centers[:, 0]),\n                              np.minimum(centers[:, 1], 1 - centers[:, 1]))\n        \n        # Distance between centers\n        # We need to find the radius r_i for each circle such that r_i + r_j <= dist(i, j)\n        # A common simplification for maximizing sum(r) is to assume r_i = r_j = dist/2\n        # But for heterogeneous radii, we solve for r_i subject to r_i + r_j <= d_ij\n        # Here we use a heuristic: r_i is limited by the nearest neighbor or wall.\n        # To keep it simple and valid: all r_i = r (uniform) or greedy assignment.\n        # For this specific objective, we optimize centers and a single global r, \n        # or individual r_i. Let's use individual r_i = min(d_bounds_i, min_j(dist_ij - r_j)).\n        # However, the most robust way to get a valid packing is to use a fixed r \n        # or calculate the maximum possible r for each center given others.\n        \n        # Simplified approach for PSO fitness: \n        # r_i = min (dist_to_wall, min_{j != i} (dist_ij / 2))\n        dist_matrix = np.sqrt(np.sum((centers[:, np.newaxis, :] - centers[np.newaxis, :, :])**2, axis=2))\n        np.fill_diagonal(dist_matrix, np.inf)\n        min_dist_to_others = np.min(dist_matrix, axis=1)\n        radii = np.minimum(d_bounds, min_dist_to_others / 2.0)\n        radii = np.maximum(radii, 0)\n        return radii\n\n    def objective(centers_flat):\n        return -np.sum(get_radii(centers_flat))\n\n    # PSO Parameters\n    num_particles = 20\n    generations = 100\n    w = 0.5  # inertia\n    c1 = 1.5 # cognitive\n    c2 = 1.5 # social\n    \n    dim = n * 2\n    particles = np.random.rand(num_particles, dim)\n    velocities = np.random.uniform(-0.1, 0.1, (num_particles, dim))\n    p_best = particles.copy()\n    p_best_scores = np.array([objective(p) for p in particles])\n    g_best = p_best[np.argmin(p_best_scores)].copy()\n    g_best_score = np.min(p_best_scores)\n\n    for _ in range(generations):\n        for i in range(num_particles):\n            r1, r2 = np.random.rand(2)\n            velocities[i] = w * velocities[i] + c1 * r1 * (p_best[i] - particles[i]) + \\\n                            c2 * r2 * (g_best - particles[i])\n            particles[i] = np.clip(particles[i] + velocities[i], 0, 1)\n            \n            score = objective(particles[i])\n            if score < p_best_scores[i]:\n                p_best_scores[i] = score\n                p_best[i] = particles[i].copy()\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best = particles[i].copy()\n\n    # Refinement using SLSQP\n    # Define constraints: r_i + r_j <= dist(i, j) and r_i <= dist_to_wall\n    # To make it easier for SLSQP, we optimize centers and radii together\n    def refinement_obj(x):\n        # x is [x1, y1, ..., x26, y26, r1, ..., r26]\n        return -np.sum(x[2*n:])\n\n    def constraints(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        cons = []\n        # Non-overlap\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                cons.append(dist - (radii[i] + radii[j]))\n            # Boundary\n            cons.append(centers[i, 0] - radii[i])\n            cons.append(1.0 - centers[i, 0] - radii[i])\n            cons.append(centers[i, 1] - radii[i])\n            cons.append(1.0 - centers[i, 1] - radii[i])\n        return np.array(cons)\n\n    # Initial guess for refinement\n    init_radii = get_radii(g_best)\n    x0 = np.concatenate([g_best, init_radii])\n    \n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n    res = minimize(refinement_obj, x0, method='SLSQP', \n                   constraints={'type': 'ineq', 'fun': constraints},\n                   bounds=bounds, options={'maxiter': 100})\n\n    final_centers = res.x[:2*n].reshape(n, 2)\n    final_radii = res.x[2*n:]\n    \n    # Final safety check to ensure no overlap due to solver tolerances\n    # Slightly scale down if necessary to be strictly valid\n    for i in range(n):\n        # Boundary check\n        final_radii[i] = min(final_radii[i], final_centers[i, 0], 1 - final_centers[i, 0], \n                             final_centers[i, 1], 1 - final_centers[i, 1])\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(final_centers[i] - final_centers[j])\n            if final_radii[i] + final_radii[j] > dist:\n                # Shrink radii proportionally\n                ratio = dist / (final_radii[i] + final_radii[j])\n                final_radii[i] *= (ratio - 1e-9)\n                final_radii[j] *= (ratio - 1e-9)\n\n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.5803048346997794,
    "eval_time": 0.580035924911499,
    "error": null
  },
  "prompt": "Use a 'Particle Swarm Optimization' (PSO) approach for the initial layout.\n1. Each particle represents the coordinates of 26 centers.\n2. The fitness function is the sum of radii calculated for those centers (by finding the minimum distance to walls or other centers).\n3. Run PSO for 100 generations with 20 particles to find a good global region.\n4. Refine the best particle's position using SLSQP.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using PSO\n    followed by SLSQP refinement.\n    \"\"\"\n    n = 26\n    \n    def get_radii(centers_flat):\n        centers = centers_flat.reshape(n, 2)\n        # Distance to boundaries (x, 1-x, y, 1-y)\n        d_bounds = np.minimum(np.minimum(centers[:, 0], 1 - centers[:, 0]),\n                              np.minimum(centers[:, 1], 1 - centers[:, 1]))\n        \n        # Distance between centers\n        # We need to find the radius r_i for each circle such that r_i + r_j <= dist(i, j)\n        # A common simplification for maximizing sum(r) is to assume r_i = r_j = dist/2\n        # But for heterogeneous radii, we solve for r_i subject to r_i + r_j <= d_ij\n        # Here we use a heuristic: r_i is limited by the nearest neighbor or wall.\n        # To keep it simple and valid: all r_i = r (uniform) or greedy assignment.\n        # For this specific objective, we optimize centers and a single global r, \n        # or individual r_i. Let's use individual r_i = min(d_bounds_i, min_j(dist_ij - r_j)).\n        # However, the most robust way to get a valid packing is to use a fixed r \n        # or calculate the maximum possible r for each center given others.\n        \n        # Simplified approach for PSO fitness: \n        # r_i = min (dist_to_wall, min_{j != i} (dist_ij / 2))\n        dist_matrix = np.sqrt(np.sum((centers[:, np.newaxis, :] - centers[np.newaxis, :, :])**2, axis=2))\n        np.fill_diagonal(dist_matrix, np.inf)\n        min_dist_to_others = np.min(dist_matrix, axis=1)\n        radii = np.minimum(d_bounds, min_dist_to_others / 2.0)\n        radii = np.maximum(radii, 0)\n        return radii\n\n    def objective(centers_flat):\n        return -np.sum(get_radii(centers_flat))\n\n    # PSO Parameters\n    num_particles = 20\n    generations = 100\n    w = 0.5  # inertia\n    c1 = 1.5 # cognitive\n    c2 = 1.5 # social\n    \n    dim = n * 2\n    particles = np.random.rand(num_particles, dim)\n    velocities = np.random.uniform(-0.1, 0.1, (num_particles, dim))\n    p_best = particles.copy()\n    p_best_scores = np.array([objective(p) for p in particles])\n    g_best = p_best[np.argmin(p_best_scores)].copy()\n    g_best_score = np.min(p_best_scores)\n\n    for _ in range(generations):\n        for i in range(num_particles):\n            r1, r2 = np.random.rand(2)\n            velocities[i] = w * velocities[i] + c1 * r1 * (p_best[i] - particles[i]) + \\\n                            c2 * r2 * (g_best - particles[i])\n            particles[i] = np.clip(particles[i] + velocities[i], 0, 1)\n            \n            score = objective(particles[i])\n            if score < p_best_scores[i]:\n                p_best_scores[i] = score\n                p_best[i] = particles[i].copy()\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best = particles[i].copy()\n\n    # Refinement using SLSQP\n    # Define constraints: r_i + r_j <= dist(i, j) and r_i <= dist_to_wall\n    # To make it easier for SLSQP, we optimize centers and radii together\n    def refinement_obj(x):\n        # x is [x1, y1, ..., x26, y26, r1, ..., r26]\n        return -np.sum(x[2*n:])\n\n    def constraints(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        cons = []\n        # Non-overlap\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                cons.append(dist - (radii[i] + radii[j]))\n            # Boundary\n            cons.append(centers[i, 0] - radii[i])\n            cons.append(1.0 - centers[i, 0] - radii[i])\n            cons.append(centers[i, 1] - radii[i])\n            cons.append(1.0 - centers[i, 1] - radii[i])\n        return np.array(cons)\n\n    # Initial guess for refinement\n    init_radii = get_radii(g_best)\n    x0 = np.concatenate([g_best, init_radii])\n    \n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n    res = minimize(refinement_obj, x0, method='SLSQP', \n                   constraints={'type': 'ineq', 'fun': constraints},\n                   bounds=bounds, options={'maxiter': 100})\n\n    final_centers = res.x[:2*n].reshape(n, 2)\n    final_radii = res.x[2*n:]\n    \n    # Final safety check to ensure no overlap due to solver tolerances\n    # Slightly scale down if necessary to be strictly valid\n    for i in range(n):\n        # Boundary check\n        final_radii[i] = min(final_radii[i], final_centers[i, 0], 1 - final_centers[i, 0], \n                             final_centers[i, 1], 1 - final_centers[i, 1])\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(final_centers[i] - final_centers[j])\n            if final_radii[i] + final_radii[j] > dist:\n                # Shrink radii proportionally\n                ratio = dist / (final_radii[i] + final_radii[j])\n                final_radii[i] *= (ratio - 1e-9)\n                final_radii[j] *= (ratio - 1e-9)\n\n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T22:23:26.090864",
  "cost_data": null
}