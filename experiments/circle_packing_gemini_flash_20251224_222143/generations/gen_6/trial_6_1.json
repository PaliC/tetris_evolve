{
  "trial_id": "trial_6_1",
  "generation": 6,
  "parent_id": "trial_5_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses multiple grid topologies and SLSQP optimization to maximize sum of radii.\n    Target sum of radii benchmark: ~2.635\n    \"\"\"\n    n = 26\n\n    def get_initial_topologies():\n        topologies = []\n        \n        # 1. Standard 5x5 Grid + 1 center point\n        x, y = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n        c1 = np.vstack([x.flatten(), y.flatten()]).T\n        c1 = np.vstack([c1, [0.5, 0.5]])\n        topologies.append(c1)\n\n        # 2. Hexagonal-Staggered (5-5-6-5-5)\n        c2 = []\n        rows = [5, 5, 6, 5, 5]\n        for i, count in enumerate(rows):\n            y_val = 0.1 + i * 0.2\n            offset = 0.05 if i % 2 == 0 else 0.0\n            x_vals = np.linspace(0.1 + offset, 0.9 - offset, count)\n            for xv in x_vals:\n                c2.append([xv, y_val])\n        topologies.append(np.array(c2))\n\n        # 3. 4x6 Grid + 2 extra points\n        x, y = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4))\n        c3 = np.vstack([x.flatten(), y.flatten()]).T\n        c3 = np.vstack([c3, [[0.3, 0.5], [0.7, 0.5]]])\n        topologies.append(c3)\n\n        return topologies\n\n    def optimize_packing(init_centers):\n        # Initial radii guess\n        init_radii = np.full(n, 0.1)\n        # Flatten: [x0, y0, ..., xn, yn, r0, ..., rn]\n        params = np.concatenate([init_centers.flatten(), init_radii])\n\n        def obj(p):\n            # Objective: Maximize sum of radii (minimize negative sum)\n            return -np.sum(p[2*n:])\n\n        def cons(p):\n            c = p[:2*n].reshape((n, 2))\n            r = p[2*n:]\n            \n            # Boundary constraints: center +/- radius must be in [0, 1]\n            b_cons = np.concatenate([\n                c[:, 0] - r,          # x - r >= 0\n                1.0 - (c[:, 0] + r),  # x + r <= 1\n                c[:, 1] - r,          # y - r >= 0\n                1.0 - (c[:, 1] + r)   # y + r <= 1\n            ])\n            \n            # Overlap constraints: dist(ci, cj) >= ri + rj\n            o_cons = []\n            for i in range(n):\n                dists = np.sqrt(np.sum((c[i] - c[i+1:])**2, axis=1) + 1e-15)\n                o_cons.append(dists - (r[i] + r[i+1:]))\n            \n            return np.concatenate([b_cons, np.concatenate(o_cons)])\n\n        bounds = [(0, 1)] * (2 * n) + [(0.01, 0.5)] * n\n        \n        res = minimize(\n            obj, \n            params, \n            method='SLSQP', \n            bounds=bounds,\n            constraints={'type': 'ineq', 'fun': cons},\n            options={'maxiter': 150, 'ftol': 1e-7}\n        )\n        return res.x\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n\n    for base_c in get_initial_topologies():\n        # Symmetry-breaking nudge\n        center_of_square = np.array([0.5, 0.5])\n        nudge = (base_c - center_of_square) * 0.02\n        seed = np.clip(base_c + nudge, 0.1, 0.9)\n        \n        final_p = optimize_packing(seed)\n        c_res = final_p[:2*n].reshape((n, 2))\n        r_res = final_p[2*n:]\n        \n        # Post-process to ensure strict feasibility\n        for _ in range(150):\n            changed = False\n            # Boundary check\n            for i in range(n):\n                r_max = min(c_res[i, 0], 1 - c_res[i, 0], c_res[i, 1], 1 - c_res[i, 1])\n                if r_res[i] > r_max:\n                    r_res[i] = r_max\n                    changed = True\n            # Overlap check\n            for i in range(n):\n                for j in range(i + 1, n):\n                    d = np.linalg.norm(c_res[i] - c_res[j])\n                    if d < r_res[i] + r_res[j]:\n                        overlap = (r_res[i] + r_res[j]) - d\n                        shrinkage = overlap / 2.0 + 1e-12\n                        r_res[i] -= shrinkage\n                        r_res[j] -= shrinkage\n                        changed = True\n            if not changed: break\n            \n        cur_sum = np.sum(r_res)\n        if cur_sum > best_sum:\n            best_sum = cur_sum\n            best_centers = c_res\n            best_radii = r_res\n\n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.598907668451879,
    "eval_time": 2.0495431423187256,
    "error": null
  },
  "prompt": "Refine the multi-topology approach from trial_5_0.\n{{import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Combines multiple grid topologies with SLSQP optimization to maximize the sum of radii.\n    Target sum of radii benchmark: ~2.635\n    \"\"\"\n    n = 26\n\n    def get_initial_topologies():\n        topologies = []\n        \n        # 1. 5x5 Grid + 1 center point\n        x, y = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n        c1 = np.vstack([x.flatten(), y.flatten()]).T\n        c1 = np.vstack([c1, [0.5, 0.5]])\n        topologies.append(c1)\n\n        # 2. 4x6 Grid + 2 extra points\n        x, y = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4))\n        c2 = np.vstack([x.flatten(), y.flatten()]).T\n        c2 = np.vstack([c2, [[0.4, 0.5], [0.6, 0.5]]])\n        topologies.append(c2)\n\n        # 3. Staggered Rows (5-5-6-5-5)\n        c3 = []\n        rows = [5, 5, 6, 5, 5]\n        for i, count in enumerate(rows):\n            y_val = 0.1 + i * 0.2\n            x_vals = np.linspace(0.1, 0.9, count)\n            for xv in x_vals:\n                c3.append([xv, y_val])\n        topologies.append(np.array(c3))\n\n        return topologies\n\n    def optimize_packing(init_centers):\n        # Initial radii guess\n        init_radii = np.full(n, 0.08)\n        # Flatten: [x0, y0, ..., xn, yn, r0, ..., rn]\n        params = np.concatenate([init_centers.flatten(), init_radii])\n\n        def obj(p):\n            # Maximize sum of radii\n            return -np.sum(p[2*n:])\n\n        def cons(p):\n            c = p[:2*n].reshape((n, 2))\n            r = p[2*n:]\n            \n            # Boundary constraints (4n)\n            b_cons = np.concatenate([\n                c[:, 0] - r,          # x - r >= 0\n                1.0 - (c[:, 0] + r),  # x + r <= 1\n                c[:, 1] - r,          # y - r >= 0\n                1.0 - (c[:, 1] + r)   # y + r <= 1\n            ])\n            \n            # Overlap constraints (n*(n-1)/2)\n            o_cons = []\n            for i in range(n):\n                # Vectorized distance calculation for efficiency\n                dists = np.sqrt(np.sum((c[i] - c[i+1:])**2, axis=1) + 1e-12)\n                o_cons.append(dists - (r[i] + r[i+1:]))\n            \n            return np.concatenate([b_cons, np.concatenate(o_cons)])\n\n        bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n        \n        res = minimize(\n            obj, \n            params, \n            method='SLSQP', \n            bounds=bounds,\n            constraints={'type': 'ineq', 'fun': cons},\n            options={'maxiter': 200, 'ftol': 1e-8}\n        )\n        return res.x\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n\n    # Try different topologies and pick the best\n    for base_c in get_initial_topologies():\n        # Add a tiny bit of noise to break symmetry\n        seed = base_c + np.random.normal(0, 0.005, base_c.shape)\n        seed = np.clip(seed, 0.1, 0.9)\n        \n        final_p = optimize_packing(seed)\n        c_res = final_p[:2*n].reshape((n, 2))\n        r_res = final_p[2*n:]\n        \n        # Rigorous feasibility check and correction\n        c_res = np.clip(c_res, 0, 1)\n        for _ in range(200):\n            changed = False\n            # Boundary\n            for i in range(n):\n                r_limit = min(c_res[i, 0], 1 - c_res[i, 0], c_res[i, 1], 1 - c_res[i, 1])\n                if r_res[i] > r_limit:\n                    r_res[i] = r_limit\n                    changed = True\n            # Overlap\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist = np.linalg.norm(c_res[i] - c_res[j])\n                    if dist < r_res[i] + r_res[j]:\n                        overlap = (r_res[i] + r_res[j]) - dist\n                        r_res[i] -= overlap/2 + 1e-14\n                        r_res[j] -= overlap/2 + 1e-14\n                        changed = True\n            if not changed: break\n            \n        cur_sum = np.sum(r_res)\n        if cur_sum > best_sum:\n            best_sum = cur_sum\n            best_centers = c_res\n            best_radii = r_res\n\n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point for the evaluator.\"\"\"\n    return construct_packing()}}\n\n1. Add a 'Hexagonal-Staggered' grid to the list of initializations: 5 rows with [5, 5, 6, 5, 5] circles respectively, slightly offset to create a hexagonal pattern.\n2. For each grid, instead of a random wiggle, use a 'Symmetry-Breaking' nudge: move circles by a small amount proportional to their distance from the square center.\n3. Increase the number of Voronoi iterations from 50 to 150.\n4. If the final SLSQP result is less than 2.60, discard and try another wiggle immediately. Focus compute on the most promising seeds.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses multiple grid topologies and SLSQP optimization to maximize sum of radii.\n    Target sum of radii benchmark: ~2.635\n    \"\"\"\n    n = 26\n\n    def get_initial_topologies():\n        topologies = []\n        \n        # 1. Standard 5x5 Grid + 1 center point\n        x, y = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n        c1 = np.vstack([x.flatten(), y.flatten()]).T\n        c1 = np.vstack([c1, [0.5, 0.5]])\n        topologies.append(c1)\n\n        # 2. Hexagonal-Staggered (5-5-6-5-5)\n        c2 = []\n        rows = [5, 5, 6, 5, 5]\n        for i, count in enumerate(rows):\n            y_val = 0.1 + i * 0.2\n            offset = 0.05 if i % 2 == 0 else 0.0\n            x_vals = np.linspace(0.1 + offset, 0.9 - offset, count)\n            for xv in x_vals:\n                c2.append([xv, y_val])\n        topologies.append(np.array(c2))\n\n        # 3. 4x6 Grid + 2 extra points\n        x, y = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4))\n        c3 = np.vstack([x.flatten(), y.flatten()]).T\n        c3 = np.vstack([c3, [[0.3, 0.5], [0.7, 0.5]]])\n        topologies.append(c3)\n\n        return topologies\n\n    def optimize_packing(init_centers):\n        # Initial radii guess\n        init_radii = np.full(n, 0.1)\n        # Flatten: [x0, y0, ..., xn, yn, r0, ..., rn]\n        params = np.concatenate([init_centers.flatten(), init_radii])\n\n        def obj(p):\n            # Objective: Maximize sum of radii (minimize negative sum)\n            return -np.sum(p[2*n:])\n\n        def cons(p):\n            c = p[:2*n].reshape((n, 2))\n            r = p[2*n:]\n            \n            # Boundary constraints: center +/- radius must be in [0, 1]\n            b_cons = np.concatenate([\n                c[:, 0] - r,          # x - r >= 0\n                1.0 - (c[:, 0] + r),  # x + r <= 1\n                c[:, 1] - r,          # y - r >= 0\n                1.0 - (c[:, 1] + r)   # y + r <= 1\n            ])\n            \n            # Overlap constraints: dist(ci, cj) >= ri + rj\n            o_cons = []\n            for i in range(n):\n                dists = np.sqrt(np.sum((c[i] - c[i+1:])**2, axis=1) + 1e-15)\n                o_cons.append(dists - (r[i] + r[i+1:]))\n            \n            return np.concatenate([b_cons, np.concatenate(o_cons)])\n\n        bounds = [(0, 1)] * (2 * n) + [(0.01, 0.5)] * n\n        \n        res = minimize(\n            obj, \n            params, \n            method='SLSQP', \n            bounds=bounds,\n            constraints={'type': 'ineq', 'fun': cons},\n            options={'maxiter': 150, 'ftol': 1e-7}\n        )\n        return res.x\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n\n    for base_c in get_initial_topologies():\n        # Symmetry-breaking nudge\n        center_of_square = np.array([0.5, 0.5])\n        nudge = (base_c - center_of_square) * 0.02\n        seed = np.clip(base_c + nudge, 0.1, 0.9)\n        \n        final_p = optimize_packing(seed)\n        c_res = final_p[:2*n].reshape((n, 2))\n        r_res = final_p[2*n:]\n        \n        # Post-process to ensure strict feasibility\n        for _ in range(150):\n            changed = False\n            # Boundary check\n            for i in range(n):\n                r_max = min(c_res[i, 0], 1 - c_res[i, 0], c_res[i, 1], 1 - c_res[i, 1])\n                if r_res[i] > r_max:\n                    r_res[i] = r_max\n                    changed = True\n            # Overlap check\n            for i in range(n):\n                for j in range(i + 1, n):\n                    d = np.linalg.norm(c_res[i] - c_res[j])\n                    if d < r_res[i] + r_res[j]:\n                        overlap = (r_res[i] + r_res[j]) - d\n                        shrinkage = overlap / 2.0 + 1e-12\n                        r_res[i] -= shrinkage\n                        r_res[j] -= shrinkage\n                        changed = True\n            if not changed: break\n            \n        cur_sum = np.sum(r_res)\n        if cur_sum > best_sum:\n            best_sum = cur_sum\n            best_centers = c_res\n            best_radii = r_res\n\n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T22:24:57.972276",
  "cost_data": null
}