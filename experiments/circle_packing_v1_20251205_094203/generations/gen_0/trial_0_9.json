{
  "trial_id": "trial_0_9",
  "generation": 0,
  "parent_id": null,
  "code": "",
  "metrics": {},
  "prompt": "Write a genetic algorithm for circle packing of 26 circles in [0,1]x[0,1].\n\nEvolve a population of packing configurations to maximize sum of radii.\n\nRequirements:\n- Define construct_packing() that returns (centers, radii, sum_radii)\n- Population: multiple packing configurations\n- Fitness: sum of radii (with penalties for overlaps/boundary violations)\n- Crossover: combine parent packings\n- Mutation: perturb positions/radii\n- Run for multiple generations\n- Define run_packing() as entry point\n- Use numpy for calculations\n\nStrategy: Maintain diversity, balance exploration vs exploitation.",
  "response": "```python\nimport numpy as np\nfrom typing import Tuple, List\nimport copy\n\nclass CirclePacking:\n    \"\"\"Genetic Algorithm for Circle Packing Problem\"\"\"\n    \n    def __init__(self, n_circles: int = 26, \n                 population_size: int = 100,\n                 n_generations: int = 500,\n                 mutation_rate: float = 0.3,\n                 elite_size: int = 10,\n                 tournament_size: int = 5):\n        self.n_circles = n_circles\n        self.population_size = population_size\n        self.n_generations = n_generations\n        self.mutation_rate = mutation_rate\n        self.elite_size = elite_size\n        self.tournament_size = tournament_size\n        \n    def initialize_population(self) -> List[np.ndarray]:\n        \"\"\"Initialize population with random valid packings\"\"\"\n        population = []\n        \n        for _ in range(self.population_size):\n            # Random centers in [0,1]x[0,1]\n            centers = np.random.rand(self.n_circles, 2)\n            \n            # Initialize with small radii\n            radii = np.random.uniform(0.01, 0.1, self.n_circles)\n            \n            # Encode as single array: [x1, y1, r1, x2, y2, r2, ...]\n            individual = np.zeros(self.n_circles * 3)\n            individual[0::3] = centers[:, 0]\n            individual[1::3] = centers[:, 1]\n            individual[2::3] = radii\n            \n            population.append(individual)\n            \n        return population\n    \n    def decode_individual(self, individual: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Decode individual into centers and radii\"\"\"\n        centers = np.column_stack((individual[0::3], individual[1::3]))\n        radii = individual[2::3]\n        return centers, radii\n    \n    def calculate_fitness(self, individual: np.ndarray) -> float:\n        \"\"\"Calculate fitness with penalties for overlaps and boundary violations\"\"\"\n        centers, radii = self.decode_individual(individual)\n        \n        # Base fitness: sum of radii\n        sum_radii = np.sum(radii)\n        fitness = sum_radii\n        \n        # Penalty for overlaps\n        overlap_penalty = 0.0\n        for i in range(self.n_circles):\n            for j in range(i + 1, self.n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist:\n                    overlap = min_dist - dist\n                    overlap_penalty += overlap * 10.0  # Heavy penalty\n        \n        # Penalty for boundary violations\n        boundary_penalty = 0.0\n        for i in range(self.n_circles):\n            # Check all four boundaries\n            violations = [\n                max(0, radii[i] - centers[i, 0]),  # left\n                max(0, radii[i] - centers[i, 1]),  # bottom\n                max(0, centers[i, 0] + radii[i] - 1.0),  # right\n                max(0, centers[i, 1] + radii[i] - 1.0)   # top\n            ]\n            boundary_penalty += sum(violations) * 10.0\n        \n        # Penalty for invalid radii\n        invalid_radii_penalty = np.sum(np.maximum(0, -radii)) * 100.0\n        invalid_radii_penalty += np.sum(np.maximum(0, radii - 0.5)) * 50.0\n        \n        fitness = fitness - overlap_penalty - boundary_penalty - invalid_radii_penalty\n        \n        return fitness\n    \n    def tournament_selection(self, population: List[np.ndarray], \n                            fitness_scores: np.ndarray) -> np.ndarray:\n        \"\"\"Select individual using tournament selection\"\"\"\n        tournament_indices = np.random.choice(len(population), \n                                             self.tournament_size, \n                                             replace=False)\n        tournament_fitness = fitness_scores[tournament_indices]\n        winner_idx = tournament_indices[np.argmax(tournament_fitness)]\n        return population[winner_idx].copy()\n    \n    def crossover(self, parent1: np.ndarray, parent2: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Crossover two parents to create offspring\"\"\"\n        child1 = parent1.copy()\n        child2 = parent2.copy()\n        \n        # Multi-point crossover: swap some circles between parents\n        n_swap = np.random.randint(1, self.n_circles // 2)\n        swap_indices = np.random.choice(self.n_circles, n_swap, replace=False)\n        \n        for idx in swap_indices:\n            # Swap the three values (x, y, r) for each circle\n            start = idx * 3\n            end = start + 3\n            child1[start:end], child2[start:end] = child2[start:end].copy(), child1[start:end].copy()\n        \n        # Blend crossover for some circles\n        if np.random.rand() < 0.5:\n            alpha = np.random.rand()\n            blend_indices = np.random.choice(self.n_circles, \n                                            self.n_circles // 3, \n                                            replace=False)\n            for idx in blend_indices:\n                start = idx * 3\n                end = start + 3\n                child1[start:end] = alpha * parent1[start:end] + (1 - alpha) * parent2[start:end]\n                child2[start:end] = alpha * parent2[start:end] + (1 - alpha) * parent1[start:end]\n        \n        return child1, child2\n    \n    def mutate(self, individual: np.ndarray, generation: int) -> np.ndarray:\n        \"\"\"Mutate individual with adaptive mutation\"\"\"\n        mutated = individual.copy()\n        \n        # Adaptive mutation strength (decreases over generations)\n        strength = 0.1 * (1.0 - generation / self.n_generations)\n        \n        for i in range(self.n_circles):\n            if np.random.rand() < self.mutation_rate:\n                start = i * 3\n                \n                # Mutate position\n                if np.random.rand() < 0.7:\n                    mutated[start] += np.random.normal(0, strength)\n                    mutated[start + 1] += np.random.normal(0, strength)\n                    # Keep in bounds\n                    mutated[start] = np.clip(mutated[start], 0, 1)\n                    mutated[start + 1] = np.clip(mutated[start + 1], 0, 1)\n                \n                # Mutate radius\n                if np.random.rand() < 0.5:\n                    mutated[start + 2] += np.random.normal(0, strength * 0.5)\n                    mutated[start + 2] = np.clip(mutated[start + 2], 0.01, 0.5)\n        \n        # Occasionally do a larger perturbation to maintain diversity\n        if np.random.rand() < 0.1:\n            idx = np.random.randint(self.n_circles)\n            start = idx * 3\n            mutated[start:start+2] = np.random.rand(2)\n            mutated[start + 2] = np.random.uniform(0.01, 0.1)\n        \n        return mutated\n    \n    def repair_individual(self, individual: np.ndarray) -> np.ndarray:\n        \"\"\"Repair individual to reduce violations\"\"\"\n        repaired = individual.copy()\n        centers, radii = self.decode_individual(repaired)\n        \n        # Repair boundary violations\n        for i in range(self.n_circles):\n            # Shrink radius if it violates boundary\n            max_radius = min(\n                centers[i, 0],\n                centers[i, 1],\n                1.0 - centers[i, 0],\n                1.0 - centers[i, 1]\n            )\n            if radii[i] > max_radius:\n                radii[i] = max(0.01, max_radius * 0.95)\n        \n        # Update repaired individual\n        repaired[2::3] = radii\n        \n        return repaired\n    \n    def optimize_radii(self, individual: np.ndarray) -> np.ndarray:\n        \"\"\"Optimize radii given fixed centers\"\"\"\n        optimized = individual.copy()\n        centers, radii = self.decode_individual(optimized)\n        \n        # For each circle, find maximum possible radius\n        for i in range(self.n_circles):\n            # Check boundary constraints\n            max_r = min(\n                centers[i, 0],\n                centers[i, 1],\n                1.0 - centers[i, 0],\n                1.0 - centers[i, 1]\n            )\n            \n            # Check overlap constraints with other circles\n            for j in range(self.n_circles):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r_overlap = dist - radii[j]\n                    max_r = min(max_r, max_r_overlap)\n            \n            radii[i] = max(0.01, max_r * 0.98)  # Slightly conservative\n        \n        optimized[2::3] = radii\n        return optimized\n    \n    def evolve(self) -> Tuple[np.ndarray, List[float]]:\n        \"\"\"Main evolution loop\"\"\"\n        population = self.initialize_population()\n        best_fitness_history = []\n        best_individual = None\n        best_fitness = -np.inf\n        \n        for generation in range(self.n_generations):\n            # Evaluate fitness\n            fitness_scores = np.array([self.calculate_fitness(ind) \n                                      for ind in population])\n            \n            # Track best individual\n            gen_best_idx = np.argmax(fitness_scores)\n            gen_best_fitness = fitness_scores[gen_best_idx]\n            \n            if gen_best_fitness > best_fitness:\n                best_fitness = gen_best_fitness\n                best_individual = population[gen_best_idx].copy()\n                \n                # Try to optimize radii of best individual\n                optimized = self.optimize_radii(best_individual)\n                optimized_fitness = self.calculate_fitness(optimized)\n                if optimized_fitness > best_fitness:\n                    best_fitness = optimized_fitness\n                    best_individual = optimized\n            \n            best_fitness_history.append(best_fitness)\n            \n            if generation % 50 == 0:\n                print(f\"Generation {generation}: Best Fitness = {best_fitness:.6f}\")\n            \n            # Create new population\n            new_population = []\n            \n            # Elitism: keep best individuals\n            elite_indices = np.argsort(fitness_scores)[-self.elite_size:]\n            for idx in elite_indices:\n                new_population.append(population[idx].copy())\n            \n            # Generate offspring\n            while len(new_population) < self.population_size:\n                # Selection\n                parent1 = self.tournament_selection(population, fitness_scores)\n                parent2 = self.tournament_selection(population, fitness_scores)\n                \n                # Crossover\n                if np.random.rand() < 0.8:\n                    child1, child2 = self.crossover(parent1, parent2)\n                else:\n                    child1, child2 = parent1.copy(), parent2.copy()\n                \n                # Mutation\n                child1 = self.mutate(child1, generation)\n                child2 = self.mutate(child2, generation)\n                \n                # Repair\n                child1 = self.repair_individual(child1)\n                child2 = self.repair_individual(child2)\n                \n                new_population.append(child1)\n                if len(new_population) < self.population_size:\n                    new_population.append(child2)\n            \n            population = new_population\n        \n        return best_individual, best_fitness_history\n\n\ndef construct_packing(individual: np.ndarray = None, \n                     n_circles: int = 26) -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Construct a circle packing configuration.\n    \n    Args:\n        individual: Encoded packing configuration (optional)\n        n_circles: Number of circles\n        \n    Returns:\n        centers: Array of shape (n_circles, 2) with circle centers\n        radii: Array of shape (n_circles,) with circle radii\n        sum_radii: Sum of all radii\n    \"\"\"\n    if individual is None:\n        # Create a simple grid-based packing as default\n        grid_size = int(np.ceil(np.sqrt(n_circles)))\n        spacing = 1.0 / (grid_size + 1)\n        \n        centers = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(centers) < n_circles:\n                    x = (i + 1) * spacing\n                    y = (j + 1) * spacing\n                    centers.append([x, y])\n        \n        centers = np.array(centers)\n        radii = np.full(n_circles, spacing * 0.4)\n    else:\n        # Decode individual\n        centers = np.column_stack((individual[0::3], individual[1::3]))\n        radii = individual[2::3]\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing(n_circles: int = 26,\n                population_size: int = 100,\n                n_generations: int = 500,\n                mutation_rate: float = 0.3,\n                elite_size: int = 10,\n                tournament_size: int = 5,\n                random_seed: int = None) -> Tuple[np.ndarray, np.ndarray, float, List[float]]:\n    \"\"\"\n    Run the genetic algorithm for circle packing.\n    \n    Args:\n        n_circles: Number of circles to pack\n        population_size: Size of the population\n        n_generations: Number of generations to evolve\n        mutation_rate: Probability of mutation\n        elite_size: Number of elite individuals to preserve\n        tournament_size: Size of tournament for selection\n        random_seed: Random seed for reproducibility\n        \n    Returns:\n        centers: Array of shape (n_circles, 2) with circle centers\n        radii: Array of shape (n_circles,) with circle radii\n        sum_radii: Sum of all radii\n        fitness_history: List of best fitness values over generations\n    \"\"\"\n    if random_seed is not None:\n        np.random.seed(random_seed)\n    \n    print(f\"Starting Genetic Algorithm for Circle Packing\")\n    print(f\"Parameters: n_circles={n_circles}, population={population_size}, \"\n          f\"generations={n_generations}\")\n    print(\"-\" * 60)\n    \n    # Create and run genetic algorithm\n    ga = CirclePacking(\n        n_circles=n_circles,\n        population_size=population_size,\n        n_generations=n_generations,\n        mutation_rate=mutation_rate,\n        elite_size=elite_size,\n        tournament_size=tournament_size\n    )\n    \n    best_individual, fitness_history = ga.evolve()\n    \n    # Extract final packing\n    centers, radii, sum_radii = construct_packing(best_individual, n_circles)\n    \n    print(\"-\" * 60)\n    print(f\"Optimization complete!\")\n    print(f\"Final sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    return",
  "reasoning": "```python\nimport numpy as np\nfrom typing import Tuple, List\nimport copy\n\nclass CirclePacking:\n    \"\"\"Genetic Algorithm for Circle Packing Problem\"\"\"\n    \n    def __init__(self, n_circles: int = 26, \n                 population_size: int = 100,\n                 n_generations: int = 500,\n                 mutation_rate: float = 0.3,\n                 elite_size: int = 10,\n                 tournament_size: int = 5):\n        self.n_circles = n_circles\n        self.population_size = population_size\n        self.n_generations = n_generations\n        self.mutation_rate = mutation_rate\n        self.elite_size = elite_size\n        self.tournament_size = tournament_size\n        \n    def initialize_population(self) -> List[np.ndarray]:\n        \"\"\"Initialize population with random valid packings\"\"\"\n        population = []\n        \n        for _ in range(self.population_size):\n            # Random centers in [0,1]x[0,1]\n            centers = np.random.rand(self.n_circles, 2)\n            \n            # Initialize with small radii\n            radii = np.random.uniform(0.01, 0.1, self.n_circles)\n            \n            # Encode as single array: [x1, y1, r1, x2, y2, r2, ...]\n            individual = np.zeros(self.n_circles * 3)\n            individual[0::3] = centers[:, 0]\n            individual[1::3] = centers[:, 1]\n            individual[2::3] = radii\n            \n            population.append(individual)\n            \n        return population\n    \n    def decode_individual(self, individual: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Decode individual into centers and radii\"\"\"\n        centers = np.column_stack((individual[0::3], individual[1::3]))\n        radii = individual[2::3]\n        return centers, radii\n    \n    def calculate_fitness(self, individual: np.ndarray) -> float:\n        \"\"\"Calculate fitness with penalties for overlaps and boundary violations\"\"\"\n        centers, radii = self.decode_individual(individual)\n        \n        # Base fitness: sum of radii\n        sum_radii = np.sum(radii)\n        fitness = sum_radii\n        \n        # Penalty for overlaps\n        overlap_penalty = 0.0\n        for i in range(self.n_circles):\n            for j in range(i + 1, self.n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist:\n                    overlap = min_dist - dist\n                    overlap_penalty += overlap * 10.0  # Heavy penalty\n        \n        # Penalty for boundary violations\n        boundary_penalty = 0.0\n        for i in range(self.n_circles):\n            # Check all four boundaries\n            violations = [\n                max(0, radii[i] - centers[i, 0]),  # left\n                max(0, radii[i] - centers[i, 1]),  # bottom\n                max(0, centers[i, 0] + radii[i] - 1.0),  # right\n                max(0, centers[i, 1] + radii[i] - 1.0)   # top\n            ]\n            boundary_penalty += sum(violations) * 10.0\n        \n        # Penalty for invalid radii\n        invalid_radii_penalty = np.sum(np.maximum(0, -radii)) * 100.0\n        invalid_radii_penalty += np.sum(np.maximum(0, radii - 0.5)) * 50.0\n        \n        fitness = fitness - overlap_penalty - boundary_penalty - invalid_radii_penalty\n        \n        return fitness\n    \n    def tournament_selection(self, population: List[np.ndarray], \n                            fitness_scores: np.ndarray) -> np.ndarray:\n        \"\"\"Select individual using tournament selection\"\"\"\n        tournament_indices = np.random.choice(len(population), \n                                             self.tournament_size, \n                                             replace=False)\n        tournament_fitness = fitness_scores[tournament_indices]\n        winner_idx = tournament_indices[np.argmax(tournament_fitness)]\n        return population[winner_idx].copy()\n    \n    def crossover(self, parent1: np.ndarray, parent2: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Crossover two parents to create offspring\"\"\"\n        child1 = parent1.copy()\n        child2 = parent2.copy()\n        \n        # Multi-point crossover: swap some circles between parents\n        n_swap = np.random.randint(1, self.n_circles // 2)\n        swap_indices = np.random.choice(self.n_circles, n_swap, replace=False)\n        \n        for idx in swap_indices:\n            # Swap the three values (x, y, r) for each circle\n            start = idx * 3\n            end = start + 3\n            child1[start:end], child2[start:end] = child2[start:end].copy(), child1[start:end].copy()\n        \n        # Blend crossover for some circles\n        if np.random.rand() < 0.5:\n            alpha = np.random.rand()\n            blend_indices = np.random.choice(self.n_circles, \n                                            self.n_circles // 3, \n                                            replace=False)\n            for idx in blend_indices:\n                start = idx * 3\n                end = start + 3\n                child1[start:end] = alpha * parent1[start:end] + (1 - alpha) * parent2[start:end]\n                child2[start:end] = alpha * parent2[start:end] + (1 - alpha) * parent1[start:end]\n        \n        return child1, child2\n    \n    def mutate(self, individual: np.ndarray, generation: int) -> np.ndarray:\n        \"\"\"Mutate individual with adaptive mutation\"\"\"\n        mutated = individual.copy()\n        \n        # Adaptive mutation strength (decreases over generations)\n        strength = 0.1 * (1.0 - generation / self.n_generations)\n        \n        for i in range(self.n_circles):\n            if np.random.rand() < self.mutation_rate:\n                start = i * 3\n                \n                # Mutate position\n                if np.random.rand() < 0.7:\n                    mutated[start] += np.random.normal(0, strength)\n                    mutated[start + 1] += np.random.normal(0, strength)\n                    # Keep in bounds\n                    mutated[start] = np.clip(mutated[start], 0, 1)\n                    mutated[start + 1] = np.clip(mutated[start + 1], 0, 1)\n                \n                # Mutate radius\n                if np.random.rand() < 0.5:\n                    mutated[start + 2] += np.random.normal(0, strength * 0.5)\n                    mutated[start + 2] = np.clip(mutated[start + 2], 0.01, 0.5)\n        \n        # Occasionally do a larger perturbation to maintain diversity\n        if np.random.rand() < 0.1:\n            idx = np.random.randint(self.n_circles)\n            start = idx * 3\n            mutated[start:start+2] = np.random.rand(2)\n            mutated[start + 2] = np.random.uniform(0.01, 0.1)\n        \n        return mutated\n    \n    def repair_individual(self, individual: np.ndarray) -> np.ndarray:\n        \"\"\"Repair individual to reduce violations\"\"\"\n        repaired = individual.copy()\n        centers, radii = self.decode_individual(repaired)\n        \n        # Repair boundary violations\n        for i in range(self.n_circles):\n            # Shrink radius if it violates boundary\n            max_radius = min(\n                centers[i, 0],\n                centers[i, 1],\n                1.0 - centers[i, 0],\n                1.0 - centers[i, 1]\n            )\n            if radii[i] > max_radius:\n                radii[i] = max(0.01, max_radius * 0.95)\n        \n        # Update repaired individual\n        repaired[2::3] = radii\n        \n        return repaired\n    \n    def optimize_radii(self, individual: np.ndarray) -> np.ndarray:\n        \"\"\"Optimize radii given fixed centers\"\"\"\n        optimized = individual.copy()\n        centers, radii = self.decode_individual(optimized)\n        \n        # For each circle, find maximum possible radius\n        for i in range(self.n_circles):\n            # Check boundary constraints\n            max_r = min(\n                centers[i, 0],\n                centers[i, 1],\n                1.0 - centers[i, 0],\n                1.0 - centers[i, 1]\n            )\n            \n            # Check overlap constraints with other circles\n            for j in range(self.n_circles):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r_overlap = dist - radii[j]\n                    max_r = min(max_r, max_r_overlap)\n            \n            radii[i] = max(0.01, max_r * 0.98)  # Slightly conservative\n        \n        optimized[2::3] = radii\n        return optimized\n    \n    def evolve(self) -> Tuple[np.ndarray, List[float]]:\n        \"\"\"Main evolution loop\"\"\"\n        population = self.initialize_population()\n        best_fitness_history = []\n        best_individual = None\n        best_fitness = -np.inf\n        \n        for generation in range(self.n_generations):\n            # Evaluate fitness\n            fitness_scores = np.array([self.calculate_fitness(ind) \n                                      for ind in population])\n            \n            # Track best individual\n            gen_best_idx = np.argmax(fitness_scores)\n            gen_best_fitness = fitness_scores[gen_best_idx]\n            \n            if gen_best_fitness > best_fitness:\n                best_fitness = gen_best_fitness\n                best_individual = population[gen_best_idx].copy()\n                \n                # Try to optimize radii of best individual\n                optimized = self.optimize_radii(best_individual)\n                optimized_fitness = self.calculate_fitness(optimized)\n                if optimized_fitness > best_fitness:\n                    best_fitness = optimized_fitness\n                    best_individual = optimized\n            \n            best_fitness_history.append(best_fitness)\n            \n            if generation % 50 == 0:\n                print(f\"Generation {generation}: Best Fitness = {best_fitness:.6f}\")\n            \n            # Create new population\n            new_population = []\n            \n            # Elitism: keep best individuals\n            elite_indices = np.argsort(fitness_scores)[-self.elite_size:]\n            for idx in elite_indices:\n                new_population.append(population[idx].copy())\n            \n            # Generate offspring\n            while len(new_population) < self.population_size:\n                # Selection\n                parent1 = self.tournament_selection(population, fitness_scores)\n                parent2 = self.tournament_selection(population, fitness_scores)\n                \n                # Crossover\n                if np.random.rand() < 0.8:\n                    child1, child2 = self.crossover(parent1, parent2)\n                else:\n                    child1, child2 = parent1.copy(), parent2.copy()\n                \n                # Mutation\n                child1 = self.mutate(child1, generation)\n                child2 = self.mutate(child2, generation)\n                \n                # Repair\n                child1 = self.repair_individual(child1)\n                child2 = self.repair_individual(child2)\n                \n                new_population.append(child1)\n                if len(new_population) < self.population_size:\n                    new_population.append(child2)\n            \n            population = new_population\n        \n        return best_individual, best_fitness_history\n\ndef construct_packing(individual: np.ndarray = None, \n                     n_circles: int = 26) -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Construct a circle packing configuration.\n    \n    Args:\n        individual: Encoded packing configuration (optional)\n        n_circles: Number of circles\n        \n    Returns:\n        centers: Array of shape (n_circles, 2) with circle centers\n        radii: Array of shape (n_circles,) with circle radii\n        sum_radii: Sum of all radii\n    \"\"\"\n    if individual is None:\n        # Create a simple grid-based packing as default\n        grid_size = int(np.ceil(np.sqrt(n_circles)))\n        spacing = 1.0 / (grid_size + 1)\n        \n        centers = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(centers) < n_circles:\n                    x = (i + 1) * spacing\n                    y = (j + 1) * spacing\n                    centers.append([x, y])\n        \n        centers = np.array(centers)\n        radii = np.full(n_circles, spacing * 0.4)\n    else:\n        # Decode individual\n        centers = np.column_stack((individual[0::3], individual[1::3]))\n        radii = individual[2::3]\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing(n_circles: int = 26,\n                population_size: int = 100,\n                n_generations: int = 500,\n                mutation_rate: float = 0.3,\n                elite_size: int = 10,\n                tournament_size: int = 5,\n                random_seed: int = None) -> Tuple[np.ndarray, np.ndarray, float, List[float]]:\n    \"\"\"\n    Run the genetic algorithm for circle packing.\n    \n    Args:\n        n_circles: Number of circles to pack\n        population_size: Size of the population\n        n_generations: Number of generations to evolve\n        mutation_rate: Probability of mutation\n        elite_size: Number of elite individuals to preserve\n        tournament_size: Size of tournament for selection\n        random_seed: Random seed for reproducibility\n        \n    Returns:\n        centers: Array of shape (n_circles, 2) with circle centers\n        radii: Array of shape (n_circles,) with circle radii\n        sum_radii: Sum of all radii\n        fitness_history: List of best fitness values over generations\n    \"\"\"\n    if random_seed is not None:\n        np.random.seed(random_seed)\n    \n    print(f\"Starting Genetic Algorithm for Circle Packing\")\n    print(f\"Parameters: n_circles={n_circles}, population={population_size}, \"\n          f\"generations={n_generations}\")\n    print(\"-\" * 60)\n    \n    # Create and run genetic algorithm\n    ga = CirclePacking(\n        n_circles=n_circles,\n        population_size=population_size,\n        n_generations=n_generations,\n        mutation_rate=mutation_rate,\n        elite_size=elite_size,\n        tournament_size=tournament_size\n    )\n    \n    best_individual, fitness_history = ga.evolve()\n    \n    # Extract final packing\n    centers, radii, sum_radii = construct_packing(best_individual, n_circles)\n    \n    print(\"-\" * 60)\n    print(f\"Optimization complete!\")\n    print(f\"Final sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    return",
  "timestamp": "2025-12-05T09:46:18.302747",
  "cost_data": null
}