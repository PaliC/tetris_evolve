{
  "trial_id": "trial_0_8",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom typing import Tuple, List\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Multi-scale packing of 26 circles using larger circles first, then filling gaps.\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of circle radii (sorted from largest to smallest)\n        sum_radii: sum of all radii\n    \"\"\"\n    centers = []\n    radii = []\n    \n    # Layer 1: Large circles in corners and center (5 circles)\n    # These anchor the packing structure\n    r1 = 0.15\n    large_positions = [\n        (r1, r1),           # bottom-left\n        (1-r1, r1),         # bottom-right\n        (r1, 1-r1),         # top-left\n        (1-r1, 1-r1),       # top-right\n        (0.5, 0.5),         # center\n    ]\n    for pos in large_positions:\n        centers.append(pos)\n        radii.append(r1)\n    \n    # Layer 2: Medium circles along edges (8 circles)\n    r2 = 0.095\n    medium_positions = [\n        (0.5, r2),          # bottom center\n        (0.5, 1-r2),        # top center\n        (r2, 0.5),          # left center\n        (1-r2, 0.5),        # right center\n        (0.28, r2+0.01),    # bottom left-center\n        (0.72, r2+0.01),    # bottom right-center\n        (0.28, 1-r2-0.01),  # top left-center\n        (0.72, 1-r2-0.01),  # top right-center\n    ]\n    for pos in medium_positions:\n        centers.append(pos)\n        radii.append(r2)\n    \n    # Layer 3: Small circles filling gaps (13 circles)\n    r3 = 0.055\n    small_positions = [\n        (0.28, 0.28),\n        (0.72, 0.28),\n        (0.28, 0.72),\n        (0.72, 0.72),\n        (0.5, 0.28),\n        (0.5, 0.72),\n        (0.28, 0.5),\n        (0.72, 0.5),\n        (0.15, 0.35),\n        (0.85, 0.35),\n        (0.15, 0.65),\n        (0.85, 0.65),\n        (0.35, 0.15),\n    ]\n    for pos in small_positions:\n        centers.append(pos)\n        radii.append(r3)\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    \n    # Refine positions to avoid overlaps and ensure all circles are inside\n    centers, radii = refine_packing(centers, radii)\n    \n    # Sort by radius (largest first)\n    sort_idx = np.argsort(-radii)\n    centers = centers[sort_idx]\n    radii = radii[sort_idx]\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef refine_packing(centers: np.ndarray, radii: np.ndarray, \n                   max_iter: int = 1000) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Refine packing to eliminate overlaps and ensure all circles are inside unit square.\n    \"\"\"\n    centers = centers.copy()\n    radii = radii.copy()\n    n = len(centers)\n    \n    for iteration in range(max_iter):\n        moved = False\n        \n        # Check and fix boundary violations\n        for i in range(n):\n            r = radii[i]\n            c = centers[i]\n            \n            # Clamp to boundaries\n            if c[0] - r < 0:\n                centers[i, 0] = r\n                moved = True\n            if c[0] + r > 1:\n                centers[i, 0] = 1 - r\n                moved = True\n            if c[1] - r < 0:\n                centers[i, 1] = r\n                moved = True\n            if c[1] + r > 1:\n                centers[i, 1] = 1 - r\n                moved = True\n        \n        # Check and fix overlaps\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist:\n                    # Move circles apart\n                    if dist > 0:\n                        direction = (centers[j] - centers[i]) / dist\n                    else:\n                        direction = np.random.randn(2)\n                        direction /= np.linalg.norm(direction)\n                    \n                    overlap = min_dist - dist\n                    centers[i] -= direction * overlap * 0.5\n                    centers[j] += direction * overlap * 0.5\n                    moved = True\n        \n        if not moved:\n            break\n    \n    # Final check: shrink radii slightly if still overlapping\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if dist < min_dist:\n                # Shrink both radii proportionally\n                scale = 0.99 * dist / min_dist\n                radii[i] *= scale\n                radii[j] *= scale\n    \n    # Ensure all circles fit in unit square\n    for i in range(n):\n        r = radii[i]\n        c = centers[i]\n        max_r = min(c[0], 1 - c[0], c[1], 1 - c[1])\n        if r > max_r:\n            radii[i] = max_r * 0.99\n    \n    return centers, radii\n\n\ndef verify_packing(centers: np.ndarray, radii: np.ndarray) -> bool:\n    \"\"\"\n    Verify that the packing is valid (no overlaps, all inside unit square).\n    \"\"\"\n    n = len(centers)\n    \n    # Check boundary constraints\n    for i in range(n):\n        c = centers[i]\n        r = radii[i]\n        if c[0] - r < -1e-6 or c[0] + r > 1 + 1e-6:\n            print(f\"Circle {i} violates x-boundary\")\n            return False\n        if c[1] - r < -1e-6 or c[1] + r > 1 + 1e-6:\n            print(f\"Circle {i} violates y-boundary\")\n            return False\n    \n    # Check overlap constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if dist < min_dist - 1e-6:\n                print(f\"Circles {i} and {j} overlap: dist={dist}, min_dist={min_dist}\")\n                return False\n    \n    return True\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for the multi-scale circle packing.\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    \n    print(f\"Number of circles: {len(centers)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Radii range: [{radii.min():.6f}, {radii.max():.6f}]\")\n    print(f\"Radii (sorted): {radii}\")\n    \n    # Verify packing\n    is_valid = verify_packing(centers, radii)\n    print(f\"Packing valid: {is_valid}\")\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    # Optional: Visualize the packing\n    try:\n        import matplotlib.pyplot as plt\n        from matplotlib.patches import Circle\n        \n        fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n        ax.set_xlim(0, 1)\n        ax.set_ylim(0, 1)\n        ax.set_aspect('equal')\n        ax.set_title(f'Multi-scale Packing: 26 circles, Sum of radii = {sum_radii:.4f}')\n        \n        # Color circles by size\n        colors = plt.cm.viridis(radii / radii.max())\n        \n        for i, (center, radius) in enumerate(zip(centers, radii)):\n            circle = Circle(center, radius, fill=True, alpha=0.6, \n                          edgecolor='black', facecolor=colors[i], linewidth=1)\n            ax.add_patch(circle)\n        \n        plt.grid(True, alpha=0.3)\n        plt.tight_layout()\n        plt.savefig('multi_scale_packing_26.png', dpi=150, bbox_inches='tight')\n        print(\"Visualization saved as 'multi_scale_packing_26.png'\")\n        plt.show()\n    except ImportError:\n        print(\"Matplotlib not available for visualization\")",
  "metrics": {
    "valid": true,
    "sum_radii": 2.2075499999995407,
    "target_ratio": 0.8377798861478334,
    "combined_score": 0.8377798861478334,
    "eval_time": 0.6253976821899414,
    "error": null
  },
  "prompt": "Write a multi-scale packing for 26 circles in [0,1]x[0,1].\n\nUse circles of different sizes strategically - larger circles first, then fill gaps with smaller ones.\n\nRequirements:\n- Define construct_packing() that returns (centers, radii, sum_radii)\n- Sort circles by size (start with larger radii)\n- Place larger circles first in optimal positions\n- Fill remaining space with progressively smaller circles\n- Ensure no overlaps and all inside [0,1]x[0,1]\n- Define run_packing() as entry point\n- Use numpy for calculations\n\nStrategy: This mimics natural packing patterns and often achieves high density.",
  "response": "```python\nimport numpy as np\nfrom typing import Tuple, List\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Multi-scale packing of 26 circles using larger circles first, then filling gaps.\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of circle radii (sorted from largest to smallest)\n        sum_radii: sum of all radii\n    \"\"\"\n    centers = []\n    radii = []\n    \n    # Layer 1: Large circles in corners and center (5 circles)\n    # These anchor the packing structure\n    r1 = 0.15\n    large_positions = [\n        (r1, r1),           # bottom-left\n        (1-r1, r1),         # bottom-right\n        (r1, 1-r1),         # top-left\n        (1-r1, 1-r1),       # top-right\n        (0.5, 0.5),         # center\n    ]\n    for pos in large_positions:\n        centers.append(pos)\n        radii.append(r1)\n    \n    # Layer 2: Medium circles along edges (8 circles)\n    r2 = 0.095\n    medium_positions = [\n        (0.5, r2),          # bottom center\n        (0.5, 1-r2),        # top center\n        (r2, 0.5),          # left center\n        (1-r2, 0.5),        # right center\n        (0.28, r2+0.01),    # bottom left-center\n        (0.72, r2+0.01),    # bottom right-center\n        (0.28, 1-r2-0.01),  # top left-center\n        (0.72, 1-r2-0.01),  # top right-center\n    ]\n    for pos in medium_positions:\n        centers.append(pos)\n        radii.append(r2)\n    \n    # Layer 3: Small circles filling gaps (13 circles)\n    r3 = 0.055\n    small_positions = [\n        (0.28, 0.28),\n        (0.72, 0.28),\n        (0.28, 0.72),\n        (0.72, 0.72),\n        (0.5, 0.28),\n        (0.5, 0.72),\n        (0.28, 0.5),\n        (0.72, 0.5),\n        (0.15, 0.35),\n        (0.85, 0.35),\n        (0.15, 0.65),\n        (0.85, 0.65),\n        (0.35, 0.15),\n    ]\n    for pos in small_positions:\n        centers.append(pos)\n        radii.append(r3)\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    \n    # Refine positions to avoid overlaps and ensure all circles are inside\n    centers, radii = refine_packing(centers, radii)\n    \n    # Sort by radius (largest first)\n    sort_idx = np.argsort(-radii)\n    centers = centers[sort_idx]\n    radii = radii[sort_idx]\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef refine_packing(centers: np.ndarray, radii: np.ndarray, \n                   max_iter: int = 1000) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Refine packing to eliminate overlaps and ensure all circles are inside unit square.\n    \"\"\"\n    centers = centers.copy()\n    radii = radii.copy()\n    n = len(centers)\n    \n    for iteration in range(max_iter):\n        moved = False\n        \n        # Check and fix boundary violations\n        for i in range(n):\n            r = radii[i]\n            c = centers[i]\n            \n            # Clamp to boundaries\n            if c[0] - r < 0:\n                centers[i, 0] = r\n                moved = True\n            if c[0] + r > 1:\n                centers[i, 0] = 1 - r\n                moved = True\n            if c[1] - r < 0:\n                centers[i, 1] = r\n                moved = True\n            if c[1] + r > 1:\n                centers[i, 1] = 1 - r\n                moved = True\n        \n        # Check and fix overlaps\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist:\n                    # Move circles apart\n                    if dist > 0:\n                        direction = (centers[j] - centers[i]) / dist\n                    else:\n                        direction = np.random.randn(2)\n                        direction /= np.linalg.norm(direction)\n                    \n                    overlap = min_dist - dist\n                    centers[i] -= direction * overlap * 0.5\n                    centers[j] += direction * overlap * 0.5\n                    moved = True\n        \n        if not moved:\n            break\n    \n    # Final check: shrink radii slightly if still overlapping\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if dist < min_dist:\n                # Shrink both radii proportionally\n                scale = 0.99 * dist / min_dist\n                radii[i] *= scale\n                radii[j] *= scale\n    \n    # Ensure all circles fit in unit square\n    for i in range(n):\n        r = radii[i]\n        c = centers[i]\n        max_r = min(c[0], 1 - c[0], c[1], 1 - c[1])\n        if r > max_r:\n            radii[i] = max_r * 0.99\n    \n    return centers, radii\n\n\ndef verify_packing(centers: np.ndarray, radii: np.ndarray) -> bool:\n    \"\"\"\n    Verify that the packing is valid (no overlaps, all inside unit square).\n    \"\"\"\n    n = len(centers)\n    \n    # Check boundary constraints\n    for i in range(n):\n        c = centers[i]\n        r = radii[i]\n        if c[0] - r < -1e-6 or c[0] + r > 1 + 1e-6:\n            print(f\"Circle {i} violates x-boundary\")\n            return False\n        if c[1] - r < -1e-6 or c[1] + r > 1 + 1e-6:\n            print(f\"Circle {i} violates y-boundary\")\n            return False\n    \n    # Check overlap constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if dist < min_dist - 1e-6:\n                print(f\"Circles {i} and {j} overlap: dist={dist}, min_dist={min_dist}\")\n                return False\n    \n    return True\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for the multi-scale circle packing.\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    \n    print(f\"Number of circles: {len(centers)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Radii range: [{radii.min():.6f}, {radii.max():.6f}]\")\n    print(f\"Radii (sorted): {radii}\")\n    \n    # Verify packing\n    is_valid = verify_packing(centers, radii)\n    print(f\"Packing valid: {is_valid}\")\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    # Optional: Visualize the packing\n    try:\n        import matplotlib.pyplot as plt\n        from matplotlib.patches import Circle\n        \n        fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n        ax.set_xlim(0, 1)\n        ax.set_ylim(0, 1)\n        ax.set_aspect('equal')\n        ax.set_title(f'Multi-scale Packing: 26 circles, Sum of radii = {sum_radii:.4f}')\n        \n        # Color circles by size\n        colors = plt.cm.viridis(radii / radii.max())\n        \n        for i, (center, radius) in enumerate(zip(centers, radii)):\n            circle = Circle(center, radius, fill=True, alpha=0.6, \n                          edgecolor='black', facecolor=colors[i], linewidth=1)\n            ax.add_patch(circle)\n        \n        plt.grid(True, alpha=0.3)\n        plt.tight_layout()\n        plt.savefig('multi_scale_packing_26.png', dpi=150, bbox_inches='tight')\n        print(\"Visualization saved as 'multi_scale_packing_26.png'\")\n        plt.show()\n    except ImportError:\n        print(\"Matplotlib not available for visualization\")\n```\n\nThis implementation uses a multi-scale strategy:\n\n1. **Layer 1 (5 large circles, r\u22480.15)**: Placed at the four corners and center to establish the main structure\n2. **Layer 2 (8 medium circles, r\u22480.095)**: Positioned along edges and between large circles\n3. **Layer 3 (13 small circles, r\u22480.055)**: Fill remaining gaps strategically\n\nThe `refine_packing()` function ensures:\n- No overlaps between circles\n- All circles stay within [0,1]\u00d7[0,1]\n- Iterative adjustment of positions and radii if needed\n\nThe circles are sorted by size (largest first) as required, and the approach mimics natural packing patterns for high density.",
  "reasoning": "This implementation uses a multi-scale strategy:\n\n1. **Layer 1 (5 large circles, r\u22480.15)**: Placed at the four corners and center to establish the main structure\n2. **Layer 2 (8 medium circles, r\u22480.095)**: Positioned along edges and between large circles\n3. **Layer 3 (13 small circles, r\u22480.055)**: Fill remaining gaps strategically\n\nThe `refine_packing()` function ensures:\n- No overlaps between circles\n- All circles stay within [0,1]\u00d7[0,1]\n- Iterative adjustment of positions and radii if needed\n\nThe circles are sorted by size (largest first) as required, and the approach mimics natural packing patterns for high density.",
  "timestamp": "2025-12-05T09:46:18.302598",
  "cost_data": null
}