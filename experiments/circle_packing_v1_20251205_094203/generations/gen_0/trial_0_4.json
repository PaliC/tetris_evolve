{
  "trial_id": "trial_0_4",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Boundary-first circle packing for 26 circles in [0,1]x[0,1].\n    \n    Strategy:\n    1. Place circles along the 4 edges (boundary)\n    2. Fill interior with remaining circles\n    3. Use larger circles on boundary, smaller in interior\n    \n    Returns:\n        centers: np.array of shape (26, 2) with circle centers\n        radii: np.array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    centers = []\n    radii = []\n    \n    # Step 1: Place circles along the boundary\n    # We'll place 16 circles on the boundary (4 per edge)\n    \n    # Boundary circle radius - leave some margin\n    boundary_radius = 0.055\n    margin = boundary_radius  # distance from edge\n    \n    # Top edge (4 circles)\n    top_y = 1.0 - margin\n    top_positions = np.linspace(margin, 1.0 - margin, 4)\n    for x in top_positions:\n        centers.append([x, top_y])\n        radii.append(boundary_radius)\n    \n    # Bottom edge (4 circles)\n    bottom_y = margin\n    bottom_positions = np.linspace(margin, 1.0 - margin, 4)\n    for x in bottom_positions:\n        centers.append([x, bottom_y])\n        radii.append(boundary_radius)\n    \n    # Left edge (4 circles, excluding corners to avoid overlap)\n    left_x = margin\n    left_positions = np.linspace(0.2, 0.8, 4)\n    for y in left_positions:\n        centers.append([left_x, y])\n        radii.append(boundary_radius)\n    \n    # Right edge (4 circles, excluding corners to avoid overlap)\n    right_x = 1.0 - margin\n    right_positions = np.linspace(0.2, 0.8, 4)\n    for y in right_positions:\n        centers.append([right_x, y])\n        radii.append(boundary_radius)\n    \n    # Step 2: Fill interior with remaining 10 circles\n    # Use a grid-based approach for interior circles\n    interior_radius = 0.048\n    \n    # Create a grid of potential interior positions\n    interior_centers = [\n        [0.25, 0.25],\n        [0.25, 0.5],\n        [0.25, 0.75],\n        [0.5, 0.25],\n        [0.5, 0.5],\n        [0.5, 0.75],\n        [0.75, 0.25],\n        [0.75, 0.5],\n        [0.75, 0.75],\n        [0.5, 0.38],  # Additional circle between grid points\n    ]\n    \n    for center in interior_centers:\n        centers.append(center)\n        radii.append(interior_radius)\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    \n    # Step 3: Verify and adjust if needed\n    # Check for overlaps and boundary violations\n    centers, radii = verify_and_adjust(centers, radii)\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef verify_and_adjust(centers, radii, max_iterations=100):\n    \"\"\"\n    Verify packing constraints and make minor adjustments if needed.\n    \n    Args:\n        centers: np.array of circle centers\n        radii: np.array of circle radii\n        max_iterations: maximum adjustment iterations\n    \n    Returns:\n        adjusted centers and radii\n    \"\"\"\n    for iteration in range(max_iterations):\n        adjusted = False\n        \n        # Check boundary constraints\n        for i in range(len(centers)):\n            r = radii[i]\n            c = centers[i]\n            \n            # Ensure circle stays within [0,1]x[0,1]\n            if c[0] - r < 0:\n                centers[i, 0] = r\n                adjusted = True\n            if c[0] + r > 1:\n                centers[i, 0] = 1 - r\n                adjusted = True\n            if c[1] - r < 0:\n                centers[i, 1] = r\n                adjusted = True\n            if c[1] + r > 1:\n                centers[i, 1] = 1 - r\n                adjusted = True\n        \n        # Check for overlaps\n        distances = cdist(centers, centers)\n        n = len(centers)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                min_dist = radii[i] + radii[j]\n                actual_dist = distances[i, j]\n                \n                if actual_dist < min_dist - 1e-6:  # Small tolerance\n                    # Push circles apart slightly\n                    direction = centers[j] - centers[i]\n                    direction_norm = np.linalg.norm(direction)\n                    \n                    if direction_norm > 1e-6:\n                        direction = direction / direction_norm\n                        overlap = (min_dist - actual_dist) / 2\n                        centers[i] -= direction * overlap * 0.5\n                        centers[j] += direction * overlap * 0.5\n                        adjusted = True\n        \n        if not adjusted:\n            break\n    \n    return centers, radii\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for the circle packing algorithm.\n    \n    Returns:\n        centers: np.array of shape (26, 2) with circle centers\n        radii: np.array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    \n    # Verify final constraints\n    assert len(centers) == 26, f\"Expected 26 circles, got {len(centers)}\"\n    assert len(radii) == 26, f\"Expected 26 radii, got {len(radii)}\"\n    assert np.all(radii > 0), \"All radii must be positive\"\n    \n    # Check boundary constraints\n    for i in range(len(centers)):\n        r = radii[i]\n        c = centers[i]\n        assert c[0] - r >= -1e-6, f\"Circle {i} violates left boundary\"\n        assert c[0] + r <= 1 + 1e-6, f\"Circle {i} violates right boundary\"\n        assert c[1] - r >= -1e-6, f\"Circle {i} violates bottom boundary\"\n        assert c[1] + r <= 1 + 1e-6, f\"Circle {i} violates top boundary\"\n    \n    # Check overlap constraints\n    distances = cdist(centers, centers)\n    n = len(centers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            min_dist = radii[i] + radii[j]\n            actual_dist = distances[i, j]\n            assert actual_dist >= min_dist - 1e-6, \\\n                f\"Circles {i} and {j} overlap: dist={actual_dist:.6f}, min={min_dist:.6f}\"\n    \n    print(f\"Successfully packed 26 circles\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.36,
    "target_ratio": 0.5161290322580646,
    "combined_score": 0.5161290322580646,
    "eval_time": 0.12756705284118652,
    "error": null
  },
  "prompt": "Write a boundary-first circle packing for 26 circles in [0,1]x[0,1].\n\nStrategy: Place larger circles along the boundary first, then pack smaller circles in the interior.\n\nRequirements:\n- Define construct_packing() that returns (centers, radii, sum_radii)\n- Place circles along the 4 edges of the square first\n- Fill interior with remaining circles\n- Calculate radii based on available space\n- Ensure no overlaps and all inside [0,1]x[0,1]\n- Define run_packing() as entry point\n- Use numpy for calculations\n\nThis approach often works well for fixed-count packing problems.",
  "response": "```python\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Boundary-first circle packing for 26 circles in [0,1]x[0,1].\n    \n    Strategy:\n    1. Place circles along the 4 edges (boundary)\n    2. Fill interior with remaining circles\n    3. Use larger circles on boundary, smaller in interior\n    \n    Returns:\n        centers: np.array of shape (26, 2) with circle centers\n        radii: np.array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    centers = []\n    radii = []\n    \n    # Step 1: Place circles along the boundary\n    # We'll place 16 circles on the boundary (4 per edge)\n    \n    # Boundary circle radius - leave some margin\n    boundary_radius = 0.055\n    margin = boundary_radius  # distance from edge\n    \n    # Top edge (4 circles)\n    top_y = 1.0 - margin\n    top_positions = np.linspace(margin, 1.0 - margin, 4)\n    for x in top_positions:\n        centers.append([x, top_y])\n        radii.append(boundary_radius)\n    \n    # Bottom edge (4 circles)\n    bottom_y = margin\n    bottom_positions = np.linspace(margin, 1.0 - margin, 4)\n    for x in bottom_positions:\n        centers.append([x, bottom_y])\n        radii.append(boundary_radius)\n    \n    # Left edge (4 circles, excluding corners to avoid overlap)\n    left_x = margin\n    left_positions = np.linspace(0.2, 0.8, 4)\n    for y in left_positions:\n        centers.append([left_x, y])\n        radii.append(boundary_radius)\n    \n    # Right edge (4 circles, excluding corners to avoid overlap)\n    right_x = 1.0 - margin\n    right_positions = np.linspace(0.2, 0.8, 4)\n    for y in right_positions:\n        centers.append([right_x, y])\n        radii.append(boundary_radius)\n    \n    # Step 2: Fill interior with remaining 10 circles\n    # Use a grid-based approach for interior circles\n    interior_radius = 0.048\n    \n    # Create a grid of potential interior positions\n    interior_centers = [\n        [0.25, 0.25],\n        [0.25, 0.5],\n        [0.25, 0.75],\n        [0.5, 0.25],\n        [0.5, 0.5],\n        [0.5, 0.75],\n        [0.75, 0.25],\n        [0.75, 0.5],\n        [0.75, 0.75],\n        [0.5, 0.38],  # Additional circle between grid points\n    ]\n    \n    for center in interior_centers:\n        centers.append(center)\n        radii.append(interior_radius)\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    \n    # Step 3: Verify and adjust if needed\n    # Check for overlaps and boundary violations\n    centers, radii = verify_and_adjust(centers, radii)\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef verify_and_adjust(centers, radii, max_iterations=100):\n    \"\"\"\n    Verify packing constraints and make minor adjustments if needed.\n    \n    Args:\n        centers: np.array of circle centers\n        radii: np.array of circle radii\n        max_iterations: maximum adjustment iterations\n    \n    Returns:\n        adjusted centers and radii\n    \"\"\"\n    for iteration in range(max_iterations):\n        adjusted = False\n        \n        # Check boundary constraints\n        for i in range(len(centers)):\n            r = radii[i]\n            c = centers[i]\n            \n            # Ensure circle stays within [0,1]x[0,1]\n            if c[0] - r < 0:\n                centers[i, 0] = r\n                adjusted = True\n            if c[0] + r > 1:\n                centers[i, 0] = 1 - r\n                adjusted = True\n            if c[1] - r < 0:\n                centers[i, 1] = r\n                adjusted = True\n            if c[1] + r > 1:\n                centers[i, 1] = 1 - r\n                adjusted = True\n        \n        # Check for overlaps\n        distances = cdist(centers, centers)\n        n = len(centers)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                min_dist = radii[i] + radii[j]\n                actual_dist = distances[i, j]\n                \n                if actual_dist < min_dist - 1e-6:  # Small tolerance\n                    # Push circles apart slightly\n                    direction = centers[j] - centers[i]\n                    direction_norm = np.linalg.norm(direction)\n                    \n                    if direction_norm > 1e-6:\n                        direction = direction / direction_norm\n                        overlap = (min_dist - actual_dist) / 2\n                        centers[i] -= direction * overlap * 0.5\n                        centers[j] += direction * overlap * 0.5\n                        adjusted = True\n        \n        if not adjusted:\n            break\n    \n    return centers, radii\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for the circle packing algorithm.\n    \n    Returns:\n        centers: np.array of shape (26, 2) with circle centers\n        radii: np.array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    \n    # Verify final constraints\n    assert len(centers) == 26, f\"Expected 26 circles, got {len(centers)}\"\n    assert len(radii) == 26, f\"Expected 26 radii, got {len(radii)}\"\n    assert np.all(radii > 0), \"All radii must be positive\"\n    \n    # Check boundary constraints\n    for i in range(len(centers)):\n        r = radii[i]\n        c = centers[i]\n        assert c[0] - r >= -1e-6, f\"Circle {i} violates left boundary\"\n        assert c[0] + r <= 1 + 1e-6, f\"Circle {i} violates right boundary\"\n        assert c[1] - r >= -1e-6, f\"Circle {i} violates bottom boundary\"\n        assert c[1] + r <= 1 + 1e-6, f\"Circle {i} violates top boundary\"\n    \n    # Check overlap constraints\n    distances = cdist(centers, centers)\n    n = len(centers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            min_dist = radii[i] + radii[j]\n            actual_dist = distances[i, j]\n            assert actual_dist >= min_dist - 1e-6, \\\n                f\"Circles {i} and {j} overlap: dist={actual_dist:.6f}, min={min_dist:.6f}\"\n    \n    print(f\"Successfully packed 26 circles\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T09:46:18.301719",
  "cost_data": null
}