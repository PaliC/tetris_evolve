{
  "trial_id": "trial_0_5",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle\n\ndef construct_packing(n_circles=26, max_iterations=50000, initial_temp=1.0, cooling_rate=0.9995):\n    \"\"\"\n    Constructs a circle packing using simulated annealing.\n    \n    Returns:\n        centers: numpy array of shape (n_circles, 2) with circle centers\n        radii: numpy array of shape (n_circles,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    np.random.seed(42)\n    \n    # Initialize circles on a grid with small radii\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    centers = np.zeros((n_circles, 2))\n    idx = 0\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if idx >= n_circles:\n                break\n            centers[idx] = [(i + 0.5) / grid_size, (j + 0.5) / grid_size]\n            idx += 1\n    \n    # Initialize radii to small values\n    radii = np.full(n_circles, 0.02)\n    \n    # Simulated annealing parameters\n    temp = initial_temp\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    def check_constraints(centers, radii):\n        \"\"\"Check if all constraints are satisfied.\"\"\"\n        # Check if circles are inside [0,1]x[0,1]\n        for i in range(n_circles):\n            if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n                centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n                return False\n        \n        # Check for overlaps\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-6:  # Small tolerance\n                    return False\n        return True\n    \n    def compute_penalty(centers, radii):\n        \"\"\"Compute penalty for constraint violations.\"\"\"\n        penalty = 0.0\n        \n        # Penalty for being outside square\n        for i in range(n_circles):\n            if centers[i, 0] - radii[i] < 0:\n                penalty += (radii[i] - centers[i, 0]) * 10\n            if centers[i, 0] + radii[i] > 1:\n                penalty += (centers[i, 0] + radii[i] - 1) * 10\n            if centers[i, 1] - radii[i] < 0:\n                penalty += (radii[i] - centers[i, 1]) * 10\n            if centers[i, 1] + radii[i] > 1:\n                penalty += (centers[i, 1] + radii[i] - 1) * 10\n        \n        # Penalty for overlaps\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    penalty += overlap * 20\n        \n        return penalty\n    \n    def objective(centers, radii):\n        \"\"\"Objective function: maximize sum of radii minus penalties.\"\"\"\n        return np.sum(radii) - compute_penalty(centers, radii)\n    \n    current_obj = objective(centers, radii)\n    \n    # Simulated annealing loop\n    for iteration in range(max_iterations):\n        # Create a copy for perturbation\n        new_centers = centers.copy()\n        new_radii = radii.copy()\n        \n        # Choose perturbation type\n        perturbation_type = np.random.rand()\n        \n        if perturbation_type < 0.4:\n            # Move a random circle\n            idx = np.random.randint(n_circles)\n            step_size = 0.05 * (temp / initial_temp)\n            new_centers[idx] += np.random.randn(2) * step_size\n            new_centers[idx] = np.clip(new_centers[idx], 0, 1)\n            \n        elif perturbation_type < 0.7:\n            # Change radius of a random circle\n            idx = np.random.randint(n_circles)\n            delta = np.random.randn() * 0.01 * (temp / initial_temp)\n            new_radii[idx] = max(0.005, new_radii[idx] + delta)\n            \n        else:\n            # Try to grow all radii slightly\n            growth_factor = 1.0 + np.random.uniform(0, 0.02)\n            new_radii *= growth_factor\n        \n        # Compute new objective\n        new_obj = objective(new_centers, new_radii)\n        \n        # Accept or reject based on Metropolis criterion\n        delta_obj = new_obj - current_obj\n        \n        if delta_obj > 0 or np.random.rand() < np.exp(delta_obj / temp):\n            centers = new_centers\n            radii = new_radii\n            current_obj = new_obj\n            \n            # Update best solution if valid and better\n            if check_constraints(centers, radii):\n                current_sum = np.sum(radii)\n                if current_sum > best_sum:\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n                    best_sum = current_sum\n        \n        # Cool down temperature\n        temp *= cooling_rate\n        \n        # Print progress\n        if iteration % 5000 == 0:\n            print(f\"Iteration {iteration}, Temp: {temp:.6f}, Current obj: {current_obj:.4f}, Best sum: {best_sum:.4f}\")\n    \n    print(f\"\\nFinal sum of radii: {best_sum:.6f}\")\n    print(f\"Valid packing: {check_constraints(best_centers, best_radii)}\")\n    \n    return best_centers, best_radii, best_sum\n\n\ndef visualize_packing(centers, radii):\n    \"\"\"Visualize the circle packing.\"\"\"\n    fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n    \n    # Draw the square\n    ax.plot([0, 1, 1, 0, 0], [0, 0, 1, 1, 0], 'k-', linewidth=2)\n    \n    # Draw circles\n    for i in range(len(centers)):\n        circle = Circle(centers[i], radii[i], fill=False, edgecolor='blue', linewidth=1.5)\n        ax.add_patch(circle)\n    \n    ax.set_xlim(-0.1, 1.1)\n    ax.set_ylim(-0.1, 1.1)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    ax.set_title(f'Circle Packing: {len(centers)} circles, Sum of radii = {np.sum(radii):.4f}')\n    \n    plt.tight_layout()\n    plt.savefig('circle_packing.png', dpi=150, bbox_inches='tight')\n    print(\"Visualization saved as 'circle_packing.png'\")\n    plt.show()\n\n\ndef run_packing():\n    \"\"\"Entry point for the circle packing algorithm.\"\"\"\n    print(\"Starting simulated annealing circle packing...\")\n    print(\"=\" * 60)\n    \n    centers, radii, sum_radii = construct_packing(\n        n_circles=26,\n        max_iterations=50000,\n        initial_temp=1.0,\n        cooling_rate=0.9995\n    )\n    \n    print(\"=\" * 60)\n    print(f\"\\nPacking complete!\")\n    print(f\"Number of circles: {len(centers)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    visualize_packing(centers, radii)\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 0.5447756367298864,
    "target_ratio": 0.2067459721935053,
    "combined_score": 0.2067459721935053,
    "eval_time": 27.401108980178833,
    "error": null
  },
  "prompt": "Write a simulated annealing circle packing for 26 circles in [0,1]x[0,1].\n\nUse simulated annealing to optimize circle positions and radii.\n\nRequirements:\n- Define construct_packing() that returns (centers, radii, sum_radii)\n- Start with random or grid initialization\n- Iteratively perturb positions/radii and accept based on temperature\n- Objective: maximize sum of radii\n- Ensure constraints: no overlaps, inside square\n- Define run_packing() as entry point\n- Use numpy for calculations\n\nStrategy: Use temperature schedule, accept worse solutions early to escape local minima.",
  "response": "```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle\n\ndef construct_packing(n_circles=26, max_iterations=50000, initial_temp=1.0, cooling_rate=0.9995):\n    \"\"\"\n    Constructs a circle packing using simulated annealing.\n    \n    Returns:\n        centers: numpy array of shape (n_circles, 2) with circle centers\n        radii: numpy array of shape (n_circles,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    np.random.seed(42)\n    \n    # Initialize circles on a grid with small radii\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    centers = np.zeros((n_circles, 2))\n    idx = 0\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if idx >= n_circles:\n                break\n            centers[idx] = [(i + 0.5) / grid_size, (j + 0.5) / grid_size]\n            idx += 1\n    \n    # Initialize radii to small values\n    radii = np.full(n_circles, 0.02)\n    \n    # Simulated annealing parameters\n    temp = initial_temp\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    def check_constraints(centers, radii):\n        \"\"\"Check if all constraints are satisfied.\"\"\"\n        # Check if circles are inside [0,1]x[0,1]\n        for i in range(n_circles):\n            if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n                centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n                return False\n        \n        # Check for overlaps\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-6:  # Small tolerance\n                    return False\n        return True\n    \n    def compute_penalty(centers, radii):\n        \"\"\"Compute penalty for constraint violations.\"\"\"\n        penalty = 0.0\n        \n        # Penalty for being outside square\n        for i in range(n_circles):\n            if centers[i, 0] - radii[i] < 0:\n                penalty += (radii[i] - centers[i, 0]) * 10\n            if centers[i, 0] + radii[i] > 1:\n                penalty += (centers[i, 0] + radii[i] - 1) * 10\n            if centers[i, 1] - radii[i] < 0:\n                penalty += (radii[i] - centers[i, 1]) * 10\n            if centers[i, 1] + radii[i] > 1:\n                penalty += (centers[i, 1] + radii[i] - 1) * 10\n        \n        # Penalty for overlaps\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    penalty += overlap * 20\n        \n        return penalty\n    \n    def objective(centers, radii):\n        \"\"\"Objective function: maximize sum of radii minus penalties.\"\"\"\n        return np.sum(radii) - compute_penalty(centers, radii)\n    \n    current_obj = objective(centers, radii)\n    \n    # Simulated annealing loop\n    for iteration in range(max_iterations):\n        # Create a copy for perturbation\n        new_centers = centers.copy()\n        new_radii = radii.copy()\n        \n        # Choose perturbation type\n        perturbation_type = np.random.rand()\n        \n        if perturbation_type < 0.4:\n            # Move a random circle\n            idx = np.random.randint(n_circles)\n            step_size = 0.05 * (temp / initial_temp)\n            new_centers[idx] += np.random.randn(2) * step_size\n            new_centers[idx] = np.clip(new_centers[idx], 0, 1)\n            \n        elif perturbation_type < 0.7:\n            # Change radius of a random circle\n            idx = np.random.randint(n_circles)\n            delta = np.random.randn() * 0.01 * (temp / initial_temp)\n            new_radii[idx] = max(0.005, new_radii[idx] + delta)\n            \n        else:\n            # Try to grow all radii slightly\n            growth_factor = 1.0 + np.random.uniform(0, 0.02)\n            new_radii *= growth_factor\n        \n        # Compute new objective\n        new_obj = objective(new_centers, new_radii)\n        \n        # Accept or reject based on Metropolis criterion\n        delta_obj = new_obj - current_obj\n        \n        if delta_obj > 0 or np.random.rand() < np.exp(delta_obj / temp):\n            centers = new_centers\n            radii = new_radii\n            current_obj = new_obj\n            \n            # Update best solution if valid and better\n            if check_constraints(centers, radii):\n                current_sum = np.sum(radii)\n                if current_sum > best_sum:\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n                    best_sum = current_sum\n        \n        # Cool down temperature\n        temp *= cooling_rate\n        \n        # Print progress\n        if iteration % 5000 == 0:\n            print(f\"Iteration {iteration}, Temp: {temp:.6f}, Current obj: {current_obj:.4f}, Best sum: {best_sum:.4f}\")\n    \n    print(f\"\\nFinal sum of radii: {best_sum:.6f}\")\n    print(f\"Valid packing: {check_constraints(best_centers, best_radii)}\")\n    \n    return best_centers, best_radii, best_sum\n\n\ndef visualize_packing(centers, radii):\n    \"\"\"Visualize the circle packing.\"\"\"\n    fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n    \n    # Draw the square\n    ax.plot([0, 1, 1, 0, 0], [0, 0, 1, 1, 0], 'k-', linewidth=2)\n    \n    # Draw circles\n    for i in range(len(centers)):\n        circle = Circle(centers[i], radii[i], fill=False, edgecolor='blue', linewidth=1.5)\n        ax.add_patch(circle)\n    \n    ax.set_xlim(-0.1, 1.1)\n    ax.set_ylim(-0.1, 1.1)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    ax.set_title(f'Circle Packing: {len(centers)} circles, Sum of radii = {np.sum(radii):.4f}')\n    \n    plt.tight_layout()\n    plt.savefig('circle_packing.png', dpi=150, bbox_inches='tight')\n    print(\"Visualization saved as 'circle_packing.png'\")\n    plt.show()\n\n\ndef run_packing():\n    \"\"\"Entry point for the circle packing algorithm.\"\"\"\n    print(\"Starting simulated annealing circle packing...\")\n    print(\"=\" * 60)\n    \n    centers, radii, sum_radii = construct_packing(\n        n_circles=26,\n        max_iterations=50000,\n        initial_temp=1.0,\n        cooling_rate=0.9995\n    )\n    \n    print(\"=\" * 60)\n    print(f\"\\nPacking complete!\")\n    print(f\"Number of circles: {len(centers)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    visualize_packing(centers, radii)\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n```\n\nThis implementation provides a complete simulated annealing solution for circle packing with the following features:\n\n**Key Components:**\n\n1. **`construct_packing()`**: Main optimization function that:\n   - Initializes circles on a grid\n   - Uses simulated annealing with temperature cooling\n   - Applies three types of perturbations: position moves, radius changes, and global growth\n   - Uses penalty-based objective function for constraint handling\n   - Tracks the best valid solution found\n\n2. **Constraint Handling**:\n   - Checks circles stay within [0,1]\u00d7[0,1]\n   - Prevents overlaps between circles\n   - Uses soft penalties in objective function for exploration\n\n3. **Simulated Annealing Strategy**:\n   - Temperature-dependent step sizes for gradual refinement\n   - Metropolis acceptance criterion for escaping local minima\n   - Exponential cooling schedule\n   - Multiple perturbation types for diverse exploration\n\n4. **`run_packing()`**: Entry point that executes the algorithm and displays results\n\n5. **Visualization**: Creates a matplotlib figure showing the final packing\n\nThe algorithm balances exploration (accepting worse solutions early) with exploitation (refining good solutions as temperature decreases) to find high-quality packings.",
  "reasoning": "This implementation provides a complete simulated annealing solution for circle packing with the following features:\n\n**Key Components:**\n\n1. **`construct_packing()`**: Main optimization function that:\n   - Initializes circles on a grid\n   - Uses simulated annealing with temperature cooling\n   - Applies three types of perturbations: position moves, radius changes, and global growth\n   - Uses penalty-based objective function for constraint handling\n   - Tracks the best valid solution found\n\n2. **Constraint Handling**:\n   - Checks circles stay within [0,1]\u00d7[0,1]\n   - Prevents overlaps between circles\n   - Uses soft penalties in objective function for exploration\n\n3. **Simulated Annealing Strategy**:\n   - Temperature-dependent step sizes for gradual refinement\n   - Metropolis acceptance criterion for escaping local minima\n   - Exponential cooling schedule\n   - Multiple perturbation types for diverse exploration\n\n4. **`run_packing()`**: Entry point that executes the algorithm and displays results\n\n5. **Visualization**: Creates a matplotlib figure showing the final packing\n\nThe algorithm balances exploration (accepting worse solutions early) with exploitation (refining good solutions as temperature decreases) to find high-quality packings.",
  "timestamp": "2025-12-05T09:46:18.302080",
  "cost_data": null
}