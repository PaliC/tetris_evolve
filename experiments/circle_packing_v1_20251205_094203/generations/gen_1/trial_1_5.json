{
  "trial_id": "trial_1_5",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize_scalar\nfrom typing import Tuple, List\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Construct optimized hexagonal packing for exactly 26 circles.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) with circle centers\n        radii: np.ndarray of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    \n    def generate_hex_grid(rows: int, cols: int, spacing: float, orientation: float = 0) -> np.ndarray:\n        \"\"\"Generate hexagonal grid points.\"\"\"\n        points = []\n        for row in range(rows):\n            for col in range(cols):\n                x = col * spacing\n                y = row * spacing * np.sqrt(3) / 2\n                # Offset every other row for hexagonal packing\n                if row % 2 == 1:\n                    x += spacing / 2\n                points.append([x, y])\n        \n        points = np.array(points)\n        \n        # Apply rotation\n        if orientation != 0:\n            theta = np.radians(orientation)\n            rot_matrix = np.array([\n                [np.cos(theta), -np.sin(theta)],\n                [np.sin(theta), np.cos(theta)]\n            ])\n            points = points @ rot_matrix.T\n        \n        return points\n    \n    def try_configuration(rows: int, cols: int, orientation: float = 0) -> Tuple[np.ndarray, float]:\n        \"\"\"Try a specific grid configuration and optimize spacing.\"\"\"\n        \n        def objective(spacing: float) -> float:\n            \"\"\"Negative radius (to maximize radius via minimization).\"\"\"\n            if spacing <= 0:\n                return 1e10\n            \n            points = generate_hex_grid(rows, cols, spacing, orientation)\n            \n            # Take first 26 points\n            if len(points) < 26:\n                return 1e10\n            points = points[:26]\n            \n            # Center the points\n            center = (points.min(axis=0) + points.max(axis=0)) / 2\n            points = points - center\n            \n            # Find bounding box\n            min_coords = points.min(axis=0)\n            max_coords = points.max(axis=0)\n            width = max_coords[0] - min_coords[0]\n            height = max_coords[1] - min_coords[1]\n            \n            # Calculate minimum distance between any two points\n            min_dist = np.inf\n            for i in range(len(points)):\n                for j in range(i + 1, len(points)):\n                    dist = np.linalg.norm(points[i] - points[j])\n                    min_dist = min(min_dist, dist)\n            \n            # Radius is limited by:\n            # 1. Half the minimum distance between points (no overlap)\n            # 2. Distance to boundary\n            radius_from_spacing = min_dist / 2\n            \n            # Scale to fit in [0, 1] x [0, 1]\n            scale = min(1.0 / (width + 2 * radius_from_spacing),\n                       1.0 / (height + 2 * radius_from_spacing))\n            \n            final_radius = radius_from_spacing * scale\n            \n            return -final_radius  # Negative because we minimize\n        \n        # Optimize spacing\n        result = minimize_scalar(objective, bounds=(0.01, 2.0), method='bounded')\n        optimal_spacing = result.x\n        optimal_radius = -result.fun\n        \n        # Generate final configuration\n        points = generate_hex_grid(rows, cols, optimal_spacing, orientation)[:26]\n        \n        return points, optimal_radius\n    \n    # Try different grid configurations and orientations\n    configurations = [\n        (4, 7, 0),    # 4 rows, 7 cols, 0\u00b0 rotation (28 points, take 26)\n        (5, 6, 0),    # 5 rows, 6 cols, 0\u00b0 rotation (30 points, take 26)\n        (3, 9, 0),    # 3 rows, 9 cols, 0\u00b0 rotation (27 points, take 26)\n        (4, 7, 30),   # With 30\u00b0 rotation\n        (5, 6, 30),   # With 30\u00b0 rotation\n        (6, 5, 0),    # 6 rows, 5 cols\n        (6, 5, 15),   # With 15\u00b0 rotation\n        (7, 4, 0),    # 7 rows, 4 cols\n    ]\n    \n    best_radius = 0\n    best_centers = None\n    best_config = None\n    \n    for rows, cols, orientation in configurations:\n        if rows * cols >= 26:\n            points, radius = try_configuration(rows, cols, orientation)\n            if radius > best_radius:\n                best_radius = radius\n                best_centers = points\n                best_config = (rows, cols, orientation)\n    \n    # Final optimization: scale and center the best configuration\n    optimal_spacing_result = minimize_scalar(\n        lambda s: compute_final_radius(best_config[0], best_config[1], best_config[2], s),\n        bounds=(0.01, 2.0),\n        method='bounded'\n    )\n    \n    optimal_spacing = optimal_spacing_result.x\n    centers = generate_hex_grid(best_config[0], best_config[1], optimal_spacing, best_config[2])[:26]\n    \n    # Center the configuration\n    center = (centers.min(axis=0) + centers.max(axis=0)) / 2\n    centers = centers - center\n    \n    # Calculate radius\n    min_dist = np.inf\n    for i in range(len(centers)):\n        for j in range(i + 1, len(centers)):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            min_dist = min(min_dist, dist)\n    \n    radius = min_dist / 2\n    \n    # Scale to fit in [0, 1] x [0, 1] with margin\n    min_coords = centers.min(axis=0)\n    max_coords = centers.max(axis=0)\n    width = max_coords[0] - min_coords[0]\n    height = max_coords[1] - min_coords[1]\n    \n    scale = min(1.0 / (width + 2 * radius), 1.0 / (height + 2 * radius))\n    centers = centers * scale\n    radius = radius * scale\n    \n    # Translate to [0, 1] x [0, 1]\n    centers = centers + 0.5\n    \n    radii = np.full(26, radius)\n    sum_radii = float(np.sum(radii))\n    \n    return centers, radii, sum_radii\n\ndef compute_final_radius(rows: int, cols: int, orientation: float, spacing: float) -> float:\n    \"\"\"Helper function to compute final radius for optimization.\"\"\"\n    def generate_hex_grid(rows: int, cols: int, spacing: float, orientation: float = 0) -> np.ndarray:\n        points = []\n        for row in range(rows):\n            for col in range(cols):\n                x = col * spacing\n                y = row * spacing * np.sqrt(3) / 2\n                if row % 2 == 1:\n                    x += spacing / 2\n                points.append([x, y])\n        \n        points = np.array(points)\n        \n        if orientation != 0:\n            theta = np.radians(orientation)\n            rot_matrix = np.array([\n                [np.cos(theta), -np.sin(theta)],\n                [np.sin(theta), np.cos(theta)]\n            ])\n            points = points @ rot_matrix.T\n        \n        return points\n    \n    points = generate_hex_grid(rows, cols, spacing, orientation)[:26]\n    center = (points.min(axis=0) + points.max(axis=0)) / 2\n    points = points - center\n    \n    min_dist = np.inf\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            dist = np.linalg.norm(points[i] - points[j])\n            min_dist = min(min_dist, dist)\n    \n    radius = min_dist / 2\n    \n    min_coords = points.min(axis=0)\n    max_coords = points.max(axis=0)\n    width = max_coords[0] - min_coords[0]\n    height = max_coords[1] - min_coords[1]\n    \n    scale = min(1.0 / (width + 2 * radius), 1.0 / (height + 2 * radius))\n    final_radius = radius * scale\n    \n    return -final_radius\n\ndef run_packing():\n    \"\"\"Entry point for the packing algorithm.\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    \n    print(f\"Number of circles: {len(centers)}\")\n    print(f\"Radius (uniform): {radii[0]:.6f}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Centers shape: {centers.shape}\")\n    \n    return centers, radii, sum_radii\n\nif __name__ == \"__main__\":\n    run_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.3636363636363633,
    "target_ratio": 0.897015697774711,
    "combined_score": 0.897015697774711,
    "eval_time": 0.25803089141845703,
    "error": null
  },
  "prompt": "Write a hexagonal packing with OPTIMIZED spacing for exactly 26 circles.\n\nUse hexagonal lattice but optimize the lattice spacing and orientation for 26 circles.\n\nTASK:\n1. Create hexagonal grid pattern\n2. Select 26 positions from the grid\n3. Optimize spacing parameter to maximize circle radii\n4. Try different orientations (0\u00b0, 30\u00b0, 45\u00b0)\n5. Center and scale the pattern optimally in [0,1]x[0,1]\n\nHexagonal packing is theoretically optimal for infinite plane, adapt it for n=26.\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Use numpy\n- All circles same radius (uniform packing)\n- Ensure no overlaps, all inside [0,1]x[0,1]",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize_scalar\nfrom typing import Tuple, List\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Construct optimized hexagonal packing for exactly 26 circles.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) with circle centers\n        radii: np.ndarray of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    \n    def generate_hex_grid(rows: int, cols: int, spacing: float, orientation: float = 0) -> np.ndarray:\n        \"\"\"Generate hexagonal grid points.\"\"\"\n        points = []\n        for row in range(rows):\n            for col in range(cols):\n                x = col * spacing\n                y = row * spacing * np.sqrt(3) / 2\n                # Offset every other row for hexagonal packing\n                if row % 2 == 1:\n                    x += spacing / 2\n                points.append([x, y])\n        \n        points = np.array(points)\n        \n        # Apply rotation\n        if orientation != 0:\n            theta = np.radians(orientation)\n            rot_matrix = np.array([\n                [np.cos(theta), -np.sin(theta)],\n                [np.sin(theta), np.cos(theta)]\n            ])\n            points = points @ rot_matrix.T\n        \n        return points\n    \n    def try_configuration(rows: int, cols: int, orientation: float = 0) -> Tuple[np.ndarray, float]:\n        \"\"\"Try a specific grid configuration and optimize spacing.\"\"\"\n        \n        def objective(spacing: float) -> float:\n            \"\"\"Negative radius (to maximize radius via minimization).\"\"\"\n            if spacing <= 0:\n                return 1e10\n            \n            points = generate_hex_grid(rows, cols, spacing, orientation)\n            \n            # Take first 26 points\n            if len(points) < 26:\n                return 1e10\n            points = points[:26]\n            \n            # Center the points\n            center = (points.min(axis=0) + points.max(axis=0)) / 2\n            points = points - center\n            \n            # Find bounding box\n            min_coords = points.min(axis=0)\n            max_coords = points.max(axis=0)\n            width = max_coords[0] - min_coords[0]\n            height = max_coords[1] - min_coords[1]\n            \n            # Calculate minimum distance between any two points\n            min_dist = np.inf\n            for i in range(len(points)):\n                for j in range(i + 1, len(points)):\n                    dist = np.linalg.norm(points[i] - points[j])\n                    min_dist = min(min_dist, dist)\n            \n            # Radius is limited by:\n            # 1. Half the minimum distance between points (no overlap)\n            # 2. Distance to boundary\n            radius_from_spacing = min_dist / 2\n            \n            # Scale to fit in [0, 1] x [0, 1]\n            scale = min(1.0 / (width + 2 * radius_from_spacing),\n                       1.0 / (height + 2 * radius_from_spacing))\n            \n            final_radius = radius_from_spacing * scale\n            \n            return -final_radius  # Negative because we minimize\n        \n        # Optimize spacing\n        result = minimize_scalar(objective, bounds=(0.01, 2.0), method='bounded')\n        optimal_spacing = result.x\n        optimal_radius = -result.fun\n        \n        # Generate final configuration\n        points = generate_hex_grid(rows, cols, optimal_spacing, orientation)[:26]\n        \n        return points, optimal_radius\n    \n    # Try different grid configurations and orientations\n    configurations = [\n        (4, 7, 0),    # 4 rows, 7 cols, 0\u00b0 rotation (28 points, take 26)\n        (5, 6, 0),    # 5 rows, 6 cols, 0\u00b0 rotation (30 points, take 26)\n        (3, 9, 0),    # 3 rows, 9 cols, 0\u00b0 rotation (27 points, take 26)\n        (4, 7, 30),   # With 30\u00b0 rotation\n        (5, 6, 30),   # With 30\u00b0 rotation\n        (6, 5, 0),    # 6 rows, 5 cols\n        (6, 5, 15),   # With 15\u00b0 rotation\n        (7, 4, 0),    # 7 rows, 4 cols\n    ]\n    \n    best_radius = 0\n    best_centers = None\n    best_config = None\n    \n    for rows, cols, orientation in configurations:\n        if rows * cols >= 26:\n            points, radius = try_configuration(rows, cols, orientation)\n            if radius > best_radius:\n                best_radius = radius\n                best_centers = points\n                best_config = (rows, cols, orientation)\n    \n    # Final optimization: scale and center the best configuration\n    optimal_spacing_result = minimize_scalar(\n        lambda s: compute_final_radius(best_config[0], best_config[1], best_config[2], s),\n        bounds=(0.01, 2.0),\n        method='bounded'\n    )\n    \n    optimal_spacing = optimal_spacing_result.x\n    centers = generate_hex_grid(best_config[0], best_config[1], optimal_spacing, best_config[2])[:26]\n    \n    # Center the configuration\n    center = (centers.min(axis=0) + centers.max(axis=0)) / 2\n    centers = centers - center\n    \n    # Calculate radius\n    min_dist = np.inf\n    for i in range(len(centers)):\n        for j in range(i + 1, len(centers)):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            min_dist = min(min_dist, dist)\n    \n    radius = min_dist / 2\n    \n    # Scale to fit in [0, 1] x [0, 1] with margin\n    min_coords = centers.min(axis=0)\n    max_coords = centers.max(axis=0)\n    width = max_coords[0] - min_coords[0]\n    height = max_coords[1] - min_coords[1]\n    \n    scale = min(1.0 / (width + 2 * radius), 1.0 / (height + 2 * radius))\n    centers = centers * scale\n    radius = radius * scale\n    \n    # Translate to [0, 1] x [0, 1]\n    centers = centers + 0.5\n    \n    radii = np.full(26, radius)\n    sum_radii = float(np.sum(radii))\n    \n    return centers, radii, sum_radii\n\ndef compute_final_radius(rows: int, cols: int, orientation: float, spacing: float) -> float:\n    \"\"\"Helper function to compute final radius for optimization.\"\"\"\n    def generate_hex_grid(rows: int, cols: int, spacing: float, orientation: float = 0) -> np.ndarray:\n        points = []\n        for row in range(rows):\n            for col in range(cols):\n                x = col * spacing\n                y = row * spacing * np.sqrt(3) / 2\n                if row % 2 == 1:\n                    x += spacing / 2\n                points.append([x, y])\n        \n        points = np.array(points)\n        \n        if orientation != 0:\n            theta = np.radians(orientation)\n            rot_matrix = np.array([\n                [np.cos(theta), -np.sin(theta)],\n                [np.sin(theta), np.cos(theta)]\n            ])\n            points = points @ rot_matrix.T\n        \n        return points\n    \n    points = generate_hex_grid(rows, cols, spacing, orientation)[:26]\n    center = (points.min(axis=0) + points.max(axis=0)) / 2\n    points = points - center\n    \n    min_dist = np.inf\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            dist = np.linalg.norm(points[i] - points[j])\n            min_dist = min(min_dist, dist)\n    \n    radius = min_dist / 2\n    \n    min_coords = points.min(axis=0)\n    max_coords = points.max(axis=0)\n    width = max_coords[0] - min_coords[0]\n    height = max_coords[1] - min_coords[1]\n    \n    scale = min(1.0 / (width + 2 * radius), 1.0 / (height + 2 * radius))\n    final_radius = radius * scale\n    \n    return -final_radius\n\ndef run_packing():\n    \"\"\"Entry point for the packing algorithm.\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    \n    print(f\"Number of circles: {len(centers)}\")\n    print(f\"Radius (uniform): {radii[0]:.6f}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Centers shape: {centers.shape}\")\n    \n    return centers, radii, sum_radii\n\nif __name__ == \"__main__\":\n    run_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T09:49:12.906722",
  "cost_data": null
}