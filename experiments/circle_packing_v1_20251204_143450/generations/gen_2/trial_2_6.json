{
  "trial_id": "trial_2_6",
  "generation": 2,
  "parent_id": "trial_2_1",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import cdist\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef construct_packing():\n    \"\"\"\n    State-of-the-art circle packing algorithm for 26 circles in [0,1]x[0,1]\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    n_circles = 26\n    best_result = None\n    best_sum = 0\n    \n    # Track which initialization strategies work best\n    strategy_scores = {'hex': [], 'spiral': [], 'grid': [], 'random': []}\n    \n    def generate_initial_configs():\n        \"\"\"Generate diverse initial configurations with more variations\"\"\"\n        configs = []\n        \n        # 1. Hexagonal grids with finer spacing variations\n        for spacing in np.linspace(0.175, 0.225, 15):\n            centers = []\n            for row in range(7):\n                for col in range(6):\n                    x = 0.08 + col * spacing + (row % 2) * spacing / 2\n                    y = 0.08 + row * spacing * 0.866\n                    if 0.05 <= x <= 0.95 and 0.05 <= y <= 0.95:\n                        centers.append([x, y])\n            if len(centers) >= n_circles:\n                configs.append(('hex', np.array(centers[:n_circles])))\n        \n        # 2. Golden ratio spiral patterns with more variations\n        phi = (1 + np.sqrt(5)) / 2\n        for scale in np.linspace(0.33, 0.44, 12):\n            for offset in [0, 0.1, 0.2]:\n                centers = []\n                for i in range(n_circles):\n                    theta = 2 * np.pi * i / phi + offset\n                    r = scale * np.sqrt(i / n_circles)\n                    x = 0.5 + r * np.cos(theta)\n                    y = 0.5 + r * np.sin(theta)\n                    centers.append([x, y])\n                configs.append(('spiral', np.array(centers)))\n        \n        # 3. Grid-based with more variations\n        for nx in [4, 5, 6, 7]:\n            ny = (n_circles + nx - 1) // nx\n            for margin in [0.06, 0.08, 0.10]:\n                centers = []\n                for i in range(n_circles):\n                    x = margin + (i % nx) * ((1 - 2*margin) / max(1, nx - 1)) if nx > 1 else 0.5\n                    y = margin + (i // nx) * ((1 - 2*margin) / max(1, ny - 1)) if ny > 1 else 0.5\n                    centers.append([x, y])\n                configs.append(('grid', np.array(centers)))\n        \n        # 4. Random with strategic placement (more seeds)\n        for seed in range(80):\n            np.random.seed(seed)\n            centers = np.random.uniform(0.12, 0.88, (n_circles, 2))\n            # Strategic corner and center placement\n            centers[0] = [0.5, 0.5]\n            centers[1] = [0.12, 0.12]\n            centers[2] = [0.88, 0.12]\n            centers[3] = [0.12, 0.88]\n            centers[4] = [0.88, 0.88]\n            centers[5] = [0.5, 0.12]\n            centers[6] = [0.5, 0.88]\n            centers[7] = [0.12, 0.5]\n            centers[8] = [0.88, 0.5]\n            configs.append(('random', centers))\n        \n        return configs\n    \n    def objective(x):\n        \"\"\"Maximize sum of radii (minimize negative sum)\"\"\"\n        radii = x[2*n_circles:]\n        return -np.sum(radii)\n    \n    def create_constraints(x):\n        \"\"\"Create constraint vector: all values should be >= 0\"\"\"\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        constraints = []\n        \n        # Non-overlap constraints\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt((centers[i,0] - centers[j,0])**2 + \n                             (centers[i,1] - centers[j,1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Boundary constraints\n        for i in range(n_circles):\n            constraints.append(centers[i,0] - radii[i])  # left\n            constraints.append(1 - centers[i,0] - radii[i])  # right\n            constraints.append(centers[i,1] - radii[i])  # bottom\n            constraints.append(1 - centers[i,1] - radii[i])  # top\n        \n        return np.array(constraints)\n    \n    def optimize_config(initial_centers, method='SLSQP', ftol=1e-14, maxiter=8000):\n        \"\"\"Optimize a single configuration\"\"\"\n        # Initial radii estimate based on nearest neighbor\n        try:\n            dists = cdist(initial_centers, initial_centers)\n            np.fill_diagonal(dists, np.inf)\n            min_dists = np.min(dists, axis=1)\n            initial_radii = np.minimum(min_dists / 2.5, 0.1)\n        except:\n            initial_radii = np.full(n_circles, 0.08)\n        \n        x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n        \n        # Bounds\n        bounds = [(0.03, 0.97)] * (2*n_circles) + [(0.005, 0.35)] * n_circles\n        \n        # Constraints\n        nlc = NonlinearConstraint(create_constraints, 0, np.inf)\n        \n        try:\n            result = minimize(\n                objective, x0, method=method,\n                bounds=bounds,\n                constraints=nlc,\n                options={'ftol': ftol, 'maxiter': maxiter}\n            )\n            \n            if result.success or result.fun < 0:\n                centers = result.x[:2*n_circles].reshape(n_circles, 2)\n                radii = result.x[2*n_circles:]\n                sum_radii = np.sum(radii)\n                \n                # Verify constraints\n                constraints = create_constraints(result.x)\n                if np.all(constraints >= -1e-6):\n                    return centers, radii, sum_radii\n        except:\n            pass\n        \n        return None, None, 0\n    \n    # Generate initial configurations\n    initial_configs = generate_initial_configs()\n    \n    print(f\"Generated {len(initial_configs)} initial configurations\")\n    \n    # Optimize each configuration with primary method\n    results = []\n    for i, (strategy, config) in enumerate(initial_configs):\n        centers, radii, sum_radii = optimize_config(config, method='SLSQP', ftol=1e-14, maxiter=8000)\n        if sum_radii > 0:\n            results.append((strategy, centers, radii, sum_radii))\n            strategy_scores[strategy].append(sum_radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_result = (centers, radii, sum_radii)\n                print(f\"New best from {strategy}: {sum_radii:.6f}\")\n    \n    # Sort results\n    results.sort(key=lambda x: x[3], reverse=True)\n    \n    # Multi-method refinement on top 10 results\n    print(f\"Refining top 10 results...\")\n    for strategy, centers, radii, sum_radii in results[:10]:\n        # Method 2: trust-constr\n        centers_new, radii_new, sum_new = optimize_config(centers, method='trust-constr', maxiter=5000)\n        if sum_new > best_sum:\n            best_sum = sum_new\n            best_result = (centers_new, radii_new, sum_new)\n            print(f\"Improved with trust-constr: {sum_new:.6f}\")\n        \n        # Micro-perturbations with multiple attempts\n        for attempt in range(5):\n            perturbed = centers + np.random.randn(n_circles, 2) * (0.005 + attempt * 0.002)\n            perturbed = np.clip(perturbed, 0.08, 0.92)\n            centers_new, radii_new, sum_new = optimize_config(perturbed, method='SLSQP', ftol=1e-14, maxiter=8000)\n            if sum_new > best_sum:\n                best_sum = sum_new\n                best_result = (centers_new, radii_new, sum_new)\n                print(f\"Improved with perturbation: {sum_new:.6f}\")\n    \n    # Adaptive restart: use best performing strategies\n    if best_sum < 2.63:\n        print(\"Applying adaptive restart...\")\n        best_strategies = sorted(strategy_scores.items(), \n                                key=lambda x: max(x[1]) if x[1] else 0, \n                                reverse=True)[:2]\n        \n        for strategy_name, _ in best_strategies:\n            # Generate more configs from best strategies\n            extra_configs = [c for s, c in initial_configs if s == strategy_name][:10]\n            for config in extra_configs:\n                # Try with different random perturbations\n                for _ in range(3):\n                    perturbed = config + np.random.randn(n_circles, 2) * 0.015\n                    perturbed = np.clip(perturbed, 0.08, 0.92)\n                    centers_new, radii_new, sum_new = optimize_config(\n                        perturbed, method='SLSQP', ftol=1e-14, maxiter=8000)\n                    if sum_new > best_sum:\n                        best_sum = sum_new\n                        best_result = (centers_new, radii_new, sum_new)\n                        print(f\"Improved with adaptive restart: {sum_new:.6f}\")\n    \n    if best_result is None:\n        # Fallback: optimized grid\n        centers = []\n        for i in range(n_circles):\n            x = 0.1 + (i % 5) * 0.18\n            y = 0.1 + (i // 5) * 0.15\n            centers.append([x, y])\n        centers = np.array(centers)\n        radii = np.full(n_circles, 0.08)\n        return centers, radii, np.sum(radii)\n    \n    return best_result\n\ndef run_packing():\n    \"\"\"Run the packing algorithm and return results\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"\\nFinal sum of radii: {sum_radii:.6f}\")\n    print(f\"Target: 2.635\")\n    print(f\"Success: {sum_radii >= 2.635}\")",
  "metrics": {
    "valid": true,
    "sum_radii": 2.629914376399171,
    "target_ratio": 0.9980699720679966,
    "combined_score": 0.9980699720679966,
    "eval_time": 133.79169583320618,
    "error": null
  },
  "prompt": "\nImprove this algorithm that achieved 2.625386 using lessons from the best (2.627423).\n\nCURRENT CODE:\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import cdist\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef construct_packing():\n    \"\"\"\n    State-of-the-art circle packing algorithm for 26 circles in [0,1]x[0,1]\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    n_circles = 26\n    best_result = None\n    best_sum = 0\n    \n    def generate_initial_configs():\n        \"\"\"Generate diverse initial configurations\"\"\"\n        configs = []\n        \n        # 1. Hexagonal grids with various spacings\n        for spacing in [0.18, 0.19, 0.20, 0.21, 0.22]:\n            centers = []\n            for row in range(6):\n                for col in range(5):\n                    x = 0.1 + col * spacing + (row % 2) * spacing / 2\n                    y = 0.1 + row * spacing * 0.866\n                    if x <= 0.9 and y <= 0.9:\n                        centers.append([x, y])\n            if len(centers) >= n_circles:\n                configs.append(np.array(centers[:n_circles]))\n        \n        # 2. Golden ratio spiral patterns\n        phi = (1 + np.sqrt(5)) / 2\n        for scale in [0.35, 0.38, 0.40, 0.42]:\n            centers = []\n            for i in range(n_circles):\n                theta = 2 * np.pi * i / phi\n                r = scale * np.sqrt(i / n_circles)\n                x = 0.5 + r * np.cos(theta)\n                y = 0.5 + r * np.sin(theta)\n                centers.append([x, y])\n            configs.append(np.array(centers))\n        \n        # 3. Grid-based with variations\n        for nx in [5, 6]:\n            ny = (n_circles + nx - 1) // nx\n            centers = []\n            for i in range(n_circles):\n                x = 0.08 + (i % nx) * (0.84 / (nx - 1)) if nx > 1 else 0.5\n                y = 0.08 + (i // nx) * (0.84 / (ny - 1)) if ny > 1 else 0.5\n                centers.append([x, y])\n            configs.append(np.array(centers))\n        \n        # 4. Random with strategic placement\n        np.random.seed(42)\n        for seed in range(35):\n            np.random.seed(seed)\n            centers = np.random.uniform(0.15, 0.85, (n_circles, 2))\n            # Place some circles strategically\n            centers[0] = [0.5, 0.5]  # center\n            centers[1] = [0.15, 0.15]  # corners\n            centers[2] = [0.85, 0.15]\n            centers[3] = [0.15, 0.85]\n            centers[4] = [0.85, 0.85]\n            configs.append(centers)\n        \n        return configs\n    \n    def objective(x):\n        \"\"\"Maximize sum of radii (minimize negative sum)\"\"\"\n        radii = x[2*n_circles:]\n        return -np.sum(radii)\n    \n    def create_constraints(x):\n        \"\"\"Create constraint vector: all values should be >= 0\"\"\"\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        constraints = []\n        \n        # Non-overlap constraints\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt((centers[i,0] - centers[j,0])**2 + \n                             (centers[i,1] - centers[j,1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Boundary constraints\n        for i in range(n_circles):\n            constraints.append(centers[i,0] - radii[i])  # left\n            constraints.append(1 - centers[i,0] - radii[i])  # right\n            constraints.append(centers[i,1] - radii[i])  # bottom\n            constraints.append(1 - centers[i,1] - radii[i])  # top\n        \n        return np.array(constraints)\n    \n    def optimize_config(initial_centers, method='SLSQP'):\n        \"\"\"Optimize a single configuration\"\"\"\n        # Initial radii estimate\n        initial_radii = np.full(n_circles, 0.08)\n        x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n        \n        # Bounds\n        bounds = [(0.05, 0.95)] * (2*n_circles) + [(0.01, 0.3)] * n_circles\n        \n        # Constraints\n        nlc = NonlinearConstraint(create_constraints, 0, np.inf)\n        \n        try:\n            result = minimize(\n                objective, x0, method=method,\n                bounds=bounds,\n                constraints=nlc,\n                options={'ftol': 1e-12, 'maxiter': 3000}\n            )\n            \n            if result.success or result.fun < 0:\n                centers = result.x[:2*n_circles].reshape(n_circles, 2)\n                radii = result.x[2*n_circles:]\n                sum_radii = np.sum(radii)\n                \n                # Verify constraints\n                constraints = create_constraints(result.x)\n                if np.all(constraints >= -1e-6):\n                    return centers, radii, sum_radii\n        except:\n            pass\n        \n        return None, None, 0\n    \n    # Generate initial configurations\n    initial_configs = generate_initial_configs()\n    \n    # Optimize each configuration\n    results = []\n    for i, config in enumerate(initial_configs):\n        centers, radii, sum_radii = optimize_config(config, method='SLSQP')\n        if sum_radii > 0:\n            results.append((centers, radii, sum_radii))\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_result = (centers, radii, sum_radii)\n    \n    # Refine top 5 results\n    results.sort(key=lambda x: x[2], reverse=True)\n    for centers, radii, sum_radii in results[:5]:\n        # Try trust-constr method\n        centers_new, radii_new, sum_new = optimize_config(centers, method='trust-constr')\n        if sum_new > best_sum:\n            best_sum = sum_new\n            best_result = (centers_new, radii_new, sum_new)\n        \n        # Micro-perturbations\n        for _ in range(3):\n            perturbed = centers + np.random.randn(n_circles, 2) * 0.01\n            perturbed = np.clip(perturbed, 0.1, 0.9)\n            centers_new, radii_new, sum_new = optimize_config(perturbed, method='SLSQP')\n            if sum_new > best_sum:\n                best_sum = sum_new\n                best_result = (centers_new, radii_new, sum_new)\n    \n    if best_result is None:\n        # Fallback: simple grid\n        centers = []\n        for i in range(n_circles):\n            x = 0.1 + (i % 5) * 0.2\n            y = 0.1 + (i // 5) * 0.15\n            centers.append([x, y])\n        centers = np.array(centers)\n        radii = np.full(n_circles, 0.08)\n        return centers, radii, np.sum(radii)\n    \n    return best_result\n\ndef run_packing():\n    \"\"\"Run the packing algorithm and return results\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Target: 2.635\")\n    print(f\"Success: {sum_radii >= 2.635}\")\n\nIMPROVEMENTS:\n1. Combine the ensemble approach with more aggressive parameters\n2. Use 60+ independent runs with diverse initializations\n3. Apply multi-method optimization:\n   - Primary: SLSQP with ftol=1e-14\n   - Secondary: trust-constr for refinement\n   - Tertiary: Nelder-Mead for final adjustment\n4. Implement adaptive restart strategy:\n   - If no improvement after 10 restarts, change initialization strategy\n   - Track which initialization types work best, use more of those\n5. Post-optimization local search on top 10 results\n6. Increase maxiter to 8000\n\nTARGET: sum_radii >= 2.635\n\nRequirements:\n- Define construct_packing() that returns (centers, radii, sum_radii)\n- Define run_packing() that calls construct_packing()\n- Use numpy and scipy.optimize\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import cdist\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef construct_packing():\n    \"\"\"\n    State-of-the-art circle packing algorithm for 26 circles in [0,1]x[0,1]\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    n_circles = 26\n    best_result = None\n    best_sum = 0\n    \n    # Track which initialization strategies work best\n    strategy_scores = {'hex': [], 'spiral': [], 'grid': [], 'random': []}\n    \n    def generate_initial_configs():\n        \"\"\"Generate diverse initial configurations with more variations\"\"\"\n        configs = []\n        \n        # 1. Hexagonal grids with finer spacing variations\n        for spacing in np.linspace(0.175, 0.225, 15):\n            centers = []\n            for row in range(7):\n                for col in range(6):\n                    x = 0.08 + col * spacing + (row % 2) * spacing / 2\n                    y = 0.08 + row * spacing * 0.866\n                    if 0.05 <= x <= 0.95 and 0.05 <= y <= 0.95:\n                        centers.append([x, y])\n            if len(centers) >= n_circles:\n                configs.append(('hex', np.array(centers[:n_circles])))\n        \n        # 2. Golden ratio spiral patterns with more variations\n        phi = (1 + np.sqrt(5)) / 2\n        for scale in np.linspace(0.33, 0.44, 12):\n            for offset in [0, 0.1, 0.2]:\n                centers = []\n                for i in range(n_circles):\n                    theta = 2 * np.pi * i / phi + offset\n                    r = scale * np.sqrt(i / n_circles)\n                    x = 0.5 + r * np.cos(theta)\n                    y = 0.5 + r * np.sin(theta)\n                    centers.append([x, y])\n                configs.append(('spiral', np.array(centers)))\n        \n        # 3. Grid-based with more variations\n        for nx in [4, 5, 6, 7]:\n            ny = (n_circles + nx - 1) // nx\n            for margin in [0.06, 0.08, 0.10]:\n                centers = []\n                for i in range(n_circles):\n                    x = margin + (i % nx) * ((1 - 2*margin) / max(1, nx - 1)) if nx > 1 else 0.5\n                    y = margin + (i // nx) * ((1 - 2*margin) / max(1, ny - 1)) if ny > 1 else 0.5\n                    centers.append([x, y])\n                configs.append(('grid', np.array(centers)))\n        \n        # 4. Random with strategic placement (more seeds)\n        for seed in range(80):\n            np.random.seed(seed)\n            centers = np.random.uniform(0.12, 0.88, (n_circles, 2))\n            # Strategic corner and center placement\n            centers[0] = [0.5, 0.5]\n            centers[1] = [0.12, 0.12]\n            centers[2] = [0.88, 0.12]\n            centers[3] = [0.12, 0.88]\n            centers[4] = [0.88, 0.88]\n            centers[5] = [0.5, 0.12]\n            centers[6] = [0.5, 0.88]\n            centers[7] = [0.12, 0.5]\n            centers[8] = [0.88, 0.5]\n            configs.append(('random', centers))\n        \n        return configs\n    \n    def objective(x):\n        \"\"\"Maximize sum of radii (minimize negative sum)\"\"\"\n        radii = x[2*n_circles:]\n        return -np.sum(radii)\n    \n    def create_constraints(x):\n        \"\"\"Create constraint vector: all values should be >= 0\"\"\"\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        constraints = []\n        \n        # Non-overlap constraints\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt((centers[i,0] - centers[j,0])**2 + \n                             (centers[i,1] - centers[j,1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Boundary constraints\n        for i in range(n_circles):\n            constraints.append(centers[i,0] - radii[i])  # left\n            constraints.append(1 - centers[i,0] - radii[i])  # right\n            constraints.append(centers[i,1] - radii[i])  # bottom\n            constraints.append(1 - centers[i,1] - radii[i])  # top\n        \n        return np.array(constraints)\n    \n    def optimize_config(initial_centers, method='SLSQP', ftol=1e-14, maxiter=8000):\n        \"\"\"Optimize a single configuration\"\"\"\n        # Initial radii estimate based on nearest neighbor\n        try:\n            dists = cdist(initial_centers, initial_centers)\n            np.fill_diagonal(dists, np.inf)\n            min_dists = np.min(dists, axis=1)\n            initial_radii = np.minimum(min_dists / 2.5, 0.1)\n        except:\n            initial_radii = np.full(n_circles, 0.08)\n        \n        x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n        \n        # Bounds\n        bounds = [(0.03, 0.97)] * (2*n_circles) + [(0.005, 0.35)] * n_circles\n        \n        # Constraints\n        nlc = NonlinearConstraint(create_constraints, 0, np.inf)\n        \n        try:\n            result = minimize(\n                objective, x0, method=method,\n                bounds=bounds,\n                constraints=nlc,\n                options={'ftol': ftol, 'maxiter': maxiter}\n            )\n            \n            if result.success or result.fun < 0:\n                centers = result.x[:2*n_circles].reshape(n_circles, 2)\n                radii = result.x[2*n_circles:]\n                sum_radii = np.sum(radii)\n                \n                # Verify constraints\n                constraints = create_constraints(result.x)\n                if np.all(constraints >= -1e-6):\n                    return centers, radii, sum_radii\n        except:\n            pass\n        \n        return None, None, 0\n    \n    # Generate initial configurations\n    initial_configs = generate_initial_configs()\n    \n    print(f\"Generated {len(initial_configs)} initial configurations\")\n    \n    # Optimize each configuration with primary method\n    results = []\n    for i, (strategy, config) in enumerate(initial_configs):\n        centers, radii, sum_radii = optimize_config(config, method='SLSQP', ftol=1e-14, maxiter=8000)\n        if sum_radii > 0:\n            results.append((strategy, centers, radii, sum_radii))\n            strategy_scores[strategy].append(sum_radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_result = (centers, radii, sum_radii)\n                print(f\"New best from {strategy}: {sum_radii:.6f}\")\n    \n    # Sort results\n    results.sort(key=lambda x: x[3], reverse=True)\n    \n    # Multi-method refinement on top 10 results\n    print(f\"Refining top 10 results...\")\n    for strategy, centers, radii, sum_radii in results[:10]:\n        # Method 2: trust-constr\n        centers_new, radii_new, sum_new = optimize_config(centers, method='trust-constr', maxiter=5000)\n        if sum_new > best_sum:\n            best_sum = sum_new\n            best_result = (centers_new, radii_new, sum_new)\n            print(f\"Improved with trust-constr: {sum_new:.6f}\")\n        \n        # Micro-perturbations with multiple attempts\n        for attempt in range(5):\n            perturbed = centers + np.random.randn(n_circles, 2) * (0.005 + attempt * 0.002)\n            perturbed = np.clip(perturbed, 0.08, 0.92)\n            centers_new, radii_new, sum_new = optimize_config(perturbed, method='SLSQP', ftol=1e-14, maxiter=8000)\n            if sum_new > best_sum:\n                best_sum = sum_new\n                best_result = (centers_new, radii_new, sum_new)\n                print(f\"Improved with perturbation: {sum_new:.6f}\")\n    \n    # Adaptive restart: use best performing strategies\n    if best_sum < 2.63:\n        print(\"Applying adaptive restart...\")\n        best_strategies = sorted(strategy_scores.items(), \n                                key=lambda x: max(x[1]) if x[1] else 0, \n                                reverse=True)[:2]\n        \n        for strategy_name, _ in best_strategies:\n            # Generate more configs from best strategies\n            extra_configs = [c for s, c in initial_configs if s == strategy_name][:10]\n            for config in extra_configs:\n                # Try with different random perturbations\n                for _ in range(3):\n                    perturbed = config + np.random.randn(n_circles, 2) * 0.015\n                    perturbed = np.clip(perturbed, 0.08, 0.92)\n                    centers_new, radii_new, sum_new = optimize_config(\n                        perturbed, method='SLSQP', ftol=1e-14, maxiter=8000)\n                    if sum_new > best_sum:\n                        best_sum = sum_new\n                        best_result = (centers_new, radii_new, sum_new)\n                        print(f\"Improved with adaptive restart: {sum_new:.6f}\")\n    \n    if best_result is None:\n        # Fallback: optimized grid\n        centers = []\n        for i in range(n_circles):\n            x = 0.1 + (i % 5) * 0.18\n            y = 0.1 + (i // 5) * 0.15\n            centers.append([x, y])\n        centers = np.array(centers)\n        radii = np.full(n_circles, 0.08)\n        return centers, radii, np.sum(radii)\n    \n    return best_result\n\ndef run_packing():\n    \"\"\"Run the packing algorithm and return results\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"\\nFinal sum of radii: {sum_radii:.6f}\")\n    print(f\"Target: 2.635\")\n    print(f\"Success: {sum_radii >= 2.635}\")\n```",
  "reasoning": "",
  "timestamp": "2025-12-04T15:34:57.227755",
  "cost_data": null
}