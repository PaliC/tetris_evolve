{
  "trial_id": "trial_2_7",
  "generation": 2,
  "parent_id": "trial_2_3",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom itertools import product\n\ndef construct_packing():\n    \"\"\"\n    Focused optimization for 26 circles in [0,1]x[0,1] targeting 2.635+\n    \"\"\"\n    n_circles = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    np.random.seed(42)\n    \n    def create_hexagonal_grid(n, perturbation=0.0):\n        \"\"\"Create hexagonal grid initialization with optional perturbation\"\"\"\n        centers = []\n        rows = int(np.sqrt(n * 2 / np.sqrt(3))) + 1\n        cols = int(np.sqrt(n * np.sqrt(3) / 2)) + 1\n        \n        for i in range(rows):\n            for j in range(cols):\n                x = 0.15 + j * 0.15\n                y = 0.15 + i * 0.13\n                if i % 2 == 1:\n                    x += 0.075\n                \n                if perturbation > 0:\n                    x += np.random.uniform(-perturbation, perturbation)\n                    y += np.random.uniform(-perturbation, perturbation)\n                \n                x = np.clip(x, 0.05, 0.95)\n                y = np.clip(y, 0.05, 0.95)\n                centers.append([x, y])\n                \n                if len(centers) >= n:\n                    return np.array(centers[:n])\n        \n        # Fill remaining with random\n        while len(centers) < n:\n            centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n        \n        return np.array(centers[:n])\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii\"\"\"\n        radii = x[2*n_circles:]\n        return -np.sum(radii)\n    \n    def constraints_list(x):\n        \"\"\"All constraints as a list for SLSQP\"\"\"\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        constraints = []\n        \n        # Non-overlap constraints\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt((centers[i,0] - centers[j,0])**2 + (centers[i,1] - centers[j,1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Boundary constraints\n        for i in range(n_circles):\n            constraints.append(centers[i,0] - radii[i])  # left\n            constraints.append(1 - centers[i,0] - radii[i])  # right\n            constraints.append(centers[i,1] - radii[i])  # bottom\n            constraints.append(1 - centers[i,1] - radii[i])  # top\n        \n        # Minimum radius constraints\n        for i in range(n_circles):\n            constraints.append(radii[i] - 0.001)\n        \n        return np.array(constraints)\n    \n    # Initial configurations to try\n    perturbations = [0.0, 0.005, 0.01, 0.015, 0.02, 0.025, 0.03]\n    \n    print(\"Starting focused optimization with 30 restarts...\")\n    \n    for restart in range(30):\n        # Select initialization strategy\n        if restart < len(perturbations):\n            centers_init = create_hexagonal_grid(n_circles, perturbations[restart])\n        elif restart < 15:\n            # More hexagonal perturbations\n            centers_init = create_hexagonal_grid(n_circles, np.random.uniform(0, 0.04))\n        else:\n            # Use best solution with small noise if available\n            if best_centers is not None:\n                centers_init = best_centers + np.random.normal(0, 0.01, (n_circles, 2))\n                centers_init = np.clip(centers_init, 0.05, 0.95)\n            else:\n                centers_init = create_hexagonal_grid(n_circles, np.random.uniform(0, 0.05))\n        \n        # Initialize radii based on nearest neighbor distance\n        radii_init = np.zeros(n_circles)\n        for i in range(n_circles):\n            min_dist = 1.0\n            for j in range(n_circles):\n                if i != j:\n                    dist = np.sqrt(np.sum((centers_init[i] - centers_init[j])**2))\n                    min_dist = min(min_dist, dist)\n            \n            # Also consider boundaries\n            boundary_dist = min(\n                centers_init[i,0], 1 - centers_init[i,0],\n                centers_init[i,1], 1 - centers_init[i,1]\n            )\n            min_dist = min(min_dist, boundary_dist)\n            radii_init[i] = max(0.02, min_dist * 0.45)\n        \n        x0 = np.concatenate([centers_init.flatten(), radii_init])\n        \n        # Bounds\n        bounds = [(0.001, 0.999)] * (2*n_circles) + [(0.001, 0.5)] * n_circles\n        \n        # Constraints\n        cons = {'type': 'ineq', 'fun': constraints_list}\n        \n        # Optimize\n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=cons,\n            options={'ftol': 1e-14, 'maxiter': 5000, 'disp': False}\n        )\n        \n        if result.success or result.fun < -best_sum:\n            centers = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii = result.x[2*n_circles:]\n            current_sum = np.sum(radii)\n            \n            # Verify constraints\n            cons_values = constraints_list(result.x)\n            if np.all(cons_values >= -1e-6):\n                if current_sum > best_sum:\n                    best_sum = current_sum\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n                    print(f\"Restart {restart+1}/30: New best sum = {best_sum:.6f}\")\n    \n    # Fine-tuning phase\n    if best_centers is not None:\n        print(f\"\\nFine-tuning best solution (sum = {best_sum:.6f})...\")\n        \n        for micro_iter in range(10):\n            improved = False\n            \n            # Try small adjustments to each circle\n            for i in range(n_circles):\n                best_local = best_sum\n                best_local_centers = best_centers.copy()\n                best_local_radii = best_radii.copy()\n                \n                # Try small movements\n                for dx, dy in [(0.001, 0), (-0.001, 0), (0, 0.001), (0, -0.001)]:\n                    test_centers = best_centers.copy()\n                    test_centers[i] += [dx, dy]\n                    \n                    if 0.001 <= test_centers[i,0] <= 0.999 and 0.001 <= test_centers[i,1] <= 0.999:\n                        # Re-optimize radii with new centers\n                        x0 = np.concatenate([test_centers.flatten(), best_radii])\n                        bounds = [(c, c) for c in test_centers.flatten()] + [(0.001, 0.5)] * n_circles\n                        cons = {'type': 'ineq', 'fun': constraints_list}\n                        \n                        result = minimize(\n                            objective, x0, method='SLSQP',\n                            bounds=bounds, constraints=cons,\n                            options={'ftol': 1e-12, 'maxiter': 1000, 'disp': False}\n                        )\n                        \n                        if result.success:\n                            radii = result.x[2*n_circles:]\n                            current_sum = np.sum(radii)\n                            \n                            if current_sum > best_local:\n                                best_local = current_sum\n                                best_local_centers = test_centers.copy()\n                                best_local_radii = radii.copy()\n                                improved = True\n                \n                if best_local > best_sum:\n                    best_sum = best_local\n                    best_centers = best_local_centers\n                    best_radii = best_local_radii\n            \n            if improved:\n                print(f\"  Micro-iteration {micro_iter+1}: sum = {best_sum:.6f}\")\n            else:\n                break\n    \n    print(f\"\\nFinal sum of radii: {best_sum:.6f}\")\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Run the packing optimization\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, total = run_packing()\n    print(f\"\\nOptimization complete!\")\n    print(f\"Total sum of radii: {total:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")",
  "metrics": {
    "valid": true,
    "sum_radii": 2.623068621083394,
    "target_ratio": 0.9954719624604912,
    "combined_score": 0.9954719624604912,
    "eval_time": 13.824300050735474,
    "error": null
  },
  "prompt": "\nFocused optimization for 26 circles in [0,1]x[0,1] targeting 2.635+.\n\nFOCUSED STRATEGY:\nInstead of trying everything, focus on what works:\n1. Use 30 restarts with proven good initializations:\n   - Hexagonal grid (the best traditional packing)\n   - Random perturbations of hexagonal (\u00b10.01, \u00b10.02, \u00b10.03)\n   - Previous best solutions with small noise\n\n2. Single optimization method (SLSQP) but with perfect parameters:\n   - ftol=1e-14, gtol=1e-14\n   - maxiter=5000\n   - Variable radii (78 variables)\n   - Tight constraint formulation\n\n3. After main optimization phase:\n   - Take the single best result\n   - Apply systematic local search in a 0.001 radius around each circle\n   - For each position, re-optimize radii\n   - This fine-tunes the solution\n\n4. Final check:\n   - Verify all constraints\n   - Ensure maximum possible radii given positions\n\nThis focused approach avoids timeout issues while being thorough where it matters.\n\nRequirements:\n- Define construct_packing() that returns (centers, radii, sum_radii)\n- Define run_packing() that calls construct_packing()\n- Use numpy and scipy.optimize\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom itertools import product\n\ndef construct_packing():\n    \"\"\"\n    Focused optimization for 26 circles in [0,1]x[0,1] targeting 2.635+\n    \"\"\"\n    n_circles = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    np.random.seed(42)\n    \n    def create_hexagonal_grid(n, perturbation=0.0):\n        \"\"\"Create hexagonal grid initialization with optional perturbation\"\"\"\n        centers = []\n        rows = int(np.sqrt(n * 2 / np.sqrt(3))) + 1\n        cols = int(np.sqrt(n * np.sqrt(3) / 2)) + 1\n        \n        for i in range(rows):\n            for j in range(cols):\n                x = 0.15 + j * 0.15\n                y = 0.15 + i * 0.13\n                if i % 2 == 1:\n                    x += 0.075\n                \n                if perturbation > 0:\n                    x += np.random.uniform(-perturbation, perturbation)\n                    y += np.random.uniform(-perturbation, perturbation)\n                \n                x = np.clip(x, 0.05, 0.95)\n                y = np.clip(y, 0.05, 0.95)\n                centers.append([x, y])\n                \n                if len(centers) >= n:\n                    return np.array(centers[:n])\n        \n        # Fill remaining with random\n        while len(centers) < n:\n            centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n        \n        return np.array(centers[:n])\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii\"\"\"\n        radii = x[2*n_circles:]\n        return -np.sum(radii)\n    \n    def constraints_list(x):\n        \"\"\"All constraints as a list for SLSQP\"\"\"\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        constraints = []\n        \n        # Non-overlap constraints\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt((centers[i,0] - centers[j,0])**2 + (centers[i,1] - centers[j,1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Boundary constraints\n        for i in range(n_circles):\n            constraints.append(centers[i,0] - radii[i])  # left\n            constraints.append(1 - centers[i,0] - radii[i])  # right\n            constraints.append(centers[i,1] - radii[i])  # bottom\n            constraints.append(1 - centers[i,1] - radii[i])  # top\n        \n        # Minimum radius constraints\n        for i in range(n_circles):\n            constraints.append(radii[i] - 0.001)\n        \n        return np.array(constraints)\n    \n    # Initial configurations to try\n    perturbations = [0.0, 0.005, 0.01, 0.015, 0.02, 0.025, 0.03]\n    \n    print(\"Starting focused optimization with 30 restarts...\")\n    \n    for restart in range(30):\n        # Select initialization strategy\n        if restart < len(perturbations):\n            centers_init = create_hexagonal_grid(n_circles, perturbations[restart])\n        elif restart < 15:\n            # More hexagonal perturbations\n            centers_init = create_hexagonal_grid(n_circles, np.random.uniform(0, 0.04))\n        else:\n            # Use best solution with small noise if available\n            if best_centers is not None:\n                centers_init = best_centers + np.random.normal(0, 0.01, (n_circles, 2))\n                centers_init = np.clip(centers_init, 0.05, 0.95)\n            else:\n                centers_init = create_hexagonal_grid(n_circles, np.random.uniform(0, 0.05))\n        \n        # Initialize radii based on nearest neighbor distance\n        radii_init = np.zeros(n_circles)\n        for i in range(n_circles):\n            min_dist = 1.0\n            for j in range(n_circles):\n                if i != j:\n                    dist = np.sqrt(np.sum((centers_init[i] - centers_init[j])**2))\n                    min_dist = min(min_dist, dist)\n            \n            # Also consider boundaries\n            boundary_dist = min(\n                centers_init[i,0], 1 - centers_init[i,0],\n                centers_init[i,1], 1 - centers_init[i,1]\n            )\n            min_dist = min(min_dist, boundary_dist)\n            radii_init[i] = max(0.02, min_dist * 0.45)\n        \n        x0 = np.concatenate([centers_init.flatten(), radii_init])\n        \n        # Bounds\n        bounds = [(0.001, 0.999)] * (2*n_circles) + [(0.001, 0.5)] * n_circles\n        \n        # Constraints\n        cons = {'type': 'ineq', 'fun': constraints_list}\n        \n        # Optimize\n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=cons,\n            options={'ftol': 1e-14, 'maxiter': 5000, 'disp': False}\n        )\n        \n        if result.success or result.fun < -best_sum:\n            centers = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii = result.x[2*n_circles:]\n            current_sum = np.sum(radii)\n            \n            # Verify constraints\n            cons_values = constraints_list(result.x)\n            if np.all(cons_values >= -1e-6):\n                if current_sum > best_sum:\n                    best_sum = current_sum\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n                    print(f\"Restart {restart+1}/30: New best sum = {best_sum:.6f}\")\n    \n    # Fine-tuning phase\n    if best_centers is not None:\n        print(f\"\\nFine-tuning best solution (sum = {best_sum:.6f})...\")\n        \n        for micro_iter in range(10):\n            improved = False\n            \n            # Try small adjustments to each circle\n            for i in range(n_circles):\n                best_local = best_sum\n                best_local_centers = best_centers.copy()\n                best_local_radii = best_radii.copy()\n                \n                # Try small movements\n                for dx, dy in [(0.001, 0), (-0.001, 0), (0, 0.001), (0, -0.001)]:\n                    test_centers = best_centers.copy()\n                    test_centers[i] += [dx, dy]\n                    \n                    if 0.001 <= test_centers[i,0] <= 0.999 and 0.001 <= test_centers[i,1] <= 0.999:\n                        # Re-optimize radii with new centers\n                        x0 = np.concatenate([test_centers.flatten(), best_radii])\n                        bounds = [(c, c) for c in test_centers.flatten()] + [(0.001, 0.5)] * n_circles\n                        cons = {'type': 'ineq', 'fun': constraints_list}\n                        \n                        result = minimize(\n                            objective, x0, method='SLSQP',\n                            bounds=bounds, constraints=cons,\n                            options={'ftol': 1e-12, 'maxiter': 1000, 'disp': False}\n                        )\n                        \n                        if result.success:\n                            radii = result.x[2*n_circles:]\n                            current_sum = np.sum(radii)\n                            \n                            if current_sum > best_local:\n                                best_local = current_sum\n                                best_local_centers = test_centers.copy()\n                                best_local_radii = radii.copy()\n                                improved = True\n                \n                if best_local > best_sum:\n                    best_sum = best_local\n                    best_centers = best_local_centers\n                    best_radii = best_local_radii\n            \n            if improved:\n                print(f\"  Micro-iteration {micro_iter+1}: sum = {best_sum:.6f}\")\n            else:\n                break\n    \n    print(f\"\\nFinal sum of radii: {best_sum:.6f}\")\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Run the packing optimization\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, total = run_packing()\n    print(f\"\\nOptimization complete!\")\n    print(f\"Total sum of radii: {total:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n```",
  "reasoning": "",
  "timestamp": "2025-12-04T15:35:43.044548",
  "cost_data": null
}