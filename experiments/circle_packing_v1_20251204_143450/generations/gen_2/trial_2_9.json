{
  "trial_id": "trial_2_9",
  "generation": 2,
  "parent_id": "trial_2_6",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Ultimate circle packing algorithm combining all top insights.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    np.random.seed(42)\n    n_circles = 39\n    n_vars = n_circles * 3  # x, y, r for each circle\n    \n    def generate_hex_grid(spacing, noise_level=0.01):\n        \"\"\"Generate hexagonal grid with perturbations\"\"\"\n        centers = []\n        for i in range(8):\n            for j in range(8):\n                x = j * spacing + (i % 2) * spacing / 2\n                y = i * spacing * np.sqrt(3) / 2\n                if 0 < x < 1 and 0 < y < 1:\n                    x += np.random.uniform(-noise_level, noise_level)\n                    y += np.random.uniform(-noise_level, noise_level)\n                    centers.append([x, y])\n        \n        # Take first n_circles\n        centers = np.array(centers[:n_circles])\n        if len(centers) < n_circles:\n            # Fill remaining with random\n            remaining = n_circles - len(centers)\n            centers = np.vstack([centers, np.random.uniform(0.1, 0.9, (remaining, 2))])\n        \n        return centers\n    \n    def generate_spiral(n):\n        \"\"\"Generate spiral pattern\"\"\"\n        centers = []\n        theta = 0\n        r = 0\n        for i in range(n):\n            x = 0.5 + r * np.cos(theta)\n            y = 0.5 + r * np.sin(theta)\n            centers.append([x, y])\n            theta += 2.4  # Golden angle\n            r += 0.015\n        return np.array(centers)\n    \n    def pack_to_vars(centers, radii):\n        \"\"\"Convert centers and radii to optimization variables\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def vars_to_pack(x):\n        \"\"\"Convert optimization variables to centers and radii\"\"\"\n        centers = x[:n_circles*2].reshape(n_circles, 2)\n        radii = x[n_circles*2:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii\"\"\"\n        _, radii = vars_to_pack(x)\n        return -np.sum(radii)\n    \n    def constraint_no_overlap(x):\n        \"\"\"Constraint: all circles must not overlap\"\"\"\n        centers, radii = vars_to_pack(x)\n        dists = squareform(pdist(centers))\n        min_dists = radii[:, None] + radii[None, :]\n        # Return positive values when constraint satisfied\n        return (dists - min_dists + np.eye(n_circles) * 1e6).flatten()\n    \n    def constraint_within_bounds(x):\n        \"\"\"Constraint: all circles within [0,1]x[0,1]\"\"\"\n        centers, radii = vars_to_pack(x)\n        constraints = []\n        # x - r >= 0\n        constraints.append(centers[:, 0] - radii)\n        # x + r <= 1\n        constraints.append(1 - centers[:, 0] - radii)\n        # y - r >= 0\n        constraints.append(centers[:, 1] - radii)\n        # y + r <= 1\n        constraints.append(1 - centers[:, 1] - radii)\n        return np.concatenate(constraints)\n    \n    def optimize_packing(x0):\n        \"\"\"Run single optimization\"\"\"\n        bounds = [(0, 1)] * (n_circles * 2) + [(0.001, 0.5)] * n_circles\n        \n        constraints = [\n            {'type': 'ineq', 'fun': constraint_no_overlap},\n            {'type': 'ineq', 'fun': constraint_within_bounds}\n        ]\n        \n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'ftol': 1e-14, 'maxiter': 5000}\n        )\n        \n        return result\n    \n    def local_search(x, delta=0.001):\n        \"\"\"Apply local search around solution\"\"\"\n        best_x = x.copy()\n        best_obj = objective(x)\n        \n        for _ in range(20):\n            x_new = x.copy()\n            # Perturb positions slightly\n            x_new[:n_circles*2] += np.random.uniform(-delta, delta, n_circles*2)\n            x_new[:n_circles*2] = np.clip(x_new[:n_circles*2], 0, 1)\n            \n            result = optimize_packing(x_new)\n            if result.success and result.fun < best_obj:\n                best_obj = result.fun\n                best_x = result.x\n        \n        return best_x, best_obj\n    \n    # Store all results\n    all_results = []\n    \n    print(\"Running 50 independent optimizations...\")\n    \n    # 20 hexagonal grid perturbations\n    for i in range(20):\n        spacing = np.random.uniform(0.12, 0.18)\n        noise = np.random.uniform(0.005, 0.02)\n        centers = generate_hex_grid(spacing, noise)\n        radii = np.random.uniform(0.02, 0.05, n_circles)\n        x0 = pack_to_vars(centers, radii)\n        \n        result = optimize_packing(x0)\n        if result.success:\n            all_results.append((result.x, result.fun))\n            print(f\"Hex {i+1}: sum_radii = {-result.fun:.6f}\")\n    \n    # 10 random initializations\n    for i in range(10):\n        centers = np.random.uniform(0.1, 0.9, (n_circles, 2))\n        radii = np.random.uniform(0.02, 0.05, n_circles)\n        x0 = pack_to_vars(centers, radii)\n        \n        result = optimize_packing(x0)\n        if result.success:\n            all_results.append((result.x, result.fun))\n            print(f\"Random {i+1}: sum_radii = {-result.fun:.6f}\")\n    \n    # 10 spiral patterns\n    for i in range(10):\n        centers = generate_spiral(n_circles)\n        centers = np.clip(centers, 0.05, 0.95)\n        radii = np.random.uniform(0.02, 0.05, n_circles)\n        x0 = pack_to_vars(centers, radii)\n        \n        result = optimize_packing(x0)\n        if result.success:\n            all_results.append((result.x, result.fun))\n            print(f\"Spiral {i+1}: sum_radii = {-result.fun:.6f}\")\n    \n    # 10 from previous best with noise\n    if all_results:\n        all_results.sort(key=lambda x: x[1])\n        for i in range(min(10, len(all_results))):\n            x_base = all_results[i][0].copy()\n            x_new = x_base.copy()\n            x_new[:n_circles*2] += np.random.uniform(-0.02, 0.02, n_circles*2)\n            x_new[:n_circles*2] = np.clip(x_new[:n_circles*2], 0, 1)\n            x_new[n_circles*2:] += np.random.uniform(-0.01, 0.01, n_circles)\n            x_new[n_circles*2:] = np.clip(x_new[n_circles*2:], 0.001, 0.5)\n            \n            result = optimize_packing(x_new)\n            if result.success:\n                all_results.append((result.x, result.fun))\n                print(f\"Refined {i+1}: sum_radii = {-result.fun:.6f}\")\n    \n    # Take top 10 and apply local search\n    all_results.sort(key=lambda x: x[1])\n    top_results = all_results[:min(10, len(all_results))]\n    \n    print(\"\\nApplying local search to top 10...\")\n    final_results = []\n    for i, (x, obj) in enumerate(top_results):\n        x_refined, obj_refined = local_search(x)\n        final_results.append((x_refined, obj_refined))\n        print(f\"Local search {i+1}: sum_radii = {-obj_refined:.6f}\")\n    \n    # Get absolute best\n    final_results.sort(key=lambda x: x[1])\n    best_x, best_obj = final_results[0]\n    \n    centers, radii = vars_to_pack(best_x)\n    sum_radii = -best_obj\n    \n    print(f\"\\nFinal best sum_radii: {sum_radii:.6f}\")\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Run the packing algorithm\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"\\nFinal sum of radii: {sum_radii:.6f}\")\n    print(f\"Target (2.635): {'ACHIEVED!' if sum_radii >= 2.635 else 'Not reached'}\")",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 100.66591000556946,
    "error": "Invalid centers shape: (39, 2), expected (26, 2)"
  },
  "prompt": "\nCreate the ultimate circle packing algorithm by combining insights from evolution.\n\nINSIGHTS FROM TOP PERFORMERS:\n1. Variable radii optimization (not uniform) is essential\n2. Multiple restarts (30-50) with diverse initializations work best\n3. Hexagonal grid perturbations are excellent starting points\n4. SLSQP with tight tolerances is most effective\n5. Post-optimization local search helps\n6. Ensemble approach with many independent runs works well\n\nULTIMATE ALGORITHM:\n1. Run 50 independent optimizations:\n   - 20 from hexagonal grid perturbations (various spacings, small noise)\n   - 10 from random initializations\n   - 10 from spiral patterns\n   - 10 from previous best solutions with noise\n\n2. For each run:\n   - Optimize positions and radii (78 variables)\n   - Method: SLSQP with ftol=1e-14, maxiter=5000\n   - Constraints: no overlaps, within [0,1]x[0,1]\n\n3. Take top 10 results:\n   - Apply local search (\u00b10.001 position adjustments)\n   - Re-optimize radii\n   - Try trust-constr for final refinement\n\n4. Return absolute best valid configuration\n\nThis combines all successful strategies for maximum performance.\n\nTARGET: sum_radii >= 2.635\n\nRequirements:\n- Define construct_packing() that returns (centers, radii, sum_radii)\n- Define run_packing() that calls construct_packing()\n- Use numpy and scipy.optimize\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Ultimate circle packing algorithm combining all top insights.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    np.random.seed(42)\n    n_circles = 39\n    n_vars = n_circles * 3  # x, y, r for each circle\n    \n    def generate_hex_grid(spacing, noise_level=0.01):\n        \"\"\"Generate hexagonal grid with perturbations\"\"\"\n        centers = []\n        for i in range(8):\n            for j in range(8):\n                x = j * spacing + (i % 2) * spacing / 2\n                y = i * spacing * np.sqrt(3) / 2\n                if 0 < x < 1 and 0 < y < 1:\n                    x += np.random.uniform(-noise_level, noise_level)\n                    y += np.random.uniform(-noise_level, noise_level)\n                    centers.append([x, y])\n        \n        # Take first n_circles\n        centers = np.array(centers[:n_circles])\n        if len(centers) < n_circles:\n            # Fill remaining with random\n            remaining = n_circles - len(centers)\n            centers = np.vstack([centers, np.random.uniform(0.1, 0.9, (remaining, 2))])\n        \n        return centers\n    \n    def generate_spiral(n):\n        \"\"\"Generate spiral pattern\"\"\"\n        centers = []\n        theta = 0\n        r = 0\n        for i in range(n):\n            x = 0.5 + r * np.cos(theta)\n            y = 0.5 + r * np.sin(theta)\n            centers.append([x, y])\n            theta += 2.4  # Golden angle\n            r += 0.015\n        return np.array(centers)\n    \n    def pack_to_vars(centers, radii):\n        \"\"\"Convert centers and radii to optimization variables\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def vars_to_pack(x):\n        \"\"\"Convert optimization variables to centers and radii\"\"\"\n        centers = x[:n_circles*2].reshape(n_circles, 2)\n        radii = x[n_circles*2:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii\"\"\"\n        _, radii = vars_to_pack(x)\n        return -np.sum(radii)\n    \n    def constraint_no_overlap(x):\n        \"\"\"Constraint: all circles must not overlap\"\"\"\n        centers, radii = vars_to_pack(x)\n        dists = squareform(pdist(centers))\n        min_dists = radii[:, None] + radii[None, :]\n        # Return positive values when constraint satisfied\n        return (dists - min_dists + np.eye(n_circles) * 1e6).flatten()\n    \n    def constraint_within_bounds(x):\n        \"\"\"Constraint: all circles within [0,1]x[0,1]\"\"\"\n        centers, radii = vars_to_pack(x)\n        constraints = []\n        # x - r >= 0\n        constraints.append(centers[:, 0] - radii)\n        # x + r <= 1\n        constraints.append(1 - centers[:, 0] - radii)\n        # y - r >= 0\n        constraints.append(centers[:, 1] - radii)\n        # y + r <= 1\n        constraints.append(1 - centers[:, 1] - radii)\n        return np.concatenate(constraints)\n    \n    def optimize_packing(x0):\n        \"\"\"Run single optimization\"\"\"\n        bounds = [(0, 1)] * (n_circles * 2) + [(0.001, 0.5)] * n_circles\n        \n        constraints = [\n            {'type': 'ineq', 'fun': constraint_no_overlap},\n            {'type': 'ineq', 'fun': constraint_within_bounds}\n        ]\n        \n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'ftol': 1e-14, 'maxiter': 5000}\n        )\n        \n        return result\n    \n    def local_search(x, delta=0.001):\n        \"\"\"Apply local search around solution\"\"\"\n        best_x = x.copy()\n        best_obj = objective(x)\n        \n        for _ in range(20):\n            x_new = x.copy()\n            # Perturb positions slightly\n            x_new[:n_circles*2] += np.random.uniform(-delta, delta, n_circles*2)\n            x_new[:n_circles*2] = np.clip(x_new[:n_circles*2], 0, 1)\n            \n            result = optimize_packing(x_new)\n            if result.success and result.fun < best_obj:\n                best_obj = result.fun\n                best_x = result.x\n        \n        return best_x, best_obj\n    \n    # Store all results\n    all_results = []\n    \n    print(\"Running 50 independent optimizations...\")\n    \n    # 20 hexagonal grid perturbations\n    for i in range(20):\n        spacing = np.random.uniform(0.12, 0.18)\n        noise = np.random.uniform(0.005, 0.02)\n        centers = generate_hex_grid(spacing, noise)\n        radii = np.random.uniform(0.02, 0.05, n_circles)\n        x0 = pack_to_vars(centers, radii)\n        \n        result = optimize_packing(x0)\n        if result.success:\n            all_results.append((result.x, result.fun))\n            print(f\"Hex {i+1}: sum_radii = {-result.fun:.6f}\")\n    \n    # 10 random initializations\n    for i in range(10):\n        centers = np.random.uniform(0.1, 0.9, (n_circles, 2))\n        radii = np.random.uniform(0.02, 0.05, n_circles)\n        x0 = pack_to_vars(centers, radii)\n        \n        result = optimize_packing(x0)\n        if result.success:\n            all_results.append((result.x, result.fun))\n            print(f\"Random {i+1}: sum_radii = {-result.fun:.6f}\")\n    \n    # 10 spiral patterns\n    for i in range(10):\n        centers = generate_spiral(n_circles)\n        centers = np.clip(centers, 0.05, 0.95)\n        radii = np.random.uniform(0.02, 0.05, n_circles)\n        x0 = pack_to_vars(centers, radii)\n        \n        result = optimize_packing(x0)\n        if result.success:\n            all_results.append((result.x, result.fun))\n            print(f\"Spiral {i+1}: sum_radii = {-result.fun:.6f}\")\n    \n    # 10 from previous best with noise\n    if all_results:\n        all_results.sort(key=lambda x: x[1])\n        for i in range(min(10, len(all_results))):\n            x_base = all_results[i][0].copy()\n            x_new = x_base.copy()\n            x_new[:n_circles*2] += np.random.uniform(-0.02, 0.02, n_circles*2)\n            x_new[:n_circles*2] = np.clip(x_new[:n_circles*2], 0, 1)\n            x_new[n_circles*2:] += np.random.uniform(-0.01, 0.01, n_circles)\n            x_new[n_circles*2:] = np.clip(x_new[n_circles*2:], 0.001, 0.5)\n            \n            result = optimize_packing(x_new)\n            if result.success:\n                all_results.append((result.x, result.fun))\n                print(f\"Refined {i+1}: sum_radii = {-result.fun:.6f}\")\n    \n    # Take top 10 and apply local search\n    all_results.sort(key=lambda x: x[1])\n    top_results = all_results[:min(10, len(all_results))]\n    \n    print(\"\\nApplying local search to top 10...\")\n    final_results = []\n    for i, (x, obj) in enumerate(top_results):\n        x_refined, obj_refined = local_search(x)\n        final_results.append((x_refined, obj_refined))\n        print(f\"Local search {i+1}: sum_radii = {-obj_refined:.6f}\")\n    \n    # Get absolute best\n    final_results.sort(key=lambda x: x[1])\n    best_x, best_obj = final_results[0]\n    \n    centers, radii = vars_to_pack(best_x)\n    sum_radii = -best_obj\n    \n    print(f\"\\nFinal best sum_radii: {sum_radii:.6f}\")\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Run the packing algorithm\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"\\nFinal sum of radii: {sum_radii:.6f}\")\n    print(f\"Target (2.635): {'ACHIEVED!' if sum_radii >= 2.635 else 'Not reached'}\")\n```",
  "reasoning": "",
  "timestamp": "2025-12-04T15:44:04.530840",
  "cost_data": null
}