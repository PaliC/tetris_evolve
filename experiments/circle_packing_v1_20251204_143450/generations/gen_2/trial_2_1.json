{
  "trial_id": "trial_2_1",
  "generation": 2,
  "parent_id": "trial_1_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import cdist\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef construct_packing():\n    \"\"\"\n    State-of-the-art circle packing algorithm for 26 circles in [0,1]x[0,1]\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    n_circles = 26\n    best_result = None\n    best_sum = 0\n    \n    def generate_initial_configs():\n        \"\"\"Generate diverse initial configurations\"\"\"\n        configs = []\n        \n        # 1. Hexagonal grids with various spacings\n        for spacing in [0.18, 0.19, 0.20, 0.21, 0.22]:\n            centers = []\n            for row in range(6):\n                for col in range(5):\n                    x = 0.1 + col * spacing + (row % 2) * spacing / 2\n                    y = 0.1 + row * spacing * 0.866\n                    if x <= 0.9 and y <= 0.9:\n                        centers.append([x, y])\n            if len(centers) >= n_circles:\n                configs.append(np.array(centers[:n_circles]))\n        \n        # 2. Golden ratio spiral patterns\n        phi = (1 + np.sqrt(5)) / 2\n        for scale in [0.35, 0.38, 0.40, 0.42]:\n            centers = []\n            for i in range(n_circles):\n                theta = 2 * np.pi * i / phi\n                r = scale * np.sqrt(i / n_circles)\n                x = 0.5 + r * np.cos(theta)\n                y = 0.5 + r * np.sin(theta)\n                centers.append([x, y])\n            configs.append(np.array(centers))\n        \n        # 3. Grid-based with variations\n        for nx in [5, 6]:\n            ny = (n_circles + nx - 1) // nx\n            centers = []\n            for i in range(n_circles):\n                x = 0.08 + (i % nx) * (0.84 / (nx - 1)) if nx > 1 else 0.5\n                y = 0.08 + (i // nx) * (0.84 / (ny - 1)) if ny > 1 else 0.5\n                centers.append([x, y])\n            configs.append(np.array(centers))\n        \n        # 4. Random with strategic placement\n        np.random.seed(42)\n        for seed in range(35):\n            np.random.seed(seed)\n            centers = np.random.uniform(0.15, 0.85, (n_circles, 2))\n            # Place some circles strategically\n            centers[0] = [0.5, 0.5]  # center\n            centers[1] = [0.15, 0.15]  # corners\n            centers[2] = [0.85, 0.15]\n            centers[3] = [0.15, 0.85]\n            centers[4] = [0.85, 0.85]\n            configs.append(centers)\n        \n        return configs\n    \n    def objective(x):\n        \"\"\"Maximize sum of radii (minimize negative sum)\"\"\"\n        radii = x[2*n_circles:]\n        return -np.sum(radii)\n    \n    def create_constraints(x):\n        \"\"\"Create constraint vector: all values should be >= 0\"\"\"\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        constraints = []\n        \n        # Non-overlap constraints\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt((centers[i,0] - centers[j,0])**2 + \n                             (centers[i,1] - centers[j,1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Boundary constraints\n        for i in range(n_circles):\n            constraints.append(centers[i,0] - radii[i])  # left\n            constraints.append(1 - centers[i,0] - radii[i])  # right\n            constraints.append(centers[i,1] - radii[i])  # bottom\n            constraints.append(1 - centers[i,1] - radii[i])  # top\n        \n        return np.array(constraints)\n    \n    def optimize_config(initial_centers, method='SLSQP'):\n        \"\"\"Optimize a single configuration\"\"\"\n        # Initial radii estimate\n        initial_radii = np.full(n_circles, 0.08)\n        x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n        \n        # Bounds\n        bounds = [(0.05, 0.95)] * (2*n_circles) + [(0.01, 0.3)] * n_circles\n        \n        # Constraints\n        nlc = NonlinearConstraint(create_constraints, 0, np.inf)\n        \n        try:\n            result = minimize(\n                objective, x0, method=method,\n                bounds=bounds,\n                constraints=nlc,\n                options={'ftol': 1e-12, 'maxiter': 3000}\n            )\n            \n            if result.success or result.fun < 0:\n                centers = result.x[:2*n_circles].reshape(n_circles, 2)\n                radii = result.x[2*n_circles:]\n                sum_radii = np.sum(radii)\n                \n                # Verify constraints\n                constraints = create_constraints(result.x)\n                if np.all(constraints >= -1e-6):\n                    return centers, radii, sum_radii\n        except:\n            pass\n        \n        return None, None, 0\n    \n    # Generate initial configurations\n    initial_configs = generate_initial_configs()\n    \n    # Optimize each configuration\n    results = []\n    for i, config in enumerate(initial_configs):\n        centers, radii, sum_radii = optimize_config(config, method='SLSQP')\n        if sum_radii > 0:\n            results.append((centers, radii, sum_radii))\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_result = (centers, radii, sum_radii)\n    \n    # Refine top 5 results\n    results.sort(key=lambda x: x[2], reverse=True)\n    for centers, radii, sum_radii in results[:5]:\n        # Try trust-constr method\n        centers_new, radii_new, sum_new = optimize_config(centers, method='trust-constr')\n        if sum_new > best_sum:\n            best_sum = sum_new\n            best_result = (centers_new, radii_new, sum_new)\n        \n        # Micro-perturbations\n        for _ in range(3):\n            perturbed = centers + np.random.randn(n_circles, 2) * 0.01\n            perturbed = np.clip(perturbed, 0.1, 0.9)\n            centers_new, radii_new, sum_new = optimize_config(perturbed, method='SLSQP')\n            if sum_new > best_sum:\n                best_sum = sum_new\n                best_result = (centers_new, radii_new, sum_new)\n    \n    if best_result is None:\n        # Fallback: simple grid\n        centers = []\n        for i in range(n_circles):\n            x = 0.1 + (i % 5) * 0.2\n            y = 0.1 + (i // 5) * 0.15\n            centers.append([x, y])\n        centers = np.array(centers)\n        radii = np.full(n_circles, 0.08)\n        return centers, radii, np.sum(radii)\n    \n    return best_result\n\ndef run_packing():\n    \"\"\"Run the packing algorithm and return results\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Target: 2.635\")\n    print(f\"Success: {sum_radii >= 2.635}\")",
  "metrics": {
    "valid": true,
    "sum_radii": 2.6253859489418034,
    "target_ratio": 0.9963514037729805,
    "combined_score": 0.9963514037729805,
    "eval_time": 28.00575613975525,
    "error": null
  },
  "prompt": "\nWrite a state-of-the-art circle packing algorithm for 26 circles in [0,1]x[0,1].\n\nLESSONS FROM EVOLUTION:\n- Variable radii optimization works best (not uniform sizing)\n- Multiple restarts are essential (30+)\n- Good initial configurations matter\n- Fine-tuning after main optimization helps\n\nALGORITHM:\n1. Generate 40+ diverse initial configurations:\n   - Hexagonal grids with various spacings\n   - Golden ratio spiral patterns\n   - Random with strategic placement (corners, edges, center)\n   - Perturbed optimal patterns\n\n2. For each initial configuration:\n   - Optimize positions and radii jointly (78 variables)\n   - Use scipy.optimize.minimize with method='SLSQP'\n   - Set tight tolerances: ftol=1e-12, maxiter=3000\n   - Constraints: no overlaps, circles within bounds\n\n3. Take top 5 results and refine:\n   - Try trust-constr method for better constraint handling\n   - Apply micro-perturbations and re-optimize\n   - Test boundary adjustments\n\n4. Return the absolute best valid configuration\n\nTARGET: sum_radii >= 2.635\n\nRequirements:\n- Define construct_packing() that returns (centers, radii, sum_radii)\n- Define run_packing() that calls construct_packing()\n- Use numpy and scipy.optimize\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import cdist\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef construct_packing():\n    \"\"\"\n    State-of-the-art circle packing algorithm for 26 circles in [0,1]x[0,1]\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    n_circles = 26\n    best_result = None\n    best_sum = 0\n    \n    def generate_initial_configs():\n        \"\"\"Generate diverse initial configurations\"\"\"\n        configs = []\n        \n        # 1. Hexagonal grids with various spacings\n        for spacing in [0.18, 0.19, 0.20, 0.21, 0.22]:\n            centers = []\n            for row in range(6):\n                for col in range(5):\n                    x = 0.1 + col * spacing + (row % 2) * spacing / 2\n                    y = 0.1 + row * spacing * 0.866\n                    if x <= 0.9 and y <= 0.9:\n                        centers.append([x, y])\n            if len(centers) >= n_circles:\n                configs.append(np.array(centers[:n_circles]))\n        \n        # 2. Golden ratio spiral patterns\n        phi = (1 + np.sqrt(5)) / 2\n        for scale in [0.35, 0.38, 0.40, 0.42]:\n            centers = []\n            for i in range(n_circles):\n                theta = 2 * np.pi * i / phi\n                r = scale * np.sqrt(i / n_circles)\n                x = 0.5 + r * np.cos(theta)\n                y = 0.5 + r * np.sin(theta)\n                centers.append([x, y])\n            configs.append(np.array(centers))\n        \n        # 3. Grid-based with variations\n        for nx in [5, 6]:\n            ny = (n_circles + nx - 1) // nx\n            centers = []\n            for i in range(n_circles):\n                x = 0.08 + (i % nx) * (0.84 / (nx - 1)) if nx > 1 else 0.5\n                y = 0.08 + (i // nx) * (0.84 / (ny - 1)) if ny > 1 else 0.5\n                centers.append([x, y])\n            configs.append(np.array(centers))\n        \n        # 4. Random with strategic placement\n        np.random.seed(42)\n        for seed in range(35):\n            np.random.seed(seed)\n            centers = np.random.uniform(0.15, 0.85, (n_circles, 2))\n            # Place some circles strategically\n            centers[0] = [0.5, 0.5]  # center\n            centers[1] = [0.15, 0.15]  # corners\n            centers[2] = [0.85, 0.15]\n            centers[3] = [0.15, 0.85]\n            centers[4] = [0.85, 0.85]\n            configs.append(centers)\n        \n        return configs\n    \n    def objective(x):\n        \"\"\"Maximize sum of radii (minimize negative sum)\"\"\"\n        radii = x[2*n_circles:]\n        return -np.sum(radii)\n    \n    def create_constraints(x):\n        \"\"\"Create constraint vector: all values should be >= 0\"\"\"\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        constraints = []\n        \n        # Non-overlap constraints\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt((centers[i,0] - centers[j,0])**2 + \n                             (centers[i,1] - centers[j,1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Boundary constraints\n        for i in range(n_circles):\n            constraints.append(centers[i,0] - radii[i])  # left\n            constraints.append(1 - centers[i,0] - radii[i])  # right\n            constraints.append(centers[i,1] - radii[i])  # bottom\n            constraints.append(1 - centers[i,1] - radii[i])  # top\n        \n        return np.array(constraints)\n    \n    def optimize_config(initial_centers, method='SLSQP'):\n        \"\"\"Optimize a single configuration\"\"\"\n        # Initial radii estimate\n        initial_radii = np.full(n_circles, 0.08)\n        x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n        \n        # Bounds\n        bounds = [(0.05, 0.95)] * (2*n_circles) + [(0.01, 0.3)] * n_circles\n        \n        # Constraints\n        nlc = NonlinearConstraint(create_constraints, 0, np.inf)\n        \n        try:\n            result = minimize(\n                objective, x0, method=method,\n                bounds=bounds,\n                constraints=nlc,\n                options={'ftol': 1e-12, 'maxiter': 3000}\n            )\n            \n            if result.success or result.fun < 0:\n                centers = result.x[:2*n_circles].reshape(n_circles, 2)\n                radii = result.x[2*n_circles:]\n                sum_radii = np.sum(radii)\n                \n                # Verify constraints\n                constraints = create_constraints(result.x)\n                if np.all(constraints >= -1e-6):\n                    return centers, radii, sum_radii\n        except:\n            pass\n        \n        return None, None, 0\n    \n    # Generate initial configurations\n    initial_configs = generate_initial_configs()\n    \n    # Optimize each configuration\n    results = []\n    for i, config in enumerate(initial_configs):\n        centers, radii, sum_radii = optimize_config(config, method='SLSQP')\n        if sum_radii > 0:\n            results.append((centers, radii, sum_radii))\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_result = (centers, radii, sum_radii)\n    \n    # Refine top 5 results\n    results.sort(key=lambda x: x[2], reverse=True)\n    for centers, radii, sum_radii in results[:5]:\n        # Try trust-constr method\n        centers_new, radii_new, sum_new = optimize_config(centers, method='trust-constr')\n        if sum_new > best_sum:\n            best_sum = sum_new\n            best_result = (centers_new, radii_new, sum_new)\n        \n        # Micro-perturbations\n        for _ in range(3):\n            perturbed = centers + np.random.randn(n_circles, 2) * 0.01\n            perturbed = np.clip(perturbed, 0.1, 0.9)\n            centers_new, radii_new, sum_new = optimize_config(perturbed, method='SLSQP')\n            if sum_new > best_sum:\n                best_sum = sum_new\n                best_result = (centers_new, radii_new, sum_new)\n    \n    if best_result is None:\n        # Fallback: simple grid\n        centers = []\n        for i in range(n_circles):\n            x = 0.1 + (i % 5) * 0.2\n            y = 0.1 + (i // 5) * 0.15\n            centers.append([x, y])\n        centers = np.array(centers)\n        radii = np.full(n_circles, 0.08)\n        return centers, radii, np.sum(radii)\n    \n    return best_result\n\ndef run_packing():\n    \"\"\"Run the packing algorithm and return results\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Target: 2.635\")\n    print(f\"Success: {sum_radii >= 2.635}\")\n```",
  "reasoning": "",
  "timestamp": "2025-12-04T15:18:46.784688",
  "cost_data": null
}