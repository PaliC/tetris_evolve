{
  "trial_id": "trial_0_6",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom typing import Tuple\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Construct a circle packing for 26 circles in a unit square using\n    hybrid simulated annealing + gradient-based optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - circle centers\n        radii: np.array of shape (26,) - circle radii\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n_circles = 26\n    np.random.seed(42)\n    \n    # Initialize with grid layout\n    def initialize_grid(n):\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(centers) >= n:\n                    break\n                x = (i + 0.5) / grid_size\n                y = (j + 0.5) / grid_size\n                centers.append([x, y])\n        return np.array(centers[:n])\n    \n    def compute_max_radii(centers):\n        \"\"\"Compute maximum valid radius for each circle given positions.\"\"\"\n        n = len(centers)\n        radii = np.ones(n) * 0.5  # Start with large radii\n        \n        for i in range(n):\n            # Distance to boundaries\n            min_r = min(centers[i, 0], 1 - centers[i, 0], \n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    min_r = min(min_r, dist / 2)\n            \n            radii[i] = max(min_r, 1e-6)\n        \n        return radii\n    \n    def is_valid_packing(centers, radii):\n        \"\"\"Check if packing is valid (no overlaps, within bounds).\"\"\"\n        n = len(centers)\n        \n        # Check boundaries\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < -1e-6 or \n                centers[i, 0] + radii[i] > 1 + 1e-6 or\n                centers[i, 1] - radii[i] < -1e-6 or \n                centers[i, 1] + radii[i] > 1 + 1e-6):\n                return False\n        \n        # Check overlaps\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-6:\n                    return False\n        \n        return True\n    \n    # Phase 1: Simulated Annealing\n    centers = initialize_grid(n_circles)\n    radii = compute_max_radii(centers)\n    \n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    current_centers = centers.copy()\n    current_sum = best_sum\n    \n    T_initial = 0.1\n    T_final = 0.001\n    n_iterations = 5000\n    \n    for iteration in range(n_iterations):\n        T = T_initial * (T_final / T_initial) ** (iteration / n_iterations)\n        \n        # Perturb positions\n        new_centers = current_centers.copy()\n        n_perturb = np.random.randint(1, min(5, n_circles + 1))\n        indices = np.random.choice(n_circles, n_perturb, replace=False)\n        \n        for idx in indices:\n            perturbation = np.random.randn(2) * T * 0.5\n            new_centers[idx] += perturbation\n            # Keep within bounds with margin\n            new_centers[idx] = np.clip(new_centers[idx], 0.02, 0.98)\n        \n        # Compute radii for new configuration\n        new_radii = compute_max_radii(new_centers)\n        new_sum = np.sum(new_radii)\n        \n        # Accept or reject\n        delta = new_sum - current_sum\n        if delta > 0 or np.random.random() < np.exp(delta / T):\n            current_centers = new_centers\n            current_sum = new_sum\n            \n            # Update best\n            if new_sum > best_sum:\n                best_centers = new_centers.copy()\n                best_radii = new_radii.copy()\n                best_sum = new_sum\n    \n    # Phase 2: Gradient-based optimization\n    def objective(x):\n        \"\"\"Negative sum of radii (minimize negative = maximize positive).\"\"\"\n        centers_opt = x.reshape(n_circles, 2)\n        radii_opt = compute_max_radii(centers_opt)\n        return -np.sum(radii_opt)\n    \n    def constraint_boundary(x):\n        \"\"\"Ensure circles stay within boundaries.\"\"\"\n        centers_opt = x.reshape(n_circles, 2)\n        radii_opt = compute_max_radii(centers_opt)\n        constraints = []\n        \n        for i in range(n_circles):\n            constraints.append(centers_opt[i, 0] - radii_opt[i])  # left\n            constraints.append(1 - centers_opt[i, 0] - radii_opt[i])  # right\n            constraints.append(centers_opt[i, 1] - radii_opt[i])  # bottom\n            constraints.append(1 - centers_opt[i, 1] - radii_opt[i])  # top\n        \n        return np.array(constraints)\n    \n    def constraint_overlap(x):\n        \"\"\"Ensure no overlaps.\"\"\"\n        centers_opt = x.reshape(n_circles, 2)\n        radii_opt = compute_max_radii(centers_opt)\n        constraints = []\n        \n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers_opt[i] - centers_opt[j])\n                constraints.append(dist - radii_opt[i] - radii_opt[j])\n        \n        return np.array(constraints)\n    \n    # Optimize from best SA result\n    x0 = best_centers.flatten()\n    bounds = [(0.01, 0.99)] * (n_circles * 2)\n    \n    constraints = [\n        {'type': 'ineq', 'fun': constraint_boundary},\n        {'type': 'ineq', 'fun': constraint_overlap}\n    ]\n    \n    result = minimize(objective, x0, method='SLSQP', bounds=bounds,\n                     constraints=constraints, options={'maxiter': 500, 'ftol': 1e-9})\n    \n    if result.success or result.fun < -best_sum:\n        final_centers = result.x.reshape(n_circles, 2)\n        final_radii = compute_max_radii(final_centers)\n        final_sum = np.sum(final_radii)\n        \n        if is_valid_packing(final_centers, final_radii) and final_sum > best_sum:\n            best_centers = final_centers\n            best_radii = final_radii\n            best_sum = final_sum\n    \n    # Final validation and adjustment\n    best_radii = compute_max_radii(best_centers)\n    best_sum = np.sum(best_radii)\n    \n    return best_centers, best_radii, best_sum\n\n\ndef run_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Run the circle packing algorithm.\n    \n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Centers shape: {centers.shape}\")\n    print(f\"Radii shape: {radii.shape}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    # Validation\n    n = len(centers)\n    valid = True\n    \n    # Check boundaries\n    for i in range(n):\n        if (centers[i, 0] - radii[i] < -1e-6 or \n            centers[i, 0] + radii[i] > 1 + 1e-6 or\n            centers[i, 1] - radii[i] < -1e-6 or \n            centers[i, 1] + radii[i] > 1 + 1e-6):\n            print(f\"Circle {i} violates boundary\")\n            valid = False\n    \n    # Check overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-6:\n                print(f\"Circles {i} and {j} overlap\")\n                valid = False\n    \n    print(f\"Packing valid: {valid}\")",
  "metrics": {
    "valid": true,
    "sum_radii": 2.1666666666666665,
    "target_ratio": 0.8222643896268185,
    "combined_score": 0.8222643896268185,
    "eval_time": 4.513164043426514,
    "error": null
  },
  "prompt": "\nWrite a hybrid circle packing algorithm for 26 circles in a unit square [0,1]x[0,1].\n\nCombine simulated annealing with gradient-based optimization:\n1. Phase 1: Use simulated annealing (5000 iterations) to explore solution space\n2. Phase 2: Take the best configuration from SA and refine with scipy.optimize\n3. This combines global exploration (SA) with local refinement (optimization)\n\nAlgorithm details:\n- SA: Start from grid, perturb positions, optimize radii at each step\n- Optimization: Use SLSQP to fine-tune the SA result\n- Track the best valid configuration throughout\n\nRequirements:\n- Define construct_packing() that returns (centers, radii, sum_radii)\n- Define run_packing() that calls construct_packing()\n- centers: np.array of shape (26, 2)\n- radii: np.array of shape (26,)\n- Ensure final result is valid (no overlaps, within bounds)\n\nUse numpy and scipy.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom typing import Tuple\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Construct a circle packing for 26 circles in a unit square using\n    hybrid simulated annealing + gradient-based optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - circle centers\n        radii: np.array of shape (26,) - circle radii\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n_circles = 26\n    np.random.seed(42)\n    \n    # Initialize with grid layout\n    def initialize_grid(n):\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(centers) >= n:\n                    break\n                x = (i + 0.5) / grid_size\n                y = (j + 0.5) / grid_size\n                centers.append([x, y])\n        return np.array(centers[:n])\n    \n    def compute_max_radii(centers):\n        \"\"\"Compute maximum valid radius for each circle given positions.\"\"\"\n        n = len(centers)\n        radii = np.ones(n) * 0.5  # Start with large radii\n        \n        for i in range(n):\n            # Distance to boundaries\n            min_r = min(centers[i, 0], 1 - centers[i, 0], \n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    min_r = min(min_r, dist / 2)\n            \n            radii[i] = max(min_r, 1e-6)\n        \n        return radii\n    \n    def is_valid_packing(centers, radii):\n        \"\"\"Check if packing is valid (no overlaps, within bounds).\"\"\"\n        n = len(centers)\n        \n        # Check boundaries\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < -1e-6 or \n                centers[i, 0] + radii[i] > 1 + 1e-6 or\n                centers[i, 1] - radii[i] < -1e-6 or \n                centers[i, 1] + radii[i] > 1 + 1e-6):\n                return False\n        \n        # Check overlaps\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-6:\n                    return False\n        \n        return True\n    \n    # Phase 1: Simulated Annealing\n    centers = initialize_grid(n_circles)\n    radii = compute_max_radii(centers)\n    \n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    current_centers = centers.copy()\n    current_sum = best_sum\n    \n    T_initial = 0.1\n    T_final = 0.001\n    n_iterations = 5000\n    \n    for iteration in range(n_iterations):\n        T = T_initial * (T_final / T_initial) ** (iteration / n_iterations)\n        \n        # Perturb positions\n        new_centers = current_centers.copy()\n        n_perturb = np.random.randint(1, min(5, n_circles + 1))\n        indices = np.random.choice(n_circles, n_perturb, replace=False)\n        \n        for idx in indices:\n            perturbation = np.random.randn(2) * T * 0.5\n            new_centers[idx] += perturbation\n            # Keep within bounds with margin\n            new_centers[idx] = np.clip(new_centers[idx], 0.02, 0.98)\n        \n        # Compute radii for new configuration\n        new_radii = compute_max_radii(new_centers)\n        new_sum = np.sum(new_radii)\n        \n        # Accept or reject\n        delta = new_sum - current_sum\n        if delta > 0 or np.random.random() < np.exp(delta / T):\n            current_centers = new_centers\n            current_sum = new_sum\n            \n            # Update best\n            if new_sum > best_sum:\n                best_centers = new_centers.copy()\n                best_radii = new_radii.copy()\n                best_sum = new_sum\n    \n    # Phase 2: Gradient-based optimization\n    def objective(x):\n        \"\"\"Negative sum of radii (minimize negative = maximize positive).\"\"\"\n        centers_opt = x.reshape(n_circles, 2)\n        radii_opt = compute_max_radii(centers_opt)\n        return -np.sum(radii_opt)\n    \n    def constraint_boundary(x):\n        \"\"\"Ensure circles stay within boundaries.\"\"\"\n        centers_opt = x.reshape(n_circles, 2)\n        radii_opt = compute_max_radii(centers_opt)\n        constraints = []\n        \n        for i in range(n_circles):\n            constraints.append(centers_opt[i, 0] - radii_opt[i])  # left\n            constraints.append(1 - centers_opt[i, 0] - radii_opt[i])  # right\n            constraints.append(centers_opt[i, 1] - radii_opt[i])  # bottom\n            constraints.append(1 - centers_opt[i, 1] - radii_opt[i])  # top\n        \n        return np.array(constraints)\n    \n    def constraint_overlap(x):\n        \"\"\"Ensure no overlaps.\"\"\"\n        centers_opt = x.reshape(n_circles, 2)\n        radii_opt = compute_max_radii(centers_opt)\n        constraints = []\n        \n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers_opt[i] - centers_opt[j])\n                constraints.append(dist - radii_opt[i] - radii_opt[j])\n        \n        return np.array(constraints)\n    \n    # Optimize from best SA result\n    x0 = best_centers.flatten()\n    bounds = [(0.01, 0.99)] * (n_circles * 2)\n    \n    constraints = [\n        {'type': 'ineq', 'fun': constraint_boundary},\n        {'type': 'ineq', 'fun': constraint_overlap}\n    ]\n    \n    result = minimize(objective, x0, method='SLSQP', bounds=bounds,\n                     constraints=constraints, options={'maxiter': 500, 'ftol': 1e-9})\n    \n    if result.success or result.fun < -best_sum:\n        final_centers = result.x.reshape(n_circles, 2)\n        final_radii = compute_max_radii(final_centers)\n        final_sum = np.sum(final_radii)\n        \n        if is_valid_packing(final_centers, final_radii) and final_sum > best_sum:\n            best_centers = final_centers\n            best_radii = final_radii\n            best_sum = final_sum\n    \n    # Final validation and adjustment\n    best_radii = compute_max_radii(best_centers)\n    best_sum = np.sum(best_radii)\n    \n    return best_centers, best_radii, best_sum\n\n\ndef run_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Run the circle packing algorithm.\n    \n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Centers shape: {centers.shape}\")\n    print(f\"Radii shape: {radii.shape}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    # Validation\n    n = len(centers)\n    valid = True\n    \n    # Check boundaries\n    for i in range(n):\n        if (centers[i, 0] - radii[i] < -1e-6 or \n            centers[i, 0] + radii[i] > 1 + 1e-6 or\n            centers[i, 1] - radii[i] < -1e-6 or \n            centers[i, 1] + radii[i] > 1 + 1e-6):\n            print(f\"Circle {i} violates boundary\")\n            valid = False\n    \n    # Check overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-6:\n                print(f\"Circles {i} and {j} overlap\")\n                valid = False\n    \n    print(f\"Packing valid: {valid}\")\n```\n\nThis implementation:\n\n1. **Phase 1 (Simulated Annealing)**: \n   - Starts with a grid initialization\n   - Runs 5000 iterations with cooling schedule\n   - Perturbs circle positions randomly\n   - Recomputes optimal radii after each perturbation\n   - Accepts worse solutions probabilistically to escape local minima\n\n2. **Phase 2 (Gradient Optimization)**:\n   - Takes the best SA configuration\n   - Uses SLSQP with boundary and overlap constraints\n   - Fine-tunes positions to maximize total radii\n\n3. **Key features**:\n   - `compute_max_radii()`: Efficiently computes maximum valid radius for each circle\n   - `is_valid_packing()`: Validates final configuration\n   - Tracks best solution throughout both phases\n   - Returns valid packing with no overlaps\n\nThe hybrid approach combines SA's global exploration with gradient descent's local precision for high-quality results.",
  "reasoning": "This implementation:\n\n1. **Phase 1 (Simulated Annealing)**: \n   - Starts with a grid initialization\n   - Runs 5000 iterations with cooling schedule\n   - Perturbs circle positions randomly\n   - Recomputes optimal radii after each perturbation\n   - Accepts worse solutions probabilistically to escape local minima\n\n2. **Phase 2 (Gradient Optimization)**:\n   - Takes the best SA configuration\n   - Uses SLSQP with boundary and overlap constraints\n   - Fine-tunes positions to maximize total radii\n\n3. **Key features**:\n   - `compute_max_radii()`: Efficiently computes maximum valid radius for each circle\n   - `is_valid_packing()`: Validates final configuration\n   - Tracks best solution throughout both phases\n   - Returns valid packing with no overlaps\n\nThe hybrid approach combines SA's global exploration with gradient descent's local precision for high-quality results.",
  "timestamp": "2025-12-04T14:40:04.050704",
  "cost_data": null
}