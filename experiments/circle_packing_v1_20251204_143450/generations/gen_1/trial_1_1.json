{
  "trial_id": "trial_1_1",
  "generation": 1,
  "parent_id": "trial_0_9",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct optimal circle packing with variable radii using advanced optimization.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    n_circles = 26\n    best_result = None\n    best_sum = 0\n    \n    def generate_hex_grid_init(n, scale_variation=0.3):\n        \"\"\"Generate hexagonal grid initialization with variable radii.\"\"\"\n        centers = []\n        # Create hexagonal pattern\n        rows = int(np.sqrt(n * 2/np.sqrt(3))) + 1\n        for row in range(rows):\n            cols = int(n / rows) + 1\n            y_offset = row * np.sqrt(3) / 2\n            x_offset = (row % 2) * 0.5\n            for col in range(cols):\n                if len(centers) >= n:\n                    break\n                x = (col + x_offset) / (cols + 1)\n                y = y_offset / (rows * np.sqrt(3) / 2 + 1)\n                centers.append([x * 0.8 + 0.1, y * 0.8 + 0.1])\n        centers = np.array(centers[:n])\n        # Variable radii initialization\n        radii = np.random.uniform(0.02, 0.06, n) * (1 + np.random.randn(n) * scale_variation)\n        radii = np.clip(radii, 0.01, 0.1)\n        return np.concatenate([centers.flatten(), radii])\n    \n    def generate_spiral_init(n):\n        \"\"\"Generate spiral pattern initialization.\"\"\"\n        centers = []\n        theta = 0\n        r = 0\n        for i in range(n):\n            x = 0.5 + r * np.cos(theta)\n            y = 0.5 + r * np.sin(theta)\n            centers.append([x, y])\n            theta += 2.4  # Golden angle approximation\n            r += 0.012\n        centers = np.array(centers)\n        # Normalize to fit in bounds\n        centers = (centers - centers.min()) / (centers.max() - centers.min()) * 0.8 + 0.1\n        radii = np.random.uniform(0.02, 0.06, n)\n        return np.concatenate([centers.flatten(), radii])\n    \n    def generate_random_init(n):\n        \"\"\"Generate random initialization.\"\"\"\n        centers = np.random.uniform(0.15, 0.85, (n, 2))\n        radii = np.random.uniform(0.02, 0.08, n)\n        return np.concatenate([centers.flatten(), radii])\n    \n    def objective(x, alpha=1.0):\n        \"\"\"Objective: maximize sum of radii with soft constraints.\"\"\"\n        radii = x[2*n_circles:]\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        \n        # Primary objective: maximize sum of radii\n        obj = -np.sum(radii)\n        \n        # Soft constraint penalties (used in early stages)\n        if alpha > 0:\n            # Penalty for circles outside bounds\n            for i in range(n_circles):\n                cx, cy, r = centers[i, 0], centers[i, 1], radii[i]\n                if cx - r < 0:\n                    obj += alpha * 1000 * (0 - (cx - r))**2\n                if cx + r > 1:\n                    obj += alpha * 1000 * ((cx + r) - 1)**2\n                if cy - r < 0:\n                    obj += alpha * 1000 * (0 - (cy - r))**2\n                if cy + r > 1:\n                    obj += alpha * 1000 * ((cy + r) - 1)**2\n            \n            # Penalty for overlapping circles\n            for i in range(n_circles):\n                for j in range(i+1, n_circles):\n                    dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                                   (centers[i, 1] - centers[j, 1])**2)\n                    min_dist = radii[i] + radii[j]\n                    if dist < min_dist:\n                        obj += alpha * 1000 * (min_dist - dist)**2\n        \n        return obj\n    \n    def constraints_factory():\n        \"\"\"Generate constraint functions.\"\"\"\n        constraints = []\n        \n        # Non-overlap constraints\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                def non_overlap(x, i=i, j=j):\n                    centers = x[:2*n_circles].reshape(n_circles, 2)\n                    radii = x[2*n_circles:]\n                    dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                                   (centers[i, 1] - centers[j, 1])**2)\n                    return dist - radii[i] - radii[j]\n                constraints.append({'type': 'ineq', 'fun': non_overlap})\n        \n        # Boundary constraints\n        for i in range(n_circles):\n            # Left boundary\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: x[:2*n_circles].reshape(n_circles, 2)[i, 0] - x[2*n_circles + i]\n            })\n            # Right boundary\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: 1 - x[:2*n_circles].reshape(n_circles, 2)[i, 0] - x[2*n_circles + i]\n            })\n            # Bottom boundary\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: x[:2*n_circles].reshape(n_circles, 2)[i, 1] - x[2*n_circles + i]\n            })\n            # Top boundary\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: 1 - x[:2*n_circles].reshape(n_circles, 2)[i, 1] - x[2*n_circles + i]\n            })\n        \n        return constraints\n    \n    # Bounds for variables\n    bounds = [(0, 1)] * (2 * n_circles) + [(0.001, 0.15)] * n_circles\n    \n    # Multiple restart optimization with different strategies\n    n_restarts = 15\n    \n    for restart in range(n_restarts):\n        print(f\"Restart {restart + 1}/{n_restarts}\")\n        \n        # Choose initialization strategy\n        if restart % 3 == 0:\n            x0 = generate_hex_grid_init(n_circles)\n        elif restart % 3 == 1:\n            x0 = generate_spiral_init(n_circles)\n        else:\n            x0 = generate_random_init(n_circles)\n        \n        # Stage 1: Soft constraints with moderate penalty\n        print(\"  Stage 1: Soft constraints...\")\n        result = minimize(\n            lambda x: objective(x, alpha=0.5),\n            x0,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': 500, 'ftol': 1e-8}\n        )\n        \n        # Stage 2: Hard constraints with SLSQP\n        print(\"  Stage 2: Hard constraints with SLSQP...\")\n        constraints = constraints_factory()\n        result = minimize(\n            lambda x: objective(x, alpha=0),\n            result.x,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-10, 'disp': False}\n        )\n        \n        # Stage 3: Refinement with tighter tolerances\n        if result.success:\n            print(\"  Stage 3: Refinement...\")\n            result = minimize(\n                lambda x: objective(x, alpha=0),\n                result.x,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 500, 'ftol': 1e-12, 'disp': False}\n            )\n        \n        # Post-optimization: local perturbations\n        if result.success:\n            print(\"  Stage 4: Local perturbations...\")\n            for _ in range(5):\n                perturbed = result.x.copy()\n                perturbed[:2*n_circles] += np.random.randn(2*n_circles) * 0.001\n                temp_result = minimize(\n                    lambda x: objective(x, alpha=0),\n                    perturbed,\n                    method='SLSQP',\n                    bounds=bounds,\n                    constraints=constraints,\n                    options={'maxiter': 200, 'ftol': 1e-12, 'disp': False}\n                )\n                if temp_result.success and temp_result.fun < result.fun:\n                    result = temp_result\n        \n        if result.success:\n            sum_radii = np.sum(result.x[2*n_circles:])\n            print(f\"  Sum of radii: {sum_radii:.6f}\")\n            \n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_result = result\n                print(f\"  *** NEW BEST: {best_sum:.6f} ***\")\n    \n    if best_result is None:\n        # Fallback\n        x0 = generate_hex_grid_init(n_circles)\n        best_result = minimize(\n            lambda x: objective(x, alpha=1.0),\n            x0,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': 1000}\n        )\n    \n    centers = best_result.x[:2*n_circles].reshape(n_circles, 2)\n    radii = best_result.x[2*n_circles:]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Run the packing algorithm and return results.\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    print(f\"\\nFinal sum_radii = {sum_radii:.6f}\")\n    return centers, radii, sum_radii\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.6180682559627315,
    "target_ratio": 0.9935742906879438,
    "combined_score": 0.9935742906879438,
    "eval_time": 140.01780128479004,
    "error": null
  },
  "prompt": "\nImprove this circle packing algorithm by focusing on constraint handling.\n\nCURRENT BEST: sum_radii = 2.516062\n\nCreate a variable radii optimization algorithm with:\n1. Soft constraints initially, then hard constraints\n2. Sequential quadratic programming (SLSQP) with tight tolerances\n3. Smart initialization from multiple patterns:\n   - Hexagonal grid with variable radii\n   - Random perturbations of uniform grid\n   - Spiral pattern\n4. Post-optimization refinement: try small position adjustments\n5. Use scipy.optimize with multiple restarts (at least 10)\n\nKey insight: Allow radii to vary significantly - some circles can be much larger than others.\n\nRequirements:\n- Define construct_packing() that returns (centers, radii, sum_radii)\n- Define run_packing() that calls construct_packing()\n- 26 circles in [0,1]x[0,1], no overlaps\n- Use numpy and scipy.optimize\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct optimal circle packing with variable radii using advanced optimization.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    n_circles = 26\n    best_result = None\n    best_sum = 0\n    \n    def generate_hex_grid_init(n, scale_variation=0.3):\n        \"\"\"Generate hexagonal grid initialization with variable radii.\"\"\"\n        centers = []\n        # Create hexagonal pattern\n        rows = int(np.sqrt(n * 2/np.sqrt(3))) + 1\n        for row in range(rows):\n            cols = int(n / rows) + 1\n            y_offset = row * np.sqrt(3) / 2\n            x_offset = (row % 2) * 0.5\n            for col in range(cols):\n                if len(centers) >= n:\n                    break\n                x = (col + x_offset) / (cols + 1)\n                y = y_offset / (rows * np.sqrt(3) / 2 + 1)\n                centers.append([x * 0.8 + 0.1, y * 0.8 + 0.1])\n        centers = np.array(centers[:n])\n        # Variable radii initialization\n        radii = np.random.uniform(0.02, 0.06, n) * (1 + np.random.randn(n) * scale_variation)\n        radii = np.clip(radii, 0.01, 0.1)\n        return np.concatenate([centers.flatten(), radii])\n    \n    def generate_spiral_init(n):\n        \"\"\"Generate spiral pattern initialization.\"\"\"\n        centers = []\n        theta = 0\n        r = 0\n        for i in range(n):\n            x = 0.5 + r * np.cos(theta)\n            y = 0.5 + r * np.sin(theta)\n            centers.append([x, y])\n            theta += 2.4  # Golden angle approximation\n            r += 0.012\n        centers = np.array(centers)\n        # Normalize to fit in bounds\n        centers = (centers - centers.min()) / (centers.max() - centers.min()) * 0.8 + 0.1\n        radii = np.random.uniform(0.02, 0.06, n)\n        return np.concatenate([centers.flatten(), radii])\n    \n    def generate_random_init(n):\n        \"\"\"Generate random initialization.\"\"\"\n        centers = np.random.uniform(0.15, 0.85, (n, 2))\n        radii = np.random.uniform(0.02, 0.08, n)\n        return np.concatenate([centers.flatten(), radii])\n    \n    def objective(x, alpha=1.0):\n        \"\"\"Objective: maximize sum of radii with soft constraints.\"\"\"\n        radii = x[2*n_circles:]\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        \n        # Primary objective: maximize sum of radii\n        obj = -np.sum(radii)\n        \n        # Soft constraint penalties (used in early stages)\n        if alpha > 0:\n            # Penalty for circles outside bounds\n            for i in range(n_circles):\n                cx, cy, r = centers[i, 0], centers[i, 1], radii[i]\n                if cx - r < 0:\n                    obj += alpha * 1000 * (0 - (cx - r))**2\n                if cx + r > 1:\n                    obj += alpha * 1000 * ((cx + r) - 1)**2\n                if cy - r < 0:\n                    obj += alpha * 1000 * (0 - (cy - r))**2\n                if cy + r > 1:\n                    obj += alpha * 1000 * ((cy + r) - 1)**2\n            \n            # Penalty for overlapping circles\n            for i in range(n_circles):\n                for j in range(i+1, n_circles):\n                    dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                                   (centers[i, 1] - centers[j, 1])**2)\n                    min_dist = radii[i] + radii[j]\n                    if dist < min_dist:\n                        obj += alpha * 1000 * (min_dist - dist)**2\n        \n        return obj\n    \n    def constraints_factory():\n        \"\"\"Generate constraint functions.\"\"\"\n        constraints = []\n        \n        # Non-overlap constraints\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                def non_overlap(x, i=i, j=j):\n                    centers = x[:2*n_circles].reshape(n_circles, 2)\n                    radii = x[2*n_circles:]\n                    dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                                   (centers[i, 1] - centers[j, 1])**2)\n                    return dist - radii[i] - radii[j]\n                constraints.append({'type': 'ineq', 'fun': non_overlap})\n        \n        # Boundary constraints\n        for i in range(n_circles):\n            # Left boundary\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: x[:2*n_circles].reshape(n_circles, 2)[i, 0] - x[2*n_circles + i]\n            })\n            # Right boundary\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: 1 - x[:2*n_circles].reshape(n_circles, 2)[i, 0] - x[2*n_circles + i]\n            })\n            # Bottom boundary\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: x[:2*n_circles].reshape(n_circles, 2)[i, 1] - x[2*n_circles + i]\n            })\n            # Top boundary\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: 1 - x[:2*n_circles].reshape(n_circles, 2)[i, 1] - x[2*n_circles + i]\n            })\n        \n        return constraints\n    \n    # Bounds for variables\n    bounds = [(0, 1)] * (2 * n_circles) + [(0.001, 0.15)] * n_circles\n    \n    # Multiple restart optimization with different strategies\n    n_restarts = 15\n    \n    for restart in range(n_restarts):\n        print(f\"Restart {restart + 1}/{n_restarts}\")\n        \n        # Choose initialization strategy\n        if restart % 3 == 0:\n            x0 = generate_hex_grid_init(n_circles)\n        elif restart % 3 == 1:\n            x0 = generate_spiral_init(n_circles)\n        else:\n            x0 = generate_random_init(n_circles)\n        \n        # Stage 1: Soft constraints with moderate penalty\n        print(\"  Stage 1: Soft constraints...\")\n        result = minimize(\n            lambda x: objective(x, alpha=0.5),\n            x0,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': 500, 'ftol': 1e-8}\n        )\n        \n        # Stage 2: Hard constraints with SLSQP\n        print(\"  Stage 2: Hard constraints with SLSQP...\")\n        constraints = constraints_factory()\n        result = minimize(\n            lambda x: objective(x, alpha=0),\n            result.x,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-10, 'disp': False}\n        )\n        \n        # Stage 3: Refinement with tighter tolerances\n        if result.success:\n            print(\"  Stage 3: Refinement...\")\n            result = minimize(\n                lambda x: objective(x, alpha=0),\n                result.x,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 500, 'ftol': 1e-12, 'disp': False}\n            )\n        \n        # Post-optimization: local perturbations\n        if result.success:\n            print(\"  Stage 4: Local perturbations...\")\n            for _ in range(5):\n                perturbed = result.x.copy()\n                perturbed[:2*n_circles] += np.random.randn(2*n_circles) * 0.001\n                temp_result = minimize(\n                    lambda x: objective(x, alpha=0),\n                    perturbed,\n                    method='SLSQP',\n                    bounds=bounds,\n                    constraints=constraints,\n                    options={'maxiter': 200, 'ftol': 1e-12, 'disp': False}\n                )\n                if temp_result.success and temp_result.fun < result.fun:\n                    result = temp_result\n        \n        if result.success:\n            sum_radii = np.sum(result.x[2*n_circles:])\n            print(f\"  Sum of radii: {sum_radii:.6f}\")\n            \n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_result = result\n                print(f\"  *** NEW BEST: {best_sum:.6f} ***\")\n    \n    if best_result is None:\n        # Fallback\n        x0 = generate_hex_grid_init(n_circles)\n        best_result = minimize(\n            lambda x: objective(x, alpha=1.0),\n            x0,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': 1000}\n        )\n    \n    centers = best_result.x[:2*n_circles].reshape(n_circles, 2)\n    radii = best_result.x[2*n_circles:]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Run the packing algorithm and return results.\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    print(f\"\\nFinal sum_radii = {sum_radii:.6f}\")\n    return centers, radii, sum_radii\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-04T14:56:20.122338",
  "cost_data": null
}