{
  "trial_id": "trial_1_10",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def objective(x):\n        \"\"\"\n        Objective function to minimize (negative sum of radii with penalties).\n        \n        x: flattened array of [x1, y1, r1, x2, y2, r2, ..., xn, yn, rn]\n        \"\"\"\n        # Reshape into centers and radii\n        centers = x.reshape(n, 3)[:, :2]\n        radii = x.reshape(n, 3)[:, 2]\n        \n        # Penalty for constraint violations\n        penalty = 0.0\n        penalty_weight = 1000.0\n        \n        # Check boundary constraints\n        for i in range(n):\n            cx, cy, r = x[i*3], x[i*3+1], x[i*3+2]\n            \n            # Circles must be inside [0,1] x [0,1]\n            if cx - r < 0:\n                penalty += penalty_weight * (0 - (cx - r))**2\n            if cx + r > 1:\n                penalty += penalty_weight * ((cx + r) - 1)**2\n            if cy - r < 0:\n                penalty += penalty_weight * (0 - (cy - r))**2\n            if cy + r > 1:\n                penalty += penalty_weight * ((cy + r) - 1)**2\n        \n        # Check overlap constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                cx_i, cy_i, r_i = x[i*3], x[i*3+1], x[i*3+2]\n                cx_j, cy_j, r_j = x[j*3], x[j*3+1], x[j*3+2]\n                \n                dist = np.sqrt((cx_i - cx_j)**2 + (cy_i - cy_j)**2)\n                min_dist = r_i + r_j\n                \n                if dist < min_dist:\n                    overlap = min_dist - dist\n                    penalty += penalty_weight * overlap**2\n        \n        # Objective: minimize negative sum of radii (maximize sum of radii)\n        sum_radii = np.sum(radii)\n        \n        return -sum_radii + penalty\n    \n    # Set bounds for all variables\n    # For each circle: (x, y, r)\n    # x, y in [0, 1], r in [0, 0.5]\n    bounds = []\n    for i in range(n):\n        bounds.append((0.0, 1.0))  # x\n        bounds.append((0.0, 1.0))  # y\n        bounds.append((0.0, 0.5))  # r\n    \n    # Run differential evolution\n    result = differential_evolution(\n        objective,\n        bounds,\n        strategy='best1bin',\n        maxiter=1000,\n        popsize=30,\n        tol=1e-7,\n        mutation=(0.5, 1.5),\n        recombination=0.9,\n        seed=42,\n        workers=-1,\n        updating='deferred',\n        polish=True\n    )\n    \n    # Extract solution\n    x_opt = result.x\n    centers = x_opt.reshape(n, 3)[:, :2]\n    radii = x_opt.reshape(n, 3)[:, 2]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 0.3551628589630127,
    "error": "PicklingError: Can't pickle local object <function construct_packing.<locals>.objective at 0x10ab07110>"
  },
  "prompt": "Create a circle packing using differential evolution from scipy.\n\nUse scipy.optimize.differential_evolution for global optimization:\n- Variables: all positions and radii (78 variables for 26 circles)\n- Objective: maximize sum of radii (minimize negative)\n- Constraints: bounds on positions [0,1], radii [0,0.5]\n- Add penalty for overlaps and boundary violations\n- Use 'best1bin' strategy with high population\n\nRequirements:\n- Import scipy.optimize.differential_evolution\n- Set bounds properly\n- Run with workers=-1 for parallel\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import differential_evolution\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def objective(x):\n        \"\"\"\n        Objective function to minimize (negative sum of radii with penalties).\n        \n        x: flattened array of [x1, y1, r1, x2, y2, r2, ..., xn, yn, rn]\n        \"\"\"\n        # Reshape into centers and radii\n        centers = x.reshape(n, 3)[:, :2]\n        radii = x.reshape(n, 3)[:, 2]\n        \n        # Penalty for constraint violations\n        penalty = 0.0\n        penalty_weight = 1000.0\n        \n        # Check boundary constraints\n        for i in range(n):\n            cx, cy, r = x[i*3], x[i*3+1], x[i*3+2]\n            \n            # Circles must be inside [0,1] x [0,1]\n            if cx - r < 0:\n                penalty += penalty_weight * (0 - (cx - r))**2\n            if cx + r > 1:\n                penalty += penalty_weight * ((cx + r) - 1)**2\n            if cy - r < 0:\n                penalty += penalty_weight * (0 - (cy - r))**2\n            if cy + r > 1:\n                penalty += penalty_weight * ((cy + r) - 1)**2\n        \n        # Check overlap constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                cx_i, cy_i, r_i = x[i*3], x[i*3+1], x[i*3+2]\n                cx_j, cy_j, r_j = x[j*3], x[j*3+1], x[j*3+2]\n                \n                dist = np.sqrt((cx_i - cx_j)**2 + (cy_i - cy_j)**2)\n                min_dist = r_i + r_j\n                \n                if dist < min_dist:\n                    overlap = min_dist - dist\n                    penalty += penalty_weight * overlap**2\n        \n        # Objective: minimize negative sum of radii (maximize sum of radii)\n        sum_radii = np.sum(radii)\n        \n        return -sum_radii + penalty\n    \n    # Set bounds for all variables\n    # For each circle: (x, y, r)\n    # x, y in [0, 1], r in [0, 0.5]\n    bounds = []\n    for i in range(n):\n        bounds.append((0.0, 1.0))  # x\n        bounds.append((0.0, 1.0))  # y\n        bounds.append((0.0, 0.5))  # r\n    \n    # Run differential evolution\n    result = differential_evolution(\n        objective,\n        bounds,\n        strategy='best1bin',\n        maxiter=1000,\n        popsize=30,\n        tol=1e-7,\n        mutation=(0.5, 1.5),\n        recombination=0.9,\n        seed=42,\n        workers=-1,\n        updating='deferred',\n        polish=True\n    )\n    \n    # Extract solution\n    x_opt = result.x\n    centers = x_opt.reshape(n, 3)[:, :2]\n    radii = x_opt.reshape(n, 3)[:, 2]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T17:52:46.805804",
  "cost_data": null
}