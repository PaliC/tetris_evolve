{
  "trial_id": "trial_1_8",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using\n    advanced force-directed algorithm with radius optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # Initialize with hexagonal grid pattern\n    def init_hexagonal_grid(n):\n        \"\"\"Initialize circles in a hexagonal grid pattern.\"\"\"\n        # Estimate grid dimensions\n        aspect_ratio = 1.0\n        cols = int(np.ceil(np.sqrt(n * aspect_ratio / 0.866)))\n        rows = int(np.ceil(n / cols))\n        \n        centers = []\n        dx = 1.0 / (cols + 0.5)\n        dy = 0.866 * dx  # Hexagonal spacing\n        \n        for row in range(rows):\n            offset = 0.5 * dx if row % 2 == 1 else 0\n            for col in range(cols):\n                if len(centers) >= n:\n                    break\n                x = offset + (col + 0.5) * dx\n                y = (row + 0.5) * dy\n                if x <= 1.0 and y <= 1.0:\n                    centers.append([x, y])\n        \n        # Fill remaining with random positions\n        while len(centers) < n:\n            centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n        \n        centers = np.array(centers[:n])\n        # Normalize to fit in unit square with margin\n        centers = 0.1 + 0.8 * (centers - centers.min(axis=0)) / (centers.max(axis=0) - centers.min(axis=0) + 1e-10)\n        return centers\n    \n    centers = init_hexagonal_grid(n)\n    radii = np.ones(n) * 0.05\n    \n    def compute_max_radius(centers, idx):\n        \"\"\"Binary search for maximum radius for circle idx.\"\"\"\n        center = centers[idx]\n        \n        # Check boundary constraints\n        max_r_boundary = min(center[0], center[1], 1.0 - center[0], 1.0 - center[1])\n        \n        # Check overlap constraints with other circles\n        max_r_overlap = float('inf')\n        for j in range(len(centers)):\n            if j != idx:\n                dist = np.linalg.norm(centers[j] - center)\n                max_r_overlap = min(max_r_overlap, dist - radii[j])\n        \n        max_r = min(max_r_boundary, max_r_overlap)\n        return max(0.0, max_r)\n    \n    def apply_forces(centers, radii, iteration, max_iterations):\n        \"\"\"Apply force-directed layout forces.\"\"\"\n        forces = np.zeros_like(centers)\n        \n        # Compute pairwise distances\n        dists = cdist(centers, centers)\n        np.fill_diagonal(dists, np.inf)\n        \n        # Repulsion force between circles (inverse square law)\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = centers[i] - centers[j]\n                dist = dists[i, j]\n                \n                if dist < 1e-6:\n                    # Random push if too close\n                    diff = np.random.randn(2)\n                    dist = np.linalg.norm(diff)\n                \n                # Stronger repulsion if overlapping\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist:\n                    strength = 0.5 * (min_dist - dist) / (dist + 1e-10)\n                else:\n                    # Inverse square repulsion\n                    strength = 0.01 / (dist ** 2 + 0.01)\n                \n                force = strength * diff / (dist + 1e-10)\n                forces[i] += force\n                forces[j] -= force\n        \n        # Boundary forces - keep circles away from edges\n        boundary_margin = 0.05\n        boundary_strength = 0.1\n        \n        for i in range(n):\n            # Left boundary\n            if centers[i, 0] < boundary_margin:\n                forces[i, 0] += boundary_strength * (boundary_margin - centers[i, 0])\n            # Right boundary\n            if centers[i, 0] > 1.0 - boundary_margin:\n                forces[i, 0] -= boundary_strength * (centers[i, 0] - (1.0 - boundary_margin))\n            # Bottom boundary\n            if centers[i, 1] < boundary_margin:\n                forces[i, 1] += boundary_strength * (boundary_margin - centers[i, 1])\n            # Top boundary\n            if centers[i, 1] > 1.0 - boundary_margin:\n                forces[i, 1] -= boundary_strength * (centers[i, 1] - (1.0 - boundary_margin))\n        \n        # Adaptive learning rate\n        lr = 0.01 * (1.0 - 0.9 * iteration / max_iterations)\n        \n        # Update positions\n        centers += lr * forces\n        \n        # Enforce hard boundaries\n        centers[:, 0] = np.clip(centers[:, 0], radii, 1.0 - radii)\n        centers[:, 1] = np.clip(centers[:, 1], radii, 1.0 - radii)\n        \n        return centers\n    \n    # Main optimization loop\n    max_iterations = 30000\n    radius_update_freq = 50\n    \n    for iteration in range(max_iterations):\n        # Apply force-directed layout\n        centers = apply_forces(centers, radii, iteration, max_iterations)\n        \n        # Periodically update radii\n        if iteration % radius_update_freq == 0:\n            # Update radii for all circles\n            for i in range(n):\n                radii[i] = compute_max_radius(centers, i)\n            \n            # Refine radii with small incremental adjustments\n            for i in range(n):\n                max_r = compute_max_radius(centers, i)\n                radii[i] = max_r * 0.98  # Small safety margin\n    \n    # Final radius optimization phase\n    for refinement in range(100):\n        # Random order to avoid bias\n        order = np.random.permutation(n)\n        for i in order:\n            radii[i] = compute_max_radius(centers, i) * 0.98\n    \n    # Final verification and adjustment\n    for i in range(n):\n        # Ensure boundary constraints\n        max_r_boundary = min(centers[i, 0], centers[i, 1], \n                            1.0 - centers[i, 0], 1.0 - centers[i, 1])\n        \n        # Ensure no overlaps\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_r_boundary = min(max_r_boundary, dist - radii[j])\n        \n        radii[i] = max(0.0, max_r_boundary * 0.99)\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 0.7939661537634065,
    "target_ratio": 0.30131542837320935,
    "combined_score": 0.30131542837320935,
    "eval_time": 33.27120494842529,
    "error": null
  },
  "prompt": "Create an advanced force-directed algorithm with radius optimization.\n\nInspired by trial_0_10's success, create an improved version:\n1. Initialize with optimal hexagonal grid pattern\n2. Apply force-directed layout with these forces:\n   - Repulsion between circles (inverse square law)\n   - Boundary attraction (keep circles from edges)\n   - Overlap prevention (strong repulsion when overlapping)\n3. After positions stabilize, run radius maximization:\n   - For each circle, binary search for maximum radius\n   - Check all constraints efficiently\n4. Alternate between position and radius optimization\n\nRequirements:\n- Advanced force-directed with radius optimization\n- At least 30000 iterations\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using\n    advanced force-directed algorithm with radius optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # Initialize with hexagonal grid pattern\n    def init_hexagonal_grid(n):\n        \"\"\"Initialize circles in a hexagonal grid pattern.\"\"\"\n        # Estimate grid dimensions\n        aspect_ratio = 1.0\n        cols = int(np.ceil(np.sqrt(n * aspect_ratio / 0.866)))\n        rows = int(np.ceil(n / cols))\n        \n        centers = []\n        dx = 1.0 / (cols + 0.5)\n        dy = 0.866 * dx  # Hexagonal spacing\n        \n        for row in range(rows):\n            offset = 0.5 * dx if row % 2 == 1 else 0\n            for col in range(cols):\n                if len(centers) >= n:\n                    break\n                x = offset + (col + 0.5) * dx\n                y = (row + 0.5) * dy\n                if x <= 1.0 and y <= 1.0:\n                    centers.append([x, y])\n        \n        # Fill remaining with random positions\n        while len(centers) < n:\n            centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n        \n        centers = np.array(centers[:n])\n        # Normalize to fit in unit square with margin\n        centers = 0.1 + 0.8 * (centers - centers.min(axis=0)) / (centers.max(axis=0) - centers.min(axis=0) + 1e-10)\n        return centers\n    \n    centers = init_hexagonal_grid(n)\n    radii = np.ones(n) * 0.05\n    \n    def compute_max_radius(centers, idx):\n        \"\"\"Binary search for maximum radius for circle idx.\"\"\"\n        center = centers[idx]\n        \n        # Check boundary constraints\n        max_r_boundary = min(center[0], center[1], 1.0 - center[0], 1.0 - center[1])\n        \n        # Check overlap constraints with other circles\n        max_r_overlap = float('inf')\n        for j in range(len(centers)):\n            if j != idx:\n                dist = np.linalg.norm(centers[j] - center)\n                max_r_overlap = min(max_r_overlap, dist - radii[j])\n        \n        max_r = min(max_r_boundary, max_r_overlap)\n        return max(0.0, max_r)\n    \n    def apply_forces(centers, radii, iteration, max_iterations):\n        \"\"\"Apply force-directed layout forces.\"\"\"\n        forces = np.zeros_like(centers)\n        \n        # Compute pairwise distances\n        dists = cdist(centers, centers)\n        np.fill_diagonal(dists, np.inf)\n        \n        # Repulsion force between circles (inverse square law)\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = centers[i] - centers[j]\n                dist = dists[i, j]\n                \n                if dist < 1e-6:\n                    # Random push if too close\n                    diff = np.random.randn(2)\n                    dist = np.linalg.norm(diff)\n                \n                # Stronger repulsion if overlapping\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist:\n                    strength = 0.5 * (min_dist - dist) / (dist + 1e-10)\n                else:\n                    # Inverse square repulsion\n                    strength = 0.01 / (dist ** 2 + 0.01)\n                \n                force = strength * diff / (dist + 1e-10)\n                forces[i] += force\n                forces[j] -= force\n        \n        # Boundary forces - keep circles away from edges\n        boundary_margin = 0.05\n        boundary_strength = 0.1\n        \n        for i in range(n):\n            # Left boundary\n            if centers[i, 0] < boundary_margin:\n                forces[i, 0] += boundary_strength * (boundary_margin - centers[i, 0])\n            # Right boundary\n            if centers[i, 0] > 1.0 - boundary_margin:\n                forces[i, 0] -= boundary_strength * (centers[i, 0] - (1.0 - boundary_margin))\n            # Bottom boundary\n            if centers[i, 1] < boundary_margin:\n                forces[i, 1] += boundary_strength * (boundary_margin - centers[i, 1])\n            # Top boundary\n            if centers[i, 1] > 1.0 - boundary_margin:\n                forces[i, 1] -= boundary_strength * (centers[i, 1] - (1.0 - boundary_margin))\n        \n        # Adaptive learning rate\n        lr = 0.01 * (1.0 - 0.9 * iteration / max_iterations)\n        \n        # Update positions\n        centers += lr * forces\n        \n        # Enforce hard boundaries\n        centers[:, 0] = np.clip(centers[:, 0], radii, 1.0 - radii)\n        centers[:, 1] = np.clip(centers[:, 1], radii, 1.0 - radii)\n        \n        return centers\n    \n    # Main optimization loop\n    max_iterations = 30000\n    radius_update_freq = 50\n    \n    for iteration in range(max_iterations):\n        # Apply force-directed layout\n        centers = apply_forces(centers, radii, iteration, max_iterations)\n        \n        # Periodically update radii\n        if iteration % radius_update_freq == 0:\n            # Update radii for all circles\n            for i in range(n):\n                radii[i] = compute_max_radius(centers, i)\n            \n            # Refine radii with small incremental adjustments\n            for i in range(n):\n                max_r = compute_max_radius(centers, i)\n                radii[i] = max_r * 0.98  # Small safety margin\n    \n    # Final radius optimization phase\n    for refinement in range(100):\n        # Random order to avoid bias\n        order = np.random.permutation(n)\n        for i in order:\n            radii[i] = compute_max_radius(centers, i) * 0.98\n    \n    # Final verification and adjustment\n    for i in range(n):\n        # Ensure boundary constraints\n        max_r_boundary = min(centers[i, 0], centers[i, 1], \n                            1.0 - centers[i, 0], 1.0 - centers[i, 1])\n        \n        # Ensure no overlaps\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_r_boundary = min(max_r_boundary, dist - radii[j])\n        \n        radii[i] = max(0.0, max_r_boundary * 0.99)\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T17:53:34.257210",
  "cost_data": null
}