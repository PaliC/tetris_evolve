{
  "trial_id": "trial_1_14",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Initialize with hexagonal grid layout\n    centers = initialize_hexagonal_grid(n)\n    radii = np.full(n, 0.01)\n    \n    # Iterative optimization\n    max_iterations = 50\n    for iteration in range(max_iterations):\n        # Phase 1: Expand radii\n        radii = expand_radii(centers, radii, steps=20)\n        \n        # Phase 2: Optimize positions\n        centers = optimize_positions(centers, radii)\n        \n        # Phase 3: Expand radii again\n        radii = expand_radii(centers, radii, steps=20)\n        \n        # Check convergence\n        if iteration > 0:\n            improvement = np.sum(radii) - prev_sum\n            if improvement < 1e-5:\n                break\n        prev_sum = np.sum(radii)\n    \n    # Final refinement\n    for _ in range(5):\n        centers = optimize_positions(centers, radii)\n        radii = expand_radii(centers, radii, steps=30)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef initialize_hexagonal_grid(n):\n    \"\"\"Initialize circles in a hexagonal grid pattern.\"\"\"\n    centers = []\n    rows = 6\n    cols = 5\n    \n    spacing_x = 1.0 / (cols + 1)\n    spacing_y = 1.0 / (rows + 1)\n    \n    count = 0\n    for row in range(rows):\n        offset = (row % 2) * spacing_x * 0.5\n        for col in range(cols):\n            if count >= n:\n                break\n            x = spacing_x * (col + 1) + offset\n            y = spacing_y * (row + 1)\n            # Keep within bounds\n            x = np.clip(x, 0.05, 0.95)\n            y = np.clip(y, 0.05, 0.95)\n            centers.append([x, y])\n            count += 1\n        if count >= n:\n            break\n    \n    # Fill remaining if needed\n    while len(centers) < n:\n        centers.append([0.5, 0.5])\n    \n    return np.array(centers[:n])\n\ndef is_valid_packing(centers, radii):\n    \"\"\"Check if packing satisfies all constraints.\"\"\"\n    n = len(centers)\n    \n    # Check bounds\n    for i in range(n):\n        if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n            centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n            return False\n    \n    # Check overlaps\n    distances = cdist(centers, centers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if distances[i, j] < radii[i] + radii[j] - 1e-10:\n                return False\n    \n    return True\n\ndef expand_radii(centers, radii, steps=20):\n    \"\"\"Iteratively expand radii while maintaining validity.\"\"\"\n    n = len(centers)\n    radii = radii.copy()\n    \n    for step in range(steps):\n        improved = False\n        increment = 0.01 / (step + 1)  # Decrease increment over time\n        \n        # Try to expand each circle\n        order = np.random.permutation(n)\n        for i in order:\n            old_radius = radii[i]\n            radii[i] += increment\n            \n            # Check if still valid\n            if not is_valid_single_circle(centers, radii, i):\n                radii[i] = old_radius\n            else:\n                improved = True\n        \n        if not improved:\n            break\n    \n    return radii\n\ndef is_valid_single_circle(centers, radii, idx):\n    \"\"\"Check if a single circle satisfies all constraints.\"\"\"\n    n = len(centers)\n    \n    # Check bounds\n    if (centers[idx, 0] - radii[idx] < 0 or centers[idx, 0] + radii[idx] > 1 or\n        centers[idx, 1] - radii[idx] < 0 or centers[idx, 1] + radii[idx] > 1):\n        return False\n    \n    # Check overlaps with other circles\n    for j in range(n):\n        if j != idx:\n            dist = np.linalg.norm(centers[idx] - centers[j])\n            if dist < radii[idx] + radii[j] - 1e-10:\n                return False\n    \n    return True\n\ndef optimize_positions(centers, radii):\n    \"\"\"Optimize circle positions to maximize space.\"\"\"\n    n = len(centers)\n    \n    def objective(x):\n        \"\"\"Objective: minimize negative sum of minimum distances (creates space).\"\"\"\n        c = x.reshape(n, 2)\n        penalty = 0\n        \n        # Penalize constraint violations\n        for i in range(n):\n            # Bound constraints\n            if c[i, 0] - radii[i] < 0:\n                penalty += 1000 * (radii[i] - c[i, 0]) ** 2\n            if c[i, 0] + radii[i] > 1:\n                penalty += 1000 * (c[i, 0] + radii[i] - 1) ** 2\n            if c[i, 1] - radii[i] < 0:\n                penalty += 1000 * (radii[i] - c[i, 1]) ** 2\n            if c[i, 1] + radii[i] > 1:\n                penalty += 1000 * (c[i, 1] + radii[i] - 1) ** 2\n        \n        # Penalize overlaps\n        distances = cdist(c, c)\n        for i in range(n):\n            for j in range(i + 1, n):\n                overlap = radii[i] + radii[j] - distances[i, j]\n                if overlap > 0:\n                    penalty += 1000 * overlap ** 2\n        \n        # Objective: maximize minimum clearance\n        min_clearance = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                clearance = distances[i, j] - radii[i] - radii[j]\n                min_clearance = min(min_clearance, clearance)\n        \n        return -min_clearance + penalty\n    \n    x0 = centers.flatten()\n    \n    # Optimize with bounds\n    bounds = [(radii[i], 1 - radii[i]) for i in range(n) for _ in range(2)]\n    \n    result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds,\n                     options={'maxiter': 100, 'ftol': 1e-6})\n    \n    new_centers = result.x.reshape(n, 2)\n    \n    # Verify validity before returning\n    if is_valid_packing(new_centers, radii):\n        return new_centers\n    else:\n        return centers\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.130824621714715,
    "target_ratio": 0.8086620955274061,
    "combined_score": 0.8086620955274061,
    "eval_time": 1.3442139625549316,
    "error": null
  },
  "prompt": "Create an iterative radius expansion algorithm.\n\nStrategy:\n1. Start with 26 circles at reasonable positions (hexagonal grid)\n2. Start with very small radii (all 0.01)\n3. Iteratively:\n   - Try to increase each circle's radius by small amount\n   - Check if still valid (no overlaps, within bounds)\n   - Accept increase if valid\n   - Continue until no more increases possible\n4. Apply position optimization to create more space\n5. Repeat radius expansion\n\nRequirements:\n- Iterative expansion approach\n- Alternate radius expansion and position optimization\n- Run until convergence\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Initialize with hexagonal grid layout\n    centers = initialize_hexagonal_grid(n)\n    radii = np.full(n, 0.01)\n    \n    # Iterative optimization\n    max_iterations = 50\n    for iteration in range(max_iterations):\n        # Phase 1: Expand radii\n        radii = expand_radii(centers, radii, steps=20)\n        \n        # Phase 2: Optimize positions\n        centers = optimize_positions(centers, radii)\n        \n        # Phase 3: Expand radii again\n        radii = expand_radii(centers, radii, steps=20)\n        \n        # Check convergence\n        if iteration > 0:\n            improvement = np.sum(radii) - prev_sum\n            if improvement < 1e-5:\n                break\n        prev_sum = np.sum(radii)\n    \n    # Final refinement\n    for _ in range(5):\n        centers = optimize_positions(centers, radii)\n        radii = expand_radii(centers, radii, steps=30)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef initialize_hexagonal_grid(n):\n    \"\"\"Initialize circles in a hexagonal grid pattern.\"\"\"\n    centers = []\n    rows = 6\n    cols = 5\n    \n    spacing_x = 1.0 / (cols + 1)\n    spacing_y = 1.0 / (rows + 1)\n    \n    count = 0\n    for row in range(rows):\n        offset = (row % 2) * spacing_x * 0.5\n        for col in range(cols):\n            if count >= n:\n                break\n            x = spacing_x * (col + 1) + offset\n            y = spacing_y * (row + 1)\n            # Keep within bounds\n            x = np.clip(x, 0.05, 0.95)\n            y = np.clip(y, 0.05, 0.95)\n            centers.append([x, y])\n            count += 1\n        if count >= n:\n            break\n    \n    # Fill remaining if needed\n    while len(centers) < n:\n        centers.append([0.5, 0.5])\n    \n    return np.array(centers[:n])\n\ndef is_valid_packing(centers, radii):\n    \"\"\"Check if packing satisfies all constraints.\"\"\"\n    n = len(centers)\n    \n    # Check bounds\n    for i in range(n):\n        if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n            centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n            return False\n    \n    # Check overlaps\n    distances = cdist(centers, centers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if distances[i, j] < radii[i] + radii[j] - 1e-10:\n                return False\n    \n    return True\n\ndef expand_radii(centers, radii, steps=20):\n    \"\"\"Iteratively expand radii while maintaining validity.\"\"\"\n    n = len(centers)\n    radii = radii.copy()\n    \n    for step in range(steps):\n        improved = False\n        increment = 0.01 / (step + 1)  # Decrease increment over time\n        \n        # Try to expand each circle\n        order = np.random.permutation(n)\n        for i in order:\n            old_radius = radii[i]\n            radii[i] += increment\n            \n            # Check if still valid\n            if not is_valid_single_circle(centers, radii, i):\n                radii[i] = old_radius\n            else:\n                improved = True\n        \n        if not improved:\n            break\n    \n    return radii\n\ndef is_valid_single_circle(centers, radii, idx):\n    \"\"\"Check if a single circle satisfies all constraints.\"\"\"\n    n = len(centers)\n    \n    # Check bounds\n    if (centers[idx, 0] - radii[idx] < 0 or centers[idx, 0] + radii[idx] > 1 or\n        centers[idx, 1] - radii[idx] < 0 or centers[idx, 1] + radii[idx] > 1):\n        return False\n    \n    # Check overlaps with other circles\n    for j in range(n):\n        if j != idx:\n            dist = np.linalg.norm(centers[idx] - centers[j])\n            if dist < radii[idx] + radii[j] - 1e-10:\n                return False\n    \n    return True\n\ndef optimize_positions(centers, radii):\n    \"\"\"Optimize circle positions to maximize space.\"\"\"\n    n = len(centers)\n    \n    def objective(x):\n        \"\"\"Objective: minimize negative sum of minimum distances (creates space).\"\"\"\n        c = x.reshape(n, 2)\n        penalty = 0\n        \n        # Penalize constraint violations\n        for i in range(n):\n            # Bound constraints\n            if c[i, 0] - radii[i] < 0:\n                penalty += 1000 * (radii[i] - c[i, 0]) ** 2\n            if c[i, 0] + radii[i] > 1:\n                penalty += 1000 * (c[i, 0] + radii[i] - 1) ** 2\n            if c[i, 1] - radii[i] < 0:\n                penalty += 1000 * (radii[i] - c[i, 1]) ** 2\n            if c[i, 1] + radii[i] > 1:\n                penalty += 1000 * (c[i, 1] + radii[i] - 1) ** 2\n        \n        # Penalize overlaps\n        distances = cdist(c, c)\n        for i in range(n):\n            for j in range(i + 1, n):\n                overlap = radii[i] + radii[j] - distances[i, j]\n                if overlap > 0:\n                    penalty += 1000 * overlap ** 2\n        \n        # Objective: maximize minimum clearance\n        min_clearance = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                clearance = distances[i, j] - radii[i] - radii[j]\n                min_clearance = min(min_clearance, clearance)\n        \n        return -min_clearance + penalty\n    \n    x0 = centers.flatten()\n    \n    # Optimize with bounds\n    bounds = [(radii[i], 1 - radii[i]) for i in range(n) for _ in range(2)]\n    \n    result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds,\n                     options={'maxiter': 100, 'ftol': 1e-6})\n    \n    new_centers = result.x.reshape(n, 2)\n    \n    # Verify validity before returning\n    if is_valid_packing(new_centers, radii):\n        return new_centers\n    else:\n        return centers\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T17:52:57.725449",
  "cost_data": null
}