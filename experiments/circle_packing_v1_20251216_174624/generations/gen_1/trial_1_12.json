{
  "trial_id": "trial_1_12",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using PSO.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # PSO parameters\n    n_particles = 50\n    n_iterations = 1500\n    w = 0.7  # inertia weight\n    c1 = 1.5  # cognitive parameter\n    c2 = 1.5  # social parameter\n    \n    # Each particle represents: [x1, y1, ..., x26, y26, r1, ..., r26]\n    dim = n * 3  # 2 coordinates + 1 radius per circle\n    \n    # Initialize particles\n    particles = np.random.rand(n_particles, dim)\n    # Scale positions to [0.1, 0.9] and radii to [0.01, 0.1]\n    particles[:, :2*n] = particles[:, :2*n] * 0.8 + 0.1\n    particles[:, 2*n:] = particles[:, 2*n:] * 0.09 + 0.01\n    \n    velocities = np.random.randn(n_particles, dim) * 0.01\n    \n    # Personal best\n    p_best = particles.copy()\n    p_best_scores = np.full(n_particles, -np.inf)\n    \n    # Global best\n    g_best = None\n    g_best_score = -np.inf\n    \n    def evaluate_particle(particle):\n        \"\"\"Evaluate fitness of a particle with penalties for constraint violations.\"\"\"\n        centers = particle[:2*n].reshape(n, 2)\n        radii = particle[2*n:]\n        \n        # Ensure non-negative radii\n        radii = np.maximum(radii, 0)\n        \n        penalty = 0.0\n        \n        # Penalty for circles outside square\n        for i in range(n):\n            if centers[i, 0] - radii[i] < 0:\n                penalty += (0 - (centers[i, 0] - radii[i])) * 10\n            if centers[i, 0] + radii[i] > 1:\n                penalty += ((centers[i, 0] + radii[i]) - 1) * 10\n            if centers[i, 1] - radii[i] < 0:\n                penalty += (0 - (centers[i, 1] - radii[i])) * 10\n            if centers[i, 1] + radii[i] > 1:\n                penalty += ((centers[i, 1] + radii[i]) - 1) * 10\n        \n        # Penalty for overlapping circles\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist:\n                    penalty += (min_dist - dist) * 20\n        \n        # Fitness: sum of radii minus penalties\n        fitness = np.sum(radii) - penalty\n        return fitness\n    \n    # Main PSO loop\n    for iteration in range(n_iterations):\n        # Evaluate all particles\n        for i in range(n_particles):\n            score = evaluate_particle(particles[i])\n            \n            # Update personal best\n            if score > p_best_scores[i]:\n                p_best_scores[i] = score\n                p_best[i] = particles[i].copy()\n            \n            # Update global best\n            if score > g_best_score:\n                g_best_score = score\n                g_best = particles[i].copy()\n        \n        # Update velocities and positions\n        for i in range(n_particles):\n            r1 = np.random.rand(dim)\n            r2 = np.random.rand(dim)\n            \n            velocities[i] = (w * velocities[i] + \n                           c1 * r1 * (p_best[i] - particles[i]) +\n                           c2 * r2 * (g_best - particles[i]))\n            \n            particles[i] += velocities[i]\n            \n            # Clamp positions to valid ranges\n            particles[i, :2*n] = np.clip(particles[i, :2*n], 0.01, 0.99)\n            particles[i, 2*n:] = np.clip(particles[i, 2*n:], 0.001, 0.15)\n        \n        # Adaptive inertia weight\n        w = 0.9 - 0.5 * (iteration / n_iterations)\n    \n    # Post-process best solution to ensure constraints\n    centers = g_best[:2*n].reshape(n, 2)\n    radii = g_best[2*n:]\n    radii = np.maximum(radii, 0)\n    \n    # Repair constraint violations\n    for _ in range(100):\n        # Fix boundary violations\n        for i in range(n):\n            if centers[i, 0] - radii[i] < 0:\n                radii[i] = centers[i, 0] - 0.001\n            if centers[i, 0] + radii[i] > 1:\n                radii[i] = 1 - centers[i, 0] - 0.001\n            if centers[i, 1] - radii[i] < 0:\n                radii[i] = centers[i, 1] - 0.001\n            if centers[i, 1] + radii[i] > 1:\n                radii[i] = 1 - centers[i, 1] - 0.001\n            radii[i] = max(radii[i], 0.001)\n        \n        # Fix overlaps by shrinking radii\n        violations = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist:\n                    violations.append((i, j, dist, min_dist))\n        \n        if not violations:\n            break\n        \n        for i, j, dist, min_dist in violations:\n            if dist > 0.001:\n                # Shrink both radii proportionally\n                scale = (dist - 0.001) / min_dist\n                radii[i] *= scale\n                radii[j] *= scale\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.339014907371377,
    "target_ratio": 0.5081650502358168,
    "combined_score": 0.5081650502358168,
    "eval_time": 43.14843201637268,
    "error": null
  },
  "prompt": "Create a particle swarm optimization for circle packing.\n\nImplement PSO:\n- Particles represent full packings (positions + radii)\n- Fitness: sum of radii (with penalty for violations)\n- Update velocities based on personal best and global best\n- Run for many iterations\n- Ensure constraint satisfaction\n\nRequirements:\n- Implement PSO algorithm\n- Population ~50 particles\n- Run 1000+ iterations\n- No plotting or printing",
  "response": "```python\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using PSO.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # PSO parameters\n    n_particles = 50\n    n_iterations = 1500\n    w = 0.7  # inertia weight\n    c1 = 1.5  # cognitive parameter\n    c2 = 1.5  # social parameter\n    \n    # Each particle represents: [x1, y1, ..., x26, y26, r1, ..., r26]\n    dim = n * 3  # 2 coordinates + 1 radius per circle\n    \n    # Initialize particles\n    particles = np.random.rand(n_particles, dim)\n    # Scale positions to [0.1, 0.9] and radii to [0.01, 0.1]\n    particles[:, :2*n] = particles[:, :2*n] * 0.8 + 0.1\n    particles[:, 2*n:] = particles[:, 2*n:] * 0.09 + 0.01\n    \n    velocities = np.random.randn(n_particles, dim) * 0.01\n    \n    # Personal best\n    p_best = particles.copy()\n    p_best_scores = np.full(n_particles, -np.inf)\n    \n    # Global best\n    g_best = None\n    g_best_score = -np.inf\n    \n    def evaluate_particle(particle):\n        \"\"\"Evaluate fitness of a particle with penalties for constraint violations.\"\"\"\n        centers = particle[:2*n].reshape(n, 2)\n        radii = particle[2*n:]\n        \n        # Ensure non-negative radii\n        radii = np.maximum(radii, 0)\n        \n        penalty = 0.0\n        \n        # Penalty for circles outside square\n        for i in range(n):\n            if centers[i, 0] - radii[i] < 0:\n                penalty += (0 - (centers[i, 0] - radii[i])) * 10\n            if centers[i, 0] + radii[i] > 1:\n                penalty += ((centers[i, 0] + radii[i]) - 1) * 10\n            if centers[i, 1] - radii[i] < 0:\n                penalty += (0 - (centers[i, 1] - radii[i])) * 10\n            if centers[i, 1] + radii[i] > 1:\n                penalty += ((centers[i, 1] + radii[i]) - 1) * 10\n        \n        # Penalty for overlapping circles\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist:\n                    penalty += (min_dist - dist) * 20\n        \n        # Fitness: sum of radii minus penalties\n        fitness = np.sum(radii) - penalty\n        return fitness\n    \n    # Main PSO loop\n    for iteration in range(n_iterations):\n        # Evaluate all particles\n        for i in range(n_particles):\n            score = evaluate_particle(particles[i])\n            \n            # Update personal best\n            if score > p_best_scores[i]:\n                p_best_scores[i] = score\n                p_best[i] = particles[i].copy()\n            \n            # Update global best\n            if score > g_best_score:\n                g_best_score = score\n                g_best = particles[i].copy()\n        \n        # Update velocities and positions\n        for i in range(n_particles):\n            r1 = np.random.rand(dim)\n            r2 = np.random.rand(dim)\n            \n            velocities[i] = (w * velocities[i] + \n                           c1 * r1 * (p_best[i] - particles[i]) +\n                           c2 * r2 * (g_best - particles[i]))\n            \n            particles[i] += velocities[i]\n            \n            # Clamp positions to valid ranges\n            particles[i, :2*n] = np.clip(particles[i, :2*n], 0.01, 0.99)\n            particles[i, 2*n:] = np.clip(particles[i, 2*n:], 0.001, 0.15)\n        \n        # Adaptive inertia weight\n        w = 0.9 - 0.5 * (iteration / n_iterations)\n    \n    # Post-process best solution to ensure constraints\n    centers = g_best[:2*n].reshape(n, 2)\n    radii = g_best[2*n:]\n    radii = np.maximum(radii, 0)\n    \n    # Repair constraint violations\n    for _ in range(100):\n        # Fix boundary violations\n        for i in range(n):\n            if centers[i, 0] - radii[i] < 0:\n                radii[i] = centers[i, 0] - 0.001\n            if centers[i, 0] + radii[i] > 1:\n                radii[i] = 1 - centers[i, 0] - 0.001\n            if centers[i, 1] - radii[i] < 0:\n                radii[i] = centers[i, 1] - 0.001\n            if centers[i, 1] + radii[i] > 1:\n                radii[i] = 1 - centers[i, 1] - 0.001\n            radii[i] = max(radii[i], 0.001)\n        \n        # Fix overlaps by shrinking radii\n        violations = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist:\n                    violations.append((i, j, dist, min_dist))\n        \n        if not violations:\n            break\n        \n        for i, j, dist, min_dist in violations:\n            if dist > 0.001:\n                # Shrink both radii proportionally\n                scale = (dist - 0.001) / min_dist\n                radii[i] *= scale\n                radii[j] *= scale\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T17:53:37.958687",
  "cost_data": null
}