{
  "trial_id": "trial_1_5",
  "generation": 1,
  "parent_id": "trial_0_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using improved simulated annealing.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    def optimize_radii_given_centers(centers):\n        \"\"\"Optimize radii for fixed centers using iterative approach.\"\"\"\n        radii = np.zeros(n)\n        \n        # Iterate to find consistent radii\n        for iteration in range(10):\n            old_radii = radii.copy()\n            for i in range(n):\n                # Distance to boundaries\n                x, y = centers[i]\n                max_r = min(x, 1-x, y, 1-y)\n                \n                # Distance to other circles\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        max_r = min(max_r, dist - radii[j])\n                \n                radii[i] = max(0, max_r)\n            \n            # Check convergence\n            if np.allclose(radii, old_radii, atol=1e-8):\n                break\n        \n        return radii\n    \n    def is_valid_packing(centers, radii):\n        \"\"\"Check if packing satisfies all constraints.\"\"\"\n        # Check boundary constraints\n        for i in range(n):\n            x, y = centers[i]\n            r = radii[i]\n            if x - r < -1e-10 or x + r > 1 + 1e-10 or y - r < -1e-10 or y + r > 1 + 1e-10:\n                return False\n        \n        # Check overlap constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-10:\n                    return False\n        \n        return True\n    \n    def create_hexagonal_grid(n):\n        \"\"\"Create initial configuration using hexagonal packing.\"\"\"\n        centers = []\n        \n        # Hexagonal grid parameters\n        rows = 5\n        cols = 6\n        \n        # Spacing for hexagonal packing\n        dx = 1.0 / (cols + 0.5)\n        dy = 1.0 / (rows + 0.5)\n        \n        for row in range(rows):\n            for col in range(cols):\n                if len(centers) >= n:\n                    break\n                \n                x = (col + 1) * dx\n                y = (row + 1) * dy\n                \n                # Offset every other row for hexagonal packing\n                if row % 2 == 1:\n                    x += dx / 2\n                \n                centers.append([x, y])\n            \n            if len(centers) >= n:\n                break\n        \n        # Add remaining circles if needed\n        while len(centers) < n:\n            centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n        \n        return np.array(centers[:n])\n    \n    def simulated_annealing(initial_centers, max_iterations=50000):\n        \"\"\"Improved simulated annealing with adaptive strategies.\"\"\"\n        current_centers = initial_centers.copy()\n        current_radii = optimize_radii_given_centers(current_centers)\n        current_sum = np.sum(current_radii)\n        \n        best_centers = current_centers.copy()\n        best_radii = current_radii.copy()\n        best_sum = current_sum\n        \n        # Temperature schedule parameters\n        T_initial = 0.1\n        T_min = 1e-6\n        cooling_rate = 0.9995  # Slower cooling\n        T = T_initial\n        \n        # Adaptive perturbation\n        perturbation_initial = 0.05\n        perturbation_min = 0.001\n        \n        # Reheating parameters\n        reheat_interval = 5000\n        reheat_factor = 2.0\n        iterations_since_improvement = 0\n        \n        for iteration in range(max_iterations):\n            # Adaptive perturbation size based on temperature\n            perturbation = perturbation_min + (perturbation_initial - perturbation_min) * (T / T_initial)\n            \n            # Generate neighbor solution\n            new_centers = current_centers.copy()\n            \n            # Perturb multiple circles (adaptive)\n            num_perturb = max(1, int(n * 0.2 * (T / T_initial)))\n            indices = np.random.choice(n, size=num_perturb, replace=False)\n            \n            for idx in indices:\n                # Random perturbation\n                dx = np.random.uniform(-perturbation, perturbation)\n                dy = np.random.uniform(-perturbation, perturbation)\n                \n                new_centers[idx, 0] = np.clip(new_centers[idx, 0] + dx, 0.01, 0.99)\n                new_centers[idx, 1] = np.clip(new_centers[idx, 1] + dy, 0.01, 0.99)\n            \n            # Compute radii for new configuration\n            new_radii = optimize_radii_given_centers(new_centers)\n            new_sum = np.sum(new_radii)\n            \n            # Acceptance criterion\n            delta = new_sum - current_sum\n            \n            if delta > 0 or np.random.random() < np.exp(delta / T):\n                current_centers = new_centers\n                current_radii = new_radii\n                current_sum = new_sum\n                iterations_since_improvement = 0\n                \n                # Update best solution\n                if is_valid_packing(current_centers, current_radii) and current_sum > best_sum:\n                    best_centers = current_centers.copy()\n                    best_radii = current_radii.copy()\n                    best_sum = current_sum\n            else:\n                iterations_since_improvement += 1\n            \n            # Reheating strategy\n            if iterations_since_improvement > reheat_interval and T < T_initial * 0.1:\n                T = min(T * reheat_factor, T_initial * 0.3)\n                iterations_since_improvement = 0\n            \n            # Exponential cooling\n            T = max(T * cooling_rate, T_min)\n        \n        return best_centers, best_radii, best_sum\n    \n    # Try multiple strategies\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Strategy 1: Hexagonal grid + SA\n    hex_centers = create_hexagonal_grid(n)\n    centers, radii, sum_radii = simulated_annealing(hex_centers, max_iterations=50000)\n    if is_valid_packing(centers, radii) and sum_radii > best_sum:\n        best_sum = sum_radii\n        best_centers = centers\n        best_radii = radii\n    \n    # Strategy 2: Multiple random initializations with SA\n    for trial in range(5):\n        np.random.seed(42 + trial)\n        random_centers = np.random.uniform(0.1, 0.9, (n, 2))\n        centers, radii, sum_radii = simulated_annealing(random_centers, max_iterations=30000)\n        if is_valid_packing(centers, radii) and sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers\n            best_radii = radii\n    \n    # Strategy 3: Grid-based initialization with SA\n    for grid_size in [5, 6]:\n        if grid_size * grid_size >= n:\n            spacing = 1.0 / (grid_size + 1)\n            centers_list = []\n            for i in range(grid_size):\n                for j in range(grid_size):\n                    if len(centers_list) < n:\n                        x = (i + 1) * spacing\n                        y = (j + 1) * spacing\n                        centers_list.append([x, y])\n            \n            grid_centers = np.array(centers_list[:n])\n            centers, radii, sum_radii = simulated_annealing(grid_centers, max_iterations=30000)\n            if is_valid_packing(centers, radii) and sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers\n                best_radii = radii\n    \n    # Final local optimization\n    if best_centers is not None:\n        def objective(x):\n            centers = x.reshape(n, 2)\n            radii = optimize_radii_given_centers(centers)\n            return -np.sum(radii)\n        \n        x0 = best_centers.flatten()\n        bounds = [(0.01, 0.99) for _ in range(2*n)]\n        \n        try:\n            result = minimize(\n                objective,\n                x0,\n                method='L-BFGS-B',\n                bounds=bounds,\n                options={'maxiter': 500, 'ftol': 1e-8}\n            )\n            \n            opt_centers = result.x.reshape(n, 2)\n            opt_radii = optimize_radii_given_centers(opt_centers)\n            opt_sum = np.sum(opt_radii)\n            \n            if is_valid_packing(opt_centers, opt_radii) and opt_sum > best_sum:\n                best_sum = opt_sum\n                best_centers = opt_centers\n                best_radii = opt_radii\n        except:\n            pass\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 300.0071189403534,
    "error": "Timeout after 300s"
  },
  "prompt": "Improve this simulated annealing circle packing:\n\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    def compute_max_radii(centers):\n        \"\"\"Compute maximum safe radius for each circle given centers.\"\"\"\n        radii = np.zeros(n)\n        \n        for i in range(n):\n            # Distance to boundaries\n            x, y = centers[i]\n            dist_to_boundary = min(x, 1-x, y, 1-y)\n            \n            # Distance to other circles\n            min_dist_to_others = float('inf')\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    # We need dist > r_i + r_j, so r_i < dist - r_j\n                    # For max radius, assume r_j will be set similarly\n                    # Conservative: r_i < dist/2\n                    min_dist_to_others = min(min_dist_to_others, dist / 2)\n            \n            radii[i] = min(dist_to_boundary, min_dist_to_others)\n        \n        return radii\n    \n    def is_valid_packing(centers, radii):\n        \"\"\"Check if packing satisfies all constraints.\"\"\"\n        # Check boundary constraints\n        for i in range(n):\n            x, y = centers[i]\n            r = radii[i]\n            if x - r < 0 or x + r > 1 or y - r < 0 or y + r > 1:\n                return False\n        \n        # Check overlap constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-10:\n                    return False\n        \n        return True\n    \n    def optimize_radii_given_centers(centers):\n        \"\"\"Optimize radii for fixed centers using linear programming approach.\"\"\"\n        radii = np.zeros(n)\n        \n        for i in range(n):\n            # Distance to boundaries\n            x, y = centers[i]\n            max_r = min(x, 1-x, y, 1-y)\n            \n            # Distance to other circles (considering their current radii)\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, dist - radii[j])\n            \n            radii[i] = max(0, max_r)\n        \n        return radii\n    \n    def objective(x):\n        \"\"\"Objective function for optimization (negative sum of radii).\"\"\"\n        centers = x.reshape(n, 2)\n        radii = optimize_radii_given_centers(centers)\n        return -np.sum(radii)\n    \n    # Generate random initializations\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    num_trials = 2000\n    candidates = []\n    \n    # Phase 1: Random sampling\n    for trial in range(num_trials):\n        # Generate random centers with some margin from boundaries\n        margin = 0.05\n        centers = np.random.uniform(margin, 1-margin, (n, 2))\n        \n        # Compute radii\n        radii = optimize_radii_given_centers(centers)\n        sum_radii = np.sum(radii)\n        \n        if is_valid_packing(centers, radii):\n            candidates.append((sum_radii, centers.copy(), radii.copy()))\n    \n    # Sort candidates by sum of radii\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    \n    # Keep top candidates\n    top_k = min(20, len(candidates))\n    if len(candidates) > 0:\n        best_sum, best_centers, best_radii = candidates[0]\n    \n    # Phase 2: Local optimization on best candidates\n    for idx in range(min(top_k, len(candidates))):\n        sum_radii, centers, radii = candidates[idx]\n        \n        # Try local optimization\n        x0 = centers.flatten()\n        \n        # Bounds to keep centers away from boundaries\n        bounds = [(0.01, 0.99) for _ in range(2*n)]\n        \n        try:\n            result = minimize(\n                objective,\n                x0,\n                method='L-BFGS-B',\n                bounds=bounds,\n                options={'maxiter': 100, 'ftol': 1e-6}\n            )\n            \n            opt_centers = result.x.reshape(n, 2)\n            opt_radii = optimize_radii_given_centers(opt_centers)\n            opt_sum = np.sum(opt_radii)\n            \n            if is_valid_packing(opt_centers, opt_radii) and opt_sum > best_sum:\n                best_sum = opt_sum\n                best_centers = opt_centers\n                best_radii = opt_radii\n        except:\n            pass\n    \n    # Phase 3: Grid-based initialization for more structured approach\n    grid_sizes = [5, 6]\n    for grid_size in grid_sizes:\n        if grid_size * grid_size >= n:\n            spacing = 1.0 / (grid_size + 1)\n            centers = []\n            for i in range(grid_size):\n                for j in range(grid_size):\n                    if len(centers) < n:\n                        x = (i + 1) * spacing + np.random.uniform(-0.02, 0.02)\n                        y = (j + 1) * spacing + np.random.uniform(-0.02, 0.02)\n                        centers.append([x, y])\n            \n            centers = np.array(centers[:n])\n            radii = optimize_radii_given_centers(centers)\n            sum_radii = np.sum(radii)\n            \n            if is_valid_packing(centers, radii) and sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers\n                best_radii = radii\n            \n            # Optimize this grid configuration\n            x0 = centers.flatten()\n            bounds = [(0.01, 0.99) for _ in range(2*n)]\n            \n            try:\n                result = minimize(\n                    objective,\n                    x0,\n                    method='L-BFGS-B',\n                    bounds=bounds,\n                    options={'maxiter': 200, 'ftol': 1e-6}\n                )\n                \n                opt_centers = result.x.reshape(n, 2)\n                opt_radii = optimize_radii_given_centers(opt_centers)\n                opt_sum = np.sum(opt_radii)\n                \n                if is_valid_packing(opt_centers, opt_radii) and opt_sum > best_sum:\n                    best_sum = opt_sum\n                    best_centers = opt_centers\n                    best_radii = opt_radii\n            except:\n                pass\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nEnhancements:\n1. Better cooling schedule: use exponential cooling with slower rate\n2. Adaptive perturbation size: decrease as temperature decreases\n3. Increase iterations to 50000+\n4. Better initial configuration: use hexagonal grid\n5. Add reheating: if stuck in local minimum, occasionally increase temperature\n\nRequirements:\n- Keep simulated annealing approach\n- Implement adaptive strategies\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using improved simulated annealing.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    def optimize_radii_given_centers(centers):\n        \"\"\"Optimize radii for fixed centers using iterative approach.\"\"\"\n        radii = np.zeros(n)\n        \n        # Iterate to find consistent radii\n        for iteration in range(10):\n            old_radii = radii.copy()\n            for i in range(n):\n                # Distance to boundaries\n                x, y = centers[i]\n                max_r = min(x, 1-x, y, 1-y)\n                \n                # Distance to other circles\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        max_r = min(max_r, dist - radii[j])\n                \n                radii[i] = max(0, max_r)\n            \n            # Check convergence\n            if np.allclose(radii, old_radii, atol=1e-8):\n                break\n        \n        return radii\n    \n    def is_valid_packing(centers, radii):\n        \"\"\"Check if packing satisfies all constraints.\"\"\"\n        # Check boundary constraints\n        for i in range(n):\n            x, y = centers[i]\n            r = radii[i]\n            if x - r < -1e-10 or x + r > 1 + 1e-10 or y - r < -1e-10 or y + r > 1 + 1e-10:\n                return False\n        \n        # Check overlap constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-10:\n                    return False\n        \n        return True\n    \n    def create_hexagonal_grid(n):\n        \"\"\"Create initial configuration using hexagonal packing.\"\"\"\n        centers = []\n        \n        # Hexagonal grid parameters\n        rows = 5\n        cols = 6\n        \n        # Spacing for hexagonal packing\n        dx = 1.0 / (cols + 0.5)\n        dy = 1.0 / (rows + 0.5)\n        \n        for row in range(rows):\n            for col in range(cols):\n                if len(centers) >= n:\n                    break\n                \n                x = (col + 1) * dx\n                y = (row + 1) * dy\n                \n                # Offset every other row for hexagonal packing\n                if row % 2 == 1:\n                    x += dx / 2\n                \n                centers.append([x, y])\n            \n            if len(centers) >= n:\n                break\n        \n        # Add remaining circles if needed\n        while len(centers) < n:\n            centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n        \n        return np.array(centers[:n])\n    \n    def simulated_annealing(initial_centers, max_iterations=50000):\n        \"\"\"Improved simulated annealing with adaptive strategies.\"\"\"\n        current_centers = initial_centers.copy()\n        current_radii = optimize_radii_given_centers(current_centers)\n        current_sum = np.sum(current_radii)\n        \n        best_centers = current_centers.copy()\n        best_radii = current_radii.copy()\n        best_sum = current_sum\n        \n        # Temperature schedule parameters\n        T_initial = 0.1\n        T_min = 1e-6\n        cooling_rate = 0.9995  # Slower cooling\n        T = T_initial\n        \n        # Adaptive perturbation\n        perturbation_initial = 0.05\n        perturbation_min = 0.001\n        \n        # Reheating parameters\n        reheat_interval = 5000\n        reheat_factor = 2.0\n        iterations_since_improvement = 0\n        \n        for iteration in range(max_iterations):\n            # Adaptive perturbation size based on temperature\n            perturbation = perturbation_min + (perturbation_initial - perturbation_min) * (T / T_initial)\n            \n            # Generate neighbor solution\n            new_centers = current_centers.copy()\n            \n            # Perturb multiple circles (adaptive)\n            num_perturb = max(1, int(n * 0.2 * (T / T_initial)))\n            indices = np.random.choice(n, size=num_perturb, replace=False)\n            \n            for idx in indices:\n                # Random perturbation\n                dx = np.random.uniform(-perturbation, perturbation)\n                dy = np.random.uniform(-perturbation, perturbation)\n                \n                new_centers[idx, 0] = np.clip(new_centers[idx, 0] + dx, 0.01, 0.99)\n                new_centers[idx, 1] = np.clip(new_centers[idx, 1] + dy, 0.01, 0.99)\n            \n            # Compute radii for new configuration\n            new_radii = optimize_radii_given_centers(new_centers)\n            new_sum = np.sum(new_radii)\n            \n            # Acceptance criterion\n            delta = new_sum - current_sum\n            \n            if delta > 0 or np.random.random() < np.exp(delta / T):\n                current_centers = new_centers\n                current_radii = new_radii\n                current_sum = new_sum\n                iterations_since_improvement = 0\n                \n                # Update best solution\n                if is_valid_packing(current_centers, current_radii) and current_sum > best_sum:\n                    best_centers = current_centers.copy()\n                    best_radii = current_radii.copy()\n                    best_sum = current_sum\n            else:\n                iterations_since_improvement += 1\n            \n            # Reheating strategy\n            if iterations_since_improvement > reheat_interval and T < T_initial * 0.1:\n                T = min(T * reheat_factor, T_initial * 0.3)\n                iterations_since_improvement = 0\n            \n            # Exponential cooling\n            T = max(T * cooling_rate, T_min)\n        \n        return best_centers, best_radii, best_sum\n    \n    # Try multiple strategies\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Strategy 1: Hexagonal grid + SA\n    hex_centers = create_hexagonal_grid(n)\n    centers, radii, sum_radii = simulated_annealing(hex_centers, max_iterations=50000)\n    if is_valid_packing(centers, radii) and sum_radii > best_sum:\n        best_sum = sum_radii\n        best_centers = centers\n        best_radii = radii\n    \n    # Strategy 2: Multiple random initializations with SA\n    for trial in range(5):\n        np.random.seed(42 + trial)\n        random_centers = np.random.uniform(0.1, 0.9, (n, 2))\n        centers, radii, sum_radii = simulated_annealing(random_centers, max_iterations=30000)\n        if is_valid_packing(centers, radii) and sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers\n            best_radii = radii\n    \n    # Strategy 3: Grid-based initialization with SA\n    for grid_size in [5, 6]:\n        if grid_size * grid_size >= n:\n            spacing = 1.0 / (grid_size + 1)\n            centers_list = []\n            for i in range(grid_size):\n                for j in range(grid_size):\n                    if len(centers_list) < n:\n                        x = (i + 1) * spacing\n                        y = (j + 1) * spacing\n                        centers_list.append([x, y])\n            \n            grid_centers = np.array(centers_list[:n])\n            centers, radii, sum_radii = simulated_annealing(grid_centers, max_iterations=30000)\n            if is_valid_packing(centers, radii) and sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers\n                best_radii = radii\n    \n    # Final local optimization\n    if best_centers is not None:\n        def objective(x):\n            centers = x.reshape(n, 2)\n            radii = optimize_radii_given_centers(centers)\n            return -np.sum(radii)\n        \n        x0 = best_centers.flatten()\n        bounds = [(0.01, 0.99) for _ in range(2*n)]\n        \n        try:\n            result = minimize(\n                objective,\n                x0,\n                method='L-BFGS-B',\n                bounds=bounds,\n                options={'maxiter': 500, 'ftol': 1e-8}\n            )\n            \n            opt_centers = result.x.reshape(n, 2)\n            opt_radii = optimize_radii_given_centers(opt_centers)\n            opt_sum = np.sum(opt_radii)\n            \n            if is_valid_packing(opt_centers, opt_radii) and opt_sum > best_sum:\n                best_sum = opt_sum\n                best_centers = opt_centers\n                best_radii = opt_radii\n        except:\n            pass\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T17:58:02.222071",
  "cost_data": null
}