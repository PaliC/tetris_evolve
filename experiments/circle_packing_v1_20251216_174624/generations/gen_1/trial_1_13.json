{
  "trial_id": "trial_1_13",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, differential_evolution\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses divide-and-conquer with quadrant-based optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    \n    # Divide into 4 quadrants with allocation: 7, 7, 6, 6 circles\n    quadrant_counts = [7, 7, 6, 6]\n    quadrant_bounds = [\n        (0.0, 0.5, 0.0, 0.5),  # Bottom-left\n        (0.5, 1.0, 0.0, 0.5),  # Bottom-right\n        (0.0, 0.5, 0.5, 1.0),  # Top-left\n        (0.5, 1.0, 0.5, 1.0),  # Top-right\n    ]\n    \n    all_centers = []\n    all_radii = []\n    \n    # Step 1: Optimize each quadrant independently\n    for q_idx, (n_circles, bounds) in enumerate(zip(quadrant_counts, quadrant_bounds)):\n        x_min, x_max, y_min, y_max = bounds\n        centers, radii = optimize_quadrant(n_circles, x_min, x_max, y_min, y_max)\n        all_centers.append(centers)\n        all_radii.append(radii)\n    \n    # Combine all quadrants\n    centers = np.vstack(all_centers)\n    radii = np.hstack(all_radii)\n    \n    # Step 2: Global refinement with boundary relaxation\n    centers, radii = global_refinement(centers, radii)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\n\ndef optimize_quadrant(n_circles, x_min, x_max, y_min, y_max):\n    \"\"\"\n    Optimize circle packing within a single quadrant.\n    \n    Args:\n        n_circles: number of circles to pack\n        x_min, x_max, y_min, y_max: quadrant boundaries\n        \n    Returns:\n        centers: np.array of shape (n_circles, 2)\n        radii: np.array of shape (n_circles,)\n    \"\"\"\n    \n    def objective(params):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        radii = params[:n_circles]\n        return -np.sum(radii)\n    \n    def constraints_func(params):\n        \"\"\"Return constraint violations (should be >= 0).\"\"\"\n        radii = params[:n_circles]\n        centers = params[n_circles:].reshape(n_circles, 2)\n        \n        violations = []\n        \n        # Boundary constraints\n        for i in range(n_circles):\n            violations.append(centers[i, 0] - radii[i] - x_min)  # left\n            violations.append(x_max - (centers[i, 0] + radii[i]))  # right\n            violations.append(centers[i, 1] - radii[i] - y_min)  # bottom\n            violations.append(y_max - (centers[i, 1] + radii[i]))  # top\n        \n        # Non-overlap constraints\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                violations.append(dist - (radii[i] + radii[j]))\n        \n        return np.array(violations)\n    \n    # Initial guess: grid layout with small radii\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    x_spacing = (x_max - x_min) / (grid_size + 1)\n    y_spacing = (y_max - y_min) / (grid_size + 1)\n    \n    centers_init = []\n    for i in range(n_circles):\n        row = i // grid_size\n        col = i % grid_size\n        x = x_min + (col + 1) * x_spacing\n        y = y_min + (row + 1) * y_spacing\n        centers_init.append([x, y])\n    centers_init = np.array(centers_init)\n    \n    # Initial radii: conservative estimate\n    min_spacing = min(x_spacing, y_spacing)\n    radii_init = np.full(n_circles, min_spacing * 0.3)\n    \n    # Combine into single parameter vector\n    x0 = np.concatenate([radii_init, centers_init.flatten()])\n    \n    # Bounds\n    bounds = [(0.001, 0.5) for _ in range(n_circles)]  # radii bounds\n    for _ in range(n_circles):\n        bounds.append((x_min, x_max))  # x bounds\n        bounds.append((y_min, y_max))  # y bounds\n    \n    # Use differential evolution for global optimization\n    result = differential_evolution(\n        objective,\n        bounds,\n        maxiter=300,\n        popsize=15,\n        seed=42,\n        atol=1e-6,\n        tol=1e-6,\n        workers=1\n    )\n    \n    # Extract solution\n    radii = result.x[:n_circles]\n    centers = result.x[n_circles:].reshape(n_circles, 2)\n    \n    # Local refinement\n    from scipy.optimize import NonlinearConstraint\n    \n    nlc = NonlinearConstraint(constraints_func, 0, np.inf)\n    \n    result_local = minimize(\n        objective,\n        result.x,\n        method='SLSQP',\n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraints_func},\n        options={'maxiter': 500, 'ftol': 1e-9}\n    )\n    \n    if result_local.success or result_local.fun < result.fun:\n        radii = result_local.x[:n_circles]\n        centers = result_local.x[n_circles:].reshape(n_circles, 2)\n    \n    return centers, radii\n\n\ndef global_refinement(centers, radii):\n    \"\"\"\n    Global refinement allowing boundary adjustments.\n    \n    Args:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        \n    Returns:\n        centers: refined centers\n        radii: refined radii\n    \"\"\"\n    n_circles = len(radii)\n    \n    def objective(params):\n        radii = params[:n_circles]\n        return -np.sum(radii)\n    \n    def constraints_func(params):\n        radii = params[:n_circles]\n        centers = params[n_circles:].reshape(n_circles, 2)\n        \n        violations = []\n        \n        # Unit square boundaries\n        for i in range(n_circles):\n            violations.append(centers[i, 0] - radii[i])  # left\n            violations.append(1.0 - (centers[i, 0] + radii[i]))  # right\n            violations.append(centers[i, 1] - radii[i])  # bottom\n            violations.append(1.0 - (centers[i, 1] + radii[i]))  # top\n        \n        # Non-overlap\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                violations.append(dist - (radii[i] + radii[j]))\n        \n        return np.array(violations)\n    \n    # Initial parameters\n    x0 = np.concatenate([radii, centers.flatten()])\n    \n    # Bounds\n    bounds = [(0.001, 0.5) for _ in range(n_circles)]  # radii\n    for _ in range(n_circles):\n        bounds.append((0.0, 1.0))  # x\n        bounds.append((0.0, 1.0))  # y\n    \n    # Global refinement with SLSQP\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraints_func},\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n    \n    radii_refined = result.x[:n_circles]\n    centers_refined = result.x[n_circles:].reshape(n_circles, 2)\n    \n    return centers_refined, radii_refined\n\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.5664938211507202,
    "target_ratio": 0.9740014501520761,
    "combined_score": 0.9740014501520761,
    "eval_time": 8.75403618812561,
    "error": null
  },
  "prompt": "Create a divide-and-conquer packing with optimization.\n\nStrategy:\n1. Divide unit square into 4 quadrants\n2. Allocate circles to quadrants (7,7,6,6 or similar)\n3. Independently optimize each quadrant using scipy.optimize\n4. Refine boundaries: allow circles near boundaries to adjust\n5. Global refinement pass\n\nRequirements:\n- Divide-and-conquer structure\n- Use scipy.optimize for each region\n- Global refinement at end\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses divide-and-conquer with quadrant-based optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    \n    # Divide into 4 quadrants with allocation: 7, 7, 6, 6 circles\n    quadrant_counts = [7, 7, 6, 6]\n    quadrant_bounds = [\n        (0.0, 0.5, 0.0, 0.5),  # Bottom-left\n        (0.5, 1.0, 0.0, 0.5),  # Bottom-right\n        (0.0, 0.5, 0.5, 1.0),  # Top-left\n        (0.5, 1.0, 0.5, 1.0),  # Top-right\n    ]\n    \n    all_centers = []\n    all_radii = []\n    \n    # Step 1: Optimize each quadrant independently\n    for q_idx, (n_circles, bounds) in enumerate(zip(quadrant_counts, quadrant_bounds)):\n        x_min, x_max, y_min, y_max = bounds\n        centers, radii = optimize_quadrant(n_circles, x_min, x_max, y_min, y_max)\n        all_centers.append(centers)\n        all_radii.append(radii)\n    \n    # Combine all quadrants\n    centers = np.vstack(all_centers)\n    radii = np.hstack(all_radii)\n    \n    # Step 2: Global refinement with boundary relaxation\n    centers, radii = global_refinement(centers, radii)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\n\ndef optimize_quadrant(n_circles, x_min, x_max, y_min, y_max):\n    \"\"\"\n    Optimize circle packing within a single quadrant.\n    \n    Args:\n        n_circles: number of circles to pack\n        x_min, x_max, y_min, y_max: quadrant boundaries\n        \n    Returns:\n        centers: np.array of shape (n_circles, 2)\n        radii: np.array of shape (n_circles,)\n    \"\"\"\n    \n    def objective(params):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        radii = params[:n_circles]\n        return -np.sum(radii)\n    \n    def constraints_func(params):\n        \"\"\"Return constraint violations (should be >= 0).\"\"\"\n        radii = params[:n_circles]\n        centers = params[n_circles:].reshape(n_circles, 2)\n        \n        violations = []\n        \n        # Boundary constraints\n        for i in range(n_circles):\n            violations.append(centers[i, 0] - radii[i] - x_min)  # left\n            violations.append(x_max - (centers[i, 0] + radii[i]))  # right\n            violations.append(centers[i, 1] - radii[i] - y_min)  # bottom\n            violations.append(y_max - (centers[i, 1] + radii[i]))  # top\n        \n        # Non-overlap constraints\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                violations.append(dist - (radii[i] + radii[j]))\n        \n        return np.array(violations)\n    \n    # Initial guess: grid layout with small radii\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    x_spacing = (x_max - x_min) / (grid_size + 1)\n    y_spacing = (y_max - y_min) / (grid_size + 1)\n    \n    centers_init = []\n    for i in range(n_circles):\n        row = i // grid_size\n        col = i % grid_size\n        x = x_min + (col + 1) * x_spacing\n        y = y_min + (row + 1) * y_spacing\n        centers_init.append([x, y])\n    centers_init = np.array(centers_init)\n    \n    # Initial radii: conservative estimate\n    min_spacing = min(x_spacing, y_spacing)\n    radii_init = np.full(n_circles, min_spacing * 0.3)\n    \n    # Combine into single parameter vector\n    x0 = np.concatenate([radii_init, centers_init.flatten()])\n    \n    # Bounds\n    bounds = [(0.001, 0.5) for _ in range(n_circles)]  # radii bounds\n    for _ in range(n_circles):\n        bounds.append((x_min, x_max))  # x bounds\n        bounds.append((y_min, y_max))  # y bounds\n    \n    # Use differential evolution for global optimization\n    result = differential_evolution(\n        objective,\n        bounds,\n        maxiter=300,\n        popsize=15,\n        seed=42,\n        atol=1e-6,\n        tol=1e-6,\n        workers=1\n    )\n    \n    # Extract solution\n    radii = result.x[:n_circles]\n    centers = result.x[n_circles:].reshape(n_circles, 2)\n    \n    # Local refinement\n    from scipy.optimize import NonlinearConstraint\n    \n    nlc = NonlinearConstraint(constraints_func, 0, np.inf)\n    \n    result_local = minimize(\n        objective,\n        result.x,\n        method='SLSQP',\n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraints_func},\n        options={'maxiter': 500, 'ftol': 1e-9}\n    )\n    \n    if result_local.success or result_local.fun < result.fun:\n        radii = result_local.x[:n_circles]\n        centers = result_local.x[n_circles:].reshape(n_circles, 2)\n    \n    return centers, radii\n\n\ndef global_refinement(centers, radii):\n    \"\"\"\n    Global refinement allowing boundary adjustments.\n    \n    Args:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        \n    Returns:\n        centers: refined centers\n        radii: refined radii\n    \"\"\"\n    n_circles = len(radii)\n    \n    def objective(params):\n        radii = params[:n_circles]\n        return -np.sum(radii)\n    \n    def constraints_func(params):\n        radii = params[:n_circles]\n        centers = params[n_circles:].reshape(n_circles, 2)\n        \n        violations = []\n        \n        # Unit square boundaries\n        for i in range(n_circles):\n            violations.append(centers[i, 0] - radii[i])  # left\n            violations.append(1.0 - (centers[i, 0] + radii[i]))  # right\n            violations.append(centers[i, 1] - radii[i])  # bottom\n            violations.append(1.0 - (centers[i, 1] + radii[i]))  # top\n        \n        # Non-overlap\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                violations.append(dist - (radii[i] + radii[j]))\n        \n        return np.array(violations)\n    \n    # Initial parameters\n    x0 = np.concatenate([radii, centers.flatten()])\n    \n    # Bounds\n    bounds = [(0.001, 0.5) for _ in range(n_circles)]  # radii\n    for _ in range(n_circles):\n        bounds.append((0.0, 1.0))  # x\n        bounds.append((0.0, 1.0))  # y\n    \n    # Global refinement with SLSQP\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraints_func},\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n    \n    radii_refined = result.x[:n_circles]\n    centers_refined = result.x[n_circles:].reshape(n_circles, 2)\n    \n    return centers_refined, radii_refined\n\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T17:53:09.281684",
  "cost_data": null
}