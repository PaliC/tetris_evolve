{
  "trial_id": "trial_1_9",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # Stage 1: Initialize with coarse grid\n    grid_rows = 4\n    grid_cols = 7\n    centers = initialize_grid(n, grid_rows, grid_cols)\n    \n    # Stage 2: Compute initial radii\n    radii = compute_optimal_radii(centers)\n    best_sum = np.sum(radii)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    \n    # Stage 3: Multi-resolution refinement\n    # Phase 1: Small perturbations\n    centers, radii, sum_radii = refine_packing(centers, iterations=500, \n                                                 perturbation=0.01, temp=0.1)\n    if sum_radii > best_sum:\n        best_sum = sum_radii\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n    \n    # Phase 2: Medium perturbations\n    centers, radii, sum_radii = refine_packing(best_centers, iterations=500, \n                                                 perturbation=0.02, temp=0.05)\n    if sum_radii > best_sum:\n        best_sum = sum_radii\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n    \n    # Phase 3: Larger perturbations with cooling\n    for scale in [0.03, 0.04, 0.05]:\n        centers, radii, sum_radii = refine_packing(best_centers, iterations=300, \n                                                     perturbation=scale, temp=0.02)\n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    # Stage 4: Global optimization with scipy\n    centers, radii, sum_radii = scipy_optimization(best_centers, method='local')\n    if sum_radii > best_sum:\n        best_sum = sum_radii\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n    \n    # Stage 5: Final polish with differential evolution on subset\n    centers, radii, sum_radii = scipy_optimization(best_centers, method='global')\n    if sum_radii > best_sum:\n        best_sum = sum_radii\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\n\ndef initialize_grid(n, rows, cols):\n    \"\"\"Initialize centers on a regular grid.\"\"\"\n    centers = []\n    margin = 0.08\n    x_spacing = (1 - 2*margin) / (cols - 1)\n    y_spacing = (1 - 2*margin) / (rows - 1)\n    \n    count = 0\n    for i in range(rows):\n        for j in range(cols):\n            if count >= n:\n                break\n            x = margin + j * x_spacing\n            y = margin + i * y_spacing\n            centers.append([x, y])\n            count += 1\n        if count >= n:\n            break\n    \n    return np.array(centers)\n\n\ndef compute_optimal_radii(centers):\n    \"\"\"Compute maximum radii for given centers.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Distance to boundaries\n        x, y = centers[i]\n        r_max = min(x, 1-x, y, 1-y)\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                r_max = min(r_max, dist / 2)\n        \n        radii[i] = max(0, r_max)\n    \n    return radii\n\n\ndef is_valid_packing(centers, radii):\n    \"\"\"Check if packing satisfies all constraints.\"\"\"\n    n = len(centers)\n    \n    # Check boundary constraints\n    for i in range(n):\n        x, y = centers[i]\n        r = radii[i]\n        if x - r < 0 or x + r > 1 or y - r < 0 or y + r > 1:\n            return False\n    \n    # Check overlap constraints\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-10:\n                return False\n    \n    return True\n\n\ndef refine_packing(centers, iterations=1000, perturbation=0.01, temp=0.1):\n    \"\"\"Refine packing using simulated annealing-like approach.\"\"\"\n    n = len(centers)\n    current_centers = centers.copy()\n    current_radii = compute_optimal_radii(current_centers)\n    current_sum = np.sum(current_radii)\n    \n    best_centers = current_centers.copy()\n    best_radii = current_radii.copy()\n    best_sum = current_sum\n    \n    for iter in range(iterations):\n        # Perturb a random subset of centers\n        num_perturb = np.random.randint(1, max(2, n//5))\n        indices = np.random.choice(n, num_perturb, replace=False)\n        \n        new_centers = current_centers.copy()\n        for idx in indices:\n            new_centers[idx] += np.random.normal(0, perturbation, 2)\n            # Keep within bounds with margin\n            new_centers[idx] = np.clip(new_centers[idx], 0.02, 0.98)\n        \n        # Compute new radii\n        new_radii = compute_optimal_radii(new_centers)\n        new_sum = np.sum(new_radii)\n        \n        # Accept if improvement or with probability based on temperature\n        if new_sum > current_sum or (temp > 0 and np.random.random() < np.exp((new_sum - current_sum) / temp)):\n            current_centers = new_centers\n            current_radii = new_radii\n            current_sum = new_sum\n            \n            if new_sum > best_sum:\n                best_centers = new_centers.copy()\n                best_radii = new_radii.copy()\n                best_sum = new_sum\n    \n    return best_centers, best_radii, best_sum\n\n\ndef scipy_optimization(centers, method='local'):\n    \"\"\"Use scipy optimization for final refinement.\"\"\"\n    n = len(centers)\n    x0 = centers.flatten()\n    \n    def objective(x):\n        centers_2d = x.reshape(n, 2)\n        radii = compute_optimal_radii(centers_2d)\n        return -np.sum(radii)  # Negative because we minimize\n    \n    def constraint_boundary(x):\n        centers_2d = x.reshape(n, 2)\n        radii = compute_optimal_radii(centers_2d)\n        violations = []\n        for i in range(n):\n            cx, cy = centers_2d[i]\n            r = radii[i]\n            violations.extend([cx - r, 1 - cx - r, cy - r, 1 - cy - r])\n        return np.array(violations)\n    \n    bounds = [(0.01, 0.99) for _ in range(2*n)]\n    \n    if method == 'local':\n        # Local optimization\n        result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds,\n                         options={'maxiter': 200, 'ftol': 1e-9})\n        centers_opt = result.x.reshape(n, 2)\n    else:\n        # Global optimization with differential evolution (limited iterations)\n        result = differential_evolution(objective, bounds, maxiter=50, \n                                       seed=42, workers=1, polish=True)\n        centers_opt = result.x.reshape(n, 2)\n    \n    radii_opt = compute_optimal_radii(centers_opt)\n    sum_opt = np.sum(radii_opt)\n    \n    return centers_opt, radii_opt, sum_opt\n\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.474099249925442,
    "target_ratio": 0.9389370967458983,
    "combined_score": 0.9389370967458983,
    "eval_time": 71.4811441898346,
    "error": null
  },
  "prompt": "Create a multi-resolution optimization approach.\n\nStrategy:\n1. Start with coarse grid (e.g., 4x7 = 28 positions, use 26)\n2. Compute initial radii for grid layout\n3. Progressively refine:\n   - Small random perturbations to positions\n   - Recompute optimal radii\n   - Accept if improvement\n   - Gradually increase perturbation variance\n4. Final polish with scipy.optimize\n\nRequirements:\n- Multi-resolution approach\n- Use scipy.optimize for final refinement\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # Stage 1: Initialize with coarse grid\n    grid_rows = 4\n    grid_cols = 7\n    centers = initialize_grid(n, grid_rows, grid_cols)\n    \n    # Stage 2: Compute initial radii\n    radii = compute_optimal_radii(centers)\n    best_sum = np.sum(radii)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    \n    # Stage 3: Multi-resolution refinement\n    # Phase 1: Small perturbations\n    centers, radii, sum_radii = refine_packing(centers, iterations=500, \n                                                 perturbation=0.01, temp=0.1)\n    if sum_radii > best_sum:\n        best_sum = sum_radii\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n    \n    # Phase 2: Medium perturbations\n    centers, radii, sum_radii = refine_packing(best_centers, iterations=500, \n                                                 perturbation=0.02, temp=0.05)\n    if sum_radii > best_sum:\n        best_sum = sum_radii\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n    \n    # Phase 3: Larger perturbations with cooling\n    for scale in [0.03, 0.04, 0.05]:\n        centers, radii, sum_radii = refine_packing(best_centers, iterations=300, \n                                                     perturbation=scale, temp=0.02)\n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    # Stage 4: Global optimization with scipy\n    centers, radii, sum_radii = scipy_optimization(best_centers, method='local')\n    if sum_radii > best_sum:\n        best_sum = sum_radii\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n    \n    # Stage 5: Final polish with differential evolution on subset\n    centers, radii, sum_radii = scipy_optimization(best_centers, method='global')\n    if sum_radii > best_sum:\n        best_sum = sum_radii\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\n\ndef initialize_grid(n, rows, cols):\n    \"\"\"Initialize centers on a regular grid.\"\"\"\n    centers = []\n    margin = 0.08\n    x_spacing = (1 - 2*margin) / (cols - 1)\n    y_spacing = (1 - 2*margin) / (rows - 1)\n    \n    count = 0\n    for i in range(rows):\n        for j in range(cols):\n            if count >= n:\n                break\n            x = margin + j * x_spacing\n            y = margin + i * y_spacing\n            centers.append([x, y])\n            count += 1\n        if count >= n:\n            break\n    \n    return np.array(centers)\n\n\ndef compute_optimal_radii(centers):\n    \"\"\"Compute maximum radii for given centers.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Distance to boundaries\n        x, y = centers[i]\n        r_max = min(x, 1-x, y, 1-y)\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                r_max = min(r_max, dist / 2)\n        \n        radii[i] = max(0, r_max)\n    \n    return radii\n\n\ndef is_valid_packing(centers, radii):\n    \"\"\"Check if packing satisfies all constraints.\"\"\"\n    n = len(centers)\n    \n    # Check boundary constraints\n    for i in range(n):\n        x, y = centers[i]\n        r = radii[i]\n        if x - r < 0 or x + r > 1 or y - r < 0 or y + r > 1:\n            return False\n    \n    # Check overlap constraints\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-10:\n                return False\n    \n    return True\n\n\ndef refine_packing(centers, iterations=1000, perturbation=0.01, temp=0.1):\n    \"\"\"Refine packing using simulated annealing-like approach.\"\"\"\n    n = len(centers)\n    current_centers = centers.copy()\n    current_radii = compute_optimal_radii(current_centers)\n    current_sum = np.sum(current_radii)\n    \n    best_centers = current_centers.copy()\n    best_radii = current_radii.copy()\n    best_sum = current_sum\n    \n    for iter in range(iterations):\n        # Perturb a random subset of centers\n        num_perturb = np.random.randint(1, max(2, n//5))\n        indices = np.random.choice(n, num_perturb, replace=False)\n        \n        new_centers = current_centers.copy()\n        for idx in indices:\n            new_centers[idx] += np.random.normal(0, perturbation, 2)\n            # Keep within bounds with margin\n            new_centers[idx] = np.clip(new_centers[idx], 0.02, 0.98)\n        \n        # Compute new radii\n        new_radii = compute_optimal_radii(new_centers)\n        new_sum = np.sum(new_radii)\n        \n        # Accept if improvement or with probability based on temperature\n        if new_sum > current_sum or (temp > 0 and np.random.random() < np.exp((new_sum - current_sum) / temp)):\n            current_centers = new_centers\n            current_radii = new_radii\n            current_sum = new_sum\n            \n            if new_sum > best_sum:\n                best_centers = new_centers.copy()\n                best_radii = new_radii.copy()\n                best_sum = new_sum\n    \n    return best_centers, best_radii, best_sum\n\n\ndef scipy_optimization(centers, method='local'):\n    \"\"\"Use scipy optimization for final refinement.\"\"\"\n    n = len(centers)\n    x0 = centers.flatten()\n    \n    def objective(x):\n        centers_2d = x.reshape(n, 2)\n        radii = compute_optimal_radii(centers_2d)\n        return -np.sum(radii)  # Negative because we minimize\n    \n    def constraint_boundary(x):\n        centers_2d = x.reshape(n, 2)\n        radii = compute_optimal_radii(centers_2d)\n        violations = []\n        for i in range(n):\n            cx, cy = centers_2d[i]\n            r = radii[i]\n            violations.extend([cx - r, 1 - cx - r, cy - r, 1 - cy - r])\n        return np.array(violations)\n    \n    bounds = [(0.01, 0.99) for _ in range(2*n)]\n    \n    if method == 'local':\n        # Local optimization\n        result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds,\n                         options={'maxiter': 200, 'ftol': 1e-9})\n        centers_opt = result.x.reshape(n, 2)\n    else:\n        # Global optimization with differential evolution (limited iterations)\n        result = differential_evolution(objective, bounds, maxiter=50, \n                                       seed=42, workers=1, polish=True)\n        centers_opt = result.x.reshape(n, 2)\n    \n    radii_opt = compute_optimal_radii(centers_opt)\n    sum_opt = np.sum(radii_opt)\n    \n    return centers_opt, radii_opt, sum_opt\n\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T17:54:11.644900",
  "cost_data": null
}