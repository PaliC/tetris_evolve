{
  "trial_id": "trial_3_3",
  "generation": 3,
  "parent_id": "trial_2_3",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, differential_evolution\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def greedy_packing(seed):\n        np.random.seed(seed)\n        centers = []\n        radii = []\n        \n        for i in range(n):\n            best_pos = None\n            best_radius = 0\n            \n            # Massively increased candidate sampling\n            n_random = 8000\n            n_grid = 50\n            \n            # Random candidates with importance sampling\n            if len(centers) > 0:\n                # Focus 50% of random candidates near existing circles (gap filling)\n                n_focused = n_random // 2\n                n_uniform = n_random - n_focused\n                \n                uniform_candidates = np.random.rand(n_uniform, 2)\n                \n                # Generate candidates near existing circles\n                centers_array = np.array(centers)\n                radii_array = np.array(radii)\n                focused_candidates = []\n                \n                for j in range(min(10, len(centers))):\n                    # Sample around each circle\n                    n_per_circle = n_focused // min(10, len(centers))\n                    angles = np.random.rand(n_per_circle) * 2 * np.pi\n                    distances = radii_array[j] * (1.5 + np.random.rand(n_per_circle) * 1.5)\n                    \n                    gap_cands = centers_array[j] + distances[:, np.newaxis] * np.column_stack([np.cos(angles), np.sin(angles)])\n                    gap_cands = np.clip(gap_cands, 0, 1)\n                    focused_candidates.append(gap_cands)\n                \n                if focused_candidates:\n                    focused_candidates = np.vstack(focused_candidates)\n                    candidates = np.vstack([uniform_candidates, focused_candidates])\n                else:\n                    candidates = uniform_candidates\n            else:\n                candidates = np.random.rand(n_random, 2)\n            \n            # Dense grid candidates\n            x_grid = np.linspace(0.01, 0.99, n_grid)\n            y_grid = np.linspace(0.01, 0.99, n_grid)\n            xx, yy = np.meshgrid(x_grid, y_grid)\n            grid_candidates = np.column_stack([xx.ravel(), yy.ravel()])\n            candidates = np.vstack([candidates, grid_candidates])\n            \n            # Strategic candidates for early circles\n            if i < 10:\n                strategic = []\n                for x in [0.05, 0.15, 0.25, 0.35, 0.45, 0.55, 0.65, 0.75, 0.85, 0.95]:\n                    for y in [0.05, 0.15, 0.25, 0.35, 0.45, 0.55, 0.65, 0.75, 0.85, 0.95]:\n                        strategic.append([x, y])\n                candidates = np.vstack([candidates, np.array(strategic)])\n            \n            # Additional gap-filling candidates\n            if len(centers) >= 3:\n                centers_array = np.array(centers)\n                radii_array = np.array(radii)\n                \n                # Find potential gaps between circles\n                for j in range(min(8, len(centers))):\n                    for k in range(j+1, min(j+8, len(centers))):\n                        # Midpoint between circles\n                        midpoint = (centers_array[j] + centers_array[k]) / 2\n                        \n                        # Sample around midpoint\n                        for angle in np.linspace(0, 2*np.pi, 16):\n                            for dist in [0.02, 0.04, 0.06, 0.08]:\n                                cand = midpoint + dist * np.array([np.cos(angle), np.sin(angle)])\n                                cand = np.clip(cand, 0, 1)\n                                candidates = np.vstack([candidates, cand.reshape(1, 2)])\n            \n            for candidate in candidates:\n                x, y = candidate\n                \n                # Maximum radius from boundaries\n                max_r = min(x, y, 1 - x, 1 - y)\n                \n                if max_r <= 0:\n                    continue\n                \n                # Check constraints with existing circles\n                if len(centers) > 0:\n                    centers_array = np.array(centers)\n                    radii_array = np.array(radii)\n                    \n                    # Distance to existing circles\n                    distances = np.sqrt(np.sum((centers_array - candidate)**2, axis=1))\n                    # Maximum radius to avoid overlap\n                    max_r_circles = distances - radii_array\n                    max_r = min(max_r, np.min(max_r_circles))\n                \n                if max_r > best_radius:\n                    best_radius = max_r\n                    best_pos = candidate\n            \n            if best_radius > 0:\n                centers.append(best_pos)\n                radii.append(best_radius)\n        \n        return np.array(centers), np.array(radii)\n    \n    # Try more seeds\n    best_centers = None\n    best_radii = None\n    best_sum = 0\n    \n    seeds = [42, 123, 456, 789, 1337, 2024, 9999, 5555, 7777, 3141, 2718, 1618]\n    \n    for seed in seeds:\n        centers, radii = greedy_packing(seed)\n        current_sum = np.sum(radii)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    centers = best_centers\n    radii = best_radii\n    \n    # Enhanced local search with more iterations\n    def local_search(centers, radii, iterations=300):\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n        best_sum = np.sum(radii)\n        \n        for iter_num in range(iterations):\n            # Adaptive perturbation size\n            perturb_scale = 0.03 * (1 - iter_num / iterations) + 0.005\n            \n            # Pick a random circle\n            idx = np.random.randint(n)\n            \n            # Try more perturbations\n            for _ in range(30):\n                new_center = centers[idx] + np.random.randn(2) * perturb_scale\n                new_center = np.clip(new_center, 0, 1)\n                \n                # Calculate max radius at new position\n                max_r = min(new_center[0], new_center[1], 1 - new_center[0], 1 - new_center[1])\n                \n                # Check with other circles\n                for j in range(n):\n                    if j != idx:\n                        dist = np.sqrt(np.sum((centers[j] - new_center)**2))\n                        max_r = min(max_r, dist - radii[j])\n                \n                if max_r > 0:\n                    # Try this configuration\n                    test_centers = centers.copy()\n                    test_radii = radii.copy()\n                    test_centers[idx] = new_center\n                    test_radii[idx] = max_r\n                    \n                    test_sum = np.sum(test_radii)\n                    if test_sum > best_sum:\n                        best_sum = test_sum\n                        best_centers = test_centers.copy()\n                        best_radii = test_radii.copy()\n                        centers = best_centers.copy()\n                        radii = best_radii.copy()\n        \n        return best_centers, best_radii\n    \n    centers, radii = local_search(centers, radii, iterations=300)\n    \n    # Multiple scipy refinement passes\n    def scipy_refinement(centers, radii, num_passes=3):\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n        best_sum = np.sum(radii)\n        \n        for pass_num in range(num_passes):\n            def objective(x):\n                radii_opt = x[n*2:]\n                return -np.sum(radii_opt)\n            \n            def constraint_boundary(x):\n                centers_opt = x[:n*2].reshape(n, 2)\n                radii_opt = x[n*2:]\n                \n                constraints = []\n                for i in range(n):\n                    constraints.extend([\n                        centers_opt[i, 0] - radii_opt[i],\n                        centers_opt[i, 1] - radii_opt[i],\n                        1 - centers_opt[i, 0] - radii_opt[i],\n                        1 - centers_opt[i, 1] - radii_opt[i]\n                    ])\n                return np.array(constraints)\n            \n            def constraint_overlap(x):\n                centers_opt = x[:n*2].reshape(n, 2)\n                radii_opt = x[n*2:]\n                \n                constraints = []\n                for i in range(n):\n                    for j in range(i+1, n):\n                        dist = np.sqrt(np.sum((centers_opt[i] - centers_opt[j])**2))\n                        constraints.append(dist - radii_opt[i] - radii_opt[j])\n                return np.array(constraints)\n            \n            x0 = np.concatenate([centers.ravel(), radii])\n            bounds = [(0, 1)] * (n * 2) + [(0, 0.5)] * n\n            constraints = [\n                {'type': 'ineq', 'fun': constraint_boundary},\n                {'type': 'ineq', 'fun': constraint_overlap}\n            ]\n            \n            # Multiple attempts per pass\n            for attempt in range(3):\n                try:\n                    if attempt > 0:\n                        x0_perturbed = x0 + np.random.randn(len(x0)) * 0.003\n                        x0_perturbed[:n*2] = np.clip(x0_perturbed[:n*2], 0.01, 0.99)\n                        x0_perturbed[n*2:] = np.clip(x0_perturbed[n*2:], 0, 0.4)\n                    else:\n                        x0_perturbed = x0\n                    \n                    result = minimize(\n                        objective,\n                        x0_perturbed,\n                        method='SLSQP',\n                        bounds=bounds,\n                        constraints=constraints,\n                        options={'maxiter': 1500, 'ftol': 1e-12}\n                    )\n                    \n                    if result.success or True:  # Accept even if not fully converged\n                        test_centers = result.x[:n*2].reshape(n, 2)\n                        test_radii = result.x[n*2:]\n                        test_sum = np.sum(test_radii)\n                        \n                        if test_sum > best_sum:\n                            best_sum = test_sum\n                            best_centers = test_centers.copy()\n                            best_radii = test_radii.copy()\n                            centers = best_centers.copy()\n                            radii = best_radii.copy()\n                            x0 = result.x.copy()\n                except:\n                    pass\n        \n        return best_centers, best_radii\n    \n    centers, radii = scipy_refinement(centers, radii, num_passes=3)\n    \n    # Perturbation-and-refinement loop\n    for macro_iter in range(5):\n        # Small perturbation\n        perturb_centers = centers + np.random.randn(n, 2) * 0.008\n        perturb_centers = np.clip(perturb_centers, 0, 1)\n        \n        # Recompute radii\n        perturb_radii = np.zeros(n)\n        for i in range(n):\n            max_r = min(perturb_centers[i, 0], perturb_centers[i, 1], \n                       1 - perturb_centers[i, 0], 1 - perturb_centers[i, 1])\n            \n            for j in range(n):\n                if j != i:\n                    dist = np.sqrt(np.sum((perturb_centers[i] - perturb_centers[j])**2))\n                    max_r = min(max_r, dist - perturb_radii[j])\n            \n            perturb_radii[i] = max(0, max_r)\n        \n        if np.sum(perturb_radii) > np.sum(radii):\n            centers = perturb_centers\n            radii = perturb_radii\n        \n        # Quick refinement\n        centers, radii = scipy_refinement(centers, radii, num_passes=1)\n    \n    # Final pass: optimize radii only with positions fixed\n    def optimize_radii_only(centers, radii):\n        def objective_radii(r):\n            return -np.sum(r)\n        \n        def constraint_boundary_radii(r):\n            constraints = []\n            for i in range(n):\n                constraints.extend([\n                    centers[i, 0] - r[i],\n                    centers[i, 1] - r[i],\n                    1 - centers[i, 0] - r[i],\n                    1 - centers[i, 1] - r[i]\n                ])\n            return np.array(constraints)\n        \n        def constraint_overlap_radii(r):\n            constraints = []\n            for i in range(n):\n                for j in range(i+1, n):\n                    dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                    constraints.append(dist - r[i] - r[j])\n            return np.array(constraints)\n        \n        bounds = [(0, 0.5)] * n\n        constraints = [\n            {'type': 'ineq', 'fun': constraint_boundary_radii},\n            {'type': 'ineq', 'fun': constraint_overlap_radii}\n        ]\n        \n        try:\n            result = minimize(\n                objective_radii,\n                radii,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 2000, 'ftol': 1e-14}\n            )\n            \n            if result.success or np.sum(result.x) > np.sum(radii):\n                return result.x\n        except:\n            pass\n        \n        return radii\n    \n    radii = optimize_radii_only(centers, radii)\n    \n    radii = np.maximum(radii, 0)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.5678489922783267,
    "target_ratio": 0.9745157465951905,
    "combined_score": 0.9745157465951905,
    "eval_time": 2357.350208044052,
    "error": null
  },
  "prompt": "Enhance this sequential placement optimizer:\n\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def greedy_packing(seed):\n        np.random.seed(seed)\n        centers = []\n        radii = []\n        \n        for i in range(n):\n            best_pos = None\n            best_radius = 0\n            \n            # Adaptive candidate generation\n            n_random = 3000\n            n_grid = 30\n            \n            # Random candidates\n            candidates = np.random.rand(n_random, 2)\n            \n            # Dense grid candidates\n            x_grid = np.linspace(0.02, 0.98, n_grid)\n            y_grid = np.linspace(0.02, 0.98, n_grid)\n            xx, yy = np.meshgrid(x_grid, y_grid)\n            grid_candidates = np.column_stack([xx.ravel(), yy.ravel()])\n            candidates = np.vstack([candidates, grid_candidates])\n            \n            # Strategic candidates: focus on corners and edges for first few circles\n            if i < 8:\n                corner_candidates = np.array([\n                    [0.1, 0.1], [0.9, 0.1], [0.1, 0.9], [0.9, 0.9],\n                    [0.5, 0.1], [0.5, 0.9], [0.1, 0.5], [0.9, 0.5],\n                    [0.3, 0.3], [0.7, 0.3], [0.3, 0.7], [0.7, 0.7]\n                ])\n                candidates = np.vstack([candidates, corner_candidates])\n            \n            # If we have existing circles, add candidates near them (gap filling)\n            if len(centers) > 2:\n                centers_array = np.array(centers)\n                radii_array = np.array(radii)\n                \n                # Sample points around existing circles\n                for j in range(min(5, len(centers))):\n                    angles = np.linspace(0, 2*np.pi, 20)\n                    dist = radii_array[j] * 2.2\n                    gap_candidates = centers_array[j] + dist * np.column_stack([np.cos(angles), np.sin(angles)])\n                    gap_candidates = np.clip(gap_candidates, 0, 1)\n                    candidates = np.vstack([candidates, gap_candidates])\n            \n            for candidate in candidates:\n                x, y = candidate\n                \n                # Maximum radius from boundaries\n                max_r = min(x, y, 1 - x, 1 - y)\n                \n                if max_r <= 0:\n                    continue\n                \n                # Check constraints with existing circles\n                if len(centers) > 0:\n                    centers_array = np.array(centers)\n                    radii_array = np.array(radii)\n                    \n                    # Distance to existing circles\n                    distances = np.sqrt(np.sum((centers_array - candidate)**2, axis=1))\n                    # Maximum radius to avoid overlap\n                    max_r_circles = distances - radii_array\n                    max_r = min(max_r, np.min(max_r_circles))\n                \n                if max_r > best_radius:\n                    best_radius = max_r\n                    best_pos = candidate\n            \n            if best_radius > 0:\n                centers.append(best_pos)\n                radii.append(best_radius)\n        \n        return np.array(centers), np.array(radii)\n    \n    # Try multiple seeds and keep best\n    best_centers = None\n    best_radii = None\n    best_sum = 0\n    \n    seeds = [42, 123, 456, 789, 1337, 2024, 9999]\n    \n    for seed in seeds:\n        centers, radii = greedy_packing(seed)\n        current_sum = np.sum(radii)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    centers = best_centers\n    radii = best_radii\n    \n    # Local refinement: adjust positions slightly\n    def local_search(centers, radii, iterations=100):\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n        best_sum = np.sum(radii)\n        \n        for _ in range(iterations):\n            # Pick a random circle\n            idx = np.random.randint(n)\n            \n            # Try small perturbations\n            for _ in range(20):\n                new_center = centers[idx] + np.random.randn(2) * 0.02\n                new_center = np.clip(new_center, 0, 1)\n                \n                # Calculate max radius at new position\n                max_r = min(new_center[0], new_center[1], 1 - new_center[0], 1 - new_center[1])\n                \n                # Check with other circles\n                for j in range(n):\n                    if j != idx:\n                        dist = np.sqrt(np.sum((centers[j] - new_center)**2))\n                        max_r = min(max_r, dist - radii[j])\n                \n                if max_r > 0:\n                    # Try this configuration\n                    test_centers = centers.copy()\n                    test_radii = radii.copy()\n                    test_centers[idx] = new_center\n                    test_radii[idx] = max_r\n                    \n                    test_sum = np.sum(test_radii)\n                    if test_sum > best_sum:\n                        best_sum = test_sum\n                        best_centers = test_centers.copy()\n                        best_radii = test_radii.copy()\n                        centers = best_centers.copy()\n                        radii = best_radii.copy()\n        \n        return best_centers, best_radii\n    \n    centers, radii = local_search(centers, radii, iterations=150)\n    \n    # Final optimization with scipy\n    def objective(x):\n        n_circles = len(radii)\n        radii_opt = x[n_circles*2:]\n        return -np.sum(radii_opt)\n    \n    def constraint_boundary(x):\n        n_circles = len(radii)\n        centers_opt = x[:n_circles*2].reshape(n_circles, 2)\n        radii_opt = x[n_circles*2:]\n        \n        constraints = []\n        for i in range(n_circles):\n            constraints.extend([\n                centers_opt[i, 0] - radii_opt[i],\n                centers_opt[i, 1] - radii_opt[i],\n                1 - centers_opt[i, 0] - radii_opt[i],\n                1 - centers_opt[i, 1] - radii_opt[i]\n            ])\n        return np.array(constraints)\n    \n    def constraint_overlap(x):\n        n_circles = len(radii)\n        centers_opt = x[:n_circles*2].reshape(n_circles, 2)\n        radii_opt = x[n_circles*2:]\n        \n        constraints = []\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt(np.sum((centers_opt[i] - centers_opt[j])**2))\n                constraints.append(dist - radii_opt[i] - radii_opt[j])\n        return np.array(constraints)\n    \n    x0 = np.concatenate([centers.ravel(), radii])\n    bounds = [(0, 1)] * (n * 2) + [(0, 0.5)] * n\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_boundary},\n        {'type': 'ineq', 'fun': constraint_overlap}\n    ]\n    \n    # Multiple optimization attempts\n    best_result = None\n    best_value = float('inf')\n    \n    for attempt in range(5):\n        try:\n            if attempt > 0:\n                x0_perturbed = x0 + np.random.randn(len(x0)) * 0.005\n                x0_perturbed[:n*2] = np.clip(x0_perturbed[:n*2], 0.01, 0.99)\n                x0_perturbed[n*2:] = np.clip(x0_perturbed[n*2:], 0, 0.4)\n            else:\n                x0_perturbed = x0\n            \n            result = minimize(\n                objective,\n                x0_perturbed,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 1000, 'ftol': 1e-10}\n            )\n            \n            if result.fun < best_value:\n                best_result = result\n                best_value = result.fun\n        except:\n            pass\n    \n    if best_result is not None:\n        centers = best_result.x[:n*2].reshape(n, 2)\n        radii = best_result.x[n*2:]\n    \n    radii = np.maximum(radii, 0)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nAchieved 2.6033. Refinements:\n\n1. Increase candidate sampling to 10000+ positions per circle\n2. Use importance sampling: focus candidates near optimal regions\n3. After greedy placement, apply multiple scipy refinement passes\n4. Add perturbation-and-refinement loop: perturb slightly, re-optimize\n5. Final pass: optimize radii only with positions fixed\n\nRequirements:\n- Denser candidate sampling\n- Multiple refinement passes\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def greedy_packing(seed):\n        np.random.seed(seed)\n        centers = []\n        radii = []\n        \n        for i in range(n):\n            best_pos = None\n            best_radius = 0\n            \n            # Massively increased candidate sampling\n            n_random = 8000\n            n_grid = 50\n            \n            # Random candidates with importance sampling\n            if len(centers) > 0:\n                # Focus 50% of random candidates near existing circles (gap filling)\n                n_focused = n_random // 2\n                n_uniform = n_random - n_focused\n                \n                uniform_candidates = np.random.rand(n_uniform, 2)\n                \n                # Generate candidates near existing circles\n                centers_array = np.array(centers)\n                radii_array = np.array(radii)\n                focused_candidates = []\n                \n                for j in range(min(10, len(centers))):\n                    # Sample around each circle\n                    n_per_circle = n_focused // min(10, len(centers))\n                    angles = np.random.rand(n_per_circle) * 2 * np.pi\n                    distances = radii_array[j] * (1.5 + np.random.rand(n_per_circle) * 1.5)\n                    \n                    gap_cands = centers_array[j] + distances[:, np.newaxis] * np.column_stack([np.cos(angles), np.sin(angles)])\n                    gap_cands = np.clip(gap_cands, 0, 1)\n                    focused_candidates.append(gap_cands)\n                \n                if focused_candidates:\n                    focused_candidates = np.vstack(focused_candidates)\n                    candidates = np.vstack([uniform_candidates, focused_candidates])\n                else:\n                    candidates = uniform_candidates\n            else:\n                candidates = np.random.rand(n_random, 2)\n            \n            # Dense grid candidates\n            x_grid = np.linspace(0.01, 0.99, n_grid)\n            y_grid = np.linspace(0.01, 0.99, n_grid)\n            xx, yy = np.meshgrid(x_grid, y_grid)\n            grid_candidates = np.column_stack([xx.ravel(), yy.ravel()])\n            candidates = np.vstack([candidates, grid_candidates])\n            \n            # Strategic candidates for early circles\n            if i < 10:\n                strategic = []\n                for x in [0.05, 0.15, 0.25, 0.35, 0.45, 0.55, 0.65, 0.75, 0.85, 0.95]:\n                    for y in [0.05, 0.15, 0.25, 0.35, 0.45, 0.55, 0.65, 0.75, 0.85, 0.95]:\n                        strategic.append([x, y])\n                candidates = np.vstack([candidates, np.array(strategic)])\n            \n            # Additional gap-filling candidates\n            if len(centers) >= 3:\n                centers_array = np.array(centers)\n                radii_array = np.array(radii)\n                \n                # Find potential gaps between circles\n                for j in range(min(8, len(centers))):\n                    for k in range(j+1, min(j+8, len(centers))):\n                        # Midpoint between circles\n                        midpoint = (centers_array[j] + centers_array[k]) / 2\n                        \n                        # Sample around midpoint\n                        for angle in np.linspace(0, 2*np.pi, 16):\n                            for dist in [0.02, 0.04, 0.06, 0.08]:\n                                cand = midpoint + dist * np.array([np.cos(angle), np.sin(angle)])\n                                cand = np.clip(cand, 0, 1)\n                                candidates = np.vstack([candidates, cand.reshape(1, 2)])\n            \n            for candidate in candidates:\n                x, y = candidate\n                \n                # Maximum radius from boundaries\n                max_r = min(x, y, 1 - x, 1 - y)\n                \n                if max_r <= 0:\n                    continue\n                \n                # Check constraints with existing circles\n                if len(centers) > 0:\n                    centers_array = np.array(centers)\n                    radii_array = np.array(radii)\n                    \n                    # Distance to existing circles\n                    distances = np.sqrt(np.sum((centers_array - candidate)**2, axis=1))\n                    # Maximum radius to avoid overlap\n                    max_r_circles = distances - radii_array\n                    max_r = min(max_r, np.min(max_r_circles))\n                \n                if max_r > best_radius:\n                    best_radius = max_r\n                    best_pos = candidate\n            \n            if best_radius > 0:\n                centers.append(best_pos)\n                radii.append(best_radius)\n        \n        return np.array(centers), np.array(radii)\n    \n    # Try more seeds\n    best_centers = None\n    best_radii = None\n    best_sum = 0\n    \n    seeds = [42, 123, 456, 789, 1337, 2024, 9999, 5555, 7777, 3141, 2718, 1618]\n    \n    for seed in seeds:\n        centers, radii = greedy_packing(seed)\n        current_sum = np.sum(radii)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    centers = best_centers\n    radii = best_radii\n    \n    # Enhanced local search with more iterations\n    def local_search(centers, radii, iterations=300):\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n        best_sum = np.sum(radii)\n        \n        for iter_num in range(iterations):\n            # Adaptive perturbation size\n            perturb_scale = 0.03 * (1 - iter_num / iterations) + 0.005\n            \n            # Pick a random circle\n            idx = np.random.randint(n)\n            \n            # Try more perturbations\n            for _ in range(30):\n                new_center = centers[idx] + np.random.randn(2) * perturb_scale\n                new_center = np.clip(new_center, 0, 1)\n                \n                # Calculate max radius at new position\n                max_r = min(new_center[0], new_center[1], 1 - new_center[0], 1 - new_center[1])\n                \n                # Check with other circles\n                for j in range(n):\n                    if j != idx:\n                        dist = np.sqrt(np.sum((centers[j] - new_center)**2))\n                        max_r = min(max_r, dist - radii[j])\n                \n                if max_r > 0:\n                    # Try this configuration\n                    test_centers = centers.copy()\n                    test_radii = radii.copy()\n                    test_centers[idx] = new_center\n                    test_radii[idx] = max_r\n                    \n                    test_sum = np.sum(test_radii)\n                    if test_sum > best_sum:\n                        best_sum = test_sum\n                        best_centers = test_centers.copy()\n                        best_radii = test_radii.copy()\n                        centers = best_centers.copy()\n                        radii = best_radii.copy()\n        \n        return best_centers, best_radii\n    \n    centers, radii = local_search(centers, radii, iterations=300)\n    \n    # Multiple scipy refinement passes\n    def scipy_refinement(centers, radii, num_passes=3):\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n        best_sum = np.sum(radii)\n        \n        for pass_num in range(num_passes):\n            def objective(x):\n                radii_opt = x[n*2:]\n                return -np.sum(radii_opt)\n            \n            def constraint_boundary(x):\n                centers_opt = x[:n*2].reshape(n, 2)\n                radii_opt = x[n*2:]\n                \n                constraints = []\n                for i in range(n):\n                    constraints.extend([\n                        centers_opt[i, 0] - radii_opt[i],\n                        centers_opt[i, 1] - radii_opt[i],\n                        1 - centers_opt[i, 0] - radii_opt[i],\n                        1 - centers_opt[i, 1] - radii_opt[i]\n                    ])\n                return np.array(constraints)\n            \n            def constraint_overlap(x):\n                centers_opt = x[:n*2].reshape(n, 2)\n                radii_opt = x[n*2:]\n                \n                constraints = []\n                for i in range(n):\n                    for j in range(i+1, n):\n                        dist = np.sqrt(np.sum((centers_opt[i] - centers_opt[j])**2))\n                        constraints.append(dist - radii_opt[i] - radii_opt[j])\n                return np.array(constraints)\n            \n            x0 = np.concatenate([centers.ravel(), radii])\n            bounds = [(0, 1)] * (n * 2) + [(0, 0.5)] * n\n            constraints = [\n                {'type': 'ineq', 'fun': constraint_boundary},\n                {'type': 'ineq', 'fun': constraint_overlap}\n            ]\n            \n            # Multiple attempts per pass\n            for attempt in range(3):\n                try:\n                    if attempt > 0:\n                        x0_perturbed = x0 + np.random.randn(len(x0)) * 0.003\n                        x0_perturbed[:n*2] = np.clip(x0_perturbed[:n*2], 0.01, 0.99)\n                        x0_perturbed[n*2:] = np.clip(x0_perturbed[n*2:], 0, 0.4)\n                    else:\n                        x0_perturbed = x0\n                    \n                    result = minimize(\n                        objective,\n                        x0_perturbed,\n                        method='SLSQP',\n                        bounds=bounds,\n                        constraints=constraints,\n                        options={'maxiter': 1500, 'ftol': 1e-12}\n                    )\n                    \n                    if result.success or True:  # Accept even if not fully converged\n                        test_centers = result.x[:n*2].reshape(n, 2)\n                        test_radii = result.x[n*2:]\n                        test_sum = np.sum(test_radii)\n                        \n                        if test_sum > best_sum:\n                            best_sum = test_sum\n                            best_centers = test_centers.copy()\n                            best_radii = test_radii.copy()\n                            centers = best_centers.copy()\n                            radii = best_radii.copy()\n                            x0 = result.x.copy()\n                except:\n                    pass\n        \n        return best_centers, best_radii\n    \n    centers, radii = scipy_refinement(centers, radii, num_passes=3)\n    \n    # Perturbation-and-refinement loop\n    for macro_iter in range(5):\n        # Small perturbation\n        perturb_centers = centers + np.random.randn(n, 2) * 0.008\n        perturb_centers = np.clip(perturb_centers, 0, 1)\n        \n        # Recompute radii\n        perturb_radii = np.zeros(n)\n        for i in range(n):\n            max_r = min(perturb_centers[i, 0], perturb_centers[i, 1], \n                       1 - perturb_centers[i, 0], 1 - perturb_centers[i, 1])\n            \n            for j in range(n):\n                if j != i:\n                    dist = np.sqrt(np.sum((perturb_centers[i] - perturb_centers[j])**2))\n                    max_r = min(max_r, dist - perturb_radii[j])\n            \n            perturb_radii[i] = max(0, max_r)\n        \n        if np.sum(perturb_radii) > np.sum(radii):\n            centers = perturb_centers\n            radii = perturb_radii\n        \n        # Quick refinement\n        centers, radii = scipy_refinement(centers, radii, num_passes=1)\n    \n    # Final pass: optimize radii only with positions fixed\n    def optimize_radii_only(centers, radii):\n        def objective_radii(r):\n            return -np.sum(r)\n        \n        def constraint_boundary_radii(r):\n            constraints = []\n            for i in range(n):\n                constraints.extend([\n                    centers[i, 0] - r[i],\n                    centers[i, 1] - r[i],\n                    1 - centers[i, 0] - r[i],\n                    1 - centers[i, 1] - r[i]\n                ])\n            return np.array(constraints)\n        \n        def constraint_overlap_radii(r):\n            constraints = []\n            for i in range(n):\n                for j in range(i+1, n):\n                    dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                    constraints.append(dist - r[i] - r[j])\n            return np.array(constraints)\n        \n        bounds = [(0, 0.5)] * n\n        constraints = [\n            {'type': 'ineq', 'fun': constraint_boundary_radii},\n            {'type': 'ineq', 'fun': constraint_overlap_radii}\n        ]\n        \n        try:\n            result = minimize(\n                objective_radii,\n                radii,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 2000, 'ftol': 1e-14}\n            )\n            \n            if result.success or np.sum(result.x) > np.sum(radii):\n                return result.x\n        except:\n            pass\n        \n        return radii\n    \n    radii = optimize_radii_only(centers, radii)\n    \n    radii = np.maximum(radii, 0)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T18:53:36.127977",
  "cost_data": null
}