{
  "trial_id": "trial_3_9",
  "generation": 3,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using\n    trust-region optimization with exact Hessian computation.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def pack_variables(centers, radii):\n        \"\"\"Pack centers and radii into a single vector.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def unpack_variables(x):\n        \"\"\"Unpack vector into centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Negative sum of radii (we minimize).\"\"\"\n        _, radii = unpack_variables(x)\n        return -np.sum(radii)\n    \n    def gradient(x):\n        \"\"\"Gradient of objective.\"\"\"\n        grad = np.zeros_like(x)\n        grad[2*n:] = -1.0  # derivative w.r.t. radii\n        return grad\n    \n    def hessian(x):\n        \"\"\"Exact Hessian matrix (all zeros for linear objective).\"\"\"\n        return np.zeros((len(x), len(x)))\n    \n    def constraints_and_jacobian(x):\n        \"\"\"Compute all constraints and their Jacobian.\"\"\"\n        centers, radii = unpack_variables(x)\n        \n        constraints = []\n        jac_rows = []\n        \n        # Boundary constraints: center \u00b1 radius in [0,1]\n        for i in range(n):\n            # x_i - r_i >= 0\n            constraints.append(centers[i, 0] - radii[i])\n            jac = np.zeros(len(x))\n            jac[2*i] = 1.0\n            jac[2*n + i] = -1.0\n            jac_rows.append(jac)\n            \n            # x_i + r_i <= 1\n            constraints.append(1.0 - centers[i, 0] - radii[i])\n            jac = np.zeros(len(x))\n            jac[2*i] = -1.0\n            jac[2*n + i] = -1.0\n            jac_rows.append(jac)\n            \n            # y_i - r_i >= 0\n            constraints.append(centers[i, 1] - radii[i])\n            jac = np.zeros(len(x))\n            jac[2*i + 1] = 1.0\n            jac[2*n + i] = -1.0\n            jac_rows.append(jac)\n            \n            # y_i + r_i <= 1\n            constraints.append(1.0 - centers[i, 1] - radii[i])\n            jac = np.zeros(len(x))\n            jac[2*i + 1] = -1.0\n            jac[2*n + i] = -1.0\n            jac_rows.append(jac)\n        \n        # Non-overlap constraints: ||c_i - c_j|| - r_i - r_j >= 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                dist = np.sqrt(dx**2 + dy**2 + 1e-10)\n                \n                constraints.append(dist - radii[i] - radii[j])\n                \n                jac = np.zeros(len(x))\n                jac[2*i] = dx / dist\n                jac[2*i + 1] = dy / dist\n                jac[2*j] = -dx / dist\n                jac[2*j + 1] = -dy / dist\n                jac[2*n + i] = -1.0\n                jac[2*n + j] = -1.0\n                jac_rows.append(jac)\n        \n        # Radii non-negative: r_i >= 0\n        for i in range(n):\n            constraints.append(radii[i])\n            jac = np.zeros(len(x))\n            jac[2*n + i] = 1.0\n            jac_rows.append(jac)\n        \n        return np.array(constraints), np.array(jac_rows)\n    \n    def constraint_hessian(x, v):\n        \"\"\"Hessian of constraints weighted by Lagrange multipliers v.\"\"\"\n        centers, radii = unpack_variables(x)\n        H = np.zeros((len(x), len(x)))\n        \n        # Only non-overlap constraints have non-zero Hessian\n        # Boundary and radius constraints are linear\n        constraint_idx = 4 * n  # Skip boundary constraints\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                dist = np.sqrt(dx**2 + dy**2 + 1e-10)\n                dist3 = dist ** 3\n                \n                # Hessian of distance function\n                H_dist = np.zeros((4, 4))\n                H_dist[0, 0] = dy**2 / dist3  # d\u00b2/dx_i\u00b2\n                H_dist[1, 1] = dx**2 / dist3  # d\u00b2/dy_i\u00b2\n                H_dist[0, 1] = H_dist[1, 0] = -dx*dy / dist3  # d\u00b2/dx_i dy_i\n                \n                H_dist[2, 2] = dy**2 / dist3  # d\u00b2/dx_j\u00b2\n                H_dist[3, 3] = dx**2 / dist3  # d\u00b2/dy_j\u00b2\n                H_dist[2, 3] = H_dist[3, 2] = -dx*dy / dist3  # d\u00b2/dx_j dy_j\n                \n                H_dist[0, 2] = H_dist[2, 0] = -dy**2 / dist3  # d\u00b2/dx_i dx_j\n                H_dist[1, 3] = H_dist[3, 1] = -dx**2 / dist3  # d\u00b2/dy_i dy_j\n                H_dist[0, 3] = H_dist[3, 0] = dx*dy / dist3   # d\u00b2/dx_i dy_j\n                H_dist[1, 2] = H_dist[2, 1] = dx*dy / dist3   # d\u00b2/dy_i dx_j\n                \n                # Add weighted contribution\n                indices = [2*i, 2*i+1, 2*j, 2*j+1]\n                for a in range(4):\n                    for b in range(4):\n                        H[indices[a], indices[b]] += v[constraint_idx] * H_dist[a, b]\n                \n                constraint_idx += 1\n        \n        return H\n    \n    def initialize_grid():\n        \"\"\"Initialize with grid layout.\"\"\"\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            centers.append([x, y])\n        centers = np.array(centers)\n        \n        # Initial radii - conservative estimate\n        radii = np.full(n, 0.08)\n        \n        return pack_variables(centers, radii)\n    \n    def optimize_with_restart(x0, method='trust-constr'):\n        \"\"\"Run optimization with trust-region method.\"\"\"\n        \n        # Define constraints in scipy format\n        def constraint_func(x):\n            c, _ = constraints_and_jacobian(x)\n            return c\n        \n        def constraint_jac(x):\n            _, jac = constraints_and_jacobian(x)\n            return jac\n        \n        constraint = {\n            'type': 'ineq',\n            'fun': constraint_func,\n            'jac': constraint_jac\n        }\n        \n        result = minimize(\n            objective,\n            x0,\n            method=method,\n            jac=gradient,\n            hess=hessian,\n            constraints=constraint,\n            options={\n                'maxiter': 2000,\n                'verbose': 0,\n                'gtol': 1e-8,\n                'xtol': 1e-10,\n                'barrier_tol': 1e-10\n            }\n        )\n        \n        return result\n    \n    # Try multiple initializations\n    best_result = None\n    best_value = float('inf')\n    \n    # Strategy 1: Grid initialization\n    x0 = initialize_grid()\n    result = optimize_with_restart(x0)\n    if result.fun < best_value:\n        best_value = result.fun\n        best_result = result\n    \n    # Strategy 2: Random perturbations of best solution\n    for trial in range(5):\n        if best_result is not None:\n            x0 = best_result.x + np.random.randn(len(best_result.x)) * 0.01\n            x0[2*n:] = np.maximum(x0[2*n:], 0.01)  # Keep radii positive\n        else:\n            x0 = initialize_grid()\n        \n        result = optimize_with_restart(x0)\n        if result.fun < best_value:\n            best_value = result.fun\n            best_result = result\n    \n    # Extract final solution\n    centers, radii = unpack_variables(best_result.x)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.579380560298694,
    "target_ratio": 0.9788920532442863,
    "combined_score": 0.9788920532442863,
    "eval_time": 3.9943439960479736,
    "error": null
  },
  "prompt": "Create trust-region optimizer with exact Hessian computation.\n\nStrategy:\n1. Formulate as smooth optimization problem\n2. Compute exact Hessian matrix (second derivatives)\n3. Use scipy trust-region method with Hessian\n4. This should converge faster and more accurately\n5. Run with very tight tolerances\n6. Multiple restarts from perturbed states\n\nRequirements:\n- Exact Hessian computation\n- Trust-region method\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using\n    trust-region optimization with exact Hessian computation.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def pack_variables(centers, radii):\n        \"\"\"Pack centers and radii into a single vector.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def unpack_variables(x):\n        \"\"\"Unpack vector into centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Negative sum of radii (we minimize).\"\"\"\n        _, radii = unpack_variables(x)\n        return -np.sum(radii)\n    \n    def gradient(x):\n        \"\"\"Gradient of objective.\"\"\"\n        grad = np.zeros_like(x)\n        grad[2*n:] = -1.0  # derivative w.r.t. radii\n        return grad\n    \n    def hessian(x):\n        \"\"\"Exact Hessian matrix (all zeros for linear objective).\"\"\"\n        return np.zeros((len(x), len(x)))\n    \n    def constraints_and_jacobian(x):\n        \"\"\"Compute all constraints and their Jacobian.\"\"\"\n        centers, radii = unpack_variables(x)\n        \n        constraints = []\n        jac_rows = []\n        \n        # Boundary constraints: center \u00b1 radius in [0,1]\n        for i in range(n):\n            # x_i - r_i >= 0\n            constraints.append(centers[i, 0] - radii[i])\n            jac = np.zeros(len(x))\n            jac[2*i] = 1.0\n            jac[2*n + i] = -1.0\n            jac_rows.append(jac)\n            \n            # x_i + r_i <= 1\n            constraints.append(1.0 - centers[i, 0] - radii[i])\n            jac = np.zeros(len(x))\n            jac[2*i] = -1.0\n            jac[2*n + i] = -1.0\n            jac_rows.append(jac)\n            \n            # y_i - r_i >= 0\n            constraints.append(centers[i, 1] - radii[i])\n            jac = np.zeros(len(x))\n            jac[2*i + 1] = 1.0\n            jac[2*n + i] = -1.0\n            jac_rows.append(jac)\n            \n            # y_i + r_i <= 1\n            constraints.append(1.0 - centers[i, 1] - radii[i])\n            jac = np.zeros(len(x))\n            jac[2*i + 1] = -1.0\n            jac[2*n + i] = -1.0\n            jac_rows.append(jac)\n        \n        # Non-overlap constraints: ||c_i - c_j|| - r_i - r_j >= 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                dist = np.sqrt(dx**2 + dy**2 + 1e-10)\n                \n                constraints.append(dist - radii[i] - radii[j])\n                \n                jac = np.zeros(len(x))\n                jac[2*i] = dx / dist\n                jac[2*i + 1] = dy / dist\n                jac[2*j] = -dx / dist\n                jac[2*j + 1] = -dy / dist\n                jac[2*n + i] = -1.0\n                jac[2*n + j] = -1.0\n                jac_rows.append(jac)\n        \n        # Radii non-negative: r_i >= 0\n        for i in range(n):\n            constraints.append(radii[i])\n            jac = np.zeros(len(x))\n            jac[2*n + i] = 1.0\n            jac_rows.append(jac)\n        \n        return np.array(constraints), np.array(jac_rows)\n    \n    def constraint_hessian(x, v):\n        \"\"\"Hessian of constraints weighted by Lagrange multipliers v.\"\"\"\n        centers, radii = unpack_variables(x)\n        H = np.zeros((len(x), len(x)))\n        \n        # Only non-overlap constraints have non-zero Hessian\n        # Boundary and radius constraints are linear\n        constraint_idx = 4 * n  # Skip boundary constraints\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                dist = np.sqrt(dx**2 + dy**2 + 1e-10)\n                dist3 = dist ** 3\n                \n                # Hessian of distance function\n                H_dist = np.zeros((4, 4))\n                H_dist[0, 0] = dy**2 / dist3  # d\u00b2/dx_i\u00b2\n                H_dist[1, 1] = dx**2 / dist3  # d\u00b2/dy_i\u00b2\n                H_dist[0, 1] = H_dist[1, 0] = -dx*dy / dist3  # d\u00b2/dx_i dy_i\n                \n                H_dist[2, 2] = dy**2 / dist3  # d\u00b2/dx_j\u00b2\n                H_dist[3, 3] = dx**2 / dist3  # d\u00b2/dy_j\u00b2\n                H_dist[2, 3] = H_dist[3, 2] = -dx*dy / dist3  # d\u00b2/dx_j dy_j\n                \n                H_dist[0, 2] = H_dist[2, 0] = -dy**2 / dist3  # d\u00b2/dx_i dx_j\n                H_dist[1, 3] = H_dist[3, 1] = -dx**2 / dist3  # d\u00b2/dy_i dy_j\n                H_dist[0, 3] = H_dist[3, 0] = dx*dy / dist3   # d\u00b2/dx_i dy_j\n                H_dist[1, 2] = H_dist[2, 1] = dx*dy / dist3   # d\u00b2/dy_i dx_j\n                \n                # Add weighted contribution\n                indices = [2*i, 2*i+1, 2*j, 2*j+1]\n                for a in range(4):\n                    for b in range(4):\n                        H[indices[a], indices[b]] += v[constraint_idx] * H_dist[a, b]\n                \n                constraint_idx += 1\n        \n        return H\n    \n    def initialize_grid():\n        \"\"\"Initialize with grid layout.\"\"\"\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            centers.append([x, y])\n        centers = np.array(centers)\n        \n        # Initial radii - conservative estimate\n        radii = np.full(n, 0.08)\n        \n        return pack_variables(centers, radii)\n    \n    def optimize_with_restart(x0, method='trust-constr'):\n        \"\"\"Run optimization with trust-region method.\"\"\"\n        \n        # Define constraints in scipy format\n        def constraint_func(x):\n            c, _ = constraints_and_jacobian(x)\n            return c\n        \n        def constraint_jac(x):\n            _, jac = constraints_and_jacobian(x)\n            return jac\n        \n        constraint = {\n            'type': 'ineq',\n            'fun': constraint_func,\n            'jac': constraint_jac\n        }\n        \n        result = minimize(\n            objective,\n            x0,\n            method=method,\n            jac=gradient,\n            hess=hessian,\n            constraints=constraint,\n            options={\n                'maxiter': 2000,\n                'verbose': 0,\n                'gtol': 1e-8,\n                'xtol': 1e-10,\n                'barrier_tol': 1e-10\n            }\n        )\n        \n        return result\n    \n    # Try multiple initializations\n    best_result = None\n    best_value = float('inf')\n    \n    # Strategy 1: Grid initialization\n    x0 = initialize_grid()\n    result = optimize_with_restart(x0)\n    if result.fun < best_value:\n        best_value = result.fun\n        best_result = result\n    \n    # Strategy 2: Random perturbations of best solution\n    for trial in range(5):\n        if best_result is not None:\n            x0 = best_result.x + np.random.randn(len(best_result.x)) * 0.01\n            x0[2*n:] = np.maximum(x0[2*n:], 0.01)  # Keep radii positive\n        else:\n            x0 = initialize_grid()\n        \n        result = optimize_with_restart(x0)\n        if result.fun < best_value:\n            best_value = result.fun\n            best_result = result\n    \n    # Extract final solution\n    centers, radii = unpack_variables(best_result.x)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T18:14:16.152259",
  "cost_data": null
}