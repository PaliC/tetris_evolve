{
  "trial_id": "trial_3_8",
  "generation": 3,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Initialize with hexagonal-like pattern\n    centers, radii = initialize_hexagonal(n)\n    \n    # Coordinate descent optimization\n    max_outer_iterations = 20\n    max_inner_iterations = 3\n    \n    for outer_iter in range(max_outer_iterations):\n        improved = False\n        \n        # Multiple passes through all circles\n        for inner_iter in range(max_inner_iterations):\n            for i in range(n):\n                # Optimize position of circle i\n                new_center = optimize_position(i, centers, radii)\n                \n                # Try the new position\n                old_center = centers[i].copy()\n                centers[i] = new_center\n                \n                # Maximize radius of circle i\n                new_radius = maximize_radius(i, centers, radii)\n                \n                if new_radius > radii[i]:\n                    radii[i] = new_radius\n                    improved = True\n                else:\n                    # Revert if no improvement\n                    centers[i] = old_center\n        \n        # Global optimization pass every few iterations\n        if outer_iter % 3 == 2:\n            centers, radii = global_optimization(centers, radii)\n        \n        if not improved:\n            break\n    \n    # Final polish with aggressive optimization\n    centers, radii = final_polish(centers, radii)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef initialize_hexagonal(n):\n    \"\"\"Initialize circles in hexagonal pattern.\"\"\"\n    # Estimate grid size\n    cols = int(np.ceil(np.sqrt(n * 2 / np.sqrt(3))))\n    rows = int(np.ceil(n / cols))\n    \n    centers = []\n    dx = 1.0 / (cols + 1)\n    dy = 1.0 / (rows + 1)\n    \n    for row in range(rows):\n        for col in range(cols):\n            if len(centers) >= n:\n                break\n            x = (col + 1) * dx\n            y = (row + 1) * dy\n            # Hexagonal offset\n            if row % 2 == 1:\n                x += dx / 2\n            centers.append([x, y])\n    \n    centers = np.array(centers[:n])\n    \n    # Initialize radii conservatively\n    radii = np.full(n, 0.05)\n    \n    # Maximize each radius\n    for i in range(n):\n        radii[i] = maximize_radius(i, centers, radii)\n    \n    return centers, radii\n\ndef optimize_position(i, centers, radii):\n    \"\"\"Optimize position of circle i while keeping others fixed.\"\"\"\n    n = len(centers)\n    \n    def objective(pos):\n        # Negative radius (we want to maximize)\n        temp_centers = centers.copy()\n        temp_centers[i] = pos\n        temp_radii = radii.copy()\n        \n        # Calculate maximum possible radius at this position\n        max_r = get_max_radius(i, temp_centers, temp_radii)\n        return -max_r\n    \n    # Bounds for position\n    r = radii[i]\n    bounds = [(r, 1-r), (r, 1-r)]\n    \n    # Try multiple starting points\n    best_pos = centers[i].copy()\n    best_val = objective(best_pos)\n    \n    # Current position\n    result = minimize(objective, centers[i], method='L-BFGS-B', bounds=bounds)\n    if result.fun < best_val:\n        best_val = result.fun\n        best_pos = result.x\n    \n    # Try moving towards center of square\n    center_square = np.array([0.5, 0.5])\n    direction = center_square - centers[i]\n    if np.linalg.norm(direction) > 1e-6:\n        direction = direction / np.linalg.norm(direction)\n        for step in [0.02, 0.05, 0.1]:\n            test_pos = centers[i] + direction * step\n            test_pos = np.clip(test_pos, r, 1-r)\n            val = objective(test_pos)\n            if val < best_val:\n                best_val = val\n                best_pos = test_pos\n    \n    # Try moving away from nearest neighbor\n    other_idx = [j for j in range(n) if j != i]\n    if other_idx:\n        dists = np.linalg.norm(centers[other_idx] - centers[i], axis=1)\n        nearest = other_idx[np.argmin(dists)]\n        direction = centers[i] - centers[nearest]\n        if np.linalg.norm(direction) > 1e-6:\n            direction = direction / np.linalg.norm(direction)\n            for step in [0.02, 0.05, 0.1]:\n                test_pos = centers[i] + direction * step\n                test_pos = np.clip(test_pos, r, 1-r)\n                val = objective(test_pos)\n                if val < best_val:\n                    best_val = val\n                    best_pos = test_pos\n    \n    return best_pos\n\ndef maximize_radius(i, centers, radii):\n    \"\"\"Maximize radius of circle i using binary search.\"\"\"\n    n = len(centers)\n    \n    # Maximum possible radius from boundary constraints\n    max_r_boundary = min(centers[i][0], centers[i][1], \n                         1 - centers[i][0], 1 - centers[i][1])\n    \n    # Maximum possible radius from other circles\n    other_idx = [j for j in range(n) if j != i]\n    if other_idx:\n        dists = np.linalg.norm(centers[other_idx] - centers[i], axis=1)\n        other_radii = radii[other_idx]\n        max_r_circles = np.min(dists - other_radii)\n    else:\n        max_r_circles = max_r_boundary\n    \n    max_r = min(max_r_boundary, max_r_circles)\n    \n    # Binary search for maximum valid radius\n    low, high = 0.0, max(max_r, 0.0)\n    \n    for _ in range(30):  # Binary search iterations\n        mid = (low + high) / 2\n        temp_radii = radii.copy()\n        temp_radii[i] = mid\n        \n        if is_valid_configuration(centers, temp_radii):\n            low = mid\n        else:\n            high = mid\n    \n    return low\n\ndef get_max_radius(i, centers, radii):\n    \"\"\"Get maximum possible radius for circle i at current position.\"\"\"\n    n = len(centers)\n    \n    # Boundary constraints\n    max_r = min(centers[i][0], centers[i][1], \n                1 - centers[i][0], 1 - centers[i][1])\n    \n    # Circle constraints\n    for j in range(n):\n        if j != i:\n            dist = np.linalg.norm(centers[i] - centers[j])\n            max_r = min(max_r, dist - radii[j])\n    \n    return max(max_r, 0.0)\n\ndef is_valid_configuration(centers, radii):\n    \"\"\"Check if configuration satisfies all constraints.\"\"\"\n    n = len(centers)\n    \n    # Check boundary constraints\n    for i in range(n):\n        if (centers[i][0] - radii[i] < -1e-9 or \n            centers[i][0] + radii[i] > 1 + 1e-9 or\n            centers[i][1] - radii[i] < -1e-9 or \n            centers[i][1] + radii[i] > 1 + 1e-9):\n            return False\n    \n    # Check overlap constraints\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-9:\n                return False\n    \n    return True\n\ndef global_optimization(centers, radii):\n    \"\"\"Global optimization pass.\"\"\"\n    n = len(centers)\n    \n    def objective(x):\n        c = x[:2*n].reshape(n, 2)\n        r = x[2*n:]\n        \n        if not is_valid_configuration(c, r):\n            return 1e10\n        \n        return -np.sum(r)\n    \n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    # Bounds\n    bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n    \n    result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds)\n    \n    if result.success:\n        new_centers = result.x[:2*n].reshape(n, 2)\n        new_radii = result.x[2*n:]\n        \n        if is_valid_configuration(new_centers, new_radii):\n            return new_centers, new_radii\n    \n    return centers, radii\n\ndef final_polish(centers, radii):\n    \"\"\"Final aggressive optimization.\"\"\"\n    n = len(centers)\n    \n    # Multiple passes of coordinate descent\n    for _ in range(5):\n        for i in range(n):\n            # Optimize position\n            centers[i] = optimize_position(i, centers, radii)\n            # Maximize radius\n            radii[i] = maximize_radius(i, centers, radii)\n    \n    return centers, radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.2522230233127574,
    "target_ratio": 0.8547335951851073,
    "combined_score": 0.8547335951851073,
    "eval_time": 7.625949859619141,
    "error": null
  },
  "prompt": "Create coordinate descent optimizer with aggressive radius maximization.\n\nStrategy:\n1. Start with good initialization (hexagonal)\n2. Repeat until convergence:\n   - For each circle i:\n     a. Fix all other circles\n     b. Optimize position of circle i (2D optimization)\n     c. Maximize radius of circle i (1D binary search)\n   - Accept if improvement\n3. After full pass, apply global scipy optimization\n4. Repeat coordinate descent\n5. Final polish\n\nRequirements:\n- Coordinate descent structure\n- Aggressive radius maximization\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Initialize with hexagonal-like pattern\n    centers, radii = initialize_hexagonal(n)\n    \n    # Coordinate descent optimization\n    max_outer_iterations = 20\n    max_inner_iterations = 3\n    \n    for outer_iter in range(max_outer_iterations):\n        improved = False\n        \n        # Multiple passes through all circles\n        for inner_iter in range(max_inner_iterations):\n            for i in range(n):\n                # Optimize position of circle i\n                new_center = optimize_position(i, centers, radii)\n                \n                # Try the new position\n                old_center = centers[i].copy()\n                centers[i] = new_center\n                \n                # Maximize radius of circle i\n                new_radius = maximize_radius(i, centers, radii)\n                \n                if new_radius > radii[i]:\n                    radii[i] = new_radius\n                    improved = True\n                else:\n                    # Revert if no improvement\n                    centers[i] = old_center\n        \n        # Global optimization pass every few iterations\n        if outer_iter % 3 == 2:\n            centers, radii = global_optimization(centers, radii)\n        \n        if not improved:\n            break\n    \n    # Final polish with aggressive optimization\n    centers, radii = final_polish(centers, radii)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef initialize_hexagonal(n):\n    \"\"\"Initialize circles in hexagonal pattern.\"\"\"\n    # Estimate grid size\n    cols = int(np.ceil(np.sqrt(n * 2 / np.sqrt(3))))\n    rows = int(np.ceil(n / cols))\n    \n    centers = []\n    dx = 1.0 / (cols + 1)\n    dy = 1.0 / (rows + 1)\n    \n    for row in range(rows):\n        for col in range(cols):\n            if len(centers) >= n:\n                break\n            x = (col + 1) * dx\n            y = (row + 1) * dy\n            # Hexagonal offset\n            if row % 2 == 1:\n                x += dx / 2\n            centers.append([x, y])\n    \n    centers = np.array(centers[:n])\n    \n    # Initialize radii conservatively\n    radii = np.full(n, 0.05)\n    \n    # Maximize each radius\n    for i in range(n):\n        radii[i] = maximize_radius(i, centers, radii)\n    \n    return centers, radii\n\ndef optimize_position(i, centers, radii):\n    \"\"\"Optimize position of circle i while keeping others fixed.\"\"\"\n    n = len(centers)\n    \n    def objective(pos):\n        # Negative radius (we want to maximize)\n        temp_centers = centers.copy()\n        temp_centers[i] = pos\n        temp_radii = radii.copy()\n        \n        # Calculate maximum possible radius at this position\n        max_r = get_max_radius(i, temp_centers, temp_radii)\n        return -max_r\n    \n    # Bounds for position\n    r = radii[i]\n    bounds = [(r, 1-r), (r, 1-r)]\n    \n    # Try multiple starting points\n    best_pos = centers[i].copy()\n    best_val = objective(best_pos)\n    \n    # Current position\n    result = minimize(objective, centers[i], method='L-BFGS-B', bounds=bounds)\n    if result.fun < best_val:\n        best_val = result.fun\n        best_pos = result.x\n    \n    # Try moving towards center of square\n    center_square = np.array([0.5, 0.5])\n    direction = center_square - centers[i]\n    if np.linalg.norm(direction) > 1e-6:\n        direction = direction / np.linalg.norm(direction)\n        for step in [0.02, 0.05, 0.1]:\n            test_pos = centers[i] + direction * step\n            test_pos = np.clip(test_pos, r, 1-r)\n            val = objective(test_pos)\n            if val < best_val:\n                best_val = val\n                best_pos = test_pos\n    \n    # Try moving away from nearest neighbor\n    other_idx = [j for j in range(n) if j != i]\n    if other_idx:\n        dists = np.linalg.norm(centers[other_idx] - centers[i], axis=1)\n        nearest = other_idx[np.argmin(dists)]\n        direction = centers[i] - centers[nearest]\n        if np.linalg.norm(direction) > 1e-6:\n            direction = direction / np.linalg.norm(direction)\n            for step in [0.02, 0.05, 0.1]:\n                test_pos = centers[i] + direction * step\n                test_pos = np.clip(test_pos, r, 1-r)\n                val = objective(test_pos)\n                if val < best_val:\n                    best_val = val\n                    best_pos = test_pos\n    \n    return best_pos\n\ndef maximize_radius(i, centers, radii):\n    \"\"\"Maximize radius of circle i using binary search.\"\"\"\n    n = len(centers)\n    \n    # Maximum possible radius from boundary constraints\n    max_r_boundary = min(centers[i][0], centers[i][1], \n                         1 - centers[i][0], 1 - centers[i][1])\n    \n    # Maximum possible radius from other circles\n    other_idx = [j for j in range(n) if j != i]\n    if other_idx:\n        dists = np.linalg.norm(centers[other_idx] - centers[i], axis=1)\n        other_radii = radii[other_idx]\n        max_r_circles = np.min(dists - other_radii)\n    else:\n        max_r_circles = max_r_boundary\n    \n    max_r = min(max_r_boundary, max_r_circles)\n    \n    # Binary search for maximum valid radius\n    low, high = 0.0, max(max_r, 0.0)\n    \n    for _ in range(30):  # Binary search iterations\n        mid = (low + high) / 2\n        temp_radii = radii.copy()\n        temp_radii[i] = mid\n        \n        if is_valid_configuration(centers, temp_radii):\n            low = mid\n        else:\n            high = mid\n    \n    return low\n\ndef get_max_radius(i, centers, radii):\n    \"\"\"Get maximum possible radius for circle i at current position.\"\"\"\n    n = len(centers)\n    \n    # Boundary constraints\n    max_r = min(centers[i][0], centers[i][1], \n                1 - centers[i][0], 1 - centers[i][1])\n    \n    # Circle constraints\n    for j in range(n):\n        if j != i:\n            dist = np.linalg.norm(centers[i] - centers[j])\n            max_r = min(max_r, dist - radii[j])\n    \n    return max(max_r, 0.0)\n\ndef is_valid_configuration(centers, radii):\n    \"\"\"Check if configuration satisfies all constraints.\"\"\"\n    n = len(centers)\n    \n    # Check boundary constraints\n    for i in range(n):\n        if (centers[i][0] - radii[i] < -1e-9 or \n            centers[i][0] + radii[i] > 1 + 1e-9 or\n            centers[i][1] - radii[i] < -1e-9 or \n            centers[i][1] + radii[i] > 1 + 1e-9):\n            return False\n    \n    # Check overlap constraints\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-9:\n                return False\n    \n    return True\n\ndef global_optimization(centers, radii):\n    \"\"\"Global optimization pass.\"\"\"\n    n = len(centers)\n    \n    def objective(x):\n        c = x[:2*n].reshape(n, 2)\n        r = x[2*n:]\n        \n        if not is_valid_configuration(c, r):\n            return 1e10\n        \n        return -np.sum(r)\n    \n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    # Bounds\n    bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n    \n    result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds)\n    \n    if result.success:\n        new_centers = result.x[:2*n].reshape(n, 2)\n        new_radii = result.x[2*n:]\n        \n        if is_valid_configuration(new_centers, new_radii):\n            return new_centers, new_radii\n    \n    return centers, radii\n\ndef final_polish(centers, radii):\n    \"\"\"Final aggressive optimization.\"\"\"\n    n = len(centers)\n    \n    # Multiple passes of coordinate descent\n    for _ in range(5):\n        for i in range(n):\n            # Optimize position\n            centers[i] = optimize_position(i, centers, radii)\n            # Maximize radius\n            radii[i] = maximize_radius(i, centers, radii)\n    \n    return centers, radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T18:14:19.044371",
  "cost_data": null
}