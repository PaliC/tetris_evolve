{
  "trial_id": "trial_3_12",
  "generation": 3,
  "parent_id": "trial_2_8",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # ============= METHOD 1: SCIPY OPTIMIZER WITH HEXAGONAL INIT =============\n    def method1_hexagonal_optimizer(seed):\n        np.random.seed(seed)\n        \n        def initialize_hexagonal():\n            rows = 6\n            cols = 5\n            hex_height = np.sqrt(3) / 2\n            estimated_radius = 0.5 / (cols + 0.5)\n            \n            centers = []\n            for row in range(rows):\n                for col in range(cols):\n                    x_offset = 0.5 * estimated_radius if row % 2 == 1 else 0\n                    x = estimated_radius + col * 2 * estimated_radius + x_offset\n                    y = estimated_radius + row * hex_height * 2 * estimated_radius\n                    centers.append([x, y])\n            \n            centers = np.array(centers)\n            margin = 0.02\n            centers_min = centers.min(axis=0)\n            centers_max = centers.max(axis=0)\n            centers = (centers - centers_min) / (centers_max - centers_min)\n            centers = centers * (1 - 2 * margin) + margin\n            \n            if len(centers) > n:\n                indices = []\n                remaining = list(range(len(centers)))\n                dists_to_center = np.linalg.norm(centers - np.array([0.5, 0.5]), axis=1)\n                first_idx = np.argmin(dists_to_center)\n                indices.append(first_idx)\n                remaining.remove(first_idx)\n                \n                while len(indices) < n:\n                    max_min_dist = -1\n                    best_idx = -1\n                    for idx in remaining:\n                        min_dist = np.min(np.linalg.norm(centers[indices] - centers[idx], axis=1))\n                        if min_dist > max_min_dist:\n                            max_min_dist = min_dist\n                            best_idx = idx\n                    indices.append(best_idx)\n                    remaining.remove(best_idx)\n                \n                centers = centers[indices]\n            \n            distances = pdist(centers)\n            min_dist = np.min(distances) if len(distances) > 0 else 0.1\n            radii = np.full(n, min_dist / 2.5)\n            \n            for i in range(n):\n                max_r = min(centers[i, 0], centers[i, 1], \n                           1 - centers[i, 0], 1 - centers[i, 1])\n                radii[i] = min(radii[i], max_r * 0.95)\n            \n            return centers, radii\n        \n        def pack_to_vector(centers, radii):\n            return np.concatenate([centers.flatten(), radii])\n        \n        def vector_to_pack(x):\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            return centers, radii\n        \n        def objective(x):\n            _, radii = vector_to_pack(x)\n            return -np.sum(radii)\n        \n        def constraint_no_overlap(x):\n            centers, radii = vector_to_pack(x)\n            dists = squareform(pdist(centers))\n            np.fill_diagonal(dists, np.inf)\n            constraints = []\n            for i in range(n):\n                for j in range(i+1, n):\n                    constraints.append(dists[i, j] - radii[i] - radii[j])\n            return np.array(constraints)\n        \n        def constraint_inside_square(x):\n            centers, radii = vector_to_pack(x)\n            constraints = []\n            for i in range(n):\n                constraints.append(centers[i, 0] - radii[i])\n                constraints.append(1 - centers[i, 0] - radii[i])\n                constraints.append(centers[i, 1] - radii[i])\n                constraints.append(1 - centers[i, 1] - radii[i])\n            return np.array(constraints)\n        \n        centers_init, radii_init = initialize_hexagonal()\n        \n        if seed > 0:\n            centers_init += np.random.normal(0, 0.02, centers_init.shape)\n            centers_init = np.clip(centers_init, 0.05, 0.95)\n            radii_init *= (1 + np.random.normal(0, 0.05, radii_init.shape))\n            radii_init = np.clip(radii_init, 0.01, 0.1)\n        \n        x0 = pack_to_vector(centers_init, radii_init)\n        \n        bounds = [(0.0, 1.0)] * (2*n) + [(0.001, 0.5)] * n\n        \n        nlc_overlap = NonlinearConstraint(constraint_no_overlap, 0, np.inf)\n        nlc_inside = NonlinearConstraint(constraint_inside_square, 0, np.inf)\n        \n        result = minimize(\n            objective, x0, method='trust-constr',\n            bounds=bounds, constraints=[nlc_overlap, nlc_inside],\n            options={'maxiter': 2000, 'verbose': 0, 'gtol': 1e-6, 'xtol': 1e-8}\n        )\n        \n        centers_opt, radii_opt = vector_to_pack(result.x)\n        return centers_opt, radii_opt, np.sum(radii_opt)\n    \n    # ============= METHOD 2: GREEDY SEQUENTIAL PLACEMENT =============\n    def method2_greedy_placement(seed):\n        np.random.seed(seed)\n        centers = []\n        radii = []\n        \n        for i in range(n):\n            best_pos = None\n            best_radius = 0\n            \n            n_random = 3000\n            n_grid = 30\n            \n            candidates = np.random.rand(n_random, 2)\n            \n            x_grid = np.linspace(0.02, 0.98, n_grid)\n            y_grid = np.linspace(0.02, 0.98, n_grid)\n            xx, yy = np.meshgrid(x_grid, y_grid)\n            grid_candidates = np.column_stack([xx.ravel(), yy.ravel()])\n            candidates = np.vstack([candidates, grid_candidates])\n            \n            if i < 8:\n                corner_candidates = np.array([\n                    [0.1, 0.1], [0.9, 0.1], [0.1, 0.9], [0.9, 0.9],\n                    [0.5, 0.1], [0.5, 0.9], [0.1, 0.5], [0.9, 0.5],\n                    [0.3, 0.3], [0.7, 0.3], [0.3, 0.7], [0.7, 0.7]\n                ])\n                candidates = np.vstack([candidates, corner_candidates])\n            \n            if len(centers) > 2:\n                centers_array = np.array(centers)\n                radii_array = np.array(radii)\n                \n                for j in range(min(5, len(centers))):\n                    angles = np.linspace(0, 2*np.pi, 20)\n                    dist = radii_array[j] * 2.2\n                    gap_candidates = centers_array[j] + dist * np.column_stack([np.cos(angles), np.sin(angles)])\n                    gap_candidates = np.clip(gap_candidates, 0, 1)\n                    candidates = np.vstack([candidates, gap_candidates])\n            \n            for candidate in candidates:\n                x, y = candidate\n                max_r = min(x, y, 1 - x, 1 - y)\n                \n                if max_r <= 0:\n                    continue\n                \n                if len(centers) > 0:\n                    centers_array = np.array(centers)\n                    radii_array = np.array(radii)\n                    distances = np.sqrt(np.sum((centers_array - candidate)**2, axis=1))\n                    max_r_circles = distances - radii_array\n                    max_r = min(max_r, np.min(max_r_circles))\n                \n                if max_r > best_radius:\n                    best_radius = max_r\n                    best_pos = candidate\n            \n            if best_radius > 0:\n                centers.append(best_pos)\n                radii.append(best_radius)\n        \n        return np.array(centers), np.array(radii), np.sum(radii)\n    \n    # ============= LOCAL REFINEMENT =============\n    def local_refinement(centers, radii, iterations=100):\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n        best_sum = np.sum(radii)\n        \n        for _ in range(iterations):\n            idx = np.random.randint(n)\n            \n            for _ in range(20):\n                new_center = centers[idx] + np.random.randn(2) * 0.015\n                new_center = np.clip(new_center, 0, 1)\n                \n                max_r = min(new_center[0], new_center[1], 1 - new_center[0], 1 - new_center[1])\n                \n                for j in range(n):\n                    if j != idx:\n                        dist = np.sqrt(np.sum((centers[j] - new_center)**2))\n                        max_r = min(max_r, dist - radii[j])\n                \n                if max_r > 0:\n                    test_centers = centers.copy()\n                    test_radii = radii.copy()\n                    test_centers[idx] = new_center\n                    test_radii[idx] = max_r\n                    \n                    test_sum = np.sum(test_radii)\n                    if test_sum > best_sum:\n                        best_sum = test_sum\n                        best_centers = test_centers.copy()\n                        best_radii = test_radii.copy()\n                        centers = best_centers.copy()\n                        radii = best_radii.copy()\n        \n        return best_centers, best_radii, best_sum\n    \n    # ============= VERIFICATION =============\n    def verify_solution(centers, radii):\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < -1e-6 or\n                centers[i, 0] + radii[i] > 1 + 1e-6 or\n                centers[i, 1] - radii[i] < -1e-6 or\n                centers[i, 1] + radii[i] > 1 + 1e-6):\n                return False\n        \n        dists = squareform(pdist(centers))\n        for i in range(n):\n            for j in range(i+1, n):\n                if dists[i, j] < radii[i] + radii[j] - 1e-6:\n                    return False\n        return True\n    \n    # ============= MAIN HYBRID ALGORITHM =============\n    all_results = []\n    \n    # Run Method 1 with 10 seeds\n    for seed in range(10):\n        try:\n            centers, radii, sum_radii = method1_hexagonal_optimizer(seed)\n            if verify_solution(centers, radii):\n                all_results.append((centers, radii, sum_radii, 'method1'))\n        except:\n            pass\n    \n    # Run Method 2 with 10 seeds\n    seeds2 = [42, 123, 456, 789, 1337, 2024, 9999, 3141, 5926, 8888]\n    for seed in seeds2:\n        try:\n            centers, radii, sum_radii = method2_greedy_placement(seed)\n            if verify_solution(centers, radii):\n                all_results.append((centers, radii, sum_radii, 'method2'))\n        except:\n            pass\n    \n    # Sort by sum of radii\n    all_results.sort(key=lambda x: x[2], reverse=True)\n    \n    # Take top 5 and refine\n    top_results = []\n    for i in range(min(5, len(all_results))):\n        centers, radii, sum_radii, method = all_results[i]\n        \n        # Apply local refinement\n        refined_centers, refined_radii, refined_sum = local_refinement(centers, radii, iterations=150)\n        if verify_solution(refined_centers, refined_radii):\n            top_results.append((refined_centers, refined_radii, refined_sum))\n        \n        # Try small perturbations\n        for _ in range(3):\n            perturbed_centers = centers + np.random.normal(0, 0.01, centers.shape)\n            perturbed_centers = np.clip(perturbed_centers, 0.05, 0.95)\n            perturbed_radii = radii * (1 + np.random.normal(0, 0.03, radii.shape))\n            perturbed_radii = np.clip(perturbed_radii, 0.01, 0.15)\n            \n            refined_centers, refined_radii, refined_sum = local_refinement(\n                perturbed_centers, perturbed_radii, iterations=100\n            )\n            if verify_solution(refined_centers, refined_radii):\n                top_results.append((refined_centers, refined_radii, refined_sum))\n    \n    # Return best\n    if top_results:\n        top_results.sort(key=lambda x: x[2], reverse=True)\n        return top_results[0]\n    elif all_results:\n        return all_results[0][:3]\n    else:\n        # Fallback: simple grid\n        centers = np.random.rand(n, 2) * 0.8 + 0.1\n        radii = np.full(n, 0.05)\n        return centers, radii, np.sum(radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.600642682002308,
    "target_ratio": 0.9869611696403447,
    "combined_score": 0.9869611696403447,
    "eval_time": 934.6970348358154,
    "error": null
  },
  "prompt": "Create ultimate hybrid of two best approaches:\n\nUse scipy optimizer from trial_2_8:\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def initialize_hexagonal():\n        \"\"\"Initialize with hexagonal packing pattern.\"\"\"\n        # For 26 circles, use a 5x6 hexagonal grid (30 positions, take best 26)\n        rows = 6\n        cols = 5\n        \n        # Hexagonal spacing\n        hex_height = np.sqrt(3) / 2\n        \n        # Estimate radius for tight packing\n        estimated_radius = 0.5 / (cols + 0.5)\n        \n        centers = []\n        for row in range(rows):\n            for col in range(cols):\n                x_offset = 0.5 * estimated_radius if row % 2 == 1 else 0\n                x = estimated_radius + col * 2 * estimated_radius + x_offset\n                y = estimated_radius + row * hex_height * 2 * estimated_radius\n                centers.append([x, y])\n        \n        centers = np.array(centers)\n        \n        # Scale to fit in unit square with margin\n        margin = 0.02\n        centers_min = centers.min(axis=0)\n        centers_max = centers.max(axis=0)\n        centers = (centers - centers_min) / (centers_max - centers_min)\n        centers = centers * (1 - 2 * margin) + margin\n        \n        # Select 26 most evenly distributed circles\n        if len(centers) > n:\n            # Keep centers that are most spread out\n            indices = []\n            remaining = list(range(len(centers)))\n            \n            # Start with center closest to (0.5, 0.5)\n            dists_to_center = np.linalg.norm(centers - np.array([0.5, 0.5]), axis=1)\n            first_idx = np.argmin(dists_to_center)\n            indices.append(first_idx)\n            remaining.remove(first_idx)\n            \n            # Greedily add circles that maximize minimum distance to selected\n            while len(indices) < n:\n                max_min_dist = -1\n                best_idx = -1\n                for idx in remaining:\n                    min_dist = np.min(np.linalg.norm(centers[indices] - centers[idx], axis=1))\n                    if min_dist > max_min_dist:\n                        max_min_dist = min_dist\n                        best_idx = idx\n                indices.append(best_idx)\n                remaining.remove(best_idx)\n            \n            centers = centers[indices]\n        \n        # Initialize radii based on minimum pairwise distance\n        distances = pdist(centers)\n        min_dist = np.min(distances) if len(distances) > 0 else 0.1\n        radii = np.full(n, min_dist / 2.5)\n        \n        # Adjust radii to respect boundaries\n        for i in range(n):\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = min(radii[i], max_r * 0.95)\n        \n        return centers, radii\n    \n    def pack_to_vector(centers, radii):\n        \"\"\"Convert centers and radii to optimization vector.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def vector_to_pack(x):\n        \"\"\"Convert optimization vector to centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Objective: maximize sum of radii (minimize negative sum).\"\"\"\n        _, radii = vector_to_pack(x)\n        return -np.sum(radii)\n    \n    def constraint_no_overlap(x):\n        \"\"\"Constraint: circles must not overlap.\"\"\"\n        centers, radii = vector_to_pack(x)\n        dists = squareform(pdist(centers))\n        np.fill_diagonal(dists, np.inf)\n        \n        # For each pair, distance - sum of radii should be >= 0\n        constraints = []\n        for i in range(n):\n            for j in range(i+1, n):\n                constraints.append(dists[i, j] - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    def constraint_inside_square(x):\n        \"\"\"Constraint: circles must be inside unit square.\"\"\"\n        centers, radii = vector_to_pack(x)\n        constraints = []\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        return np.array(constraints)\n    \n    best_sum = -np.inf\n    best_centers = None\n    best_radii = None\n    \n    # Multiple restarts with perturbations\n    n_restarts = 5\n    \n    for restart in range(n_restarts):\n        # Initialize\n        centers_init, radii_init = initialize_hexagonal()\n        \n        # Add small perturbation for restarts\n        if restart > 0:\n            centers_init += np.random.normal(0, 0.02, centers_init.shape)\n            centers_init = np.clip(centers_init, 0.05, 0.95)\n            radii_init *= (1 + np.random.normal(0, 0.05, radii_init.shape))\n            radii_init = np.clip(radii_init, 0.01, 0.1)\n        \n        x0 = pack_to_vector(centers_init, radii_init)\n        \n        # Bounds\n        bounds = []\n        for i in range(n):\n            bounds.append((0.0, 1.0))  # x\n            bounds.append((0.0, 1.0))  # y\n        for i in range(n):\n            bounds.append((0.001, 0.5))  # radius\n        \n        # Constraints\n        nlc_overlap = NonlinearConstraint(constraint_no_overlap, 0, np.inf)\n        nlc_inside = NonlinearConstraint(constraint_inside_square, 0, np.inf)\n        \n        # Optimize\n        result = minimize(\n            objective,\n            x0,\n            method='trust-constr',\n            bounds=bounds,\n            constraints=[nlc_overlap, nlc_inside],\n            options={\n                'maxiter': 2000,\n                'verbose': 0,\n                'gtol': 1e-6,\n                'xtol': 1e-8,\n            }\n        )\n        \n        if result.success or restart == 0:\n            centers_opt, radii_opt = vector_to_pack(result.x)\n            sum_radii = np.sum(radii_opt)\n            \n            # Verify constraints\n            valid = True\n            \n            # Check inside square\n            for i in range(n):\n                if (centers_opt[i, 0] - radii_opt[i] < -1e-6 or\n                    centers_opt[i, 0] + radii_opt[i] > 1 + 1e-6 or\n                    centers_opt[i, 1] - radii_opt[i] < -1e-6 or\n                    centers_opt[i, 1] + radii_opt[i] > 1 + 1e-6):\n                    valid = False\n                    break\n            \n            # Check no overlap\n            if valid:\n                dists = squareform(pdist(centers_opt))\n                for i in range(n):\n                    for j in range(i+1, n):\n                        if dists[i, j] < radii_opt[i] + radii_opt[j] - 1e-6:\n                            valid = False\n                            break\n                    if not valid:\n                        break\n            \n            if valid and sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers_opt.copy()\n                best_radii = radii_opt.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nAnd sequential placement from trial_2_3:\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def greedy_packing(seed):\n        np.random.seed(seed)\n        centers = []\n        radii = []\n        \n        for i in range(n):\n            best_pos = None\n            best_radius = 0\n            \n            # Adaptive candidate generation\n            n_random = 3000\n            n_grid = 30\n            \n            # Random candidates\n            candidates = np.random.rand(n_random, 2)\n            \n            # Dense grid candidates\n            x_grid = np.linspace(0.02, 0.98, n_grid)\n            y_grid = np.linspace(0.02, 0.98, n_grid)\n            xx, yy = np.meshgrid(x_grid, y_grid)\n            grid_candidates = np.column_stack([xx.ravel(), yy.ravel()])\n            candidates = np.vstack([candidates, grid_candidates])\n            \n            # Strategic candidates: focus on corners and edges for first few circles\n            if i < 8:\n                corner_candidates = np.array([\n                    [0.1, 0.1], [0.9, 0.1], [0.1, 0.9], [0.9, 0.9],\n                    [0.5, 0.1], [0.5, 0.9], [0.1, 0.5], [0.9, 0.5],\n                    [0.3, 0.3], [0.7, 0.3], [0.3, 0.7], [0.7, 0.7]\n                ])\n                candidates = np.vstack([candidates, corner_candidates])\n            \n            # If we have existing circles, add candidates near them (gap filling)\n            if len(centers) > 2:\n                centers_array = np.array(centers)\n                radii_array = np.array(radii)\n                \n                # Sample points around existing circles\n                for j in range(min(5, len(centers))):\n                    angles = np.linspace(0, 2*np.pi, 20)\n                    dist = radii_array[j] * 2.2\n                    gap_candidates = centers_array[j] + dist * np.column_stack([np.cos(angles), np.sin(angles)])\n                    gap_candidates = np.clip(gap_candidates, 0, 1)\n                    candidates = np.vstack([candidates, gap_candidates])\n            \n            for candidate in candidates:\n                x, y = candidate\n                \n                # Maximum radius from boundaries\n                max_r = min(x, y, 1 - x, 1 - y)\n                \n                if max_r <= 0:\n                    continue\n                \n                # Check constraints with existing circles\n                if len(centers) > 0:\n                    centers_array = np.array(centers)\n                    radii_array = np.array(radii)\n                    \n                    # Distance to existing circles\n                    distances = np.sqrt(np.sum((centers_array - candidate)**2, axis=1))\n                    # Maximum radius to avoid overlap\n                    max_r_circles = distances - radii_array\n                    max_r = min(max_r, np.min(max_r_circles))\n                \n                if max_r > best_radius:\n                    best_radius = max_r\n                    best_pos = candidate\n            \n            if best_radius > 0:\n                centers.append(best_pos)\n                radii.append(best_radius)\n        \n        return np.array(centers), np.array(radii)\n    \n    # Try multiple seeds and keep best\n    best_centers = None\n    best_radii = None\n    best_sum = 0\n    \n    seeds = [42, 123, 456, 789, 1337, 2024, 9999]\n    \n    for seed in seeds:\n        centers, radii = greedy_packing(seed)\n        current_sum = np.sum(radii)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    centers = best_centers\n    radii = best_radii\n    \n    # Local refinement: adjust positions slightly\n    def local_search(centers, radii, iterations=100):\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n        best_sum = np.sum(radii)\n        \n        for _ in range(iterations):\n            # Pick a random circle\n            idx = np.random.randint(n)\n            \n            # Try small perturbations\n            for _ in range(20):\n                new_center = centers[idx] + np.random.randn(2) * 0.02\n                new_center = np.clip(new_center, 0, 1)\n                \n                # Calculate max radius at new position\n                max_r = min(new_center[0], new_center[1], 1 - new_center[0], 1 - new_center[1])\n                \n                # Check with other circles\n                for j in range(n):\n                    if j != idx:\n                        dist = np.sqrt(np.sum((centers[j] - new_center)**2))\n                        max_r = min(max_r, dist - radii[j])\n                \n                if max_r > 0:\n                    # Try this configuration\n                    test_centers = centers.copy()\n                    test_radii = radii.copy()\n                    test_centers[idx] = new_center\n                    test_radii[idx] = max_r\n                    \n                    test_sum = np.sum(test_radii)\n                    if test_sum > best_sum:\n                        best_sum = test_sum\n                        best_centers = test_centers.copy()\n                        best_radii = test_radii.copy()\n                        centers = best_centers.copy()\n                        radii = best_radii.copy()\n        \n        return best_centers, best_radii\n    \n    centers, radii = local_search(centers, radii, iterations=150)\n    \n    # Final optimization with scipy\n    def objective(x):\n        n_circles = len(radii)\n        radii_opt = x[n_circles*2:]\n        return -np.sum(radii_opt)\n    \n    def constraint_boundary(x):\n        n_circles = len(radii)\n        centers_opt = x[:n_circles*2].reshape(n_circles, 2)\n        radii_opt = x[n_circles*2:]\n        \n        constraints = []\n        for i in range(n_circles):\n            constraints.extend([\n                centers_opt[i, 0] - radii_opt[i],\n                centers_opt[i, 1] - radii_opt[i],\n                1 - centers_opt[i, 0] - radii_opt[i],\n                1 - centers_opt[i, 1] - radii_opt[i]\n            ])\n        return np.array(constraints)\n    \n    def constraint_overlap(x):\n        n_circles = len(radii)\n        centers_opt = x[:n_circles*2].reshape(n_circles, 2)\n        radii_opt = x[n_circles*2:]\n        \n        constraints = []\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt(np.sum((centers_opt[i] - centers_opt[j])**2))\n                constraints.append(dist - radii_opt[i] - radii_opt[j])\n        return np.array(constraints)\n    \n    x0 = np.concatenate([centers.ravel(), radii])\n    bounds = [(0, 1)] * (n * 2) + [(0, 0.5)] * n\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_boundary},\n        {'type': 'ineq', 'fun': constraint_overlap}\n    ]\n    \n    # Multiple optimization attempts\n    best_result = None\n    best_value = float('inf')\n    \n    for attempt in range(5):\n        try:\n            if attempt > 0:\n                x0_perturbed = x0 + np.random.randn(len(x0)) * 0.005\n                x0_perturbed[:n*2] = np.clip(x0_perturbed[:n*2], 0.01, 0.99)\n                x0_perturbed[n*2:] = np.clip(x0_perturbed[n*2:], 0, 0.4)\n            else:\n                x0_perturbed = x0\n            \n            result = minimize(\n                objective,\n                x0_perturbed,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 1000, 'ftol': 1e-10}\n            )\n            \n            if result.fun < best_value:\n                best_result = result\n                best_value = result.fun\n        except:\n            pass\n    \n    if best_result is not None:\n        centers = best_result.x[:n*2].reshape(n, 2)\n        radii = best_result.x[n*2:]\n    \n    radii = np.maximum(radii, 0)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nStrategy:\n1. Run both methods independently with multiple seeds\n2. For each method, try 10 different initializations\n3. Collect all valid results\n4. Take top 5 results\n5. For each top result:\n   - Apply local refinement\n   - Try small perturbations + re-optimization\n6. Return absolute best\n\nRequirements:\n- Run both methods extensively\n- Compare all results\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # ============= METHOD 1: SCIPY OPTIMIZER WITH HEXAGONAL INIT =============\n    def method1_hexagonal_optimizer(seed):\n        np.random.seed(seed)\n        \n        def initialize_hexagonal():\n            rows = 6\n            cols = 5\n            hex_height = np.sqrt(3) / 2\n            estimated_radius = 0.5 / (cols + 0.5)\n            \n            centers = []\n            for row in range(rows):\n                for col in range(cols):\n                    x_offset = 0.5 * estimated_radius if row % 2 == 1 else 0\n                    x = estimated_radius + col * 2 * estimated_radius + x_offset\n                    y = estimated_radius + row * hex_height * 2 * estimated_radius\n                    centers.append([x, y])\n            \n            centers = np.array(centers)\n            margin = 0.02\n            centers_min = centers.min(axis=0)\n            centers_max = centers.max(axis=0)\n            centers = (centers - centers_min) / (centers_max - centers_min)\n            centers = centers * (1 - 2 * margin) + margin\n            \n            if len(centers) > n:\n                indices = []\n                remaining = list(range(len(centers)))\n                dists_to_center = np.linalg.norm(centers - np.array([0.5, 0.5]), axis=1)\n                first_idx = np.argmin(dists_to_center)\n                indices.append(first_idx)\n                remaining.remove(first_idx)\n                \n                while len(indices) < n:\n                    max_min_dist = -1\n                    best_idx = -1\n                    for idx in remaining:\n                        min_dist = np.min(np.linalg.norm(centers[indices] - centers[idx], axis=1))\n                        if min_dist > max_min_dist:\n                            max_min_dist = min_dist\n                            best_idx = idx\n                    indices.append(best_idx)\n                    remaining.remove(best_idx)\n                \n                centers = centers[indices]\n            \n            distances = pdist(centers)\n            min_dist = np.min(distances) if len(distances) > 0 else 0.1\n            radii = np.full(n, min_dist / 2.5)\n            \n            for i in range(n):\n                max_r = min(centers[i, 0], centers[i, 1], \n                           1 - centers[i, 0], 1 - centers[i, 1])\n                radii[i] = min(radii[i], max_r * 0.95)\n            \n            return centers, radii\n        \n        def pack_to_vector(centers, radii):\n            return np.concatenate([centers.flatten(), radii])\n        \n        def vector_to_pack(x):\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            return centers, radii\n        \n        def objective(x):\n            _, radii = vector_to_pack(x)\n            return -np.sum(radii)\n        \n        def constraint_no_overlap(x):\n            centers, radii = vector_to_pack(x)\n            dists = squareform(pdist(centers))\n            np.fill_diagonal(dists, np.inf)\n            constraints = []\n            for i in range(n):\n                for j in range(i+1, n):\n                    constraints.append(dists[i, j] - radii[i] - radii[j])\n            return np.array(constraints)\n        \n        def constraint_inside_square(x):\n            centers, radii = vector_to_pack(x)\n            constraints = []\n            for i in range(n):\n                constraints.append(centers[i, 0] - radii[i])\n                constraints.append(1 - centers[i, 0] - radii[i])\n                constraints.append(centers[i, 1] - radii[i])\n                constraints.append(1 - centers[i, 1] - radii[i])\n            return np.array(constraints)\n        \n        centers_init, radii_init = initialize_hexagonal()\n        \n        if seed > 0:\n            centers_init += np.random.normal(0, 0.02, centers_init.shape)\n            centers_init = np.clip(centers_init, 0.05, 0.95)\n            radii_init *= (1 + np.random.normal(0, 0.05, radii_init.shape))\n            radii_init = np.clip(radii_init, 0.01, 0.1)\n        \n        x0 = pack_to_vector(centers_init, radii_init)\n        \n        bounds = [(0.0, 1.0)] * (2*n) + [(0.001, 0.5)] * n\n        \n        nlc_overlap = NonlinearConstraint(constraint_no_overlap, 0, np.inf)\n        nlc_inside = NonlinearConstraint(constraint_inside_square, 0, np.inf)\n        \n        result = minimize(\n            objective, x0, method='trust-constr',\n            bounds=bounds, constraints=[nlc_overlap, nlc_inside],\n            options={'maxiter': 2000, 'verbose': 0, 'gtol': 1e-6, 'xtol': 1e-8}\n        )\n        \n        centers_opt, radii_opt = vector_to_pack(result.x)\n        return centers_opt, radii_opt, np.sum(radii_opt)\n    \n    # ============= METHOD 2: GREEDY SEQUENTIAL PLACEMENT =============\n    def method2_greedy_placement(seed):\n        np.random.seed(seed)\n        centers = []\n        radii = []\n        \n        for i in range(n):\n            best_pos = None\n            best_radius = 0\n            \n            n_random = 3000\n            n_grid = 30\n            \n            candidates = np.random.rand(n_random, 2)\n            \n            x_grid = np.linspace(0.02, 0.98, n_grid)\n            y_grid = np.linspace(0.02, 0.98, n_grid)\n            xx, yy = np.meshgrid(x_grid, y_grid)\n            grid_candidates = np.column_stack([xx.ravel(), yy.ravel()])\n            candidates = np.vstack([candidates, grid_candidates])\n            \n            if i < 8:\n                corner_candidates = np.array([\n                    [0.1, 0.1], [0.9, 0.1], [0.1, 0.9], [0.9, 0.9],\n                    [0.5, 0.1], [0.5, 0.9], [0.1, 0.5], [0.9, 0.5],\n                    [0.3, 0.3], [0.7, 0.3], [0.3, 0.7], [0.7, 0.7]\n                ])\n                candidates = np.vstack([candidates, corner_candidates])\n            \n            if len(centers) > 2:\n                centers_array = np.array(centers)\n                radii_array = np.array(radii)\n                \n                for j in range(min(5, len(centers))):\n                    angles = np.linspace(0, 2*np.pi, 20)\n                    dist = radii_array[j] * 2.2\n                    gap_candidates = centers_array[j] + dist * np.column_stack([np.cos(angles), np.sin(angles)])\n                    gap_candidates = np.clip(gap_candidates, 0, 1)\n                    candidates = np.vstack([candidates, gap_candidates])\n            \n            for candidate in candidates:\n                x, y = candidate\n                max_r = min(x, y, 1 - x, 1 - y)\n                \n                if max_r <= 0:\n                    continue\n                \n                if len(centers) > 0:\n                    centers_array = np.array(centers)\n                    radii_array = np.array(radii)\n                    distances = np.sqrt(np.sum((centers_array - candidate)**2, axis=1))\n                    max_r_circles = distances - radii_array\n                    max_r = min(max_r, np.min(max_r_circles))\n                \n                if max_r > best_radius:\n                    best_radius = max_r\n                    best_pos = candidate\n            \n            if best_radius > 0:\n                centers.append(best_pos)\n                radii.append(best_radius)\n        \n        return np.array(centers), np.array(radii), np.sum(radii)\n    \n    # ============= LOCAL REFINEMENT =============\n    def local_refinement(centers, radii, iterations=100):\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n        best_sum = np.sum(radii)\n        \n        for _ in range(iterations):\n            idx = np.random.randint(n)\n            \n            for _ in range(20):\n                new_center = centers[idx] + np.random.randn(2) * 0.015\n                new_center = np.clip(new_center, 0, 1)\n                \n                max_r = min(new_center[0], new_center[1], 1 - new_center[0], 1 - new_center[1])\n                \n                for j in range(n):\n                    if j != idx:\n                        dist = np.sqrt(np.sum((centers[j] - new_center)**2))\n                        max_r = min(max_r, dist - radii[j])\n                \n                if max_r > 0:\n                    test_centers = centers.copy()\n                    test_radii = radii.copy()\n                    test_centers[idx] = new_center\n                    test_radii[idx] = max_r\n                    \n                    test_sum = np.sum(test_radii)\n                    if test_sum > best_sum:\n                        best_sum = test_sum\n                        best_centers = test_centers.copy()\n                        best_radii = test_radii.copy()\n                        centers = best_centers.copy()\n                        radii = best_radii.copy()\n        \n        return best_centers, best_radii, best_sum\n    \n    # ============= VERIFICATION =============\n    def verify_solution(centers, radii):\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < -1e-6 or\n                centers[i, 0] + radii[i] > 1 + 1e-6 or\n                centers[i, 1] - radii[i] < -1e-6 or\n                centers[i, 1] + radii[i] > 1 + 1e-6):\n                return False\n        \n        dists = squareform(pdist(centers))\n        for i in range(n):\n            for j in range(i+1, n):\n                if dists[i, j] < radii[i] + radii[j] - 1e-6:\n                    return False\n        return True\n    \n    # ============= MAIN HYBRID ALGORITHM =============\n    all_results = []\n    \n    # Run Method 1 with 10 seeds\n    for seed in range(10):\n        try:\n            centers, radii, sum_radii = method1_hexagonal_optimizer(seed)\n            if verify_solution(centers, radii):\n                all_results.append((centers, radii, sum_radii, 'method1'))\n        except:\n            pass\n    \n    # Run Method 2 with 10 seeds\n    seeds2 = [42, 123, 456, 789, 1337, 2024, 9999, 3141, 5926, 8888]\n    for seed in seeds2:\n        try:\n            centers, radii, sum_radii = method2_greedy_placement(seed)\n            if verify_solution(centers, radii):\n                all_results.append((centers, radii, sum_radii, 'method2'))\n        except:\n            pass\n    \n    # Sort by sum of radii\n    all_results.sort(key=lambda x: x[2], reverse=True)\n    \n    # Take top 5 and refine\n    top_results = []\n    for i in range(min(5, len(all_results))):\n        centers, radii, sum_radii, method = all_results[i]\n        \n        # Apply local refinement\n        refined_centers, refined_radii, refined_sum = local_refinement(centers, radii, iterations=150)\n        if verify_solution(refined_centers, refined_radii):\n            top_results.append((refined_centers, refined_radii, refined_sum))\n        \n        # Try small perturbations\n        for _ in range(3):\n            perturbed_centers = centers + np.random.normal(0, 0.01, centers.shape)\n            perturbed_centers = np.clip(perturbed_centers, 0.05, 0.95)\n            perturbed_radii = radii * (1 + np.random.normal(0, 0.03, radii.shape))\n            perturbed_radii = np.clip(perturbed_radii, 0.01, 0.15)\n            \n            refined_centers, refined_radii, refined_sum = local_refinement(\n                perturbed_centers, perturbed_radii, iterations=100\n            )\n            if verify_solution(refined_centers, refined_radii):\n                top_results.append((refined_centers, refined_radii, refined_sum))\n    \n    # Return best\n    if top_results:\n        top_results.sort(key=lambda x: x[2], reverse=True)\n        return top_results[0]\n    elif all_results:\n        return all_results[0][:3]\n    else:\n        # Fallback: simple grid\n        centers = np.random.rand(n, 2) * 0.8 + 0.1\n        radii = np.full(n, 0.05)\n        return centers, radii, np.sum(radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T18:29:56.132709",
  "cost_data": null
}