{
  "trial_id": "trial_3_1",
  "generation": 3,
  "parent_id": "trial_2_8",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint, Bounds\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def initialize_hexagonal():\n        \"\"\"Initialize with hexagonal packing pattern.\"\"\"\n        rows = 6\n        cols = 5\n        \n        hex_height = np.sqrt(3) / 2\n        estimated_radius = 0.5 / (cols + 0.5)\n        \n        centers = []\n        for row in range(rows):\n            for col in range(cols):\n                x_offset = 0.5 * estimated_radius if row % 2 == 1 else 0\n                x = estimated_radius + col * 2 * estimated_radius + x_offset\n                y = estimated_radius + row * hex_height * 2 * estimated_radius\n                centers.append([x, y])\n        \n        centers = np.array(centers)\n        \n        # Scale to fit in unit square with margin\n        margin = 0.02\n        centers_min = centers.min(axis=0)\n        centers_max = centers.max(axis=0)\n        centers = (centers - centers_min) / (centers_max - centers_min)\n        centers = centers * (1 - 2 * margin) + margin\n        \n        # Select 26 most evenly distributed circles\n        if len(centers) > n:\n            indices = []\n            remaining = list(range(len(centers)))\n            \n            dists_to_center = np.linalg.norm(centers - np.array([0.5, 0.5]), axis=1)\n            first_idx = np.argmin(dists_to_center)\n            indices.append(first_idx)\n            remaining.remove(first_idx)\n            \n            while len(indices) < n:\n                max_min_dist = -1\n                best_idx = -1\n                for idx in remaining:\n                    min_dist = np.min(np.linalg.norm(centers[indices] - centers[idx], axis=1))\n                    if min_dist > max_min_dist:\n                        max_min_dist = min_dist\n                        best_idx = idx\n                indices.append(best_idx)\n                remaining.remove(best_idx)\n            \n            centers = centers[indices]\n        \n        # Initialize radii based on minimum pairwise distance\n        distances = pdist(centers)\n        min_dist = np.min(distances) if len(distances) > 0 else 0.1\n        radii = np.full(n, min_dist / 2.5)\n        \n        # Adjust radii to respect boundaries\n        for i in range(n):\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = min(radii[i], max_r * 0.95)\n        \n        return centers, radii\n    \n    def pack_to_vector(centers, radii, slacks=None):\n        \"\"\"Convert centers, radii, and optional slacks to optimization vector.\"\"\"\n        if slacks is None:\n            return np.concatenate([centers.flatten(), radii])\n        return np.concatenate([centers.flatten(), radii, slacks])\n    \n    def vector_to_pack(x, with_slacks=False):\n        \"\"\"Convert optimization vector to centers, radii, and optional slacks.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:3*n]\n        if with_slacks:\n            n_pairs = n * (n - 1) // 2\n            slacks = x[3*n:3*n + n_pairs]\n            return centers, radii, slacks\n        return centers, radii\n    \n    def objective_phase1(x):\n        \"\"\"Phase 1: minimize sum of slacks while maintaining feasibility.\"\"\"\n        _, radii, slacks = vector_to_pack(x, with_slacks=True)\n        # Minimize slacks with small penalty for negative sum of radii\n        return np.sum(slacks**2) - 0.01 * np.sum(radii)\n    \n    def objective_phase2(x):\n        \"\"\"Phase 2: maximize sum of radii.\"\"\"\n        _, radii = vector_to_pack(x)\n        return -np.sum(radii)\n    \n    def constraint_no_overlap_with_slack(x):\n        \"\"\"Constraint: distance - sum of radii - slack >= 0.\"\"\"\n        centers, radii, slacks = vector_to_pack(x, with_slacks=True)\n        dists = squareform(pdist(centers))\n        \n        constraints = []\n        slack_idx = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                # distance - r_i - r_j - slack >= 0\n                constraints.append(dists[i, j] - radii[i] - radii[j] - slacks[slack_idx])\n                slack_idx += 1\n        return np.array(constraints)\n    \n    def constraint_no_overlap(x):\n        \"\"\"Constraint: circles must not overlap (no slacks).\"\"\"\n        centers, radii = vector_to_pack(x)\n        dists = squareform(pdist(centers))\n        \n        constraints = []\n        for i in range(n):\n            for j in range(i+1, n):\n                constraints.append(dists[i, j] - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    def constraint_inside_square(x):\n        \"\"\"Constraint: circles must be inside unit square.\"\"\"\n        if len(x) > 3*n:  # with slacks\n            centers, radii, _ = vector_to_pack(x, with_slacks=True)\n        else:\n            centers, radii = vector_to_pack(x)\n            \n        constraints = []\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        return np.array(constraints)\n    \n    def optimize_radii_only(centers_fixed, radii_init):\n        \"\"\"Phase 3: Fix centers, optimize radii only.\"\"\"\n        def obj_radii(radii):\n            return -np.sum(radii)\n        \n        def constraint_overlap_radii(radii):\n            dists = squareform(pdist(centers_fixed))\n            constraints = []\n            for i in range(n):\n                for j in range(i+1, n):\n                    constraints.append(dists[i, j] - radii[i] - radii[j])\n            return np.array(constraints)\n        \n        def constraint_inside_radii(radii):\n            constraints = []\n            for i in range(n):\n                constraints.append(centers_fixed[i, 0] - radii[i])\n                constraints.append(1 - centers_fixed[i, 0] - radii[i])\n                constraints.append(centers_fixed[i, 1] - radii[i])\n                constraints.append(1 - centers_fixed[i, 1] - radii[i])\n            return np.array(constraints)\n        \n        bounds_radii = Bounds(0.001, 0.5)\n        nlc_overlap = NonlinearConstraint(constraint_overlap_radii, 0, np.inf)\n        nlc_inside = NonlinearConstraint(constraint_inside_radii, 0, np.inf)\n        \n        result = minimize(\n            obj_radii,\n            radii_init,\n            method='trust-constr',\n            bounds=bounds_radii,\n            constraints=[nlc_overlap, nlc_inside],\n            options={'maxiter': 1000, 'verbose': 0}\n        )\n        \n        return result.x if result.success else radii_init\n    \n    best_sum = -np.inf\n    best_centers = None\n    best_radii = None\n    \n    n_restarts = 3\n    \n    for restart in range(n_restarts):\n        # Initialize\n        centers_init, radii_init = initialize_hexagonal()\n        \n        # Add perturbation for restarts\n        if restart > 0:\n            centers_init += np.random.normal(0, 0.015, centers_init.shape)\n            centers_init = np.clip(centers_init, 0.05, 0.95)\n            radii_init *= (1 + np.random.normal(0, 0.03, radii_init.shape))\n            radii_init = np.clip(radii_init, 0.01, 0.1)\n        \n        # PHASE 1: Relaxed optimization with slack variables\n        n_pairs = n * (n - 1) // 2\n        slacks_init = np.zeros(n_pairs)\n        x0_phase1 = pack_to_vector(centers_init, radii_init, slacks_init)\n        \n        # Bounds for phase 1\n        bounds_phase1 = []\n        for i in range(n):\n            bounds_phase1.append((0.0, 1.0))  # x\n            bounds_phase1.append((0.0, 1.0))  # y\n        for i in range(n):\n            bounds_phase1.append((0.001, 0.5))  # radius\n        for i in range(n_pairs):\n            bounds_phase1.append((0.0, 0.5))  # slack\n        \n        nlc_overlap_slack = NonlinearConstraint(constraint_no_overlap_with_slack, 0, np.inf)\n        nlc_inside_phase1 = NonlinearConstraint(constraint_inside_square, 0, np.inf)\n        \n        result_phase1 = minimize(\n            objective_phase1,\n            x0_phase1,\n            method='trust-constr',\n            bounds=bounds_phase1,\n            constraints=[nlc_overlap_slack, nlc_inside_phase1],\n            options={'maxiter': 1000, 'verbose': 0, 'gtol': 1e-5}\n        )\n        \n        # Extract solution from phase 1\n        centers_phase1, radii_phase1, _ = vector_to_pack(result_phase1.x, with_slacks=True)\n        \n        # PHASE 2: Strict optimization without slacks\n        x0_phase2 = pack_to_vector(centers_phase1, radii_phase1)\n        \n        bounds_phase2 = []\n        for i in range(n):\n            bounds_phase2.append((0.0, 1.0))  # x\n            bounds_phase2.append((0.0, 1.0))  # y\n        for i in range(n):\n            bounds_phase2.append((0.001, 0.5))  # radius\n        \n        nlc_overlap = NonlinearConstraint(constraint_no_overlap, 0, np.inf)\n        nlc_inside = NonlinearConstraint(constraint_inside_square, 0, np.inf)\n        \n        result_phase2 = minimize(\n            objective_phase2,\n            x0_phase2,\n            method='trust-constr',\n            bounds=bounds_phase2,\n            constraints=[nlc_overlap, nlc_inside],\n            options={'maxiter': 1500, 'verbose': 0, 'gtol': 1e-6, 'xtol': 1e-8}\n        )\n        \n        centers_phase2, radii_phase2 = vector_to_pack(result_phase2.x)\n        \n        # PHASE 3: Fix centers, optimize radii\n        radii_phase3 = optimize_radii_only(centers_phase2, radii_phase2)\n        \n        sum_radii = np.sum(radii_phase3)\n        \n        # Verify constraints\n        valid = True\n        \n        # Check inside square\n        for i in range(n):\n            if (centers_phase2[i, 0] - radii_phase3[i] < -1e-6 or\n                centers_phase2[i, 0] + radii_phase3[i] > 1 + 1e-6 or\n                centers_phase2[i, 1] - radii_phase3[i] < -1e-6 or\n                centers_phase2[i, 1] + radii_phase3[i] > 1 + 1e-6):\n                valid = False\n                break\n        \n        # Check no overlap\n        if valid:\n            dists = squareform(pdist(centers_phase2))\n            for i in range(n):\n                for j in range(i+1, n):\n                    if dists[i, j] < radii_phase3[i] + radii_phase3[j] - 1e-6:\n                        valid = False\n                        break\n                if not valid:\n                    break\n        \n        if valid and sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers_phase2.copy()\n            best_radii = radii_phase3.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.5443964374098984,
    "target_ratio": 0.9656153462656162,
    "combined_score": 0.9656153462656162,
    "eval_time": 21.207846879959106,
    "error": null
  },
  "prompt": "Enhance this scipy optimizer with better constraint formulation:\n\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def initialize_hexagonal():\n        \"\"\"Initialize with hexagonal packing pattern.\"\"\"\n        # For 26 circles, use a 5x6 hexagonal grid (30 positions, take best 26)\n        rows = 6\n        cols = 5\n        \n        # Hexagonal spacing\n        hex_height = np.sqrt(3) / 2\n        \n        # Estimate radius for tight packing\n        estimated_radius = 0.5 / (cols + 0.5)\n        \n        centers = []\n        for row in range(rows):\n            for col in range(cols):\n                x_offset = 0.5 * estimated_radius if row % 2 == 1 else 0\n                x = estimated_radius + col * 2 * estimated_radius + x_offset\n                y = estimated_radius + row * hex_height * 2 * estimated_radius\n                centers.append([x, y])\n        \n        centers = np.array(centers)\n        \n        # Scale to fit in unit square with margin\n        margin = 0.02\n        centers_min = centers.min(axis=0)\n        centers_max = centers.max(axis=0)\n        centers = (centers - centers_min) / (centers_max - centers_min)\n        centers = centers * (1 - 2 * margin) + margin\n        \n        # Select 26 most evenly distributed circles\n        if len(centers) > n:\n            # Keep centers that are most spread out\n            indices = []\n            remaining = list(range(len(centers)))\n            \n            # Start with center closest to (0.5, 0.5)\n            dists_to_center = np.linalg.norm(centers - np.array([0.5, 0.5]), axis=1)\n            first_idx = np.argmin(dists_to_center)\n            indices.append(first_idx)\n            remaining.remove(first_idx)\n            \n            # Greedily add circles that maximize minimum distance to selected\n            while len(indices) < n:\n                max_min_dist = -1\n                best_idx = -1\n                for idx in remaining:\n                    min_dist = np.min(np.linalg.norm(centers[indices] - centers[idx], axis=1))\n                    if min_dist > max_min_dist:\n                        max_min_dist = min_dist\n                        best_idx = idx\n                indices.append(best_idx)\n                remaining.remove(best_idx)\n            \n            centers = centers[indices]\n        \n        # Initialize radii based on minimum pairwise distance\n        distances = pdist(centers)\n        min_dist = np.min(distances) if len(distances) > 0 else 0.1\n        radii = np.full(n, min_dist / 2.5)\n        \n        # Adjust radii to respect boundaries\n        for i in range(n):\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = min(radii[i], max_r * 0.95)\n        \n        return centers, radii\n    \n    def pack_to_vector(centers, radii):\n        \"\"\"Convert centers and radii to optimization vector.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def vector_to_pack(x):\n        \"\"\"Convert optimization vector to centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Objective: maximize sum of radii (minimize negative sum).\"\"\"\n        _, radii = vector_to_pack(x)\n        return -np.sum(radii)\n    \n    def constraint_no_overlap(x):\n        \"\"\"Constraint: circles must not overlap.\"\"\"\n        centers, radii = vector_to_pack(x)\n        dists = squareform(pdist(centers))\n        np.fill_diagonal(dists, np.inf)\n        \n        # For each pair, distance - sum of radii should be >= 0\n        constraints = []\n        for i in range(n):\n            for j in range(i+1, n):\n                constraints.append(dists[i, j] - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    def constraint_inside_square(x):\n        \"\"\"Constraint: circles must be inside unit square.\"\"\"\n        centers, radii = vector_to_pack(x)\n        constraints = []\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        return np.array(constraints)\n    \n    best_sum = -np.inf\n    best_centers = None\n    best_radii = None\n    \n    # Multiple restarts with perturbations\n    n_restarts = 5\n    \n    for restart in range(n_restarts):\n        # Initialize\n        centers_init, radii_init = initialize_hexagonal()\n        \n        # Add small perturbation for restarts\n        if restart > 0:\n            centers_init += np.random.normal(0, 0.02, centers_init.shape)\n            centers_init = np.clip(centers_init, 0.05, 0.95)\n            radii_init *= (1 + np.random.normal(0, 0.05, radii_init.shape))\n            radii_init = np.clip(radii_init, 0.01, 0.1)\n        \n        x0 = pack_to_vector(centers_init, radii_init)\n        \n        # Bounds\n        bounds = []\n        for i in range(n):\n            bounds.append((0.0, 1.0))  # x\n            bounds.append((0.0, 1.0))  # y\n        for i in range(n):\n            bounds.append((0.001, 0.5))  # radius\n        \n        # Constraints\n        nlc_overlap = NonlinearConstraint(constraint_no_overlap, 0, np.inf)\n        nlc_inside = NonlinearConstraint(constraint_inside_square, 0, np.inf)\n        \n        # Optimize\n        result = minimize(\n            objective,\n            x0,\n            method='trust-constr',\n            bounds=bounds,\n            constraints=[nlc_overlap, nlc_inside],\n            options={\n                'maxiter': 2000,\n                'verbose': 0,\n                'gtol': 1e-6,\n                'xtol': 1e-8,\n            }\n        )\n        \n        if result.success or restart == 0:\n            centers_opt, radii_opt = vector_to_pack(result.x)\n            sum_radii = np.sum(radii_opt)\n            \n            # Verify constraints\n            valid = True\n            \n            # Check inside square\n            for i in range(n):\n                if (centers_opt[i, 0] - radii_opt[i] < -1e-6 or\n                    centers_opt[i, 0] + radii_opt[i] > 1 + 1e-6 or\n                    centers_opt[i, 1] - radii_opt[i] < -1e-6 or\n                    centers_opt[i, 1] + radii_opt[i] > 1 + 1e-6):\n                    valid = False\n                    break\n            \n            # Check no overlap\n            if valid:\n                dists = squareform(pdist(centers_opt))\n                for i in range(n):\n                    for j in range(i+1, n):\n                        if dists[i, j] < radii_opt[i] + radii_opt[j] - 1e-6:\n                            valid = False\n                            break\n                    if not valid:\n                        break\n            \n            if valid and sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers_opt.copy()\n                best_radii = radii_opt.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nImprovements:\n1. Reformulate constraints to be smoother (use soft penalties initially)\n2. Add slack variables to constraints\n3. Use barrier method for inequality constraints\n4. Implement two-pass optimization: relaxed constraints first, strict second\n5. Final radius maximization: fix positions, optimize radii only\n\nRequirements:\n- Better constraint handling\n- Two-pass approach\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint, Bounds\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def initialize_hexagonal():\n        \"\"\"Initialize with hexagonal packing pattern.\"\"\"\n        rows = 6\n        cols = 5\n        \n        hex_height = np.sqrt(3) / 2\n        estimated_radius = 0.5 / (cols + 0.5)\n        \n        centers = []\n        for row in range(rows):\n            for col in range(cols):\n                x_offset = 0.5 * estimated_radius if row % 2 == 1 else 0\n                x = estimated_radius + col * 2 * estimated_radius + x_offset\n                y = estimated_radius + row * hex_height * 2 * estimated_radius\n                centers.append([x, y])\n        \n        centers = np.array(centers)\n        \n        # Scale to fit in unit square with margin\n        margin = 0.02\n        centers_min = centers.min(axis=0)\n        centers_max = centers.max(axis=0)\n        centers = (centers - centers_min) / (centers_max - centers_min)\n        centers = centers * (1 - 2 * margin) + margin\n        \n        # Select 26 most evenly distributed circles\n        if len(centers) > n:\n            indices = []\n            remaining = list(range(len(centers)))\n            \n            dists_to_center = np.linalg.norm(centers - np.array([0.5, 0.5]), axis=1)\n            first_idx = np.argmin(dists_to_center)\n            indices.append(first_idx)\n            remaining.remove(first_idx)\n            \n            while len(indices) < n:\n                max_min_dist = -1\n                best_idx = -1\n                for idx in remaining:\n                    min_dist = np.min(np.linalg.norm(centers[indices] - centers[idx], axis=1))\n                    if min_dist > max_min_dist:\n                        max_min_dist = min_dist\n                        best_idx = idx\n                indices.append(best_idx)\n                remaining.remove(best_idx)\n            \n            centers = centers[indices]\n        \n        # Initialize radii based on minimum pairwise distance\n        distances = pdist(centers)\n        min_dist = np.min(distances) if len(distances) > 0 else 0.1\n        radii = np.full(n, min_dist / 2.5)\n        \n        # Adjust radii to respect boundaries\n        for i in range(n):\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = min(radii[i], max_r * 0.95)\n        \n        return centers, radii\n    \n    def pack_to_vector(centers, radii, slacks=None):\n        \"\"\"Convert centers, radii, and optional slacks to optimization vector.\"\"\"\n        if slacks is None:\n            return np.concatenate([centers.flatten(), radii])\n        return np.concatenate([centers.flatten(), radii, slacks])\n    \n    def vector_to_pack(x, with_slacks=False):\n        \"\"\"Convert optimization vector to centers, radii, and optional slacks.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:3*n]\n        if with_slacks:\n            n_pairs = n * (n - 1) // 2\n            slacks = x[3*n:3*n + n_pairs]\n            return centers, radii, slacks\n        return centers, radii\n    \n    def objective_phase1(x):\n        \"\"\"Phase 1: minimize sum of slacks while maintaining feasibility.\"\"\"\n        _, radii, slacks = vector_to_pack(x, with_slacks=True)\n        # Minimize slacks with small penalty for negative sum of radii\n        return np.sum(slacks**2) - 0.01 * np.sum(radii)\n    \n    def objective_phase2(x):\n        \"\"\"Phase 2: maximize sum of radii.\"\"\"\n        _, radii = vector_to_pack(x)\n        return -np.sum(radii)\n    \n    def constraint_no_overlap_with_slack(x):\n        \"\"\"Constraint: distance - sum of radii - slack >= 0.\"\"\"\n        centers, radii, slacks = vector_to_pack(x, with_slacks=True)\n        dists = squareform(pdist(centers))\n        \n        constraints = []\n        slack_idx = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                # distance - r_i - r_j - slack >= 0\n                constraints.append(dists[i, j] - radii[i] - radii[j] - slacks[slack_idx])\n                slack_idx += 1\n        return np.array(constraints)\n    \n    def constraint_no_overlap(x):\n        \"\"\"Constraint: circles must not overlap (no slacks).\"\"\"\n        centers, radii = vector_to_pack(x)\n        dists = squareform(pdist(centers))\n        \n        constraints = []\n        for i in range(n):\n            for j in range(i+1, n):\n                constraints.append(dists[i, j] - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    def constraint_inside_square(x):\n        \"\"\"Constraint: circles must be inside unit square.\"\"\"\n        if len(x) > 3*n:  # with slacks\n            centers, radii, _ = vector_to_pack(x, with_slacks=True)\n        else:\n            centers, radii = vector_to_pack(x)\n            \n        constraints = []\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        return np.array(constraints)\n    \n    def optimize_radii_only(centers_fixed, radii_init):\n        \"\"\"Phase 3: Fix centers, optimize radii only.\"\"\"\n        def obj_radii(radii):\n            return -np.sum(radii)\n        \n        def constraint_overlap_radii(radii):\n            dists = squareform(pdist(centers_fixed))\n            constraints = []\n            for i in range(n):\n                for j in range(i+1, n):\n                    constraints.append(dists[i, j] - radii[i] - radii[j])\n            return np.array(constraints)\n        \n        def constraint_inside_radii(radii):\n            constraints = []\n            for i in range(n):\n                constraints.append(centers_fixed[i, 0] - radii[i])\n                constraints.append(1 - centers_fixed[i, 0] - radii[i])\n                constraints.append(centers_fixed[i, 1] - radii[i])\n                constraints.append(1 - centers_fixed[i, 1] - radii[i])\n            return np.array(constraints)\n        \n        bounds_radii = Bounds(0.001, 0.5)\n        nlc_overlap = NonlinearConstraint(constraint_overlap_radii, 0, np.inf)\n        nlc_inside = NonlinearConstraint(constraint_inside_radii, 0, np.inf)\n        \n        result = minimize(\n            obj_radii,\n            radii_init,\n            method='trust-constr',\n            bounds=bounds_radii,\n            constraints=[nlc_overlap, nlc_inside],\n            options={'maxiter': 1000, 'verbose': 0}\n        )\n        \n        return result.x if result.success else radii_init\n    \n    best_sum = -np.inf\n    best_centers = None\n    best_radii = None\n    \n    n_restarts = 3\n    \n    for restart in range(n_restarts):\n        # Initialize\n        centers_init, radii_init = initialize_hexagonal()\n        \n        # Add perturbation for restarts\n        if restart > 0:\n            centers_init += np.random.normal(0, 0.015, centers_init.shape)\n            centers_init = np.clip(centers_init, 0.05, 0.95)\n            radii_init *= (1 + np.random.normal(0, 0.03, radii_init.shape))\n            radii_init = np.clip(radii_init, 0.01, 0.1)\n        \n        # PHASE 1: Relaxed optimization with slack variables\n        n_pairs = n * (n - 1) // 2\n        slacks_init = np.zeros(n_pairs)\n        x0_phase1 = pack_to_vector(centers_init, radii_init, slacks_init)\n        \n        # Bounds for phase 1\n        bounds_phase1 = []\n        for i in range(n):\n            bounds_phase1.append((0.0, 1.0))  # x\n            bounds_phase1.append((0.0, 1.0))  # y\n        for i in range(n):\n            bounds_phase1.append((0.001, 0.5))  # radius\n        for i in range(n_pairs):\n            bounds_phase1.append((0.0, 0.5))  # slack\n        \n        nlc_overlap_slack = NonlinearConstraint(constraint_no_overlap_with_slack, 0, np.inf)\n        nlc_inside_phase1 = NonlinearConstraint(constraint_inside_square, 0, np.inf)\n        \n        result_phase1 = minimize(\n            objective_phase1,\n            x0_phase1,\n            method='trust-constr',\n            bounds=bounds_phase1,\n            constraints=[nlc_overlap_slack, nlc_inside_phase1],\n            options={'maxiter': 1000, 'verbose': 0, 'gtol': 1e-5}\n        )\n        \n        # Extract solution from phase 1\n        centers_phase1, radii_phase1, _ = vector_to_pack(result_phase1.x, with_slacks=True)\n        \n        # PHASE 2: Strict optimization without slacks\n        x0_phase2 = pack_to_vector(centers_phase1, radii_phase1)\n        \n        bounds_phase2 = []\n        for i in range(n):\n            bounds_phase2.append((0.0, 1.0))  # x\n            bounds_phase2.append((0.0, 1.0))  # y\n        for i in range(n):\n            bounds_phase2.append((0.001, 0.5))  # radius\n        \n        nlc_overlap = NonlinearConstraint(constraint_no_overlap, 0, np.inf)\n        nlc_inside = NonlinearConstraint(constraint_inside_square, 0, np.inf)\n        \n        result_phase2 = minimize(\n            objective_phase2,\n            x0_phase2,\n            method='trust-constr',\n            bounds=bounds_phase2,\n            constraints=[nlc_overlap, nlc_inside],\n            options={'maxiter': 1500, 'verbose': 0, 'gtol': 1e-6, 'xtol': 1e-8}\n        )\n        \n        centers_phase2, radii_phase2 = vector_to_pack(result_phase2.x)\n        \n        # PHASE 3: Fix centers, optimize radii\n        radii_phase3 = optimize_radii_only(centers_phase2, radii_phase2)\n        \n        sum_radii = np.sum(radii_phase3)\n        \n        # Verify constraints\n        valid = True\n        \n        # Check inside square\n        for i in range(n):\n            if (centers_phase2[i, 0] - radii_phase3[i] < -1e-6 or\n                centers_phase2[i, 0] + radii_phase3[i] > 1 + 1e-6 or\n                centers_phase2[i, 1] - radii_phase3[i] < -1e-6 or\n                centers_phase2[i, 1] + radii_phase3[i] > 1 + 1e-6):\n                valid = False\n                break\n        \n        # Check no overlap\n        if valid:\n            dists = squareform(pdist(centers_phase2))\n            for i in range(n):\n                for j in range(i+1, n):\n                    if dists[i, j] < radii_phase3[i] + radii_phase3[j] - 1e-6:\n                        valid = False\n                        break\n                if not valid:\n                    break\n        \n        if valid and sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers_phase2.copy()\n            best_radii = radii_phase3.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T18:14:34.048509",
  "cost_data": null
}