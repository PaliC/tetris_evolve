{
  "trial_id": "trial_3_13",
  "generation": 3,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using barrier method.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def barrier_objective(x, mu):\n        \"\"\"\n        Objective with logarithmic barriers for interior point method.\n        x = [centers (2n), radii (n)]\n        \"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        # Primary objective: maximize sum of radii (minimize negative)\n        obj = -np.sum(radii)\n        \n        # Barrier for radii > 0\n        barrier = 0.0\n        for i in range(n):\n            if radii[i] <= 1e-10:\n                return 1e10\n            barrier -= mu * np.log(radii[i])\n        \n        # Barrier for circles inside square\n        for i in range(n):\n            # x - r >= 0  =>  -log(x - r)\n            # x + r <= 1  =>  -log(1 - x - r)\n            if centers[i, 0] - radii[i] <= 1e-10:\n                return 1e10\n            if centers[i, 0] + radii[i] >= 1.0 - 1e-10:\n                return 1e10\n            if centers[i, 1] - radii[i] <= 1e-10:\n                return 1e10\n            if centers[i, 1] + radii[i] >= 1.0 - 1e-10:\n                return 1e10\n            \n            barrier -= mu * np.log(centers[i, 0] - radii[i])\n            barrier -= mu * np.log(1.0 - centers[i, 0] - radii[i])\n            barrier -= mu * np.log(centers[i, 1] - radii[i])\n            barrier -= mu * np.log(1.0 - centers[i, 1] - radii[i])\n        \n        # Barrier for non-overlapping circles\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                gap = dist - radii[i] - radii[j]\n                if gap <= 1e-10:\n                    return 1e10\n                barrier -= mu * np.log(gap)\n        \n        return obj + barrier\n    \n    def initialize_feasible():\n        \"\"\"Create a strictly feasible initial point.\"\"\"\n        # Start with a grid-based layout with small radii\n        grid_size = int(np.ceil(np.sqrt(n)))\n        spacing = 1.0 / (grid_size + 1)\n        \n        centers = []\n        idx = 0\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if idx >= n:\n                    break\n                x = (i + 1) * spacing\n                y = (j + 1) * spacing\n                centers.append([x, y])\n                idx += 1\n                \n        centers = np.array(centers[:n])\n        \n        # Set small initial radii to ensure feasibility\n        radii = np.full(n, spacing * 0.3)\n        \n        # Ensure strict feasibility\n        for i in range(n):\n            max_r = min(centers[i, 0], 1.0 - centers[i, 0],\n                       centers[i, 1], 1.0 - centers[i, 1])\n            radii[i] = min(radii[i], max_r * 0.9)\n        \n        return np.concatenate([centers.flatten(), radii])\n    \n    def optimize_with_barriers(x0, mu_init=1.0, mu_factor=0.1, max_outer=20):\n        \"\"\"Interior point method with decreasing barrier parameter.\"\"\"\n        x = x0.copy()\n        mu = mu_init\n        \n        for outer_iter in range(max_outer):\n            # Optimize with current barrier parameter\n            result = minimize(\n                lambda x_var: barrier_objective(x_var, mu),\n                x,\n                method='L-BFGS-B',\n                options={\n                    'maxiter': 1000,\n                    'ftol': 1e-12,\n                    'gtol': 1e-10\n                }\n            )\n            \n            if result.success:\n                x = result.x\n            \n            # Check convergence\n            if mu < 1e-8:\n                break\n            \n            # Decrease barrier parameter\n            mu *= mu_factor\n        \n        return x\n    \n    def multi_start_optimization(n_starts=5):\n        \"\"\"Run optimization from multiple starting points.\"\"\"\n        best_x = None\n        best_sum = -np.inf\n        \n        for start_idx in range(n_starts):\n            # Generate initial point\n            x0 = initialize_feasible()\n            \n            # Add small perturbation for different starts\n            if start_idx > 0:\n                x0 += np.random.randn(len(x0)) * 0.01\n                # Project back to feasible region\n                centers = x0[:2*n].reshape(n, 2)\n                radii = x0[2*n:]\n                \n                # Ensure feasibility after perturbation\n                for i in range(n):\n                    centers[i, 0] = np.clip(centers[i, 0], 0.1, 0.9)\n                    centers[i, 1] = np.clip(centers[i, 1], 0.1, 0.9)\n                    max_r = min(centers[i, 0], 1.0 - centers[i, 0],\n                               centers[i, 1], 1.0 - centers[i, 1])\n                    radii[i] = min(max(radii[i], 0.01), max_r * 0.9)\n                \n                x0 = np.concatenate([centers.flatten(), radii])\n            \n            # Optimize\n            x_opt = optimize_with_barriers(x0, mu_init=0.5, mu_factor=0.2)\n            \n            # Extract solution\n            radii = x_opt[2*n:]\n            sum_radii = np.sum(radii)\n            \n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_x = x_opt\n        \n        return best_x\n    \n    # Run multi-start optimization\n    x_final = multi_start_optimization(n_starts=3)\n    \n    # Extract final solution\n    centers = x_final[:2*n].reshape(n, 2)\n    radii = x_final[2*n:]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.178582520110984,
    "target_ratio": 0.4472798937802597,
    "combined_score": 0.4472798937802597,
    "eval_time": 2440.4743599891663,
    "error": null
  },
  "prompt": "Create barrier method optimizer using interior point approach.\n\nStrategy:\n1. Transform constraints using logarithmic barriers\n2. Optimize unconstrained problem with barriers\n3. Gradually decrease barrier parameter\n4. Use Newton's method for unconstrained optimization\n5. This keeps solution strictly feasible\n6. Very tight convergence criteria\n\nRequirements:\n- Logarithmic barrier implementation\n- Interior point method\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using barrier method.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def barrier_objective(x, mu):\n        \"\"\"\n        Objective with logarithmic barriers for interior point method.\n        x = [centers (2n), radii (n)]\n        \"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        # Primary objective: maximize sum of radii (minimize negative)\n        obj = -np.sum(radii)\n        \n        # Barrier for radii > 0\n        barrier = 0.0\n        for i in range(n):\n            if radii[i] <= 1e-10:\n                return 1e10\n            barrier -= mu * np.log(radii[i])\n        \n        # Barrier for circles inside square\n        for i in range(n):\n            # x - r >= 0  =>  -log(x - r)\n            # x + r <= 1  =>  -log(1 - x - r)\n            if centers[i, 0] - radii[i] <= 1e-10:\n                return 1e10\n            if centers[i, 0] + radii[i] >= 1.0 - 1e-10:\n                return 1e10\n            if centers[i, 1] - radii[i] <= 1e-10:\n                return 1e10\n            if centers[i, 1] + radii[i] >= 1.0 - 1e-10:\n                return 1e10\n            \n            barrier -= mu * np.log(centers[i, 0] - radii[i])\n            barrier -= mu * np.log(1.0 - centers[i, 0] - radii[i])\n            barrier -= mu * np.log(centers[i, 1] - radii[i])\n            barrier -= mu * np.log(1.0 - centers[i, 1] - radii[i])\n        \n        # Barrier for non-overlapping circles\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                gap = dist - radii[i] - radii[j]\n                if gap <= 1e-10:\n                    return 1e10\n                barrier -= mu * np.log(gap)\n        \n        return obj + barrier\n    \n    def initialize_feasible():\n        \"\"\"Create a strictly feasible initial point.\"\"\"\n        # Start with a grid-based layout with small radii\n        grid_size = int(np.ceil(np.sqrt(n)))\n        spacing = 1.0 / (grid_size + 1)\n        \n        centers = []\n        idx = 0\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if idx >= n:\n                    break\n                x = (i + 1) * spacing\n                y = (j + 1) * spacing\n                centers.append([x, y])\n                idx += 1\n                \n        centers = np.array(centers[:n])\n        \n        # Set small initial radii to ensure feasibility\n        radii = np.full(n, spacing * 0.3)\n        \n        # Ensure strict feasibility\n        for i in range(n):\n            max_r = min(centers[i, 0], 1.0 - centers[i, 0],\n                       centers[i, 1], 1.0 - centers[i, 1])\n            radii[i] = min(radii[i], max_r * 0.9)\n        \n        return np.concatenate([centers.flatten(), radii])\n    \n    def optimize_with_barriers(x0, mu_init=1.0, mu_factor=0.1, max_outer=20):\n        \"\"\"Interior point method with decreasing barrier parameter.\"\"\"\n        x = x0.copy()\n        mu = mu_init\n        \n        for outer_iter in range(max_outer):\n            # Optimize with current barrier parameter\n            result = minimize(\n                lambda x_var: barrier_objective(x_var, mu),\n                x,\n                method='L-BFGS-B',\n                options={\n                    'maxiter': 1000,\n                    'ftol': 1e-12,\n                    'gtol': 1e-10\n                }\n            )\n            \n            if result.success:\n                x = result.x\n            \n            # Check convergence\n            if mu < 1e-8:\n                break\n            \n            # Decrease barrier parameter\n            mu *= mu_factor\n        \n        return x\n    \n    def multi_start_optimization(n_starts=5):\n        \"\"\"Run optimization from multiple starting points.\"\"\"\n        best_x = None\n        best_sum = -np.inf\n        \n        for start_idx in range(n_starts):\n            # Generate initial point\n            x0 = initialize_feasible()\n            \n            # Add small perturbation for different starts\n            if start_idx > 0:\n                x0 += np.random.randn(len(x0)) * 0.01\n                # Project back to feasible region\n                centers = x0[:2*n].reshape(n, 2)\n                radii = x0[2*n:]\n                \n                # Ensure feasibility after perturbation\n                for i in range(n):\n                    centers[i, 0] = np.clip(centers[i, 0], 0.1, 0.9)\n                    centers[i, 1] = np.clip(centers[i, 1], 0.1, 0.9)\n                    max_r = min(centers[i, 0], 1.0 - centers[i, 0],\n                               centers[i, 1], 1.0 - centers[i, 1])\n                    radii[i] = min(max(radii[i], 0.01), max_r * 0.9)\n                \n                x0 = np.concatenate([centers.flatten(), radii])\n            \n            # Optimize\n            x_opt = optimize_with_barriers(x0, mu_init=0.5, mu_factor=0.2)\n            \n            # Extract solution\n            radii = x_opt[2*n:]\n            sum_radii = np.sum(radii)\n            \n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_x = x_opt\n        \n        return best_x\n    \n    # Run multi-start optimization\n    x_final = multi_start_optimization(n_starts=3)\n    \n    # Extract final solution\n    centers = x_final[:2*n].reshape(n, 2)\n    radii = x_final[2*n:]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T18:54:45.209528",
  "cost_data": null
}