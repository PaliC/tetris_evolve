{
  "trial_id": "trial_3_4",
  "generation": 3,
  "parent_id": "trial_2_3",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Hybrid approach: sequential placement + analytical gradient optimization.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Phase 1: Sequential greedy placement\n    def greedy_packing(seed):\n        np.random.seed(seed)\n        centers = []\n        radii = []\n        \n        for i in range(n):\n            best_pos = None\n            best_radius = 0\n            \n            # Adaptive candidate generation\n            n_random = 3000\n            n_grid = 30\n            \n            # Random candidates\n            candidates = np.random.rand(n_random, 2)\n            \n            # Dense grid candidates\n            x_grid = np.linspace(0.02, 0.98, n_grid)\n            y_grid = np.linspace(0.02, 0.98, n_grid)\n            xx, yy = np.meshgrid(x_grid, y_grid)\n            grid_candidates = np.column_stack([xx.ravel(), yy.ravel()])\n            candidates = np.vstack([candidates, grid_candidates])\n            \n            # Strategic candidates: focus on corners and edges for first few circles\n            if i < 8:\n                corner_candidates = np.array([\n                    [0.1, 0.1], [0.9, 0.1], [0.1, 0.9], [0.9, 0.9],\n                    [0.5, 0.1], [0.5, 0.9], [0.1, 0.5], [0.9, 0.5],\n                    [0.3, 0.3], [0.7, 0.3], [0.3, 0.7], [0.7, 0.7]\n                ])\n                candidates = np.vstack([candidates, corner_candidates])\n            \n            # Gap filling candidates\n            if len(centers) > 2:\n                centers_array = np.array(centers)\n                radii_array = np.array(radii)\n                \n                for j in range(min(5, len(centers))):\n                    angles = np.linspace(0, 2*np.pi, 20)\n                    dist = radii_array[j] * 2.2\n                    gap_candidates = centers_array[j] + dist * np.column_stack([np.cos(angles), np.sin(angles)])\n                    gap_candidates = np.clip(gap_candidates, 0, 1)\n                    candidates = np.vstack([candidates, gap_candidates])\n            \n            for candidate in candidates:\n                x, y = candidate\n                \n                # Maximum radius from boundaries\n                max_r = min(x, y, 1 - x, 1 - y)\n                \n                if max_r <= 0:\n                    continue\n                \n                # Check constraints with existing circles\n                if len(centers) > 0:\n                    centers_array = np.array(centers)\n                    radii_array = np.array(radii)\n                    \n                    distances = np.sqrt(np.sum((centers_array - candidate)**2, axis=1))\n                    max_r_circles = distances - radii_array\n                    max_r = min(max_r, np.min(max_r_circles))\n                \n                if max_r > best_radius:\n                    best_radius = max_r\n                    best_pos = candidate\n            \n            if best_radius > 0:\n                centers.append(best_pos)\n                radii.append(best_radius)\n        \n        return np.array(centers), np.array(radii)\n    \n    # Try multiple seeds and keep best\n    best_centers = None\n    best_radii = None\n    best_sum = 0\n    \n    seeds = [42, 123, 456, 789, 1337, 2024, 9999]\n    \n    for seed in seeds:\n        centers, radii = greedy_packing(seed)\n        current_sum = np.sum(radii)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    centers = best_centers\n    radii = best_radii\n    \n    # Phase 2: Analytical gradient optimization\n    def unpack_params(x):\n        \"\"\"Unpack parameter vector into centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def compute_constraints_and_gradients(x):\n        \"\"\"\n        Compute constraint violations and gradients.\n        Returns constraint values (positive = satisfied) and gradients.\n        \"\"\"\n        centers, radii = unpack_params(x)\n        \n        # Boundary constraints\n        boundary_constraints = []\n        boundary_gradients = []\n        \n        for i in range(n):\n            # x_i >= r_i\n            boundary_constraints.append(centers[i, 0] - radii[i])\n            grad = np.zeros(3*n)\n            grad[2*i] = 1.0\n            grad[2*n + i] = -1.0\n            boundary_gradients.append(grad)\n            \n            # x_i <= 1 - r_i\n            boundary_constraints.append(1.0 - centers[i, 0] - radii[i])\n            grad = np.zeros(3*n)\n            grad[2*i] = -1.0\n            grad[2*n + i] = -1.0\n            boundary_gradients.append(grad)\n            \n            # y_i >= r_i\n            boundary_constraints.append(centers[i, 1] - radii[i])\n            grad = np.zeros(3*n)\n            grad[2*i + 1] = 1.0\n            grad[2*n + i] = -1.0\n            boundary_gradients.append(grad)\n            \n            # y_i <= 1 - r_i\n            boundary_constraints.append(1.0 - centers[i, 1] - radii[i])\n            grad = np.zeros(3*n)\n            grad[2*i + 1] = -1.0\n            grad[2*n + i] = -1.0\n            boundary_gradients.append(grad)\n        \n        # Non-overlap constraints\n        overlap_constraints = []\n        overlap_gradients = []\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                diff = centers[i] - centers[j]\n                dist_sq = np.sum(diff**2)\n                dist = np.sqrt(dist_sq + 1e-10)\n                \n                # Constraint: dist - (r_i + r_j) >= 0\n                overlap_constraints.append(dist - radii[i] - radii[j])\n                \n                grad = np.zeros(3*n)\n                if dist > 1e-10:\n                    grad[2*i] = diff[0] / dist\n                    grad[2*i + 1] = diff[1] / dist\n                    grad[2*j] = -diff[0] / dist\n                    grad[2*j + 1] = -diff[1] / dist\n                grad[2*n + i] = -1.0\n                grad[2*n + j] = -1.0\n                overlap_gradients.append(grad)\n        \n        return (np.array(boundary_constraints), np.array(boundary_gradients),\n                np.array(overlap_constraints), np.array(overlap_gradients))\n    \n    def gradient_ascent_step(x, learning_rate=0.01):\n        \"\"\"\n        Perform one step of gradient ascent with constraint handling.\n        \"\"\"\n        centers, radii = unpack_params(x)\n        \n        # Objective gradient: maximize sum of radii\n        obj_gradient = np.zeros(3*n)\n        obj_gradient[2*n:] = 1.0  # Gradient w.r.t. radii\n        \n        # Get constraints and their gradients\n        boundary_cons, boundary_grads, overlap_cons, overlap_grads = compute_constraints_and_gradients(x)\n        \n        # Projected gradient: project away from violated constraints\n        gradient = obj_gradient.copy()\n        \n        # Handle violated boundary constraints\n        violated_boundary = boundary_cons < 0.01\n        if np.any(violated_boundary):\n            for idx in np.where(violated_boundary)[0]:\n                # Project gradient to satisfy constraint\n                constraint_grad = boundary_grads[idx]\n                projection = np.dot(gradient, constraint_grad)\n                if projection < 0:\n                    gradient -= projection * constraint_grad\n        \n        # Handle violated overlap constraints\n        violated_overlap = overlap_cons < 0.01\n        if np.any(violated_overlap):\n            for idx in np.where(violated_overlap)[0]:\n                constraint_grad = overlap_grads[idx]\n                projection = np.dot(gradient, constraint_grad)\n                if projection < 0:\n                    gradient -= projection * constraint_grad\n        \n        # Line search for optimal step size\n        best_x = x.copy()\n        best_sum = np.sum(radii)\n        \n        for alpha in [learning_rate, learning_rate/2, learning_rate/4, learning_rate/8]:\n            x_new = x + alpha * gradient\n            \n            # Check feasibility\n            boundary_cons_new, _, overlap_cons_new, _ = compute_constraints_and_gradients(x_new)\n            \n            if np.all(boundary_cons_new >= -1e-6) and np.all(overlap_cons_new >= -1e-6):\n                _, radii_new = unpack_params(x_new)\n                sum_new = np.sum(radii_new)\n                if sum_new > best_sum:\n                    best_sum = sum_new\n                    best_x = x_new\n        \n        return best_x\n    \n    # Initialize from sequential placement\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    # Gradient ascent iterations\n    x = x0.copy()\n    prev_sum = np.sum(radii)\n    \n    for iteration in range(100):\n        x_new = gradient_ascent_step(x, learning_rate=0.02)\n        _, radii_new = unpack_params(x_new)\n        current_sum = np.sum(radii_new)\n        \n        if current_sum - prev_sum < 1e-6:\n            break\n        \n        x = x_new\n        prev_sum = current_sum\n    \n    # Phase 3: Final scipy polish\n    def objective(x):\n        _, radii = unpack_params(x)\n        return -np.sum(radii)\n    \n    def constraint_func(x):\n        boundary_cons, _, overlap_cons, _ = compute_constraints_and_gradients(x)\n        return np.concatenate([boundary_cons, overlap_cons])\n    \n    def constraint_jacobian(x):\n        boundary_cons, boundary_grads, overlap_cons, overlap_grads = compute_constraints_and_gradients(x)\n        return np.vstack([boundary_grads, overlap_grads])\n    \n    constraint = {\n        'type': 'ineq',\n        'fun': constraint_func,\n        'jac': constraint_jacobian\n    }\n    \n    result = minimize(\n        objective,\n        x,\n        method='SLSQP',\n        jac=lambda x: -np.concatenate([np.zeros(2*n), np.ones(n)]),\n        constraints=constraint,\n        options={'maxiter': 1000, 'ftol': 1e-10}\n    )\n    \n    # Extract final solution\n    final_centers, final_radii = unpack_params(result.x)\n    final_radii = np.maximum(final_radii, 0)\n    sum_radii = np.sum(final_radii)\n    \n    return final_centers, final_radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.505165752066715,
    "target_ratio": 0.9507270406325294,
    "combined_score": 0.9507270406325294,
    "eval_time": 7.063178062438965,
    "error": null
  },
  "prompt": "Create hybrid of sequential placement with analytical gradients:\n\nStart with sequential placement from trial_2_3:\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def greedy_packing(seed):\n        np.random.seed(seed)\n        centers = []\n        radii = []\n        \n        for i in range(n):\n            best_pos = None\n            best_radius = 0\n            \n            # Adaptive candidate generation\n            n_random = 3000\n            n_grid = 30\n            \n            # Random candidates\n            candidates = np.random.rand(n_random, 2)\n            \n            # Dense grid candidates\n            x_grid = np.linspace(0.02, 0.98, n_grid)\n            y_grid = np.linspace(0.02, 0.98, n_grid)\n            xx, yy = np.meshgrid(x_grid, y_grid)\n            grid_candidates = np.column_stack([xx.ravel(), yy.ravel()])\n            candidates = np.vstack([candidates, grid_candidates])\n            \n            # Strategic candidates: focus on corners and edges for first few circles\n            if i < 8:\n                corner_candidates = np.array([\n                    [0.1, 0.1], [0.9, 0.1], [0.1, 0.9], [0.9, 0.9],\n                    [0.5, 0.1], [0.5, 0.9], [0.1, 0.5], [0.9, 0.5],\n                    [0.3, 0.3], [0.7, 0.3], [0.3, 0.7], [0.7, 0.7]\n                ])\n                candidates = np.vstack([candidates, corner_candidates])\n            \n            # If we have existing circles, add candidates near them (gap filling)\n            if len(centers) > 2:\n                centers_array = np.array(centers)\n                radii_array = np.array(radii)\n                \n                # Sample points around existing circles\n                for j in range(min(5, len(centers))):\n                    angles = np.linspace(0, 2*np.pi, 20)\n                    dist = radii_array[j] * 2.2\n                    gap_candidates = centers_array[j] + dist * np.column_stack([np.cos(angles), np.sin(angles)])\n                    gap_candidates = np.clip(gap_candidates, 0, 1)\n                    candidates = np.vstack([candidates, gap_candidates])\n            \n            for candidate in candidates:\n                x, y = candidate\n                \n                # Maximum radius from boundaries\n                max_r = min(x, y, 1 - x, 1 - y)\n                \n                if max_r <= 0:\n                    continue\n                \n                # Check constraints with existing circles\n                if len(centers) > 0:\n                    centers_array = np.array(centers)\n                    radii_array = np.array(radii)\n                    \n                    # Distance to existing circles\n                    distances = np.sqrt(np.sum((centers_array - candidate)**2, axis=1))\n                    # Maximum radius to avoid overlap\n                    max_r_circles = distances - radii_array\n                    max_r = min(max_r, np.min(max_r_circles))\n                \n                if max_r > best_radius:\n                    best_radius = max_r\n                    best_pos = candidate\n            \n            if best_radius > 0:\n                centers.append(best_pos)\n                radii.append(best_radius)\n        \n        return np.array(centers), np.array(radii)\n    \n    # Try multiple seeds and keep best\n    best_centers = None\n    best_radii = None\n    best_sum = 0\n    \n    seeds = [42, 123, 456, 789, 1337, 2024, 9999]\n    \n    for seed in seeds:\n        centers, radii = greedy_packing(seed)\n        current_sum = np.sum(radii)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    centers = best_centers\n    radii = best_radii\n    \n    # Local refinement: adjust positions slightly\n    def local_search(centers, radii, iterations=100):\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n        best_sum = np.sum(radii)\n        \n        for _ in range(iterations):\n            # Pick a random circle\n            idx = np.random.randint(n)\n            \n            # Try small perturbations\n            for _ in range(20):\n                new_center = centers[idx] + np.random.randn(2) * 0.02\n                new_center = np.clip(new_center, 0, 1)\n                \n                # Calculate max radius at new position\n                max_r = min(new_center[0], new_center[1], 1 - new_center[0], 1 - new_center[1])\n                \n                # Check with other circles\n                for j in range(n):\n                    if j != idx:\n                        dist = np.sqrt(np.sum((centers[j] - new_center)**2))\n                        max_r = min(max_r, dist - radii[j])\n                \n                if max_r > 0:\n                    # Try this configuration\n                    test_centers = centers.copy()\n                    test_radii = radii.copy()\n                    test_centers[idx] = new_center\n                    test_radii[idx] = max_r\n                    \n                    test_sum = np.sum(test_radii)\n                    if test_sum > best_sum:\n                        best_sum = test_sum\n                        best_centers = test_centers.copy()\n                        best_radii = test_radii.copy()\n                        centers = best_centers.copy()\n                        radii = best_radii.copy()\n        \n        return best_centers, best_radii\n    \n    centers, radii = local_search(centers, radii, iterations=150)\n    \n    # Final optimization with scipy\n    def objective(x):\n        n_circles = len(radii)\n        radii_opt = x[n_circles*2:]\n        return -np.sum(radii_opt)\n    \n    def constraint_boundary(x):\n        n_circles = len(radii)\n        centers_opt = x[:n_circles*2].reshape(n_circles, 2)\n        radii_opt = x[n_circles*2:]\n        \n        constraints = []\n        for i in range(n_circles):\n            constraints.extend([\n                centers_opt[i, 0] - radii_opt[i],\n                centers_opt[i, 1] - radii_opt[i],\n                1 - centers_opt[i, 0] - radii_opt[i],\n                1 - centers_opt[i, 1] - radii_opt[i]\n            ])\n        return np.array(constraints)\n    \n    def constraint_overlap(x):\n        n_circles = len(radii)\n        centers_opt = x[:n_circles*2].reshape(n_circles, 2)\n        radii_opt = x[n_circles*2:]\n        \n        constraints = []\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt(np.sum((centers_opt[i] - centers_opt[j])**2))\n                constraints.append(dist - radii_opt[i] - radii_opt[j])\n        return np.array(constraints)\n    \n    x0 = np.concatenate([centers.ravel(), radii])\n    bounds = [(0, 1)] * (n * 2) + [(0, 0.5)] * n\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_boundary},\n        {'type': 'ineq', 'fun': constraint_overlap}\n    ]\n    \n    # Multiple optimization attempts\n    best_result = None\n    best_value = float('inf')\n    \n    for attempt in range(5):\n        try:\n            if attempt > 0:\n                x0_perturbed = x0 + np.random.randn(len(x0)) * 0.005\n                x0_perturbed[:n*2] = np.clip(x0_perturbed[:n*2], 0.01, 0.99)\n                x0_perturbed[n*2:] = np.clip(x0_perturbed[n*2:], 0, 0.4)\n            else:\n                x0_perturbed = x0\n            \n            result = minimize(\n                objective,\n                x0_perturbed,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 1000, 'ftol': 1e-10}\n            )\n            \n            if result.fun < best_value:\n                best_result = result\n                best_value = result.fun\n        except:\n            pass\n    \n    if best_result is not None:\n        centers = best_result.x[:n*2].reshape(n, 2)\n        radii = best_result.x[n*2:]\n    \n    radii = np.maximum(radii, 0)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nThen apply analytical gradient optimization from trial_2_12:\nimport numpy as np\nfrom scipy.optimize import minimize, LinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using analytical gradients.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Initialize with a grid-based layout\n    grid_size = int(np.ceil(np.sqrt(n)))\n    initial_centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        initial_centers.append([x, y])\n    initial_centers = np.array(initial_centers)\n    \n    # Initialize radii to maximum possible given grid spacing\n    initial_radius = 0.45 / grid_size\n    initial_radii = np.full(n, initial_radius)\n    \n    # Combine into single parameter vector: [centers (flattened), radii]\n    x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n    \n    def unpack_params(x):\n        \"\"\"Unpack parameter vector into centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Objective: maximize sum of radii (minimize negative sum).\"\"\"\n        _, radii = unpack_params(x)\n        return -np.sum(radii)\n    \n    def gradient(x):\n        \"\"\"Analytical gradient of objective.\"\"\"\n        grad = np.zeros_like(x)\n        # Gradient w.r.t. centers is 0\n        # Gradient w.r.t. radii is -1 (since we minimize negative sum)\n        grad[2*n:] = -1.0\n        return grad\n    \n    def constraints_and_jacobian(x):\n        \"\"\"\n        Compute constraint violations and Jacobian.\n        \n        Constraints:\n        1. Centers must be inside square: r_i <= x_i <= 1-r_i, r_i <= y_i <= 1-r_i\n        2. Non-overlap: ||c_i - c_j|| >= r_i + r_j for all i < j\n        3. Non-negative radii: r_i >= 0\n        \"\"\"\n        centers, radii = unpack_params(x)\n        \n        constraints = []\n        jacobian_rows = []\n        \n        # Boundary constraints: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n        for i in range(n):\n            # x_i >= r_i\n            constraints.append(centers[i, 0] - radii[i])\n            jac = np.zeros(3*n)\n            jac[2*i] = 1.0\n            jac[2*n + i] = -1.0\n            jacobian_rows.append(jac)\n            \n            # x_i <= 1 - r_i\n            constraints.append(1.0 - centers[i, 0] - radii[i])\n            jac = np.zeros(3*n)\n            jac[2*i] = -1.0\n            jac[2*n + i] = -1.0\n            jacobian_rows.append(jac)\n            \n            # y_i >= r_i\n            constraints.append(centers[i, 1] - radii[i])\n            jac = np.zeros(3*n)\n            jac[2*i + 1] = 1.0\n            jac[2*n + i] = -1.0\n            jacobian_rows.append(jac)\n            \n            # y_i <= 1 - r_i\n            constraints.append(1.0 - centers[i, 1] - radii[i])\n            jac = np.zeros(3*n)\n            jac[2*i + 1] = -1.0\n            jac[2*n + i] = -1.0\n            jacobian_rows.append(jac)\n            \n            # r_i >= 0\n            constraints.append(radii[i])\n            jac = np.zeros(3*n)\n            jac[2*n + i] = 1.0\n            jacobian_rows.append(jac)\n        \n        # Non-overlap constraints: ||c_i - c_j||^2 >= (r_i + r_j)^2\n        for i in range(n):\n            for j in range(i+1, n):\n                diff = centers[i] - centers[j]\n                dist_sq = np.sum(diff**2)\n                dist = np.sqrt(dist_sq + 1e-10)\n                \n                # Constraint: dist - (r_i + r_j) >= 0\n                constraints.append(dist - radii[i] - radii[j])\n                \n                # Jacobian\n                jac = np.zeros(3*n)\n                if dist > 1e-10:\n                    jac[2*i] = diff[0] / dist\n                    jac[2*i + 1] = diff[1] / dist\n                    jac[2*j] = -diff[0] / dist\n                    jac[2*j + 1] = -diff[1] / dist\n                jac[2*n + i] = -1.0\n                jac[2*n + j] = -1.0\n                jacobian_rows.append(jac)\n        \n        return np.array(constraints), np.array(jacobian_rows)\n    \n    def constraint_func(x):\n        \"\"\"Constraint function for optimizer.\"\"\"\n        cons, _ = constraints_and_jacobian(x)\n        return cons\n    \n    def constraint_jacobian(x):\n        \"\"\"Jacobian of constraints.\"\"\"\n        _, jac = constraints_and_jacobian(x)\n        return jac\n    \n    # Set up constraint\n    num_constraints = 5*n + n*(n-1)//2\n    constraint = {\n        'type': 'ineq',\n        'fun': constraint_func,\n        'jac': constraint_jacobian\n    }\n    \n    # Optimize using SLSQP with analytical gradients\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        jac=gradient,\n        constraints=constraint,\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n    \n    # Try multiple random restarts for better solution\n    best_result = result\n    best_obj = result.fun\n    \n    for restart in range(5):\n        # Random initialization with some structure\n        perturb = np.random.randn(3*n) * 0.05\n        x_init = x0 + perturb\n        \n        # Ensure initial feasibility\n        centers_init, radii_init = unpack_params(x_init)\n        radii_init = np.maximum(radii_init, 0.01)\n        centers_init = np.clip(centers_init, radii_init[:, None], 1 - radii_init[:, None])\n        x_init = np.concatenate([centers_init.flatten(), radii_init])\n        \n        result_restart = minimize(\n            objective,\n            x_init,\n            method='SLSQP',\n            jac=gradient,\n            constraints=constraint,\n            options={'maxiter': 1000, 'ftol': 1e-9}\n        )\n        \n        if result_restart.fun < best_obj:\n            best_result = result_restart\n            best_obj = result_restart.fun\n    \n    # Extract final solution\n    final_centers, final_radii = unpack_params(best_result.x)\n    sum_radii = np.sum(final_radii)\n    \n    return final_centers, final_radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nStrategy:\n1. Use sequential placement for initial configuration\n2. Apply analytical gradient ascent for refinement\n3. Use line search for optimal step sizes\n4. Run until convergence\n5. Final scipy polish\n\nRequirements:\n- Sequential init + analytical gradients\n- Careful integration\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Hybrid approach: sequential placement + analytical gradient optimization.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Phase 1: Sequential greedy placement\n    def greedy_packing(seed):\n        np.random.seed(seed)\n        centers = []\n        radii = []\n        \n        for i in range(n):\n            best_pos = None\n            best_radius = 0\n            \n            # Adaptive candidate generation\n            n_random = 3000\n            n_grid = 30\n            \n            # Random candidates\n            candidates = np.random.rand(n_random, 2)\n            \n            # Dense grid candidates\n            x_grid = np.linspace(0.02, 0.98, n_grid)\n            y_grid = np.linspace(0.02, 0.98, n_grid)\n            xx, yy = np.meshgrid(x_grid, y_grid)\n            grid_candidates = np.column_stack([xx.ravel(), yy.ravel()])\n            candidates = np.vstack([candidates, grid_candidates])\n            \n            # Strategic candidates: focus on corners and edges for first few circles\n            if i < 8:\n                corner_candidates = np.array([\n                    [0.1, 0.1], [0.9, 0.1], [0.1, 0.9], [0.9, 0.9],\n                    [0.5, 0.1], [0.5, 0.9], [0.1, 0.5], [0.9, 0.5],\n                    [0.3, 0.3], [0.7, 0.3], [0.3, 0.7], [0.7, 0.7]\n                ])\n                candidates = np.vstack([candidates, corner_candidates])\n            \n            # Gap filling candidates\n            if len(centers) > 2:\n                centers_array = np.array(centers)\n                radii_array = np.array(radii)\n                \n                for j in range(min(5, len(centers))):\n                    angles = np.linspace(0, 2*np.pi, 20)\n                    dist = radii_array[j] * 2.2\n                    gap_candidates = centers_array[j] + dist * np.column_stack([np.cos(angles), np.sin(angles)])\n                    gap_candidates = np.clip(gap_candidates, 0, 1)\n                    candidates = np.vstack([candidates, gap_candidates])\n            \n            for candidate in candidates:\n                x, y = candidate\n                \n                # Maximum radius from boundaries\n                max_r = min(x, y, 1 - x, 1 - y)\n                \n                if max_r <= 0:\n                    continue\n                \n                # Check constraints with existing circles\n                if len(centers) > 0:\n                    centers_array = np.array(centers)\n                    radii_array = np.array(radii)\n                    \n                    distances = np.sqrt(np.sum((centers_array - candidate)**2, axis=1))\n                    max_r_circles = distances - radii_array\n                    max_r = min(max_r, np.min(max_r_circles))\n                \n                if max_r > best_radius:\n                    best_radius = max_r\n                    best_pos = candidate\n            \n            if best_radius > 0:\n                centers.append(best_pos)\n                radii.append(best_radius)\n        \n        return np.array(centers), np.array(radii)\n    \n    # Try multiple seeds and keep best\n    best_centers = None\n    best_radii = None\n    best_sum = 0\n    \n    seeds = [42, 123, 456, 789, 1337, 2024, 9999]\n    \n    for seed in seeds:\n        centers, radii = greedy_packing(seed)\n        current_sum = np.sum(radii)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    centers = best_centers\n    radii = best_radii\n    \n    # Phase 2: Analytical gradient optimization\n    def unpack_params(x):\n        \"\"\"Unpack parameter vector into centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def compute_constraints_and_gradients(x):\n        \"\"\"\n        Compute constraint violations and gradients.\n        Returns constraint values (positive = satisfied) and gradients.\n        \"\"\"\n        centers, radii = unpack_params(x)\n        \n        # Boundary constraints\n        boundary_constraints = []\n        boundary_gradients = []\n        \n        for i in range(n):\n            # x_i >= r_i\n            boundary_constraints.append(centers[i, 0] - radii[i])\n            grad = np.zeros(3*n)\n            grad[2*i] = 1.0\n            grad[2*n + i] = -1.0\n            boundary_gradients.append(grad)\n            \n            # x_i <= 1 - r_i\n            boundary_constraints.append(1.0 - centers[i, 0] - radii[i])\n            grad = np.zeros(3*n)\n            grad[2*i] = -1.0\n            grad[2*n + i] = -1.0\n            boundary_gradients.append(grad)\n            \n            # y_i >= r_i\n            boundary_constraints.append(centers[i, 1] - radii[i])\n            grad = np.zeros(3*n)\n            grad[2*i + 1] = 1.0\n            grad[2*n + i] = -1.0\n            boundary_gradients.append(grad)\n            \n            # y_i <= 1 - r_i\n            boundary_constraints.append(1.0 - centers[i, 1] - radii[i])\n            grad = np.zeros(3*n)\n            grad[2*i + 1] = -1.0\n            grad[2*n + i] = -1.0\n            boundary_gradients.append(grad)\n        \n        # Non-overlap constraints\n        overlap_constraints = []\n        overlap_gradients = []\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                diff = centers[i] - centers[j]\n                dist_sq = np.sum(diff**2)\n                dist = np.sqrt(dist_sq + 1e-10)\n                \n                # Constraint: dist - (r_i + r_j) >= 0\n                overlap_constraints.append(dist - radii[i] - radii[j])\n                \n                grad = np.zeros(3*n)\n                if dist > 1e-10:\n                    grad[2*i] = diff[0] / dist\n                    grad[2*i + 1] = diff[1] / dist\n                    grad[2*j] = -diff[0] / dist\n                    grad[2*j + 1] = -diff[1] / dist\n                grad[2*n + i] = -1.0\n                grad[2*n + j] = -1.0\n                overlap_gradients.append(grad)\n        \n        return (np.array(boundary_constraints), np.array(boundary_gradients),\n                np.array(overlap_constraints), np.array(overlap_gradients))\n    \n    def gradient_ascent_step(x, learning_rate=0.01):\n        \"\"\"\n        Perform one step of gradient ascent with constraint handling.\n        \"\"\"\n        centers, radii = unpack_params(x)\n        \n        # Objective gradient: maximize sum of radii\n        obj_gradient = np.zeros(3*n)\n        obj_gradient[2*n:] = 1.0  # Gradient w.r.t. radii\n        \n        # Get constraints and their gradients\n        boundary_cons, boundary_grads, overlap_cons, overlap_grads = compute_constraints_and_gradients(x)\n        \n        # Projected gradient: project away from violated constraints\n        gradient = obj_gradient.copy()\n        \n        # Handle violated boundary constraints\n        violated_boundary = boundary_cons < 0.01\n        if np.any(violated_boundary):\n            for idx in np.where(violated_boundary)[0]:\n                # Project gradient to satisfy constraint\n                constraint_grad = boundary_grads[idx]\n                projection = np.dot(gradient, constraint_grad)\n                if projection < 0:\n                    gradient -= projection * constraint_grad\n        \n        # Handle violated overlap constraints\n        violated_overlap = overlap_cons < 0.01\n        if np.any(violated_overlap):\n            for idx in np.where(violated_overlap)[0]:\n                constraint_grad = overlap_grads[idx]\n                projection = np.dot(gradient, constraint_grad)\n                if projection < 0:\n                    gradient -= projection * constraint_grad\n        \n        # Line search for optimal step size\n        best_x = x.copy()\n        best_sum = np.sum(radii)\n        \n        for alpha in [learning_rate, learning_rate/2, learning_rate/4, learning_rate/8]:\n            x_new = x + alpha * gradient\n            \n            # Check feasibility\n            boundary_cons_new, _, overlap_cons_new, _ = compute_constraints_and_gradients(x_new)\n            \n            if np.all(boundary_cons_new >= -1e-6) and np.all(overlap_cons_new >= -1e-6):\n                _, radii_new = unpack_params(x_new)\n                sum_new = np.sum(radii_new)\n                if sum_new > best_sum:\n                    best_sum = sum_new\n                    best_x = x_new\n        \n        return best_x\n    \n    # Initialize from sequential placement\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    # Gradient ascent iterations\n    x = x0.copy()\n    prev_sum = np.sum(radii)\n    \n    for iteration in range(100):\n        x_new = gradient_ascent_step(x, learning_rate=0.02)\n        _, radii_new = unpack_params(x_new)\n        current_sum = np.sum(radii_new)\n        \n        if current_sum - prev_sum < 1e-6:\n            break\n        \n        x = x_new\n        prev_sum = current_sum\n    \n    # Phase 3: Final scipy polish\n    def objective(x):\n        _, radii = unpack_params(x)\n        return -np.sum(radii)\n    \n    def constraint_func(x):\n        boundary_cons, _, overlap_cons, _ = compute_constraints_and_gradients(x)\n        return np.concatenate([boundary_cons, overlap_cons])\n    \n    def constraint_jacobian(x):\n        boundary_cons, boundary_grads, overlap_cons, overlap_grads = compute_constraints_and_gradients(x)\n        return np.vstack([boundary_grads, overlap_grads])\n    \n    constraint = {\n        'type': 'ineq',\n        'fun': constraint_func,\n        'jac': constraint_jacobian\n    }\n    \n    result = minimize(\n        objective,\n        x,\n        method='SLSQP',\n        jac=lambda x: -np.concatenate([np.zeros(2*n), np.ones(n)]),\n        constraints=constraint,\n        options={'maxiter': 1000, 'ftol': 1e-10}\n    )\n    \n    # Extract final solution\n    final_centers, final_radii = unpack_params(result.x)\n    final_radii = np.maximum(final_radii, 0)\n    sum_radii = np.sum(final_radii)\n    \n    return final_centers, final_radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T18:14:21.023933",
  "cost_data": null
}