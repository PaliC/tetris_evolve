{
  "trial_id": "trial_3_14",
  "generation": 3,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using\n    pattern search with adaptive mesh refinement.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Initialize with hexagonal-like grid\n    centers, radii = initialize_hexagonal_packing(n)\n    \n    # Pattern search with adaptive mesh refinement\n    centers, radii = pattern_search_optimization(centers, radii, n)\n    \n    # Final polish with scipy\n    centers, radii = scipy_polish(centers, radii, n)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef initialize_hexagonal_packing(n):\n    \"\"\"Initialize with approximate hexagonal packing.\"\"\"\n    # Use a grid-based initialization\n    cols = int(np.ceil(np.sqrt(n * 1.15)))\n    rows = int(np.ceil(n / cols))\n    \n    centers = []\n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) >= n:\n                break\n            # Hexagonal offset\n            offset = 0.5 * (i % 2)\n            x = (j + offset + 0.5) / (cols + 0.5)\n            y = (i + 0.5) / (rows + 0.5)\n            centers.append([x, y])\n    \n    centers = np.array(centers[:n])\n    \n    # Initialize radii based on spacing\n    radii = compute_max_radii(centers)\n    \n    return centers, radii\n\ndef compute_max_radii(centers):\n    \"\"\"Compute maximum feasible radii for given centers.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Distance to boundaries\n        r_max = min(\n            centers[i, 0],           # left\n            1 - centers[i, 0],       # right\n            centers[i, 1],           # bottom\n            1 - centers[i, 1]        # top\n        )\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                r_max = min(r_max, (dist - radii[j]) / 2)\n        \n        radii[i] = max(0, r_max)\n    \n    return radii\n\ndef pattern_search_optimization(centers, radii, n, max_iter=500):\n    \"\"\"Pattern search with adaptive mesh refinement.\"\"\"\n    \n    # Define search pattern: coordinate directions + diagonals\n    pattern = np.array([\n        [1, 0], [-1, 0], [0, 1], [0, -1],  # Coordinate directions\n        [1, 1], [1, -1], [-1, 1], [-1, -1],  # Diagonals\n        [0.5, 0.5], [0.5, -0.5], [-0.5, 0.5], [-0.5, -0.5]  # Half diagonals\n    ])\n    \n    step_size = 0.05  # Initial step size\n    min_step = 1e-5\n    reduction_factor = 0.7\n    expansion_factor = 1.2\n    \n    best_sum = np.sum(radii)\n    \n    for iteration in range(max_iter):\n        improved = False\n        \n        # Try moving each circle\n        for i in range(n):\n            best_local_sum = best_sum\n            best_local_center = centers[i].copy()\n            \n            # Try each pattern direction\n            for direction in pattern:\n                new_center = centers[i] + step_size * direction\n                \n                # Check if new center is valid\n                if not (0 <= new_center[0] <= 1 and 0 <= new_center[1] <= 1):\n                    continue\n                \n                # Temporarily update center\n                old_center = centers[i].copy()\n                centers[i] = new_center\n                \n                # Recompute radii\n                new_radii = compute_max_radii(centers)\n                new_sum = np.sum(new_radii)\n                \n                # Check if improvement\n                if new_sum > best_local_sum:\n                    best_local_sum = new_sum\n                    best_local_center = new_center.copy()\n                    improved = True\n                \n                # Restore old center\n                centers[i] = old_center\n            \n            # Apply best local move\n            if best_local_sum > best_sum:\n                centers[i] = best_local_center\n                radii = compute_max_radii(centers)\n                best_sum = best_local_sum\n        \n        # Adaptive step size control\n        if improved:\n            step_size = min(step_size * expansion_factor, 0.1)\n        else:\n            step_size *= reduction_factor\n        \n        # Termination check\n        if step_size < min_step:\n            break\n    \n    return centers, radii\n\ndef scipy_polish(centers, radii, n, max_iter=100):\n    \"\"\"Polish solution using scipy optimization.\"\"\"\n    \n    def objective(x):\n        \"\"\"Negative sum of radii (for minimization).\"\"\"\n        centers_flat = x.reshape(n, 2)\n        radii_local = compute_max_radii(centers_flat)\n        return -np.sum(radii_local)\n    \n    def constraint_boundary(x):\n        \"\"\"Ensure circles stay within boundaries.\"\"\"\n        centers_flat = x.reshape(n, 2)\n        radii_local = compute_max_radii(centers_flat)\n        \n        constraints = []\n        for i in range(n):\n            constraints.append(centers_flat[i, 0] - radii_local[i])  # left\n            constraints.append(1 - centers_flat[i, 0] - radii_local[i])  # right\n            constraints.append(centers_flat[i, 1] - radii_local[i])  # bottom\n            constraints.append(1 - centers_flat[i, 1] - radii_local[i])  # top\n        \n        return np.array(constraints)\n    \n    def constraint_overlap(x):\n        \"\"\"Ensure no overlaps.\"\"\"\n        centers_flat = x.reshape(n, 2)\n        radii_local = compute_max_radii(centers_flat)\n        \n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers_flat[i] - centers_flat[j])\n                constraints.append(dist - radii_local[i] - radii_local[j])\n        \n        return np.array(constraints)\n    \n    # Bounds\n    bounds = [(0, 1)] * (2 * n)\n    \n    # Constraints\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_boundary},\n        {'type': 'ineq', 'fun': constraint_overlap}\n    ]\n    \n    # Optimize with multiple methods\n    x0 = centers.flatten()\n    \n    # Try L-BFGS-B (respects bounds well)\n    result = minimize(\n        objective,\n        x0,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': max_iter, 'ftol': 1e-8}\n    )\n    \n    centers_opt = result.x.reshape(n, 2)\n    radii_opt = compute_max_radii(centers_opt)\n    \n    # Only accept if valid and better\n    if np.all(radii_opt >= 0) and np.sum(radii_opt) > np.sum(radii):\n        return centers_opt, radii_opt\n    \n    return centers, radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.8035599573393948,
    "target_ratio": 0.6844629819124839,
    "combined_score": 0.6844629819124839,
    "eval_time": 2383.322354078293,
    "error": null
  },
  "prompt": "Create pattern search optimizer with adaptive mesh refinement.\n\nStrategy:\n1. Start with good initialization\n2. Define search pattern (coordinate directions + diagonals)\n3. For each iteration:\n   - Try moves in all pattern directions\n   - Accept best improvement\n   - If no improvement, reduce step size\n4. Adaptive mesh: coarse initially, progressively finer\n5. Final scipy polish\n\nRequirements:\n- Pattern search implementation\n- Adaptive step size control\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using\n    pattern search with adaptive mesh refinement.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Initialize with hexagonal-like grid\n    centers, radii = initialize_hexagonal_packing(n)\n    \n    # Pattern search with adaptive mesh refinement\n    centers, radii = pattern_search_optimization(centers, radii, n)\n    \n    # Final polish with scipy\n    centers, radii = scipy_polish(centers, radii, n)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef initialize_hexagonal_packing(n):\n    \"\"\"Initialize with approximate hexagonal packing.\"\"\"\n    # Use a grid-based initialization\n    cols = int(np.ceil(np.sqrt(n * 1.15)))\n    rows = int(np.ceil(n / cols))\n    \n    centers = []\n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) >= n:\n                break\n            # Hexagonal offset\n            offset = 0.5 * (i % 2)\n            x = (j + offset + 0.5) / (cols + 0.5)\n            y = (i + 0.5) / (rows + 0.5)\n            centers.append([x, y])\n    \n    centers = np.array(centers[:n])\n    \n    # Initialize radii based on spacing\n    radii = compute_max_radii(centers)\n    \n    return centers, radii\n\ndef compute_max_radii(centers):\n    \"\"\"Compute maximum feasible radii for given centers.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Distance to boundaries\n        r_max = min(\n            centers[i, 0],           # left\n            1 - centers[i, 0],       # right\n            centers[i, 1],           # bottom\n            1 - centers[i, 1]        # top\n        )\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                r_max = min(r_max, (dist - radii[j]) / 2)\n        \n        radii[i] = max(0, r_max)\n    \n    return radii\n\ndef pattern_search_optimization(centers, radii, n, max_iter=500):\n    \"\"\"Pattern search with adaptive mesh refinement.\"\"\"\n    \n    # Define search pattern: coordinate directions + diagonals\n    pattern = np.array([\n        [1, 0], [-1, 0], [0, 1], [0, -1],  # Coordinate directions\n        [1, 1], [1, -1], [-1, 1], [-1, -1],  # Diagonals\n        [0.5, 0.5], [0.5, -0.5], [-0.5, 0.5], [-0.5, -0.5]  # Half diagonals\n    ])\n    \n    step_size = 0.05  # Initial step size\n    min_step = 1e-5\n    reduction_factor = 0.7\n    expansion_factor = 1.2\n    \n    best_sum = np.sum(radii)\n    \n    for iteration in range(max_iter):\n        improved = False\n        \n        # Try moving each circle\n        for i in range(n):\n            best_local_sum = best_sum\n            best_local_center = centers[i].copy()\n            \n            # Try each pattern direction\n            for direction in pattern:\n                new_center = centers[i] + step_size * direction\n                \n                # Check if new center is valid\n                if not (0 <= new_center[0] <= 1 and 0 <= new_center[1] <= 1):\n                    continue\n                \n                # Temporarily update center\n                old_center = centers[i].copy()\n                centers[i] = new_center\n                \n                # Recompute radii\n                new_radii = compute_max_radii(centers)\n                new_sum = np.sum(new_radii)\n                \n                # Check if improvement\n                if new_sum > best_local_sum:\n                    best_local_sum = new_sum\n                    best_local_center = new_center.copy()\n                    improved = True\n                \n                # Restore old center\n                centers[i] = old_center\n            \n            # Apply best local move\n            if best_local_sum > best_sum:\n                centers[i] = best_local_center\n                radii = compute_max_radii(centers)\n                best_sum = best_local_sum\n        \n        # Adaptive step size control\n        if improved:\n            step_size = min(step_size * expansion_factor, 0.1)\n        else:\n            step_size *= reduction_factor\n        \n        # Termination check\n        if step_size < min_step:\n            break\n    \n    return centers, radii\n\ndef scipy_polish(centers, radii, n, max_iter=100):\n    \"\"\"Polish solution using scipy optimization.\"\"\"\n    \n    def objective(x):\n        \"\"\"Negative sum of radii (for minimization).\"\"\"\n        centers_flat = x.reshape(n, 2)\n        radii_local = compute_max_radii(centers_flat)\n        return -np.sum(radii_local)\n    \n    def constraint_boundary(x):\n        \"\"\"Ensure circles stay within boundaries.\"\"\"\n        centers_flat = x.reshape(n, 2)\n        radii_local = compute_max_radii(centers_flat)\n        \n        constraints = []\n        for i in range(n):\n            constraints.append(centers_flat[i, 0] - radii_local[i])  # left\n            constraints.append(1 - centers_flat[i, 0] - radii_local[i])  # right\n            constraints.append(centers_flat[i, 1] - radii_local[i])  # bottom\n            constraints.append(1 - centers_flat[i, 1] - radii_local[i])  # top\n        \n        return np.array(constraints)\n    \n    def constraint_overlap(x):\n        \"\"\"Ensure no overlaps.\"\"\"\n        centers_flat = x.reshape(n, 2)\n        radii_local = compute_max_radii(centers_flat)\n        \n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers_flat[i] - centers_flat[j])\n                constraints.append(dist - radii_local[i] - radii_local[j])\n        \n        return np.array(constraints)\n    \n    # Bounds\n    bounds = [(0, 1)] * (2 * n)\n    \n    # Constraints\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_boundary},\n        {'type': 'ineq', 'fun': constraint_overlap}\n    ]\n    \n    # Optimize with multiple methods\n    x0 = centers.flatten()\n    \n    # Try L-BFGS-B (respects bounds well)\n    result = minimize(\n        objective,\n        x0,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': max_iter, 'ftol': 1e-8}\n    )\n    \n    centers_opt = result.x.reshape(n, 2)\n    radii_opt = compute_max_radii(centers_opt)\n    \n    # Only accept if valid and better\n    if np.all(radii_opt >= 0) and np.sum(radii_opt) > np.sum(radii):\n        return centers_opt, radii_opt\n    \n    return centers, radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T18:53:49.183453",
  "cost_data": null
}