{
  "trial_id": "trial_3_10",
  "generation": 3,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using SQP.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def constraints_and_jac(x):\n        \"\"\"\n        Compute all constraints and their Jacobian.\n        Returns: (constraints_vector, jacobian_matrix)\n        \"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        # Number of constraints\n        n_overlap = n * (n - 1) // 2\n        n_bounds = 4 * n\n        n_total = n_overlap + n_bounds\n        \n        constraints = np.zeros(n_total)\n        jacobian = np.zeros((n_total, 3*n))\n        \n        # Overlap constraints: dist(i,j) >= r_i + r_j\n        idx = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                dist = np.sqrt(dx**2 + dy**2 + 1e-16)\n                \n                constraints[idx] = dist - radii[i] - radii[j]\n                \n                # Jacobian\n                if dist > 1e-10:\n                    jacobian[idx, 2*i] = dx / dist      # d/dx_i\n                    jacobian[idx, 2*i+1] = dy / dist    # d/dy_i\n                    jacobian[idx, 2*j] = -dx / dist     # d/dx_j\n                    jacobian[idx, 2*j+1] = -dy / dist   # d/dy_j\n                \n                jacobian[idx, 2*n+i] = -1  # d/dr_i\n                jacobian[idx, 2*n+j] = -1  # d/dr_j\n                \n                idx += 1\n        \n        # Boundary constraints\n        for i in range(n):\n            # x - r >= 0\n            constraints[idx] = centers[i, 0] - radii[i]\n            jacobian[idx, 2*i] = 1\n            jacobian[idx, 2*n+i] = -1\n            idx += 1\n            \n            # x + r <= 1 => 1 - x - r >= 0\n            constraints[idx] = 1 - centers[i, 0] - radii[i]\n            jacobian[idx, 2*i] = -1\n            jacobian[idx, 2*n+i] = -1\n            idx += 1\n            \n            # y - r >= 0\n            constraints[idx] = centers[i, 1] - radii[i]\n            jacobian[idx, 2*i+1] = 1\n            jacobian[idx, 2*n+i] = -1\n            idx += 1\n            \n            # y + r <= 1 => 1 - y - r >= 0\n            constraints[idx] = 1 - centers[i, 1] - radii[i]\n            jacobian[idx, 2*i+1] = -1\n            jacobian[idx, 2*n+i] = -1\n            idx += 1\n        \n        return constraints, jacobian\n    \n    def constraint_fun(x):\n        \"\"\"Constraint function for SLSQP.\"\"\"\n        c, _ = constraints_and_jac(x)\n        return c\n    \n    def constraint_jac(x):\n        \"\"\"Jacobian of constraints for SLSQP.\"\"\"\n        _, jac = constraints_and_jac(x)\n        return jac\n    \n    # Multiple initialization strategies\n    best_result = None\n    best_sum = -np.inf\n    \n    np.random.seed(42)\n    \n    # Strategy 1: Uniform grid with perturbations\n    for attempt in range(15):\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers_init = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5 + 0.1*np.random.randn()) / grid_size\n            y = (row + 0.5 + 0.1*np.random.randn()) / grid_size\n            centers_init.append([np.clip(x, 0.05, 0.95), np.clip(y, 0.05, 0.95)])\n        \n        centers_init = np.array(centers_init)\n        radii_init = np.full(n, 0.05 + 0.02*np.random.rand())\n        x0 = np.concatenate([centers_init.flatten(), radii_init])\n        \n        # Bounds\n        bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n        \n        # Optimize\n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            jac=lambda x: np.concatenate([np.zeros(2*n), -np.ones(n)]),\n            constraints={'type': 'ineq', 'fun': constraint_fun, 'jac': constraint_jac},\n            bounds=bounds,\n            options={'maxiter': 2000, 'ftol': 1e-12, 'disp': False}\n        )\n        \n        if result.success or result.fun < best_sum:\n            sum_radii = -result.fun\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_result = result\n    \n    # Strategy 2: Random initializations\n    for attempt in range(10):\n        centers_init = np.random.uniform(0.1, 0.9, (n, 2))\n        radii_init = np.random.uniform(0.03, 0.08, n)\n        x0 = np.concatenate([centers_init.flatten(), radii_init])\n        \n        bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n        \n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            jac=lambda x: np.concatenate([np.zeros(2*n), -np.ones(n)]),\n            constraints={'type': 'ineq', 'fun': constraint_fun, 'jac': constraint_jac},\n            bounds=bounds,\n            options={'maxiter': 2000, 'ftol': 1e-12, 'disp': False}\n        )\n        \n        if result.success or result.fun < best_sum:\n            sum_radii = -result.fun\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_result = result\n    \n    # Strategy 3: Hexagonal packing inspired\n    for attempt in range(5):\n        centers_init = []\n        for row in range(6):\n            for col in range(5):\n                if len(centers_init) >= n:\n                    break\n                x = (col + 0.5 * (row % 2) + 0.5) / 5.5\n                y = (row + 0.5) / 6.5\n                x += 0.05 * np.random.randn()\n                y += 0.05 * np.random.randn()\n                centers_init.append([np.clip(x, 0.05, 0.95), np.clip(y, 0.05, 0.95)])\n        \n        centers_init = np.array(centers_init[:n])\n        radii_init = np.full(n, 0.06 + 0.01*np.random.rand())\n        x0 = np.concatenate([centers_init.flatten(), radii_init])\n        \n        bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n        \n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            jac=lambda x: np.concatenate([np.zeros(2*n), -np.ones(n)]),\n            constraints={'type': 'ineq', 'fun': constraint_fun, 'jac': constraint_jac},\n            bounds=bounds,\n            options={'maxiter': 2000, 'ftol': 1e-12, 'disp': False}\n        )\n        \n        if result.success or result.fun < best_sum:\n            sum_radii = -result.fun\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_result = result\n    \n    # Extract best solution\n    if best_result is None:\n        # Fallback\n        centers = np.random.uniform(0.1, 0.9, (n, 2))\n        radii = np.full(n, 0.05)\n    else:\n        x_best = best_result.x\n        centers = x_best[:2*n].reshape(n, 2)\n        radii = x_best[2*n:]\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 3.838433027267456,
    "error": "Circle 0 at (0.0009625919337234804, 0.33276457976034735) with radius 0.33582394103201396 extends outside x-bounds"
  },
  "prompt": "Create sequential quadratic programming (SQP) optimizer.\n\nStrategy:\n1. Formulate as constrained optimization\n2. Use scipy SLSQP (Sequential Least Squares Programming)\n3. Provide analytical Jacobian of constraints\n4. Very tight tolerances\n5. Multiple restarts\n6. Final radius-only optimization\n\nRequirements:\n- Use SLSQP method\n- Analytical constraint Jacobian\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using SQP.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def constraints_and_jac(x):\n        \"\"\"\n        Compute all constraints and their Jacobian.\n        Returns: (constraints_vector, jacobian_matrix)\n        \"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        # Number of constraints\n        n_overlap = n * (n - 1) // 2\n        n_bounds = 4 * n\n        n_total = n_overlap + n_bounds\n        \n        constraints = np.zeros(n_total)\n        jacobian = np.zeros((n_total, 3*n))\n        \n        # Overlap constraints: dist(i,j) >= r_i + r_j\n        idx = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                dist = np.sqrt(dx**2 + dy**2 + 1e-16)\n                \n                constraints[idx] = dist - radii[i] - radii[j]\n                \n                # Jacobian\n                if dist > 1e-10:\n                    jacobian[idx, 2*i] = dx / dist      # d/dx_i\n                    jacobian[idx, 2*i+1] = dy / dist    # d/dy_i\n                    jacobian[idx, 2*j] = -dx / dist     # d/dx_j\n                    jacobian[idx, 2*j+1] = -dy / dist   # d/dy_j\n                \n                jacobian[idx, 2*n+i] = -1  # d/dr_i\n                jacobian[idx, 2*n+j] = -1  # d/dr_j\n                \n                idx += 1\n        \n        # Boundary constraints\n        for i in range(n):\n            # x - r >= 0\n            constraints[idx] = centers[i, 0] - radii[i]\n            jacobian[idx, 2*i] = 1\n            jacobian[idx, 2*n+i] = -1\n            idx += 1\n            \n            # x + r <= 1 => 1 - x - r >= 0\n            constraints[idx] = 1 - centers[i, 0] - radii[i]\n            jacobian[idx, 2*i] = -1\n            jacobian[idx, 2*n+i] = -1\n            idx += 1\n            \n            # y - r >= 0\n            constraints[idx] = centers[i, 1] - radii[i]\n            jacobian[idx, 2*i+1] = 1\n            jacobian[idx, 2*n+i] = -1\n            idx += 1\n            \n            # y + r <= 1 => 1 - y - r >= 0\n            constraints[idx] = 1 - centers[i, 1] - radii[i]\n            jacobian[idx, 2*i+1] = -1\n            jacobian[idx, 2*n+i] = -1\n            idx += 1\n        \n        return constraints, jacobian\n    \n    def constraint_fun(x):\n        \"\"\"Constraint function for SLSQP.\"\"\"\n        c, _ = constraints_and_jac(x)\n        return c\n    \n    def constraint_jac(x):\n        \"\"\"Jacobian of constraints for SLSQP.\"\"\"\n        _, jac = constraints_and_jac(x)\n        return jac\n    \n    # Multiple initialization strategies\n    best_result = None\n    best_sum = -np.inf\n    \n    np.random.seed(42)\n    \n    # Strategy 1: Uniform grid with perturbations\n    for attempt in range(15):\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers_init = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5 + 0.1*np.random.randn()) / grid_size\n            y = (row + 0.5 + 0.1*np.random.randn()) / grid_size\n            centers_init.append([np.clip(x, 0.05, 0.95), np.clip(y, 0.05, 0.95)])\n        \n        centers_init = np.array(centers_init)\n        radii_init = np.full(n, 0.05 + 0.02*np.random.rand())\n        x0 = np.concatenate([centers_init.flatten(), radii_init])\n        \n        # Bounds\n        bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n        \n        # Optimize\n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            jac=lambda x: np.concatenate([np.zeros(2*n), -np.ones(n)]),\n            constraints={'type': 'ineq', 'fun': constraint_fun, 'jac': constraint_jac},\n            bounds=bounds,\n            options={'maxiter': 2000, 'ftol': 1e-12, 'disp': False}\n        )\n        \n        if result.success or result.fun < best_sum:\n            sum_radii = -result.fun\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_result = result\n    \n    # Strategy 2: Random initializations\n    for attempt in range(10):\n        centers_init = np.random.uniform(0.1, 0.9, (n, 2))\n        radii_init = np.random.uniform(0.03, 0.08, n)\n        x0 = np.concatenate([centers_init.flatten(), radii_init])\n        \n        bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n        \n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            jac=lambda x: np.concatenate([np.zeros(2*n), -np.ones(n)]),\n            constraints={'type': 'ineq', 'fun': constraint_fun, 'jac': constraint_jac},\n            bounds=bounds,\n            options={'maxiter': 2000, 'ftol': 1e-12, 'disp': False}\n        )\n        \n        if result.success or result.fun < best_sum:\n            sum_radii = -result.fun\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_result = result\n    \n    # Strategy 3: Hexagonal packing inspired\n    for attempt in range(5):\n        centers_init = []\n        for row in range(6):\n            for col in range(5):\n                if len(centers_init) >= n:\n                    break\n                x = (col + 0.5 * (row % 2) + 0.5) / 5.5\n                y = (row + 0.5) / 6.5\n                x += 0.05 * np.random.randn()\n                y += 0.05 * np.random.randn()\n                centers_init.append([np.clip(x, 0.05, 0.95), np.clip(y, 0.05, 0.95)])\n        \n        centers_init = np.array(centers_init[:n])\n        radii_init = np.full(n, 0.06 + 0.01*np.random.rand())\n        x0 = np.concatenate([centers_init.flatten(), radii_init])\n        \n        bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n        \n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            jac=lambda x: np.concatenate([np.zeros(2*n), -np.ones(n)]),\n            constraints={'type': 'ineq', 'fun': constraint_fun, 'jac': constraint_jac},\n            bounds=bounds,\n            options={'maxiter': 2000, 'ftol': 1e-12, 'disp': False}\n        )\n        \n        if result.success or result.fun < best_sum:\n            sum_radii = -result.fun\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_result = result\n    \n    # Extract best solution\n    if best_result is None:\n        # Fallback\n        centers = np.random.uniform(0.1, 0.9, (n, 2))\n        radii = np.full(n, 0.05)\n    else:\n        x_best = best_result.x\n        centers = x_best[:2*n].reshape(n, 2)\n        radii = x_best[2*n:]\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T18:14:13.102272",
  "cost_data": null
}