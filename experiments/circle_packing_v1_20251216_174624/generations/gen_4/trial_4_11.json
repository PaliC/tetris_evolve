{
  "trial_id": "trial_4_11",
  "generation": 4,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import dual_annealing, minimize, NonlinearConstraint\nfrom typing import Tuple\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using dual annealing.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def decode_solution(x):\n        \"\"\"Decode flat parameter vector into centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii (maximize sum of radii).\"\"\"\n        _, radii = decode_solution(x)\n        return -np.sum(radii)\n    \n    def constraint_function(x):\n        \"\"\"\n        Compute all constraints as a vector.\n        Returns positive values when constraints are satisfied.\n        \"\"\"\n        centers, radii = decode_solution(x)\n        constraints = []\n        \n        # Boundary constraints: center \u00b1 radius must be in [0,1]\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left boundary\n            constraints.append(1.0 - centers[i, 0] - radii[i])  # right boundary\n            constraints.append(centers[i, 1] - radii[i])  # bottom boundary\n            constraints.append(1.0 - centers[i, 1] - radii[i])  # top boundary\n        \n        # Non-overlap constraints: distance > sum of radii\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                             (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        return np.array(constraints)\n    \n    # Bounds: centers in [0,1], radii in [0, 0.5]\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n    \n    best_solution = None\n    best_value = float('inf')\n    \n    # Run dual annealing with multiple random seeds\n    n_runs = 35\n    \n    for seed in range(n_runs):\n        # Initial guess: grid-like arrangement\n        grid_size = int(np.ceil(np.sqrt(n)))\n        initial_centers = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            initial_centers.extend([x, y])\n        \n        # Initial radii: small uniform values\n        initial_radii = [0.05] * n\n        x0 = np.array(initial_centers + initial_radii)\n        \n        # Add random perturbation based on seed\n        np.random.seed(seed)\n        x0 += np.random.randn(len(x0)) * 0.02\n        x0 = np.clip(x0, [b[0] for b in bounds], [b[1] for b in bounds])\n        \n        try:\n            result = dual_annealing(\n                objective,\n                bounds=bounds,\n                maxiter=5000,\n                initial_temp=5230,\n                restart_temp_ratio=2e-5,\n                visit=2.62,\n                accept=-5.0,\n                seed=seed,\n                x0=x0\n            )\n            \n            if result.fun < best_value:\n                # Verify constraints\n                constraints_val = constraint_function(result.x)\n                if np.all(constraints_val >= -1e-6):\n                    best_value = result.fun\n                    best_solution = result.x.copy()\n        except:\n            continue\n    \n    # Polish the best solution with trust-constr\n    if best_solution is not None:\n        try:\n            nlc = NonlinearConstraint(constraint_function, 0, np.inf)\n            \n            result_polish = minimize(\n                objective,\n                best_solution,\n                method='trust-constr',\n                constraints=[nlc],\n                bounds=bounds,\n                options={'maxiter': 2000, 'verbose': 0}\n            )\n            \n            # Use polished solution if it's better and feasible\n            constraints_val = constraint_function(result_polish.x)\n            if result_polish.fun < best_value and np.all(constraints_val >= -1e-6):\n                best_solution = result_polish.x\n                best_value = result_polish.fun\n        except:\n            pass\n    \n    # If no valid solution found, return a simple grid packing\n    if best_solution is None:\n        grid_size = int(np.ceil(np.sqrt(n)))\n        spacing = 1.0 / grid_size\n        radius = spacing / 2.5\n        \n        centers = []\n        radii = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) * spacing\n            y = (row + 0.5) * spacing\n            centers.append([x, y])\n            radii.append(radius)\n        \n        centers = np.array(centers)\n        radii = np.array(radii)\n        sum_radii = np.sum(radii)\n        \n        return centers, radii, sum_radii\n    \n    # Decode best solution\n    centers, radii = decode_solution(best_solution)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 300.0092782974243,
    "error": "Timeout after 300s"
  },
  "prompt": "Create dual annealing optimizer.\n\nStrategy:\n1. Use scipy.optimize.dual_annealing\n2. This combines simulated annealing with local search\n3. Settings:\n   - maxiter=5000\n   - initial_temp=5230\n   - restart_temp_ratio=2e-5\n   - visit=2.62\n   - accept=-5.0\n4. Run 30+ times with different seeds\n5. Polish top results with trust-constr\n6. Return best\n\nRequirements:\n- Dual annealing implementation\n- Multiple restarts\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import dual_annealing, minimize, NonlinearConstraint\nfrom typing import Tuple\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using dual annealing.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def decode_solution(x):\n        \"\"\"Decode flat parameter vector into centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii (maximize sum of radii).\"\"\"\n        _, radii = decode_solution(x)\n        return -np.sum(radii)\n    \n    def constraint_function(x):\n        \"\"\"\n        Compute all constraints as a vector.\n        Returns positive values when constraints are satisfied.\n        \"\"\"\n        centers, radii = decode_solution(x)\n        constraints = []\n        \n        # Boundary constraints: center \u00b1 radius must be in [0,1]\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left boundary\n            constraints.append(1.0 - centers[i, 0] - radii[i])  # right boundary\n            constraints.append(centers[i, 1] - radii[i])  # bottom boundary\n            constraints.append(1.0 - centers[i, 1] - radii[i])  # top boundary\n        \n        # Non-overlap constraints: distance > sum of radii\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                             (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        return np.array(constraints)\n    \n    # Bounds: centers in [0,1], radii in [0, 0.5]\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n    \n    best_solution = None\n    best_value = float('inf')\n    \n    # Run dual annealing with multiple random seeds\n    n_runs = 35\n    \n    for seed in range(n_runs):\n        # Initial guess: grid-like arrangement\n        grid_size = int(np.ceil(np.sqrt(n)))\n        initial_centers = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            initial_centers.extend([x, y])\n        \n        # Initial radii: small uniform values\n        initial_radii = [0.05] * n\n        x0 = np.array(initial_centers + initial_radii)\n        \n        # Add random perturbation based on seed\n        np.random.seed(seed)\n        x0 += np.random.randn(len(x0)) * 0.02\n        x0 = np.clip(x0, [b[0] for b in bounds], [b[1] for b in bounds])\n        \n        try:\n            result = dual_annealing(\n                objective,\n                bounds=bounds,\n                maxiter=5000,\n                initial_temp=5230,\n                restart_temp_ratio=2e-5,\n                visit=2.62,\n                accept=-5.0,\n                seed=seed,\n                x0=x0\n            )\n            \n            if result.fun < best_value:\n                # Verify constraints\n                constraints_val = constraint_function(result.x)\n                if np.all(constraints_val >= -1e-6):\n                    best_value = result.fun\n                    best_solution = result.x.copy()\n        except:\n            continue\n    \n    # Polish the best solution with trust-constr\n    if best_solution is not None:\n        try:\n            nlc = NonlinearConstraint(constraint_function, 0, np.inf)\n            \n            result_polish = minimize(\n                objective,\n                best_solution,\n                method='trust-constr',\n                constraints=[nlc],\n                bounds=bounds,\n                options={'maxiter': 2000, 'verbose': 0}\n            )\n            \n            # Use polished solution if it's better and feasible\n            constraints_val = constraint_function(result_polish.x)\n            if result_polish.fun < best_value and np.all(constraints_val >= -1e-6):\n                best_solution = result_polish.x\n                best_value = result_polish.fun\n        except:\n            pass\n    \n    # If no valid solution found, return a simple grid packing\n    if best_solution is None:\n        grid_size = int(np.ceil(np.sqrt(n)))\n        spacing = 1.0 / grid_size\n        radius = spacing / 2.5\n        \n        centers = []\n        radii = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) * spacing\n            y = (row + 0.5) * spacing\n            centers.append([x, y])\n            radii.append(radius)\n        \n        centers = np.array(centers)\n        radii = np.array(radii)\n        sum_radii = np.sum(radii)\n        \n        return centers, radii, sum_radii\n    \n    # Decode best solution\n    centers, radii = decode_solution(best_solution)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T19:01:43.793022",
  "cost_data": null
}