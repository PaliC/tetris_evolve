{
  "trial_id": "trial_4_3",
  "generation": 4,
  "parent_id": "trial_3_5",
  "code": "",
  "metrics": {},
  "prompt": "Optimize this force-directed approach to exceed 2.635:\n\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using hybrid optimization\n    with enhanced hexagonal initialization and optimized force-directed refinement.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Phase 1: Enhanced hexagonal initialization\n    def hexagonal_initialization():\n        \"\"\"Initialize with optimal hexagonal packing pattern.\"\"\"\n        rows = 5\n        cols = 6\n        \n        # Calculate optimal spacing for hexagonal packing\n        h_spacing = 1.0 / (cols - 0.5)\n        v_spacing = h_spacing * np.sqrt(3) / 2\n        \n        # Adjust to fit vertically\n        total_height = (rows - 1) * v_spacing\n        if total_height > 1.0:\n            scale = 0.95 / total_height\n            h_spacing *= scale\n            v_spacing *= scale\n        \n        theoretical_radius = h_spacing / 2.0 * 0.95\n        \n        centers = []\n        for row in range(rows):\n            for col in range(cols):\n                if len(centers) >= n:\n                    break\n                \n                x_offset = (h_spacing / 2) if row % 2 == 1 else 0\n                x = col * h_spacing + x_offset + h_spacing / 2\n                y = row * v_spacing + v_spacing / 2\n                \n                x = x * 0.9 + 0.05\n                y = y * 0.9 + 0.05\n                \n                if x >= 0 and x <= 1 and y >= 0 and y <= 1:\n                    centers.append([x, y])\n            \n            if len(centers) >= n:\n                break\n        \n        while len(centers) < n:\n            grid_size = int(np.ceil(np.sqrt(n)))\n            idx = len(centers)\n            row = idx // grid_size\n            col = idx % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            centers.append([x, y])\n        \n        centers = np.array(centers[:n])\n        radii = np.ones(n) * theoretical_radius\n        \n        return centers, radii\n    \n    # Phase 2: Optimized force-directed refinement with extensive iterations\n    def force_directed_refinement(centers, radii, n_iterations=150000):\n        \"\"\"Refine positions using force-directed approach with carefully tuned parameters.\"\"\"\n        velocities = np.zeros_like(centers)\n        \n        for iteration in range(n_iterations):\n            progress = iteration / n_iterations\n            \n            # Adaptive parameters - carefully tuned\n            # Start with high damping for stability, decrease for exploration, then increase again\n            if progress < 0.3:\n                damping = 0.92\n                dt = 0.0015\n            elif progress < 0.6:\n                damping = 0.80 + 0.10 * ((progress - 0.3) / 0.3)\n                dt = 0.0020\n            else:\n                damping = 0.90 + 0.05 * ((progress - 0.6) / 0.4)\n                dt = 0.0010\n            \n            forces = np.zeros_like(centers)\n            \n            # Repulsion between overlapping/close circles with tuned parameters\n            for i in range(n):\n                for j in range(i + 1, n):\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    min_dist = radii[i] + radii[j]\n                    \n                    # Activation threshold - start repulsion slightly before contact\n                    activation_threshold = min_dist * 1.08\n                    \n                    if dist < activation_threshold:\n                        if dist > 1e-8:\n                            overlap = max(0, min_dist - dist)\n                            near_overlap = max(0, activation_threshold - dist)\n                            \n                            # Stronger force for actual overlaps, gentler for proximity\n                            if overlap > 0:\n                                force_mag = 25.0 * overlap + 8.0 * near_overlap\n                            else:\n                                force_mag = 6.0 * near_overlap\n                            \n                            force_dir = diff / dist\n                            forces[i] += force_mag * force_dir\n                            forces[j] -= force_mag * force_dir\n            \n            # Boundary forces with smooth gradient and tuned strength\n            boundary_margin = 0.015\n            for i in range(n):\n                r = radii[i]\n                \n                # Left boundary\n                if centers[i, 0] - r < boundary_margin:\n                    penetration = r + boundary_margin - centers[i, 0]\n                    forces[i, 0] += 12.0 * penetration\n                \n                # Right boundary\n                if centers[i, 0] + r > 1 - boundary_margin:\n                    penetration = centers[i, 0] + r - (1 - boundary_margin)\n                    forces[i, 0] -= 12.0 * penetration\n                \n                # Bottom boundary\n                if centers[i, 1] - r < boundary_margin:\n                    penetration = r + boundary_margin - centers[i, 1]\n                    forces[i, 1] += 12.0 * penetration\n                \n                # Top boundary\n                if centers[i, 1] + r > 1 - boundary_margin:\n                    penetration = centers[i, 1] + r - (1 - boundary_margin)\n                    forces[i, 1] -= 12.0 * penetration\n            \n            # Update velocities and positions\n            velocities = velocities * damping + forces * dt\n            centers += velocities * dt\n            \n            # Clamp to valid range\n            for i in range(n):\n                r = radii[i]\n                centers[i, 0] = np.clip(centers[i, 0], r + 1e-6, 1 - r - 1e-6)\n                centers[i, 1] = np.clip(centers[i, 1], r + 1e-6, 1 - r - 1e-6)\n            \n            # Adaptive radius growth with careful scheduling\n            if iteration % 100 == 0:\n                # More aggressive growth early, conservative later\n                if progress < 0.25:\n                    growth_rate = 1.008\n                elif progress < 0.5:\n                    growth_rate = 1.004\n                elif progress < 0.7:\n                    growth_rate = 1.002\n                else:\n                    growth_rate = 1.001\n                \n                for i in range(n):\n                    test_radius = radii[i] * growth_rate\n                    \n                    can_increase = True\n                    \n                    # Check bounds\n                    if (centers[i, 0] - test_radius < 0 or \n                        centers[i, 0] + test_radius > 1 or\n                        centers[i, 1] - test_radius < 0 or \n                        centers[i, 1] + test_radius > 1):\n                        can_increase = False\n                    \n                    # Check overlaps\n                    if can_increase:\n                        for j in range(n):\n                            if i != j:\n                                dist = np.linalg.norm(centers[i] - centers[j])\n                                if dist < test_radius + radii[j] - 1e-8:\n                                    can_increase = False\n                                    break\n                    \n                    if can_increase:\n                        radii[i] = test_radius\n        \n        return centers, radii\n    \n    # Phase 3: Multiple scipy optimization runs with perturbations\n    def scipy_optimization(centers_init, radii_init, n_attempts=8):\n        \"\"\"Refine packing using scipy optimization with multiple attempts.\"\"\"\n        \n        def objective(x):\n            radii = x[2*n:]\n            return -np.sum(radii)\n        \n        constraints = []\n        \n        # Boundary constraints\n        for i in range(n):\n            constraints.append({'type': 'ineq', 'fun': lambda x, i=i: x[2*i] - x[2*n + i]})\n            constraints.append({'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i] - x[2*n + i]})\n            constraints.append({'type': 'ineq', 'fun': lambda x, i=i: x[2*i + 1] - x[2*n + i]})\n            constraints.append({'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i + 1] - x[2*n + i]})\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                def overlap_constraint(x, i=i, j=j):\n                    cx_i, cy_i = x[2*i], x[2*i + 1]\n                    cx_j, cy_j = x[2*j], x[2*j + 1]\n                    r_i, r_j = x[2*n + i], x[2*n + j]\n                    dist = np.sqrt((cx_i - cx_j)**2 + (cy_i - cy_j)**2)\n                    return dist - (r_i + r_j)\n                \n                constraints.append({'type': 'ineq', 'fun': overlap_constraint})\n        \n        # Non-negative radii\n        for i in range(n):\n            constraints.append({'type': 'ineq', 'fun': lambda x, i=i: x[2*n + i]})\n        \n        bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n        \n        x0 = np.concatenate([centers_init.flatten(), radii_init])\n        \n        best_result = None\n        best_value = float('inf')\n        \n        for attempt in range(n_attempts):\n            if attempt == 0:\n                # First attempt: use initial state directly\n                x_init = x0.copy()\n            elif attempt < 4:\n                # Small perturbations for local exploration\n                perturbation = np.random.randn(len(x0)) * 0.002\n                x_init = x0 + perturbation\n            else:\n                # Larger perturbations for broader exploration\n                perturbation = np.random.randn(len(x0)) * 0.008\n                x_init = x0 + perturbation\n            \n            # Ensure bounds\n            x_init[:2*n] = np.clip(x_init[:2*n], 0.01, 0.99)\n            x_init[2*n:] = np.clip(x_init[2*n:], 0.001, 0.5)\n            \n            result = minimize(\n                objective,\n                x_init,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 2000, 'ftol': 1e-11}\n            )\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_result = result\n        \n        solution = best_result.x\n        centers = solution[:2*n].reshape(n, 2)\n        radii = solution[2*n:]\n        \n        return centers, radii\n    \n    # Phase 4: Final radius maximization pass\n    def maximize_radii(centers, radii):\n        \"\"\"Final pass to maximize individual radii without moving centers.\"\"\"\n        improved = True\n        iterations = 0\n        max_iterations = 150\n        \n        while improved and iterations < max_iterations:\n            improved = False\n            iterations += 1\n            \n            for i in range(n):\n                # Binary search for maximum radius\n                low, high = radii[i], 0.5\n                \n                for _ in range(25):\n                    mid = (low + high) / 2\n                    \n                    valid = True\n                    \n                    # Check bounds\n                    if (centers[i, 0] - mid < 0 or centers[i, 0] + mid > 1 or\n                        centers[i, 1] - mid < 0 or centers[i, 1] + mid > 1):\n                        valid = False\n                        high = mid\n                        continue\n                    \n                    # Check overlaps\n                    if valid:\n                        for j in range(n):\n                            if i != j:\n                                dist = np.linalg.norm(centers[i] - centers[j])\n                                if dist < mid + radii[j] - 1e-10:\n                                    valid = False\n                                    break\n                    \n                    if valid:\n                        low = mid\n                    else:\n                        high = mid\n                \n                if low > radii[i] + 1e-8:\n                    radii[i] = low\n                    improved = True\n        \n        return radii\n    \n    # Execute all phases\n    centers, radii = hexagonal_initialization()\n    centers, radii = force_directed_refinement(centers, radii, n_iterations=150000)\n    centers, radii = scipy_optimization(centers, radii, n_attempts=8)\n    radii = maximize_radii(centers, radii)\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nPush beyond 2.6019:\n1. Dramatically increase iterations: 500000+\n2. Use very slow cooling schedule for forces\n3. Add simulated annealing component: accept worse moves with probability\n4. Run 30+ times with different random seeds\n5. Apply scipy refinement to top 10 results\n6. Final radius maximization\n\nRequirements:\n- Very long convergence time\n- Multiple restarts\n- Hybrid with scipy\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using aggressive\n    hybrid optimization with simulated annealing, multiple restarts, and extensive refinement.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def hexagonal_initialization(seed=None):\n        \"\"\"Initialize with optimal hexagonal packing pattern.\"\"\"\n        if seed is not None:\n            np.random.seed(seed)\n        \n        rows = 5\n        cols = 6\n        \n        h_spacing = 1.0 / (cols - 0.5)\n        v_spacing = h_spacing * np.sqrt(3) / 2\n        \n        total_height = (rows - 1) * v_spacing\n        if total_height > 1.0:\n            scale = 0.95 / total_height\n            h_spacing *= scale\n            v_spacing *= scale\n        \n        theoretical_radius = h_spacing / 2.0 * 0.95\n        \n        centers = []\n        for row in range(rows):\n            for col in range(cols):\n                if len(centers) >= n:\n                    break\n                \n                x_offset = (h_spacing / 2) if row % 2 == 1 else 0\n                x = col * h_spacing + x_offset + h_spacing / 2\n                y = row * v_spacing + v_spacing / 2\n                \n                x = x * 0.9 + 0.05\n                y = y * 0.9 + 0.05\n                \n                if x >= 0 and x <= 1 and y >= 0 and y <= 1:\n                    centers.append([x, y])\n            \n            if len(centers) >= n:\n                break\n        \n        while len(centers) < n:\n            grid_size = int(np.ceil(np.sqrt(n)))\n            idx = len(centers)\n            row = idx // grid_size\n            col = idx % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            centers.append([x, y])\n        \n        centers = np.array(centers[:n])\n        \n        # Add small random perturbation for diversity\n        if seed is not None:\n            centers += np.random.randn(n, 2) * 0.005\n            centers = np.clip(centers, 0.05, 0.95)\n        \n        radii = np.ones(n) * theoretical_radius\n        \n        return centers, radii\n    \n    def force_directed_with_annealing(centers, radii, n_iterations=500000, temperature_init=0.01, seed=None):\n        \"\"\"Enhanced force-directed with simulated annealing for escaping local minima.\"\"\"\n        if seed is not None:\n            np.random.seed(seed)\n        \n        velocities = np.zeros_like(centers)\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n        best_sum = np.sum(radii)\n        \n        for iteration in range(n_iterations):\n            progress = iteration / n_iterations\n            \n            # Very slow cooling schedule\n            if progress < 0.2:\n                damping = 0.93\n                dt = 0.0012\n                temperature = temperature_init\n            elif progress < 0.4:\n                damping = 0.88\n                dt = 0.0018\n                temperature = temperature_init * (1 - (progress - 0.2) / 0.2) * 0.8\n            elif progress < 0.6:\n                damping = 0.85\n                dt = 0.0022\n                temperature = temperature_init * (1 - (progress - 0.4) / 0.2) * 0.5\n            elif progress < 0.8:\n                damping = 0.90\n                dt = 0.0015\n                temperature = temperature_init * (1 - (progress - 0.6) / 0.2) * 0.2\n            else:\n                damping = 0.94\n                dt = 0.0008\n                temperature = temperature_init * (1 - (progress - 0.8) / 0.2) * 0.05\n            \n            forces = np.zeros_like(centers)\n            \n            # Repulsion forces\n            for i in range(n):\n                for j in range(i + 1, n):\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    min_dist = radii[i] + radii[j]\n                    \n                    activation_threshold = min_dist * 1.10\n                    \n                    if dist < activation_threshold:\n                        if dist > 1e-8:\n                            overlap = max(0, min_dist - dist)\n                            near_overlap = max(0, activation_threshold - dist)\n                            \n                            if overlap > 0:\n                                force_mag = 30.0 * overlap + 10.0 * near_overlap\n                            else:\n                                force_mag = 7.0 * near_overlap\n                            \n                            force_dir = diff / dist\n                            forces[i] += force_mag * force_dir\n                            forces[j] -= force_mag * force_dir\n            \n            # Boundary forces\n            boundary_margin = 0.012\n            for i in range(n):\n                r = radii[i]\n                \n                if centers[i, 0] - r < boundary_margin:\n                    penetration = r + boundary_margin - centers[i, 0]\n                    forces[i, 0] += 15.0 * penetration\n                \n                if centers[i, 0] + r > 1 - boundary_margin:\n                    penetration = centers[i, 0] + r - (1 - boundary_margin)\n                    forces[i, 0] -= 15.0 * penetration\n                \n                if centers[i, 1] - r < boundary_margin:\n                    penetration = r + boundary_margin - centers[i, 1]\n                    forces[i, 1] += 15.0 * penetration\n                \n                if centers[i, 1] + r > 1 - boundary_margin:\n                    penetration = centers[i, 1] + r - (1 - boundary_margin)\n                    forces[i, 1] -= 15.0 * penetration\n            \n            # Add random thermal noise for annealing\n            if temperature > 0:\n                thermal_noise = np.random.randn(n, 2) * temperature\n                forces += thermal_noise\n            \n            # Update velocities and positions\n            velocities = velocities * damping + forces * dt\n            centers += velocities * dt\n            \n            # Clamp to valid range\n            for i in range(n):\n                r = radii[i]\n                centers[i, 0] = np.clip(centers[i, 0], r + 1e-6, 1 - r - 1e-6)\n                centers[i, 1] = np.clip(centers[i, 1], r + 1e-6, 1 - r - 1e-6)\n            \n            # Adaptive radius growth with very careful scheduling\n            if iteration % 80 == 0:\n                if progress < 0.15:\n                    growth_rate = 1.010\n                elif progress < 0.35:\n                    growth_rate = 1.006\n                elif progress < 0.55:\n                    growth_rate = 1.003\n                elif progress < 0.75:\n                    growth_rate = 1.0015\n                else:\n                    growth_rate = 1.0008\n                \n                for i in range(n):\n                    test_radius = radii[i] * growth_rate\n                    \n                    can_increase = True\n                    \n                    if (centers[i, 0] - test_radius < 0 or \n                        centers[i, 0] + test_radius > 1 or\n                        centers[i, 1] - test_radius < 0 or \n                        centers[i, 1] + test_radius > 1):\n                        can_increase = False\n                    \n                    if can_increase:\n                        for j in range(n):\n                            if i != j:\n                                dist = np.linalg.norm(centers[i] - centers[j])\n                                if dist < test_radius + radii[j] - 1e-9:\n                                    can_increase = False\n                                    break\n                    \n                    if can_increase:\n                        radii[i] = test_radius\n            \n            # Track best configuration\n            current_sum = np.sum(radii)\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n            elif temperature > 0:\n                # Simulated annealing: accept worse solutions with probability\n                delta = current_sum - best_sum\n                acceptance_prob = np.exp(delta / temperature)\n                if np.random.rand() < acceptance_prob:\n                    best_sum = current_sum\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n        \n        return best_centers, best_radii\n    \n    def scipy_optimization(centers_init, radii_init, n_attempts=12):\n        \"\"\"Refine packing using scipy optimization with multiple attempts.\"\"\"\n        \n        def objective(x):\n            radii = x[2*n:]\n            return -np.sum(radii)\n        \n        constraints = []\n        \n        for i in range(n):\n            constraints.append({'type': 'ineq', 'fun': lambda x, i=i: x[2*i] - x[2*n + i]})\n            constraints.append({'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i] - x[2*n + i]})\n            constraints.append({'type': 'ineq', 'fun': lambda x, i=i: x[2*i + 1] - x[2*n + i]})\n            constraints.append({'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i + 1] - x[2*n + i]})\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                def overlap_constraint(x, i=i, j=j):\n                    cx_i, cy_i = x[2*i], x[2*i + 1]\n                    cx_j, cy_j = x[2*j], x[2*j + 1]\n                    r_i, r_j = x[2*n + i], x[2*n + j]\n                    dist = np.sqrt((cx_i - cx_j)**2 + (cy_i - cy_j)**2)\n                    return dist - (r_i + r_j)\n                \n                constraints.append({'type': 'ineq', 'fun': overlap_constraint})\n        \n        for i in range(n):\n            constraints.append({'type': 'ineq', 'fun': lambda x, i=i: x[2*n + i]})\n        \n        bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n        \n        x0 = np.concatenate([centers_init.flatten(), radii_init])\n        \n        best_result = None\n        best_value = float('inf')\n        \n        for attempt in range(n_attempts):\n            if attempt == 0:\n                x_init = x0.copy()\n            elif attempt < 5:\n                perturbation = np.random.randn(len(x0)) * 0.0015\n                x_init = x0 + perturbation\n            elif attempt < 9:\n                perturbation = np.random.randn(len(x0)) * 0.005\n                x_init = x0 + perturbation\n            else:\n                perturbation = np.random.randn(len(x0)) * 0.012\n                x_init = x0 + perturbation\n            \n            x_init[:2*n] = np.clip(x_init[:2*n], 0.01, 0.99)\n            x_init[2*n:] = np.clip(x_init[2*n:], 0.001, 0.5)\n            \n            result = minimize(\n                objective,\n                x_init,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 3000, 'ftol': 1e-12}\n            )\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_result = result\n        \n        solution = best_result.x\n        centers = solution[:2*n].reshape(n, 2)\n        radii = solution[2*n:]\n        \n        return centers, radii\n    \n    def maximize_radii(centers, radii):\n        \"\"\"Final pass to maximize individual radii without moving centers.\"\"\"\n        improved = True\n        iterations = 0\n        max_iterations = 200\n        \n        while improved and iterations < max_iterations:\n            improved = False\n            iterations += 1\n            \n            for i in range(n):\n                low, high = radii[i], 0.5\n                \n                for _ in range(30):\n                    mid = (low + high) / 2\n                    \n                    valid = True\n                    \n                    if (centers[i, 0] - mid < 0 or centers[i, 0] + mid > 1 or\n                        centers[i, 1] - mid < 0 or centers[i, 1] + mid > 1):\n                        valid = False\n                        high = mid\n                        continue\n                    \n                    if valid:\n                        for j in range(n):\n                            if i != j:\n                                dist = np.linalg.norm(centers[i] - centers[j])\n                                if dist < mid + radii[j] - 1e-11:\n                                    valid = False\n                                    break\n                    \n                    if valid:\n                        low = mid\n                    else:\n                        high = mid\n                \n                if low > radii[i] + 1e-9:\n                    radii[i] = low\n                    improved = True\n        \n        return radii\n    \n    # Main optimization loop with multiple restarts\n    best_centers = None\n    best_radii = None\n    best_sum = 0\n    \n    candidates = []\n    \n    # Phase 1: Generate 35 diverse candidates with force-directed + annealing\n    for run in range(35):\n        centers, radii = hexagonal_initialization(seed=run)\n        centers, radii = force_directed_with_annealing(\n            centers, radii, \n            n_iterations=500000,\n            temperature_init=0.01,\n            seed=run\n        )\n        sum_radii = np.sum(radii)\n        candidates.append((centers, radii, sum_radii))\n    \n    # Sort candidates by sum of radii\n    candidates.sort(key=lambda x: x[2], reverse=True)\n    \n    # Phase 2: Apply scipy optimization to top 10 candidates\n    for i in range(min(10, len(candidates))):\n        centers, radii, _ = candidates[i]\n        centers, radii = scipy_optimization(centers, radii, n_attempts=12)\n        radii = maximize_radii(centers, radii)\n        sum_radii = np.sum(radii)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator",
  "reasoning": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using aggressive\n    hybrid optimization with simulated annealing, multiple restarts, and extensive refinement.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def hexagonal_initialization(seed=None):\n        \"\"\"Initialize with optimal hexagonal packing pattern.\"\"\"\n        if seed is not None:\n            np.random.seed(seed)\n        \n        rows = 5\n        cols = 6\n        \n        h_spacing = 1.0 / (cols - 0.5)\n        v_spacing = h_spacing * np.sqrt(3) / 2\n        \n        total_height = (rows - 1) * v_spacing\n        if total_height > 1.0:\n            scale = 0.95 / total_height\n            h_spacing *= scale\n            v_spacing *= scale\n        \n        theoretical_radius = h_spacing / 2.0 * 0.95\n        \n        centers = []\n        for row in range(rows):\n            for col in range(cols):\n                if len(centers) >= n:\n                    break\n                \n                x_offset = (h_spacing / 2) if row % 2 == 1 else 0\n                x = col * h_spacing + x_offset + h_spacing / 2\n                y = row * v_spacing + v_spacing / 2\n                \n                x = x * 0.9 + 0.05\n                y = y * 0.9 + 0.05\n                \n                if x >= 0 and x <= 1 and y >= 0 and y <= 1:\n                    centers.append([x, y])\n            \n            if len(centers) >= n:\n                break\n        \n        while len(centers) < n:\n            grid_size = int(np.ceil(np.sqrt(n)))\n            idx = len(centers)\n            row = idx // grid_size\n            col = idx % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            centers.append([x, y])\n        \n        centers = np.array(centers[:n])\n        \n        # Add small random perturbation for diversity\n        if seed is not None:\n            centers += np.random.randn(n, 2) * 0.005\n            centers = np.clip(centers, 0.05, 0.95)\n        \n        radii = np.ones(n) * theoretical_radius\n        \n        return centers, radii\n    \n    def force_directed_with_annealing(centers, radii, n_iterations=500000, temperature_init=0.01, seed=None):\n        \"\"\"Enhanced force-directed with simulated annealing for escaping local minima.\"\"\"\n        if seed is not None:\n            np.random.seed(seed)\n        \n        velocities = np.zeros_like(centers)\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n        best_sum = np.sum(radii)\n        \n        for iteration in range(n_iterations):\n            progress = iteration / n_iterations\n            \n            # Very slow cooling schedule\n            if progress < 0.2:\n                damping = 0.93\n                dt = 0.0012\n                temperature = temperature_init\n            elif progress < 0.4:\n                damping = 0.88\n                dt = 0.0018\n                temperature = temperature_init * (1 - (progress - 0.2) / 0.2) * 0.8\n            elif progress < 0.6:\n                damping = 0.85\n                dt = 0.0022\n                temperature = temperature_init * (1 - (progress - 0.4) / 0.2) * 0.5\n            elif progress < 0.8:\n                damping = 0.90\n                dt = 0.0015\n                temperature = temperature_init * (1 - (progress - 0.6) / 0.2) * 0.2\n            else:\n                damping = 0.94\n                dt = 0.0008\n                temperature = temperature_init * (1 - (progress - 0.8) / 0.2) * 0.05\n            \n            forces = np.zeros_like(centers)\n            \n            # Repulsion forces\n            for i in range(n):\n                for j in range(i + 1, n):\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    min_dist = radii[i] + radii[j]\n                    \n                    activation_threshold = min_dist * 1.10\n                    \n                    if dist < activation_threshold:\n                        if dist > 1e-8:\n                            overlap = max(0, min_dist - dist)\n                            near_overlap = max(0, activation_threshold - dist)\n                            \n                            if overlap > 0:\n                                force_mag = 30.0 * overlap + 10.0 * near_overlap\n                            else:\n                                force_mag = 7.0 * near_overlap\n                            \n                            force_dir = diff / dist\n                            forces[i] += force_mag * force_dir\n                            forces[j] -= force_mag * force_dir\n            \n            # Boundary forces\n            boundary_margin = 0.012\n            for i in range(n):\n                r = radii[i]\n                \n                if centers[i, 0] - r < boundary_margin:\n                    penetration = r + boundary_margin - centers[i, 0]\n                    forces[i, 0] += 15.0 * penetration\n                \n                if centers[i, 0] + r > 1 - boundary_margin:\n                    penetration = centers[i, 0] + r - (1 - boundary_margin)\n                    forces[i, 0] -= 15.0 * penetration\n                \n                if centers[i, 1] - r < boundary_margin:\n                    penetration = r + boundary_margin - centers[i, 1]\n                    forces[i, 1] += 15.0 * penetration\n                \n                if centers[i, 1] + r > 1 - boundary_margin:\n                    penetration = centers[i, 1] + r - (1 - boundary_margin)\n                    forces[i, 1] -= 15.0 * penetration\n            \n            # Add random thermal noise for annealing\n            if temperature > 0:\n                thermal_noise = np.random.randn(n, 2) * temperature\n                forces += thermal_noise\n            \n            # Update velocities and positions\n            velocities = velocities * damping + forces * dt\n            centers += velocities * dt\n            \n            # Clamp to valid range\n            for i in range(n):\n                r = radii[i]\n                centers[i, 0] = np.clip(centers[i, 0], r + 1e-6, 1 - r - 1e-6)\n                centers[i, 1] = np.clip(centers[i, 1], r + 1e-6, 1 - r - 1e-6)\n            \n            # Adaptive radius growth with very careful scheduling\n            if iteration % 80 == 0:\n                if progress < 0.15:\n                    growth_rate = 1.010\n                elif progress < 0.35:\n                    growth_rate = 1.006\n                elif progress < 0.55:\n                    growth_rate = 1.003\n                elif progress < 0.75:\n                    growth_rate = 1.0015\n                else:\n                    growth_rate = 1.0008\n                \n                for i in range(n):\n                    test_radius = radii[i] * growth_rate\n                    \n                    can_increase = True\n                    \n                    if (centers[i, 0] - test_radius < 0 or \n                        centers[i, 0] + test_radius > 1 or\n                        centers[i, 1] - test_radius < 0 or \n                        centers[i, 1] + test_radius > 1):\n                        can_increase = False\n                    \n                    if can_increase:\n                        for j in range(n):\n                            if i != j:\n                                dist = np.linalg.norm(centers[i] - centers[j])\n                                if dist < test_radius + radii[j] - 1e-9:\n                                    can_increase = False\n                                    break\n                    \n                    if can_increase:\n                        radii[i] = test_radius\n            \n            # Track best configuration\n            current_sum = np.sum(radii)\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n            elif temperature > 0:\n                # Simulated annealing: accept worse solutions with probability\n                delta = current_sum - best_sum\n                acceptance_prob = np.exp(delta / temperature)\n                if np.random.rand() < acceptance_prob:\n                    best_sum = current_sum\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n        \n        return best_centers, best_radii\n    \n    def scipy_optimization(centers_init, radii_init, n_attempts=12):\n        \"\"\"Refine packing using scipy optimization with multiple attempts.\"\"\"\n        \n        def objective(x):\n            radii = x[2*n:]\n            return -np.sum(radii)\n        \n        constraints = []\n        \n        for i in range(n):\n            constraints.append({'type': 'ineq', 'fun': lambda x, i=i: x[2*i] - x[2*n + i]})\n            constraints.append({'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i] - x[2*n + i]})\n            constraints.append({'type': 'ineq', 'fun': lambda x, i=i: x[2*i + 1] - x[2*n + i]})\n            constraints.append({'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i + 1] - x[2*n + i]})\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                def overlap_constraint(x, i=i, j=j):\n                    cx_i, cy_i = x[2*i], x[2*i + 1]\n                    cx_j, cy_j = x[2*j], x[2*j + 1]\n                    r_i, r_j = x[2*n + i], x[2*n + j]\n                    dist = np.sqrt((cx_i - cx_j)**2 + (cy_i - cy_j)**2)\n                    return dist - (r_i + r_j)\n                \n                constraints.append({'type': 'ineq', 'fun': overlap_constraint})\n        \n        for i in range(n):\n            constraints.append({'type': 'ineq', 'fun': lambda x, i=i: x[2*n + i]})\n        \n        bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n        \n        x0 = np.concatenate([centers_init.flatten(), radii_init])\n        \n        best_result = None\n        best_value = float('inf')\n        \n        for attempt in range(n_attempts):\n            if attempt == 0:\n                x_init = x0.copy()\n            elif attempt < 5:\n                perturbation = np.random.randn(len(x0)) * 0.0015\n                x_init = x0 + perturbation\n            elif attempt < 9:\n                perturbation = np.random.randn(len(x0)) * 0.005\n                x_init = x0 + perturbation\n            else:\n                perturbation = np.random.randn(len(x0)) * 0.012\n                x_init = x0 + perturbation\n            \n            x_init[:2*n] = np.clip(x_init[:2*n], 0.01, 0.99)\n            x_init[2*n:] = np.clip(x_init[2*n:], 0.001, 0.5)\n            \n            result = minimize(\n                objective,\n                x_init,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 3000, 'ftol': 1e-12}\n            )\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_result = result\n        \n        solution = best_result.x\n        centers = solution[:2*n].reshape(n, 2)\n        radii = solution[2*n:]\n        \n        return centers, radii\n    \n    def maximize_radii(centers, radii):\n        \"\"\"Final pass to maximize individual radii without moving centers.\"\"\"\n        improved = True\n        iterations = 0\n        max_iterations = 200\n        \n        while improved and iterations < max_iterations:\n            improved = False\n            iterations += 1\n            \n            for i in range(n):\n                low, high = radii[i], 0.5\n                \n                for _ in range(30):\n                    mid = (low + high) / 2\n                    \n                    valid = True\n                    \n                    if (centers[i, 0] - mid < 0 or centers[i, 0] + mid > 1 or\n                        centers[i, 1] - mid < 0 or centers[i, 1] + mid > 1):\n                        valid = False\n                        high = mid\n                        continue\n                    \n                    if valid:\n                        for j in range(n):\n                            if i != j:\n                                dist = np.linalg.norm(centers[i] - centers[j])\n                                if dist < mid + radii[j] - 1e-11:\n                                    valid = False\n                                    break\n                    \n                    if valid:\n                        low = mid\n                    else:\n                        high = mid\n                \n                if low > radii[i] + 1e-9:\n                    radii[i] = low\n                    improved = True\n        \n        return radii\n    \n    # Main optimization loop with multiple restarts\n    best_centers = None\n    best_radii = None\n    best_sum = 0\n    \n    candidates = []\n    \n    # Phase 1: Generate 35 diverse candidates with force-directed + annealing\n    for run in range(35):\n        centers, radii = hexagonal_initialization(seed=run)\n        centers, radii = force_directed_with_annealing(\n            centers, radii, \n            n_iterations=500000,\n            temperature_init=0.01,\n            seed=run\n        )\n        sum_radii = np.sum(radii)\n        candidates.append((centers, radii, sum_radii))\n    \n    # Sort candidates by sum of radii\n    candidates.sort(key=lambda x: x[2], reverse=True)\n    \n    # Phase 2: Apply scipy optimization to top 10 candidates\n    for i in range(min(10, len(candidates))):\n        centers, radii, _ = candidates[i]\n        centers, radii = scipy_optimization(centers, radii, n_attempts=12)\n        radii = maximize_radii(centers, radii)\n        sum_radii = np.sum(radii)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator",
  "timestamp": "2025-12-16T18:57:07.776278",
  "cost_data": null
}