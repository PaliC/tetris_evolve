{
  "trial_id": "trial_4_14",
  "generation": 4,
  "parent_id": null,
  "code": "",
  "metrics": {},
  "prompt": "Create adaptive precision optimizer that adjusts numerical precision dynamically.\n\nStrategy:\n1. Start with standard precision (1e-6 tolerances)\n2. Monitor convergence rate\n3. When convergence slows, tighten tolerances progressively\n4. Use adaptive step sizes based on gradient magnitude\n5. Implement constraint satisfaction with adaptive tolerance\n6. Run 40+ times with different seeds\n7. Return best\n\nRequirements:\n- Adaptive precision control\n- Dynamic tolerance adjustment\n- Multiple restarts\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom dataclasses import dataclass\nfrom typing import Tuple\n\n@dataclass\nclass AdaptivePrecisionConfig:\n    \"\"\"Configuration for adaptive precision optimization.\"\"\"\n    initial_tol: float = 1e-6\n    final_tol: float = 1e-10\n    tol_reduction_factor: float = 0.5\n    convergence_window: int = 5\n    min_improvement: float = 1e-7\n    max_precision_levels: int = 4\n\nclass AdaptivePrecisionOptimizer:\n    \"\"\"Optimizer with dynamically adjusting numerical precision.\"\"\"\n    \n    def __init__(self, n_circles: int, config: AdaptivePrecisionConfig):\n        self.n = n_circles\n        self.config = config\n        self.current_tol = config.initial_tol\n        self.precision_level = 0\n        self.history = []\n        \n    def pack_circles_adaptive(self, seed: int) -> Tuple[np.ndarray, np.ndarray, float]:\n        \"\"\"Pack circles with adaptive precision control.\"\"\"\n        np.random.seed(seed)\n        \n        # Initialize with grid-based layout\n        centers, radii = self._initialize_grid()\n        \n        # Multi-stage optimization with increasing precision\n        for stage in range(self.config.max_precision_levels):\n            self.current_tol = self.config.initial_tol * (self.config.tol_reduction_factor ** stage)\n            self.precision_level = stage\n            \n            # Optimize at current precision level\n            centers, radii = self._optimize_stage(centers, radii)\n            \n            # Check if we should continue to higher precision\n            if not self._should_increase_precision():\n                break\n        \n        # Final refinement\n        centers, radii = self._final_refinement(centers, radii)\n        \n        sum_radii = np.sum(radii)\n        return centers, radii, sum_radii\n    \n    def _initialize_grid(self) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Initialize circles in adaptive grid pattern.\"\"\"\n        # Use 6x5 grid with slight randomization\n        rows, cols = 6, 5\n        centers = []\n        \n        for i in range(rows):\n            for j in range(cols):\n                if len(centers) >= self.n:\n                    break\n                # Staggered grid with noise\n                x = (j + 0.5 + 0.1 * np.random.randn()) / cols\n                y = (i + 0.5 + 0.1 * np.random.randn()) / rows\n                # Add stagger for odd rows\n                if i % 2 == 1:\n                    x += 0.5 / cols\n                centers.append([np.clip(x, 0.05, 0.95), np.clip(y, 0.05, 0.95)])\n        \n        centers = np.array(centers[:self.n])\n        \n        # Initialize radii based on local density\n        radii = self._compute_initial_radii(centers)\n        \n        return centers, radii\n    \n    def _compute_initial_radii(self, centers: np.ndarray) -> np.ndarray:\n        \"\"\"Compute initial radii based on nearest neighbors.\"\"\"\n        radii = np.zeros(self.n)\n        \n        for i in range(self.n):\n            # Distance to boundaries\n            min_wall_dist = min(\n                centers[i, 0],\n                1.0 - centers[i, 0],\n                centers[i, 1],\n                1.0 - centers[i, 1]\n            )\n            \n            # Distance to nearest neighbor\n            min_neighbor_dist = float('inf')\n            for j in range(self.n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    min_neighbor_dist = min(min_neighbor_dist, dist)\n            \n            # Conservative initial radius\n            radii[i] = min(min_wall_dist, min_neighbor_dist / 2.5) * 0.95\n        \n        return radii\n    \n    def _optimize_stage(self, centers: np.ndarray, radii: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Optimize at current precision level.\"\"\"\n        # Pack parameters\n        x0 = np.concatenate([centers.flatten(), radii])\n        \n        # Adaptive bounds based on current state\n        bounds = self._compute_adaptive_bounds(centers, radii)\n        \n        # Objective: maximize sum of radii\n        def objective(x):\n            r = x[2*self.n:]\n            return -np.sum(r)\n        \n        # Constraints with current tolerance\n        constraints = self._build_constraints()\n        \n        # Optimize with adaptive settings\n        options = {\n            'ftol': self.current_tol,\n            'maxiter': 500 + 200 * self.precision_level,\n            'disp': False\n        }\n        \n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options=options\n        )\n        \n        if result.success:\n            centers_new = result.x[:2*self.n].reshape(self.n, 2)\n            radii_new = result.x[2*self.n:]\n            \n            # Verify and adjust if needed\n            centers_new, radii_new = self._enforce_constraints(centers_new, radii_new)\n            \n            return centers_new, radii_new\n        \n        return centers, radii\n    \n    def _compute_adaptive_bounds(self, centers: np.ndarray, radii: np.ndarray) -> list:\n        \"\"\"Compute adaptive bounds based on current state.\"\"\"\n        bounds = []\n        \n        # Adaptive margin based on precision level\n        margin = max(0.01, self.current_tol * 100)\n        \n        for i in range(self.n):\n            # Center bounds - allow more freedom at lower precision\n            center_margin = margin * (1 + radii[i])\n            x_min = max(radii[i] + margin, centers[i, 0] - center_margin)\n            x_max = min(1.0 - radii[i] - margin, centers[i, 0] + center_margin)\n            y_min = max(radii[i] + margin, centers[i, 1] - center_margin)\n            y_max = min(1.0 - radii[i] - margin, centers[i, 1] + center_margin)\n            \n            bounds.append((x_min, x_max))\n            bounds.append((y_min, y_max))\n        \n        # Radius bounds\n        for i in range(self.n):\n            r_max = min(\n                centers[i, 0],\n                1.0 - centers[i, 0],\n                centers[i, 1],\n                1.0 - centers[i, 1]\n            ) - margin\n            bounds.append((margin, max(margin * 2, r_max)))\n        \n        return bounds\n    \n    def _build_constraints(self) -> list:\n        \"\"\"Build constraints with current tolerance.\"\"\"\n        constraints = []\n        tol = self.current_tol\n        \n        # Non-overlap constraints\n        for i in range(self.n):\n            for j in range(i + 1, self.n):\n                def constraint_ij(x, i=i, j=j):\n                    centers = x[:2*self.n].reshape(self.n, 2)\n                    radii = x[2*self.n:]\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    return dist - radii[i] - radii[j] - tol\n                \n                constraints.append({\n                    'type': 'ineq',\n                    'fun': constraint_ij\n                })\n        \n        # Boundary constraints with adaptive tolerance\n        for i in range(self.n):\n            # Left boundary\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: x[2*i] - x[2*self.n + i] - tol\n            })\n            # Right boundary\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: 1.0 - x[2*i] - x[2*self.n + i] - tol\n            })\n            # Bottom boundary\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: x[2*i + 1] - x[2*self.n + i] - tol\n            })\n            # Top boundary\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: 1.0 - x[2*i + 1] - x[2*self.n + i] - tol\n            })\n        \n        return constraints\n    \n    def _should_increase_precision(self) -> bool:\n        \"\"\"Determine if we should increase precision.\"\"\"\n        if self.precision_level >= self.config.max_precision_levels - 1:\n            return False\n        \n        if len(self.history) < self.config.convergence_window:\n            return True\n        \n        # Check improvement rate\n        recent = self.history[-self.config.convergence_window:]\n        improvement = max(recent) - min(recent)\n        \n        return improvement > self.config.min_improvement\n    \n    def _enforce_constraints(self, centers: np.ndarray, radii: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Enforce constraints with adaptive adjustment.\"\"\"\n        margin = self.current_tol * 2\n        \n        # Adjust radii to satisfy boundary constraints\n        for i in range(self.n):\n            max_r = min(\n                centers[i, 0] - margin,\n                1.0 - centers[i, 0] - margin,\n                centers[i, 1] - margin,\n                1.0 - centers[i, 1] - margin\n            )\n            radii[i] = min(radii[i], max(0, max_r))\n        \n        # Adjust for overlaps\n        max_iterations = 100\n        for _ in range(max_iterations):\n            adjusted = False\n            for i in range(self.n):\n                for j in range(i + 1, self.n):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    overlap = radii[i] + radii[j] - dist + margin\n                    \n                    if overlap > 0:\n                        # Reduce both radii proportionally\n                        total_r = radii[i] + radii[j]\n                        if total_r > 0:\n                            reduction = overlap / 2\n                            radii[i] = max(0, radii[i] - reduction * radii[i] / total_r)\n                            radii[j] = max(0, radii[j] - reduction * radii[j] / total_r)\n                            adjusted = True\n            \n            if not adjusted:\n                break\n        \n        return centers, radii\n    \n    def _final_refinement(self, centers: np.ndarray, radii: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Final refinement with tightest tolerance.\"\"\"\n        self.current_tol = self.config.final_tol\n        \n        # Local search around current solution\n        x0 = np.concatenate([centers.flatten(), radii])\n        \n        def objective(x):\n            r = x[2*self.n:]\n            return -np.sum(r)\n        \n        bounds = self._compute_adaptive_bounds(centers, radii)\n        constraints = self._build_constraints()\n        \n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'ftol': self.config.final_tol, 'maxiter': 300}\n        )\n        \n        if result.success:\n            centers_new = result.x[:2*self.n].reshape(self.n, 2)\n            radii_new = result.x[2*self.n:]\n            centers_new, radii_new = self._enforce_constraints(centers_new, radii_new)\n            return centers_new, radii_new\n        \n        return centers, radii\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    config = AdaptivePrecisionConfig(\n        initial_tol=1e-6,\n        final_tol=1e-10,\n        tol_reduction_factor=0.5,\n        convergence_window=5,\n        min_improvement=1e-7,\n        max_precision_levels=4\n    )\n    \n    optimizer = AdaptivePrecisionOptimizer(n, config)\n    \n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Run multiple attempts with different seeds\n    n_attempts = 45\n    \n    for seed in range(n_attempts):\n        try:\n            centers, radii, sum_radii = optimizer.pack_circles_adaptive(seed)\n            \n            # Verify solution validity\n            if verify_solution(centers, radii):\n                if sum_radii > best_sum:\n                    best_sum = sum_radii\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n        except:\n            continue\n    \n    # Fallback if no valid solution found\n    if best_centers is None:\n        best_centers, best_radii = create_fallback_solution(n)\n        best_sum = np.sum(best_radii)\n    \n    return best_centers, best_radii, best_sum\n\n\ndef verify_solution(centers: np.ndarray, radii: np.ndarray, tol: float = 1e-6) -> bool:\n    \"\"\"Verify that solution satisfies all constraints.\"\"\"\n    n = len(radii)\n    \n    # Check boundary constraints\n    for i in range(n):\n        if centers[i, 0] - radii[i] < -tol or centers[i, 0] + radii[i] > 1.0 + tol:\n            return False\n        if centers[i, 1] - radii[i] < -tol or centers[i, 1] + radii[i] > 1.0 + tol:\n            return False\n        if radii[i] < -tol:\n            return False\n    \n    # Check non-overlap constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - tol:\n                return False\n    \n    return True\n\n\ndef create_fallback_solution(n: int) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Create a valid fallback solution.\"\"\"\n    # Simple grid layout\n    grid_size = int(np.ceil(np.sqrt(n)))\n    centers = []\n    \n    for i in range(grid_size):\n        for j in range(grid_size):\n            if len(centers) >= n:\n                break\n            x = (j + 0.5) / grid_size\n            y = (i + 0.5) / grid_size\n            centers.append([x, y])\n    \n    centers = np.array(centers[:n])\n    \n    # Compute safe radii\n    radii = np.zeros(n)\n    spacing = 1.0 / grid_size\n    base_radius = spacing / 2.2\n    \n    for i in range(n):\n        radii[i] = base_radius",
  "reasoning": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom dataclasses import dataclass\nfrom typing import Tuple\n\n@dataclass\nclass AdaptivePrecisionConfig:\n    \"\"\"Configuration for adaptive precision optimization.\"\"\"\n    initial_tol: float = 1e-6\n    final_tol: float = 1e-10\n    tol_reduction_factor: float = 0.5\n    convergence_window: int = 5\n    min_improvement: float = 1e-7\n    max_precision_levels: int = 4\n\nclass AdaptivePrecisionOptimizer:\n    \"\"\"Optimizer with dynamically adjusting numerical precision.\"\"\"\n    \n    def __init__(self, n_circles: int, config: AdaptivePrecisionConfig):\n        self.n = n_circles\n        self.config = config\n        self.current_tol = config.initial_tol\n        self.precision_level = 0\n        self.history = []\n        \n    def pack_circles_adaptive(self, seed: int) -> Tuple[np.ndarray, np.ndarray, float]:\n        \"\"\"Pack circles with adaptive precision control.\"\"\"\n        np.random.seed(seed)\n        \n        # Initialize with grid-based layout\n        centers, radii = self._initialize_grid()\n        \n        # Multi-stage optimization with increasing precision\n        for stage in range(self.config.max_precision_levels):\n            self.current_tol = self.config.initial_tol * (self.config.tol_reduction_factor ** stage)\n            self.precision_level = stage\n            \n            # Optimize at current precision level\n            centers, radii = self._optimize_stage(centers, radii)\n            \n            # Check if we should continue to higher precision\n            if not self._should_increase_precision():\n                break\n        \n        # Final refinement\n        centers, radii = self._final_refinement(centers, radii)\n        \n        sum_radii = np.sum(radii)\n        return centers, radii, sum_radii\n    \n    def _initialize_grid(self) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Initialize circles in adaptive grid pattern.\"\"\"\n        # Use 6x5 grid with slight randomization\n        rows, cols = 6, 5\n        centers = []\n        \n        for i in range(rows):\n            for j in range(cols):\n                if len(centers) >= self.n:\n                    break\n                # Staggered grid with noise\n                x = (j + 0.5 + 0.1 * np.random.randn()) / cols\n                y = (i + 0.5 + 0.1 * np.random.randn()) / rows\n                # Add stagger for odd rows\n                if i % 2 == 1:\n                    x += 0.5 / cols\n                centers.append([np.clip(x, 0.05, 0.95), np.clip(y, 0.05, 0.95)])\n        \n        centers = np.array(centers[:self.n])\n        \n        # Initialize radii based on local density\n        radii = self._compute_initial_radii(centers)\n        \n        return centers, radii\n    \n    def _compute_initial_radii(self, centers: np.ndarray) -> np.ndarray:\n        \"\"\"Compute initial radii based on nearest neighbors.\"\"\"\n        radii = np.zeros(self.n)\n        \n        for i in range(self.n):\n            # Distance to boundaries\n            min_wall_dist = min(\n                centers[i, 0],\n                1.0 - centers[i, 0],\n                centers[i, 1],\n                1.0 - centers[i, 1]\n            )\n            \n            # Distance to nearest neighbor\n            min_neighbor_dist = float('inf')\n            for j in range(self.n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    min_neighbor_dist = min(min_neighbor_dist, dist)\n            \n            # Conservative initial radius\n            radii[i] = min(min_wall_dist, min_neighbor_dist / 2.5) * 0.95\n        \n        return radii\n    \n    def _optimize_stage(self, centers: np.ndarray, radii: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Optimize at current precision level.\"\"\"\n        # Pack parameters\n        x0 = np.concatenate([centers.flatten(), radii])\n        \n        # Adaptive bounds based on current state\n        bounds = self._compute_adaptive_bounds(centers, radii)\n        \n        # Objective: maximize sum of radii\n        def objective(x):\n            r = x[2*self.n:]\n            return -np.sum(r)\n        \n        # Constraints with current tolerance\n        constraints = self._build_constraints()\n        \n        # Optimize with adaptive settings\n        options = {\n            'ftol': self.current_tol,\n            'maxiter': 500 + 200 * self.precision_level,\n            'disp': False\n        }\n        \n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options=options\n        )\n        \n        if result.success:\n            centers_new = result.x[:2*self.n].reshape(self.n, 2)\n            radii_new = result.x[2*self.n:]\n            \n            # Verify and adjust if needed\n            centers_new, radii_new = self._enforce_constraints(centers_new, radii_new)\n            \n            return centers_new, radii_new\n        \n        return centers, radii\n    \n    def _compute_adaptive_bounds(self, centers: np.ndarray, radii: np.ndarray) -> list:\n        \"\"\"Compute adaptive bounds based on current state.\"\"\"\n        bounds = []\n        \n        # Adaptive margin based on precision level\n        margin = max(0.01, self.current_tol * 100)\n        \n        for i in range(self.n):\n            # Center bounds - allow more freedom at lower precision\n            center_margin = margin * (1 + radii[i])\n            x_min = max(radii[i] + margin, centers[i, 0] - center_margin)\n            x_max = min(1.0 - radii[i] - margin, centers[i, 0] + center_margin)\n            y_min = max(radii[i] + margin, centers[i, 1] - center_margin)\n            y_max = min(1.0 - radii[i] - margin, centers[i, 1] + center_margin)\n            \n            bounds.append((x_min, x_max))\n            bounds.append((y_min, y_max))\n        \n        # Radius bounds\n        for i in range(self.n):\n            r_max = min(\n                centers[i, 0],\n                1.0 - centers[i, 0],\n                centers[i, 1],\n                1.0 - centers[i, 1]\n            ) - margin\n            bounds.append((margin, max(margin * 2, r_max)))\n        \n        return bounds\n    \n    def _build_constraints(self) -> list:\n        \"\"\"Build constraints with current tolerance.\"\"\"\n        constraints = []\n        tol = self.current_tol\n        \n        # Non-overlap constraints\n        for i in range(self.n):\n            for j in range(i + 1, self.n):\n                def constraint_ij(x, i=i, j=j):\n                    centers = x[:2*self.n].reshape(self.n, 2)\n                    radii = x[2*self.n:]\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    return dist - radii[i] - radii[j] - tol\n                \n                constraints.append({\n                    'type': 'ineq',\n                    'fun': constraint_ij\n                })\n        \n        # Boundary constraints with adaptive tolerance\n        for i in range(self.n):\n            # Left boundary\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: x[2*i] - x[2*self.n + i] - tol\n            })\n            # Right boundary\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: 1.0 - x[2*i] - x[2*self.n + i] - tol\n            })\n            # Bottom boundary\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: x[2*i + 1] - x[2*self.n + i] - tol\n            })\n            # Top boundary\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: 1.0 - x[2*i + 1] - x[2*self.n + i] - tol\n            })\n        \n        return constraints\n    \n    def _should_increase_precision(self) -> bool:\n        \"\"\"Determine if we should increase precision.\"\"\"\n        if self.precision_level >= self.config.max_precision_levels - 1:\n            return False\n        \n        if len(self.history) < self.config.convergence_window:\n            return True\n        \n        # Check improvement rate\n        recent = self.history[-self.config.convergence_window:]\n        improvement = max(recent) - min(recent)\n        \n        return improvement > self.config.min_improvement\n    \n    def _enforce_constraints(self, centers: np.ndarray, radii: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Enforce constraints with adaptive adjustment.\"\"\"\n        margin = self.current_tol * 2\n        \n        # Adjust radii to satisfy boundary constraints\n        for i in range(self.n):\n            max_r = min(\n                centers[i, 0] - margin,\n                1.0 - centers[i, 0] - margin,\n                centers[i, 1] - margin,\n                1.0 - centers[i, 1] - margin\n            )\n            radii[i] = min(radii[i], max(0, max_r))\n        \n        # Adjust for overlaps\n        max_iterations = 100\n        for _ in range(max_iterations):\n            adjusted = False\n            for i in range(self.n):\n                for j in range(i + 1, self.n):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    overlap = radii[i] + radii[j] - dist + margin\n                    \n                    if overlap > 0:\n                        # Reduce both radii proportionally\n                        total_r = radii[i] + radii[j]\n                        if total_r > 0:\n                            reduction = overlap / 2\n                            radii[i] = max(0, radii[i] - reduction * radii[i] / total_r)\n                            radii[j] = max(0, radii[j] - reduction * radii[j] / total_r)\n                            adjusted = True\n            \n            if not adjusted:\n                break\n        \n        return centers, radii\n    \n    def _final_refinement(self, centers: np.ndarray, radii: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Final refinement with tightest tolerance.\"\"\"\n        self.current_tol = self.config.final_tol\n        \n        # Local search around current solution\n        x0 = np.concatenate([centers.flatten(), radii])\n        \n        def objective(x):\n            r = x[2*self.n:]\n            return -np.sum(r)\n        \n        bounds = self._compute_adaptive_bounds(centers, radii)\n        constraints = self._build_constraints()\n        \n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'ftol': self.config.final_tol, 'maxiter': 300}\n        )\n        \n        if result.success:\n            centers_new = result.x[:2*self.n].reshape(self.n, 2)\n            radii_new = result.x[2*self.n:]\n            centers_new, radii_new = self._enforce_constraints(centers_new, radii_new)\n            return centers_new, radii_new\n        \n        return centers, radii\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    config = AdaptivePrecisionConfig(\n        initial_tol=1e-6,\n        final_tol=1e-10,\n        tol_reduction_factor=0.5,\n        convergence_window=5,\n        min_improvement=1e-7,\n        max_precision_levels=4\n    )\n    \n    optimizer = AdaptivePrecisionOptimizer(n, config)\n    \n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Run multiple attempts with different seeds\n    n_attempts = 45\n    \n    for seed in range(n_attempts):\n        try:\n            centers, radii, sum_radii = optimizer.pack_circles_adaptive(seed)\n            \n            # Verify solution validity\n            if verify_solution(centers, radii):\n                if sum_radii > best_sum:\n                    best_sum = sum_radii\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n        except:\n            continue\n    \n    # Fallback if no valid solution found\n    if best_centers is None:\n        best_centers, best_radii = create_fallback_solution(n)\n        best_sum = np.sum(best_radii)\n    \n    return best_centers, best_radii, best_sum\n\ndef verify_solution(centers: np.ndarray, radii: np.ndarray, tol: float = 1e-6) -> bool:\n    \"\"\"Verify that solution satisfies all constraints.\"\"\"\n    n = len(radii)\n    \n    # Check boundary constraints\n    for i in range(n):\n        if centers[i, 0] - radii[i] < -tol or centers[i, 0] + radii[i] > 1.0 + tol:\n            return False\n        if centers[i, 1] - radii[i] < -tol or centers[i, 1] + radii[i] > 1.0 + tol:\n            return False\n        if radii[i] < -tol:\n            return False\n    \n    # Check non-overlap constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - tol:\n                return False\n    \n    return True\n\ndef create_fallback_solution(n: int) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Create a valid fallback solution.\"\"\"\n    # Simple grid layout\n    grid_size = int(np.ceil(np.sqrt(n)))\n    centers = []\n    \n    for i in range(grid_size):\n        for j in range(grid_size):\n            if len(centers) >= n:\n                break\n            x = (j + 0.5) / grid_size\n            y = (i + 0.5) / grid_size\n            centers.append([x, y])\n    \n    centers = np.array(centers[:n])\n    \n    # Compute safe radii\n    radii = np.zeros(n)\n    spacing = 1.0 / grid_size\n    base_radius = spacing / 2.2\n    \n    for i in range(n):\n        radii[i] = base_radius",
  "timestamp": "2025-12-16T18:57:10.704123",
  "cost_data": null
}