{
  "trial_id": "trial_4_8",
  "generation": 4,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using hybrid GA + local search.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    def compute_radii(centers):\n        \"\"\"Compute maximum radii for given centers.\"\"\"\n        radii = np.ones(n) * 0.5\n        \n        # Distance to boundaries\n        for i in range(n):\n            r_max = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = max(0, r_max)\n        \n        # Distance to other circles\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_r_i = dist - radii[j]\n                max_r_j = dist - radii[i]\n                radii[i] = min(radii[i], max_r_i)\n                radii[j] = min(radii[j], max_r_j)\n        \n        return np.maximum(radii, 0)\n    \n    def fitness(centers):\n        \"\"\"Fitness function: sum of radii with penalties.\"\"\"\n        radii = compute_radii(centers.reshape(n, 2))\n        return np.sum(radii)\n    \n    def create_hexagonal_packing():\n        \"\"\"Create hexagonal-like initial packing.\"\"\"\n        centers = []\n        rows = 5\n        for row in range(rows):\n            cols = 6 if row % 2 == 0 else 5\n            y = 0.1 + row * 0.18\n            for col in range(cols):\n                if row % 2 == 0:\n                    x = 0.1 + col * 0.16\n                else:\n                    x = 0.18 + col * 0.16\n                if len(centers) < n:\n                    centers.append([x, y])\n        \n        while len(centers) < n:\n            centers.append([np.random.uniform(0.1, 0.9), \n                          np.random.uniform(0.1, 0.9)])\n        \n        return np.array(centers[:n])\n    \n    def initialize_population(pop_size):\n        \"\"\"Initialize population with variations.\"\"\"\n        population = []\n        \n        # Add hexagonal base\n        base = create_hexagonal_packing()\n        population.append(base.copy())\n        \n        # Add variations\n        for _ in range(pop_size - 1):\n            if np.random.rand() < 0.3:\n                # Hexagonal with noise\n                centers = base + np.random.randn(n, 2) * 0.05\n            else:\n                # Random\n                centers = np.random.rand(n, 2) * 0.8 + 0.1\n            \n            centers = np.clip(centers, 0.05, 0.95)\n            population.append(centers)\n        \n        return population\n    \n    def crossover(parent1, parent2):\n        \"\"\"Crossover two parents.\"\"\"\n        mask = np.random.rand(n) < 0.5\n        child = parent1.copy()\n        child[mask] = parent2[mask]\n        return child\n    \n    def mutate(individual, mutation_rate=0.3, mutation_scale=0.05):\n        \"\"\"Mutate individual.\"\"\"\n        mutated = individual.copy()\n        mask = np.random.rand(n) < mutation_rate\n        mutated[mask] += np.random.randn(mask.sum(), 2) * mutation_scale\n        mutated = np.clip(mutated, 0.05, 0.95)\n        return mutated\n    \n    def local_search(centers, max_iter=50):\n        \"\"\"Apply scipy local optimization.\"\"\"\n        def objective(x):\n            return -fitness(x)\n        \n        def constraint_boundary(x):\n            \"\"\"Ensure centers stay within bounds with margin.\"\"\"\n            centers_2d = x.reshape(n, 2)\n            radii = compute_radii(centers_2d)\n            violations = []\n            for i in range(n):\n                violations.extend([\n                    centers_2d[i, 0] - radii[i],\n                    centers_2d[i, 1] - radii[i],\n                    1 - centers_2d[i, 0] - radii[i],\n                    1 - centers_2d[i, 1] - radii[i]\n                ])\n            return np.array(violations)\n        \n        def constraint_overlap(x):\n            \"\"\"Ensure no overlaps.\"\"\"\n            centers_2d = x.reshape(n, 2)\n            radii = compute_radii(centers_2d)\n            distances = cdist(centers_2d, centers_2d)\n            violations = []\n            for i in range(n):\n                for j in range(i + 1, n):\n                    violations.append(distances[i, j] - radii[i] - radii[j])\n            return np.array(violations)\n        \n        constraints = [\n            {'type': 'ineq', 'fun': constraint_boundary},\n            {'type': 'ineq', 'fun': constraint_overlap}\n        ]\n        \n        bounds = [(0.05, 0.95) for _ in range(2 * n)]\n        \n        result = minimize(\n            objective,\n            centers.flatten(),\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': max_iter, 'ftol': 1e-6}\n        )\n        \n        if result.success:\n            return result.x.reshape(n, 2)\n        return centers\n    \n    # Initialize population\n    pop_size = 100\n    population = initialize_population(pop_size)\n    \n    # Genetic algorithm\n    generations = 1000\n    for gen in range(generations):\n        # Evaluate fitness\n        fitness_scores = [fitness(ind) for ind in population]\n        \n        # Sort by fitness\n        sorted_indices = np.argsort(fitness_scores)[::-1]\n        population = [population[i] for i in sorted_indices]\n        fitness_scores = [fitness_scores[i] for i in sorted_indices]\n        \n        # Apply local search to top 10 every 100 generations\n        if gen % 100 == 0:\n            for i in range(min(10, len(population))):\n                population[i] = local_search(population[i], max_iter=30)\n        \n        # Selection: keep top 50%\n        elite_size = pop_size // 2\n        new_population = population[:elite_size]\n        \n        # Generate offspring\n        while len(new_population) < pop_size:\n            # Select parents\n            p1_idx = np.random.randint(0, elite_size)\n            p2_idx = np.random.randint(0, elite_size)\n            \n            # Crossover\n            child = crossover(population[p1_idx], population[p2_idx])\n            \n            # Mutate\n            child = mutate(child)\n            \n            new_population.append(child)\n        \n        population = new_population\n    \n    # Final evaluation\n    fitness_scores = [fitness(ind) for ind in population]\n    sorted_indices = np.argsort(fitness_scores)[::-1]\n    \n    # Intensive refinement on top 20\n    best_solutions = []\n    for i in range(min(20, len(population))):\n        idx = sorted_indices[i]\n        refined = local_search(population[idx], max_iter=100)\n        best_solutions.append(refined)\n    \n    # Select best\n    best_fitness = -np.inf\n    best_centers = None\n    \n    for centers in best_solutions:\n        f = fitness(centers)\n        if f > best_fitness:\n            best_fitness = f\n            best_centers = centers\n    \n    # Final computation\n    radii = compute_radii(best_centers)\n    sum_radii = np.sum(radii)\n    \n    return best_centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.281200725207876,
    "target_ratio": 0.8657308255058354,
    "combined_score": 0.8657308255058354,
    "eval_time": 195.32480478286743,
    "error": null
  },
  "prompt": "Create hybrid genetic algorithm with scipy local search.\n\nStrategy:\n1. Initialize population of 100 packings (hexagonal + random variations)\n2. Genetic algorithm loop (1000 generations):\n   - Evaluate fitness (sum of radii)\n   - Select top 50% \n   - Crossover: combine positions from two parents\n   - Mutate: small random perturbations\n   - Apply scipy local optimization to top 10 each generation\n3. After GA, take top 20 solutions\n4. Apply intensive scipy refinement to each\n5. Return best\n\nRequirements:\n- Genetic algorithm structure\n- Scipy local search integration\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using hybrid GA + local search.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    def compute_radii(centers):\n        \"\"\"Compute maximum radii for given centers.\"\"\"\n        radii = np.ones(n) * 0.5\n        \n        # Distance to boundaries\n        for i in range(n):\n            r_max = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = max(0, r_max)\n        \n        # Distance to other circles\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_r_i = dist - radii[j]\n                max_r_j = dist - radii[i]\n                radii[i] = min(radii[i], max_r_i)\n                radii[j] = min(radii[j], max_r_j)\n        \n        return np.maximum(radii, 0)\n    \n    def fitness(centers):\n        \"\"\"Fitness function: sum of radii with penalties.\"\"\"\n        radii = compute_radii(centers.reshape(n, 2))\n        return np.sum(radii)\n    \n    def create_hexagonal_packing():\n        \"\"\"Create hexagonal-like initial packing.\"\"\"\n        centers = []\n        rows = 5\n        for row in range(rows):\n            cols = 6 if row % 2 == 0 else 5\n            y = 0.1 + row * 0.18\n            for col in range(cols):\n                if row % 2 == 0:\n                    x = 0.1 + col * 0.16\n                else:\n                    x = 0.18 + col * 0.16\n                if len(centers) < n:\n                    centers.append([x, y])\n        \n        while len(centers) < n:\n            centers.append([np.random.uniform(0.1, 0.9), \n                          np.random.uniform(0.1, 0.9)])\n        \n        return np.array(centers[:n])\n    \n    def initialize_population(pop_size):\n        \"\"\"Initialize population with variations.\"\"\"\n        population = []\n        \n        # Add hexagonal base\n        base = create_hexagonal_packing()\n        population.append(base.copy())\n        \n        # Add variations\n        for _ in range(pop_size - 1):\n            if np.random.rand() < 0.3:\n                # Hexagonal with noise\n                centers = base + np.random.randn(n, 2) * 0.05\n            else:\n                # Random\n                centers = np.random.rand(n, 2) * 0.8 + 0.1\n            \n            centers = np.clip(centers, 0.05, 0.95)\n            population.append(centers)\n        \n        return population\n    \n    def crossover(parent1, parent2):\n        \"\"\"Crossover two parents.\"\"\"\n        mask = np.random.rand(n) < 0.5\n        child = parent1.copy()\n        child[mask] = parent2[mask]\n        return child\n    \n    def mutate(individual, mutation_rate=0.3, mutation_scale=0.05):\n        \"\"\"Mutate individual.\"\"\"\n        mutated = individual.copy()\n        mask = np.random.rand(n) < mutation_rate\n        mutated[mask] += np.random.randn(mask.sum(), 2) * mutation_scale\n        mutated = np.clip(mutated, 0.05, 0.95)\n        return mutated\n    \n    def local_search(centers, max_iter=50):\n        \"\"\"Apply scipy local optimization.\"\"\"\n        def objective(x):\n            return -fitness(x)\n        \n        def constraint_boundary(x):\n            \"\"\"Ensure centers stay within bounds with margin.\"\"\"\n            centers_2d = x.reshape(n, 2)\n            radii = compute_radii(centers_2d)\n            violations = []\n            for i in range(n):\n                violations.extend([\n                    centers_2d[i, 0] - radii[i],\n                    centers_2d[i, 1] - radii[i],\n                    1 - centers_2d[i, 0] - radii[i],\n                    1 - centers_2d[i, 1] - radii[i]\n                ])\n            return np.array(violations)\n        \n        def constraint_overlap(x):\n            \"\"\"Ensure no overlaps.\"\"\"\n            centers_2d = x.reshape(n, 2)\n            radii = compute_radii(centers_2d)\n            distances = cdist(centers_2d, centers_2d)\n            violations = []\n            for i in range(n):\n                for j in range(i + 1, n):\n                    violations.append(distances[i, j] - radii[i] - radii[j])\n            return np.array(violations)\n        \n        constraints = [\n            {'type': 'ineq', 'fun': constraint_boundary},\n            {'type': 'ineq', 'fun': constraint_overlap}\n        ]\n        \n        bounds = [(0.05, 0.95) for _ in range(2 * n)]\n        \n        result = minimize(\n            objective,\n            centers.flatten(),\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': max_iter, 'ftol': 1e-6}\n        )\n        \n        if result.success:\n            return result.x.reshape(n, 2)\n        return centers\n    \n    # Initialize population\n    pop_size = 100\n    population = initialize_population(pop_size)\n    \n    # Genetic algorithm\n    generations = 1000\n    for gen in range(generations):\n        # Evaluate fitness\n        fitness_scores = [fitness(ind) for ind in population]\n        \n        # Sort by fitness\n        sorted_indices = np.argsort(fitness_scores)[::-1]\n        population = [population[i] for i in sorted_indices]\n        fitness_scores = [fitness_scores[i] for i in sorted_indices]\n        \n        # Apply local search to top 10 every 100 generations\n        if gen % 100 == 0:\n            for i in range(min(10, len(population))):\n                population[i] = local_search(population[i], max_iter=30)\n        \n        # Selection: keep top 50%\n        elite_size = pop_size // 2\n        new_population = population[:elite_size]\n        \n        # Generate offspring\n        while len(new_population) < pop_size:\n            # Select parents\n            p1_idx = np.random.randint(0, elite_size)\n            p2_idx = np.random.randint(0, elite_size)\n            \n            # Crossover\n            child = crossover(population[p1_idx], population[p2_idx])\n            \n            # Mutate\n            child = mutate(child)\n            \n            new_population.append(child)\n        \n        population = new_population\n    \n    # Final evaluation\n    fitness_scores = [fitness(ind) for ind in population]\n    sorted_indices = np.argsort(fitness_scores)[::-1]\n    \n    # Intensive refinement on top 20\n    best_solutions = []\n    for i in range(min(20, len(population))):\n        idx = sorted_indices[i]\n        refined = local_search(population[idx], max_iter=100)\n        best_solutions.append(refined)\n    \n    # Select best\n    best_fitness = -np.inf\n    best_centers = None\n    \n    for centers in best_solutions:\n        f = fitness(centers)\n        if f > best_fitness:\n            best_fitness = f\n            best_centers = centers\n    \n    # Final computation\n    radii = compute_radii(best_centers)\n    sum_radii = np.sum(radii)\n    \n    return best_centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T19:00:05.155281",
  "cost_data": null
}