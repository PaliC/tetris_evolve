{
  "trial_id": "trial_4_7",
  "generation": 4,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize_scalar, minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses coordinate ascent with exact line search.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if configuration is valid.\"\"\"\n        # Check bounds\n        if np.any(centers - radii[:, None] < 0) or np.any(centers + radii[:, None] > 1):\n            return False\n        \n        # Check overlaps\n        dists = cdist(centers, centers)\n        radii_sum = radii[:, None] + radii[None, :]\n        np.fill_diagonal(dists, np.inf)\n        if np.any(dists < radii_sum - 1e-9):\n            return False\n        \n        return True\n    \n    def compute_max_radii(centers):\n        \"\"\"Compute maximum valid radii for given centers.\"\"\"\n        radii = np.ones(n)\n        \n        for i in range(n):\n            # Distance to boundaries\n            max_r = min(centers[i, 0], 1 - centers[i, 0], \n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, dist - radii[j])\n            \n            radii[i] = max(0, max_r)\n        \n        return radii\n    \n    def objective(centers, radii):\n        \"\"\"Negative sum of radii (for minimization).\"\"\"\n        return -np.sum(radii)\n    \n    def coordinate_ascent(centers_init, max_iter=100, tol=1e-8):\n        \"\"\"Coordinate ascent with exact line search.\"\"\"\n        centers = centers_init.copy()\n        radii = compute_max_radii(centers)\n        \n        for iteration in range(max_iter):\n            improved = False\n            old_sum = np.sum(radii)\n            \n            # Optimize each coordinate\n            for i in range(n):\n                for coord in range(2):\n                    # Line search along coordinate\n                    def line_obj(alpha):\n                        new_centers = centers.copy()\n                        new_centers[i, coord] = alpha\n                        new_radii = compute_max_radii(new_centers)\n                        return -np.sum(new_radii)\n                    \n                    # Bounds for this coordinate\n                    lb = max(0, centers[i, coord] - 0.2)\n                    ub = min(1, centers[i, coord] + 0.2)\n                    \n                    result = minimize_scalar(line_obj, bounds=(lb, ub), method='bounded')\n                    \n                    if result.fun < -old_sum - tol:\n                        centers[i, coord] = result.x\n                        radii = compute_max_radii(centers)\n                        old_sum = np.sum(radii)\n                        improved = True\n                \n                # Optimize radius indirectly by adjusting position\n                for coord in range(2):\n                    def line_obj(alpha):\n                        new_centers = centers.copy()\n                        new_centers[i, coord] = alpha\n                        new_radii = compute_max_radii(new_centers)\n                        return -np.sum(new_radii)\n                    \n                    lb = max(0.01, centers[i, coord] - 0.1)\n                    ub = min(0.99, centers[i, coord] + 0.1)\n                    \n                    result = minimize_scalar(line_obj, bounds=(lb, ub), method='bounded')\n                    \n                    if result.fun < -old_sum - tol:\n                        centers[i, coord] = result.x\n                        radii = compute_max_radii(centers)\n                        old_sum = np.sum(radii)\n                        improved = True\n            \n            if not improved:\n                break\n        \n        return centers, radii\n    \n    def hexagonal_init():\n        \"\"\"Create hexagonal packing initialization.\"\"\"\n        centers = []\n        rows = 6\n        spacing = 1.0 / (rows + 1)\n        \n        for row in range(rows):\n            y = (row + 1) * spacing\n            cols = 4 + (row % 2)\n            x_spacing = 1.0 / (cols + 1)\n            offset = 0.5 * x_spacing if row % 2 == 0 else 0\n            \n            for col in range(cols):\n                x = offset + (col + 1) * x_spacing\n                if len(centers) < n:\n                    centers.append([x, y])\n        \n        centers = np.array(centers[:n])\n        return centers\n    \n    def grid_init(noise=0.02):\n        \"\"\"Create grid-based initialization with noise.\"\"\"\n        side = int(np.ceil(np.sqrt(n)))\n        centers = []\n        spacing = 1.0 / (side + 1)\n        \n        for i in range(side):\n            for j in range(side):\n                if len(centers) < n:\n                    x = (i + 1) * spacing + np.random.uniform(-noise, noise)\n                    y = (j + 1) * spacing + np.random.uniform(-noise, noise)\n                    centers.append([np.clip(x, 0.01, 0.99), np.clip(y, 0.01, 0.99)])\n        \n        return np.array(centers[:n])\n    \n    # Run multiple optimizations\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Try hexagonal initialization\n    for attempt in range(10):\n        centers_init = hexagonal_init()\n        if attempt > 0:\n            centers_init += np.random.uniform(-0.02, 0.02, centers_init.shape)\n            centers_init = np.clip(centers_init, 0.01, 0.99)\n        \n        centers, radii = coordinate_ascent(centers_init, max_iter=50)\n        \n        if is_valid(centers, radii):\n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n    \n    # Try grid initializations\n    for attempt in range(20):\n        centers_init = grid_init(noise=0.03)\n        centers, radii = coordinate_ascent(centers_init, max_iter=50)\n        \n        if is_valid(centers, radii):\n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n    \n    # Polish best solution with scipy\n    if best_centers is not None:\n        def scipy_obj(x):\n            centers = x.reshape(n, 2)\n            radii = compute_max_radii(centers)\n            return -np.sum(radii)\n        \n        x0 = best_centers.flatten()\n        bounds = [(0.01, 0.99)] * (2 * n)\n        \n        result = minimize(scipy_obj, x0, method='L-BFGS-B', bounds=bounds,\n                         options={'maxiter': 1000, 'ftol': 1e-10})\n        \n        centers = result.x.reshape(n, 2)\n        radii = compute_max_radii(centers)\n        \n        if is_valid(centers, radii):\n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers\n                best_radii = radii\n    \n    # Final verification\n    if best_centers is None:\n        # Fallback to simple grid\n        best_centers = grid_init(noise=0.0)\n        best_radii = compute_max_radii(best_centers)\n        best_sum = np.sum(best_radii)\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 300.0087821483612,
    "error": "Timeout after 300s"
  },
  "prompt": "Create coordinate ascent optimizer with exact line search for each coordinate.\n\nStrategy:\n1. Start with excellent initialization (hexagonal)\n2. For each iteration:\n   - For each variable (x, y, radius for each circle):\n     * Perform exact line search along that coordinate\n     * Use golden section search or Brent's method\n     * Find exact optimum along that direction\n   - Continue until convergence\n3. This guarantees improvement at each step\n4. Run 30+ times with different starting points\n5. Apply scipy polish to top results\n\nRequirements:\n- Exact line search per coordinate\n- Multiple restarts\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize_scalar, minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses coordinate ascent with exact line search.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if configuration is valid.\"\"\"\n        # Check bounds\n        if np.any(centers - radii[:, None] < 0) or np.any(centers + radii[:, None] > 1):\n            return False\n        \n        # Check overlaps\n        dists = cdist(centers, centers)\n        radii_sum = radii[:, None] + radii[None, :]\n        np.fill_diagonal(dists, np.inf)\n        if np.any(dists < radii_sum - 1e-9):\n            return False\n        \n        return True\n    \n    def compute_max_radii(centers):\n        \"\"\"Compute maximum valid radii for given centers.\"\"\"\n        radii = np.ones(n)\n        \n        for i in range(n):\n            # Distance to boundaries\n            max_r = min(centers[i, 0], 1 - centers[i, 0], \n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, dist - radii[j])\n            \n            radii[i] = max(0, max_r)\n        \n        return radii\n    \n    def objective(centers, radii):\n        \"\"\"Negative sum of radii (for minimization).\"\"\"\n        return -np.sum(radii)\n    \n    def coordinate_ascent(centers_init, max_iter=100, tol=1e-8):\n        \"\"\"Coordinate ascent with exact line search.\"\"\"\n        centers = centers_init.copy()\n        radii = compute_max_radii(centers)\n        \n        for iteration in range(max_iter):\n            improved = False\n            old_sum = np.sum(radii)\n            \n            # Optimize each coordinate\n            for i in range(n):\n                for coord in range(2):\n                    # Line search along coordinate\n                    def line_obj(alpha):\n                        new_centers = centers.copy()\n                        new_centers[i, coord] = alpha\n                        new_radii = compute_max_radii(new_centers)\n                        return -np.sum(new_radii)\n                    \n                    # Bounds for this coordinate\n                    lb = max(0, centers[i, coord] - 0.2)\n                    ub = min(1, centers[i, coord] + 0.2)\n                    \n                    result = minimize_scalar(line_obj, bounds=(lb, ub), method='bounded')\n                    \n                    if result.fun < -old_sum - tol:\n                        centers[i, coord] = result.x\n                        radii = compute_max_radii(centers)\n                        old_sum = np.sum(radii)\n                        improved = True\n                \n                # Optimize radius indirectly by adjusting position\n                for coord in range(2):\n                    def line_obj(alpha):\n                        new_centers = centers.copy()\n                        new_centers[i, coord] = alpha\n                        new_radii = compute_max_radii(new_centers)\n                        return -np.sum(new_radii)\n                    \n                    lb = max(0.01, centers[i, coord] - 0.1)\n                    ub = min(0.99, centers[i, coord] + 0.1)\n                    \n                    result = minimize_scalar(line_obj, bounds=(lb, ub), method='bounded')\n                    \n                    if result.fun < -old_sum - tol:\n                        centers[i, coord] = result.x\n                        radii = compute_max_radii(centers)\n                        old_sum = np.sum(radii)\n                        improved = True\n            \n            if not improved:\n                break\n        \n        return centers, radii\n    \n    def hexagonal_init():\n        \"\"\"Create hexagonal packing initialization.\"\"\"\n        centers = []\n        rows = 6\n        spacing = 1.0 / (rows + 1)\n        \n        for row in range(rows):\n            y = (row + 1) * spacing\n            cols = 4 + (row % 2)\n            x_spacing = 1.0 / (cols + 1)\n            offset = 0.5 * x_spacing if row % 2 == 0 else 0\n            \n            for col in range(cols):\n                x = offset + (col + 1) * x_spacing\n                if len(centers) < n:\n                    centers.append([x, y])\n        \n        centers = np.array(centers[:n])\n        return centers\n    \n    def grid_init(noise=0.02):\n        \"\"\"Create grid-based initialization with noise.\"\"\"\n        side = int(np.ceil(np.sqrt(n)))\n        centers = []\n        spacing = 1.0 / (side + 1)\n        \n        for i in range(side):\n            for j in range(side):\n                if len(centers) < n:\n                    x = (i + 1) * spacing + np.random.uniform(-noise, noise)\n                    y = (j + 1) * spacing + np.random.uniform(-noise, noise)\n                    centers.append([np.clip(x, 0.01, 0.99), np.clip(y, 0.01, 0.99)])\n        \n        return np.array(centers[:n])\n    \n    # Run multiple optimizations\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Try hexagonal initialization\n    for attempt in range(10):\n        centers_init = hexagonal_init()\n        if attempt > 0:\n            centers_init += np.random.uniform(-0.02, 0.02, centers_init.shape)\n            centers_init = np.clip(centers_init, 0.01, 0.99)\n        \n        centers, radii = coordinate_ascent(centers_init, max_iter=50)\n        \n        if is_valid(centers, radii):\n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n    \n    # Try grid initializations\n    for attempt in range(20):\n        centers_init = grid_init(noise=0.03)\n        centers, radii = coordinate_ascent(centers_init, max_iter=50)\n        \n        if is_valid(centers, radii):\n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n    \n    # Polish best solution with scipy\n    if best_centers is not None:\n        def scipy_obj(x):\n            centers = x.reshape(n, 2)\n            radii = compute_max_radii(centers)\n            return -np.sum(radii)\n        \n        x0 = best_centers.flatten()\n        bounds = [(0.01, 0.99)] * (2 * n)\n        \n        result = minimize(scipy_obj, x0, method='L-BFGS-B', bounds=bounds,\n                         options={'maxiter': 1000, 'ftol': 1e-10})\n        \n        centers = result.x.reshape(n, 2)\n        radii = compute_max_radii(centers)\n        \n        if is_valid(centers, radii):\n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers\n                best_radii = radii\n    \n    # Final verification\n    if best_centers is None:\n        # Fallback to simple grid\n        best_centers = grid_init(noise=0.0)\n        best_radii = compute_max_radii(best_centers)\n        best_sum = np.sum(best_radii)\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T19:01:50.353373",
  "cost_data": null
}