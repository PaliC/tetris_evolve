{
  "trial_id": "trial_4_12",
  "generation": 4,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import shgo, minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using SHGO.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def constraint_inside_square(x):\n        \"\"\"All circles must be inside [0,1] x [0,1].\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        constraints = []\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # x - r >= 0\n            constraints.append(1 - centers[i, 0] - radii[i])  # x + r <= 1\n            constraints.append(centers[i, 1] - radii[i])  # y - r >= 0\n            constraints.append(1 - centers[i, 1] - radii[i])  # y + r <= 1\n        return np.array(constraints)\n    \n    def constraint_no_overlap(x):\n        \"\"\"No two circles may overlap.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        constraints = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])  # dist >= r_i + r_j\n        return np.array(constraints)\n    \n    # Bounds: centers in [0,1], radii in [0, 0.5]\n    bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n    \n    # Constraints for SHGO\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_inside_square},\n        {'type': 'ineq', 'fun': constraint_no_overlap}\n    ]\n    \n    best_result = None\n    best_sum = -np.inf\n    \n    # Run SHGO with multiple random seeds\n    for seed in range(25):\n        try:\n            result = shgo(\n                objective,\n                bounds,\n                constraints=constraints,\n                n=500,\n                iters=5,\n                sampling_method='sobol',\n                options={'ftol': 1e-8, 'disp': False},\n                workers=1\n            )\n            \n            if result.success:\n                sum_radii = -result.fun\n                if sum_radii > best_sum:\n                    best_sum = sum_radii\n                    best_result = result.x\n        except:\n            continue\n    \n    # If SHGO didn't find good solution, try grid-based initialization\n    if best_result is None or best_sum < 2.0:\n        # Initialize with grid pattern\n        grid_size = int(np.ceil(np.sqrt(n)))\n        spacing = 1.0 / (grid_size + 1)\n        x0 = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x0.append((col + 1) * spacing)\n            x0.append((row + 1) * spacing)\n        # Initialize radii\n        initial_radius = spacing / 3\n        x0.extend([initial_radius] * n)\n        x0 = np.array(x0)\n        \n        # Polish with local optimization\n        try:\n            result = minimize(\n                objective,\n                x0,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 1000, 'ftol': 1e-9}\n            )\n            if result.success:\n                sum_radii = -result.fun\n                if sum_radii > best_sum:\n                    best_sum = sum_radii\n                    best_result = result.x\n        except:\n            pass\n    \n    # Polish best result found\n    if best_result is not None:\n        try:\n            polished = minimize(\n                objective,\n                best_result,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 2000, 'ftol': 1e-10}\n            )\n            if polished.success and -polished.fun > best_sum:\n                best_result = polished.x\n                best_sum = -polished.fun\n        except:\n            pass\n    \n    # Extract solution\n    if best_result is not None:\n        centers = best_result[:2*n].reshape(n, 2)\n        radii = best_result[2*n:]\n        sum_radii = np.sum(radii)\n    else:\n        # Fallback: return valid but suboptimal solution\n        grid_size = int(np.ceil(np.sqrt(n)))\n        spacing = 1.0 / (grid_size + 1)\n        centers = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            centers.append([(col + 1) * spacing, (row + 1) * spacing])\n        centers = np.array(centers)\n        radii = np.full(n, spacing / 3)\n        sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 300.1574339866638,
    "error": "Timeout after 300s"
  },
  "prompt": "Create SHGO optimizer for global optimization.\n\nStrategy:\n1. Use scipy.optimize.shgo\n2. This is designed for global optimization with constraints\n3. Settings:\n   - n=500 (sampling points)\n   - iters=5\n   - sampling_method='sobol'\n4. Define all constraints carefully\n5. Run 20+ times with different seeds\n6. Polish top results\n7. Return best\n\nRequirements:\n- SHGO implementation\n- Multiple restarts\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import shgo, minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using SHGO.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def constraint_inside_square(x):\n        \"\"\"All circles must be inside [0,1] x [0,1].\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        constraints = []\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # x - r >= 0\n            constraints.append(1 - centers[i, 0] - radii[i])  # x + r <= 1\n            constraints.append(centers[i, 1] - radii[i])  # y - r >= 0\n            constraints.append(1 - centers[i, 1] - radii[i])  # y + r <= 1\n        return np.array(constraints)\n    \n    def constraint_no_overlap(x):\n        \"\"\"No two circles may overlap.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        constraints = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])  # dist >= r_i + r_j\n        return np.array(constraints)\n    \n    # Bounds: centers in [0,1], radii in [0, 0.5]\n    bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n    \n    # Constraints for SHGO\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_inside_square},\n        {'type': 'ineq', 'fun': constraint_no_overlap}\n    ]\n    \n    best_result = None\n    best_sum = -np.inf\n    \n    # Run SHGO with multiple random seeds\n    for seed in range(25):\n        try:\n            result = shgo(\n                objective,\n                bounds,\n                constraints=constraints,\n                n=500,\n                iters=5,\n                sampling_method='sobol',\n                options={'ftol': 1e-8, 'disp': False},\n                workers=1\n            )\n            \n            if result.success:\n                sum_radii = -result.fun\n                if sum_radii > best_sum:\n                    best_sum = sum_radii\n                    best_result = result.x\n        except:\n            continue\n    \n    # If SHGO didn't find good solution, try grid-based initialization\n    if best_result is None or best_sum < 2.0:\n        # Initialize with grid pattern\n        grid_size = int(np.ceil(np.sqrt(n)))\n        spacing = 1.0 / (grid_size + 1)\n        x0 = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x0.append((col + 1) * spacing)\n            x0.append((row + 1) * spacing)\n        # Initialize radii\n        initial_radius = spacing / 3\n        x0.extend([initial_radius] * n)\n        x0 = np.array(x0)\n        \n        # Polish with local optimization\n        try:\n            result = minimize(\n                objective,\n                x0,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 1000, 'ftol': 1e-9}\n            )\n            if result.success:\n                sum_radii = -result.fun\n                if sum_radii > best_sum:\n                    best_sum = sum_radii\n                    best_result = result.x\n        except:\n            pass\n    \n    # Polish best result found\n    if best_result is not None:\n        try:\n            polished = minimize(\n                objective,\n                best_result,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 2000, 'ftol': 1e-10}\n            )\n            if polished.success and -polished.fun > best_sum:\n                best_result = polished.x\n                best_sum = -polished.fun\n        except:\n            pass\n    \n    # Extract solution\n    if best_result is not None:\n        centers = best_result[:2*n].reshape(n, 2)\n        radii = best_result[2*n:]\n        sum_radii = np.sum(radii)\n    else:\n        # Fallback: return valid but suboptimal solution\n        grid_size = int(np.ceil(np.sqrt(n)))\n        spacing = 1.0 / (grid_size + 1)\n        centers = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            centers.append([(col + 1) * spacing, (row + 1) * spacing])\n        centers = np.array(centers)\n        radii = np.full(n, spacing / 3)\n        sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T19:01:43.201290",
  "cost_data": null
}