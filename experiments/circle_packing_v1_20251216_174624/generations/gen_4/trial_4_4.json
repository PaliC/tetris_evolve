{
  "trial_id": "trial_4_4",
  "generation": 4,
  "parent_id": "trial_3_2",
  "code": "",
  "metrics": {},
  "prompt": "Scale up this ensemble approach:\n\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def initialize_hexagonal(seed=None):\n        \"\"\"Initialize with hexagonal packing pattern.\"\"\"\n        if seed is not None:\n            np.random.seed(seed)\n        \n        # For 26 circles, use a 5x6 hexagonal grid (30 positions, take best 26)\n        rows = 6\n        cols = 5\n        \n        # Hexagonal spacing\n        hex_height = np.sqrt(3) / 2\n        \n        # Estimate radius for tight packing\n        estimated_radius = 0.5 / (cols + 0.5)\n        \n        centers = []\n        for row in range(rows):\n            for col in range(cols):\n                x_offset = 0.5 * estimated_radius if row % 2 == 1 else 0\n                x = estimated_radius + col * 2 * estimated_radius + x_offset\n                y = estimated_radius + row * hex_height * 2 * estimated_radius\n                centers.append([x, y])\n        \n        centers = np.array(centers)\n        \n        # Scale to fit in unit square with margin\n        margin = 0.02\n        centers_min = centers.min(axis=0)\n        centers_max = centers.max(axis=0)\n        centers = (centers - centers_min) / (centers_max - centers_min)\n        centers = centers * (1 - 2 * margin) + margin\n        \n        # Select 26 most evenly distributed circles\n        if len(centers) > n:\n            indices = []\n            remaining = list(range(len(centers)))\n            \n            # Start with center closest to (0.5, 0.5)\n            dists_to_center = np.linalg.norm(centers - np.array([0.5, 0.5]), axis=1)\n            first_idx = np.argmin(dists_to_center)\n            indices.append(first_idx)\n            remaining.remove(first_idx)\n            \n            # Greedily add circles that maximize minimum distance to selected\n            while len(indices) < n:\n                max_min_dist = -1\n                best_idx = -1\n                for idx in remaining:\n                    min_dist = np.min(np.linalg.norm(centers[indices] - centers[idx], axis=1))\n                    if min_dist > max_min_dist:\n                        max_min_dist = min_dist\n                        best_idx = idx\n                indices.append(best_idx)\n                remaining.remove(best_idx)\n            \n            centers = centers[indices]\n        \n        # Initialize radii based on minimum pairwise distance\n        distances = pdist(centers)\n        min_dist = np.min(distances) if len(distances) > 0 else 0.1\n        radii = np.full(n, min_dist / 2.5)\n        \n        # Adjust radii to respect boundaries\n        for i in range(n):\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = min(radii[i], max_r * 0.95)\n        \n        return centers, radii\n    \n    def pack_to_vector(centers, radii):\n        \"\"\"Convert centers and radii to optimization vector.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def vector_to_pack(x):\n        \"\"\"Convert optimization vector to centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Objective: maximize sum of radii (minimize negative sum).\"\"\"\n        _, radii = vector_to_pack(x)\n        return -np.sum(radii)\n    \n    def constraint_no_overlap(x):\n        \"\"\"Constraint: circles must not overlap.\"\"\"\n        centers, radii = vector_to_pack(x)\n        dists = squareform(pdist(centers))\n        np.fill_diagonal(dists, np.inf)\n        \n        # For each pair, distance - sum of radii should be >= 0\n        constraints = []\n        for i in range(n):\n            for j in range(i+1, n):\n                constraints.append(dists[i, j] - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    def constraint_inside_square(x):\n        \"\"\"Constraint: circles must be inside unit square.\"\"\"\n        centers, radii = vector_to_pack(x)\n        constraints = []\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        return np.array(constraints)\n    \n    def verify_solution(centers, radii):\n        \"\"\"Verify that solution satisfies all constraints.\"\"\"\n        # Check inside square\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < -1e-6 or\n                centers[i, 0] + radii[i] > 1 + 1e-6 or\n                centers[i, 1] - radii[i] < -1e-6 or\n                centers[i, 1] + radii[i] > 1 + 1e-6):\n                return False\n        \n        # Check no overlap\n        dists = squareform(pdist(centers))\n        for i in range(n):\n            for j in range(i+1, n):\n                if dists[i, j] < radii[i] + radii[j] - 1e-6:\n                    return False\n        \n        return True\n    \n    def optimize_from_init(centers_init, radii_init, max_iter=2000):\n        \"\"\"Run optimization from given initialization.\"\"\"\n        x0 = pack_to_vector(centers_init, radii_init)\n        \n        # Bounds\n        bounds = []\n        for i in range(n):\n            bounds.append((0.0, 1.0))  # x\n            bounds.append((0.0, 1.0))  # y\n        for i in range(n):\n            bounds.append((0.001, 0.5))  # radius\n        \n        # Constraints\n        nlc_overlap = NonlinearConstraint(constraint_no_overlap, 0, np.inf)\n        nlc_inside = NonlinearConstraint(constraint_inside_square, 0, np.inf)\n        \n        # Optimize\n        result = minimize(\n            objective,\n            x0,\n            method='trust-constr',\n            bounds=bounds,\n            constraints=[nlc_overlap, nlc_inside],\n            options={\n                'maxiter': max_iter,\n                'verbose': 0,\n                'gtol': 1e-6,\n                'xtol': 1e-8,\n            }\n        )\n        \n        centers_opt, radii_opt = vector_to_pack(result.x)\n        sum_radii = np.sum(radii_opt)\n        valid = verify_solution(centers_opt, radii_opt)\n        \n        return centers_opt, radii_opt, sum_radii, valid\n    \n    # Phase 1: Run 20 optimizations with different initializations\n    all_results = []\n    \n    for trial in range(20):\n        # Initialize with different seed\n        centers_init, radii_init = initialize_hexagonal(seed=trial)\n        \n        # Add perturbation for diversity (except first trial)\n        if trial > 0:\n            centers_init += np.random.normal(0, 0.02, centers_init.shape)\n            centers_init = np.clip(centers_init, 0.05, 0.95)\n            radii_init *= (1 + np.random.normal(0, 0.05, radii_init.shape))\n            radii_init = np.clip(radii_init, 0.01, 0.1)\n        \n        # Optimize\n        centers, radii, sum_radii, valid = optimize_from_init(centers_init, radii_init)\n        \n        if valid:\n            all_results.append({\n                'centers': centers.copy(),\n                'radii': radii.copy(),\n                'sum_radii': sum_radii\n            })\n    \n    # Sort by sum of radii\n    all_results.sort(key=lambda x: x['sum_radii'], reverse=True)\n    \n    # Phase 2: Refine top 5 results with additional optimization\n    refined_results = []\n    \n    for i in range(min(5, len(all_results))):\n        result = all_results[i]\n        \n        # Apply additional refinement\n        centers_refined, radii_refined, sum_refined, valid = optimize_from_init(\n            result['centers'], \n            result['radii'], \n            max_iter=1000\n        )\n        \n        if valid:\n            refined_results.append({\n                'centers': centers_refined.copy(),\n                'radii': radii_refined.copy(),\n                'sum_radii': sum_refined\n            })\n    \n    # Combine all valid results\n    all_valid_results = all_results + refined_results\n    all_valid_results.sort(key=lambda x: x['sum_radii'], reverse=True)\n    \n    # Return best result\n    if len(all_valid_results) > 0:\n        best = all_valid_results[0]\n        return best['centers'], best['radii'], best['sum_radii']\n    else:\n        # Fallback: return basic initialization if all optimizations failed\n        centers_init, radii_init = initialize_hexagonal(seed=0)\n        return centers_init, radii_init, np.sum(radii_init)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nExpand ensemble:\n1. Increase to 200+ independent runs\n2. Test more initialization strategies:\n   - Multiple hexagonal grid orientations\n   - Random perturbations at different scales\n   - Grid-based with varying spacing\n3. For each run, try both trust-constr and SLSQP\n4. Take top 30 results and apply local refinement\n5. Return absolute best\n\nRequirements:\n- 200+ runs\n- Multiple initialization strategies\n- Extensive refinement\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def initialize_hexagonal(seed=None, rotation=0.0, scale_factor=1.0):\n        \"\"\"Initialize with hexagonal packing pattern.\"\"\"\n        if seed is not None:\n            np.random.seed(seed)\n        \n        # For 26 circles, use a 5x6 hexagonal grid (30 positions, take best 26)\n        rows = 6\n        cols = 5\n        \n        # Hexagonal spacing\n        hex_height = np.sqrt(3) / 2\n        \n        # Estimate radius for tight packing\n        estimated_radius = 0.5 / (cols + 0.5) * scale_factor\n        \n        centers = []\n        for row in range(rows):\n            for col in range(cols):\n                x_offset = 0.5 * estimated_radius if row % 2 == 1 else 0\n                x = estimated_radius + col * 2 * estimated_radius + x_offset\n                y = estimated_radius + row * hex_height * 2 * estimated_radius\n                centers.append([x, y])\n        \n        centers = np.array(centers)\n        \n        # Apply rotation\n        if rotation != 0:\n            cos_r = np.cos(rotation)\n            sin_r = np.sin(rotation)\n            rot_matrix = np.array([[cos_r, -sin_r], [sin_r, cos_r]])\n            center_of_mass = centers.mean(axis=0)\n            centers = (centers - center_of_mass) @ rot_matrix.T + center_of_mass\n        \n        # Scale to fit in unit square with margin\n        margin = 0.02\n        centers_min = centers.min(axis=0)\n        centers_max = centers.max(axis=0)\n        centers = (centers - centers_min) / (centers_max - centers_min)\n        centers = centers * (1 - 2 * margin) + margin\n        \n        # Select 26 most evenly distributed circles\n        if len(centers) > n:\n            indices = []\n            remaining = list(range(len(centers)))\n            \n            # Start with center closest to (0.5, 0.5)\n            dists_to_center = np.linalg.norm(centers - np.array([0.5, 0.5]), axis=1)\n            first_idx = np.argmin(dists_to_center)\n            indices.append(first_idx)\n            remaining.remove(first_idx)\n            \n            # Greedily add circles that maximize minimum distance to selected\n            while len(indices) < n:\n                max_min_dist = -1\n                best_idx = -1\n                for idx in remaining:\n                    min_dist = np.min(np.linalg.norm(centers[indices] - centers[idx], axis=1))\n                    if min_dist > max_min_dist:\n                        max_min_dist = min_dist\n                        best_idx = idx\n                indices.append(best_idx)\n                remaining.remove(best_idx)\n            \n            centers = centers[indices]\n        \n        # Initialize radii based on minimum pairwise distance\n        distances = pdist(centers)\n        min_dist = np.min(distances) if len(distances) > 0 else 0.1\n        radii = np.full(n, min_dist / 2.5)\n        \n        # Adjust radii to respect boundaries\n        for i in range(n):\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = min(radii[i], max_r * 0.95)\n        \n        return centers, radii\n    \n    def initialize_grid(seed=None, rows=5, cols=6):\n        \"\"\"Initialize with regular grid pattern.\"\"\"\n        if seed is not None:\n            np.random.seed(seed)\n        \n        total = rows * cols\n        margin = 0.02\n        \n        x_spacing = (1 - 2 * margin) / (cols - 1) if cols > 1 else 0\n        y_spacing = (1 - 2 * margin) / (rows - 1) if rows > 1 else 0\n        \n        centers = []\n        for i in range(rows):\n            for j in range(cols):\n                x = margin + j * x_spacing\n                y = margin + i * y_spacing\n                centers.append([x, y])\n        \n        centers = np.array(centers)\n        \n        # Select n circles\n        if len(centers) > n:\n            indices = np.random.choice(len(centers), n, replace=False)\n            centers = centers[indices]\n        \n        # Initialize radii\n        distances = pdist(centers)\n        min_dist = np.min(distances) if len(distances) > 0 else 0.1\n        radii = np.full(n, min_dist / 2.5)\n        \n        # Adjust radii to respect boundaries\n        for i in range(n):\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = min(radii[i], max_r * 0.95)\n        \n        return centers, radii\n    \n    def initialize_random(seed=None):\n        \"\"\"Initialize with random positions.\"\"\"\n        if seed is not None:\n            np.random.seed(seed)\n        \n        margin = 0.05\n        centers = np.random.uniform(margin, 1 - margin, (n, 2))\n        \n        # Initialize radii\n        distances = pdist(centers)\n        min_dist = np.min(distances) if len(distances) > 0 else 0.1\n        radii = np.full(n, min_dist / 3.0)\n        \n        # Adjust radii to respect boundaries\n        for i in range(n):\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = min(radii[i], max_r * 0.95)\n        \n        return centers, radii\n    \n    def pack_to_vector(centers, radii):\n        \"\"\"Convert centers and radii to optimization vector.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def vector_to_pack(x):\n        \"\"\"Convert optimization vector to centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Objective: maximize sum of radii (minimize negative sum).\"\"\"\n        _, radii = vector_to_pack(x)\n        return -np.sum(radii)\n    \n    def constraint_no_overlap(x):\n        \"\"\"Constraint: circles must not overlap.\"\"\"\n        centers, radii = vector_to_pack(x)\n        dists = squareform(pdist(centers))\n        np.fill_diagonal(dists, np.inf)\n        \n        # For each pair, distance - sum of radii should be >= 0\n        constraints = []\n        for i in range(n):\n            for j in range(i+1, n):\n                constraints.append(dists[i, j] - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    def constraint_inside_square(x):\n        \"\"\"Constraint: circles must be inside unit square.\"\"\"\n        centers, radii = vector_to_pack(x)\n        constraints = []\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        return np.array(constraints)\n    \n    def verify_solution(centers, radii):\n        \"\"\"Verify that solution satisfies all constraints.\"\"\"\n        # Check inside square\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < -1e-6 or\n                centers[i, 0] + radii[i] > 1 + 1e-6 or\n                centers[i, 1] - radii[i] < -1e-6 or\n                centers[i, 1] + radii[i] > 1 + 1e-6):\n                return False\n        \n        # Check no overlap\n        dists = squareform(pdist(centers))\n        for i in range(n):\n            for j in range(i+1, n):\n                if dists[i, j] < radii[i] + radii[j] - 1e-6:\n                    return False\n        \n        return True\n    \n    def optimize_from_init(centers_init, radii_init, method='trust-constr', max_iter=2000):\n        \"\"\"Run optimization from given initialization.\"\"\"\n        x0 = pack_to_vector(centers_init, radii_init)\n        \n        # Bounds\n        bounds = []\n        for i in range(n):\n            bounds.append((0.0, 1.0))  # x\n            bounds.append((0.0, 1.0))  # y\n        for i in range(n):\n            bounds.append((0.001, 0.5))  # radius\n        \n        # Constraints\n        nlc_overlap = NonlinearConstraint(constraint_no_overlap, 0, np.inf)\n        nlc_inside = NonlinearConstraint(constraint_inside_square, 0, np.inf)\n        \n        # Optimize\n        try:\n            result = minimize(\n                objective,\n                x0,\n                method=method,\n                bounds=bounds,\n                constraints=[nlc_overlap, nlc_inside],\n                options={\n                    'maxiter': max_iter,\n                    'verbose': 0,\n                }\n            )\n            \n            centers_opt, radii_opt = vector_to_pack(result.x)\n            sum_radii = np.sum(radii_opt)\n            valid = verify_solution(centers_opt, radii_opt)\n            \n            return centers_opt, radii_opt, sum_radii, valid\n        except:\n            return centers_init, radii_init, np.sum(radii_init), False\n    \n    # Phase 1: Run 250+ optimizations with different initializations\n    all_results = []\n    \n    # Strategy 1: Hexagonal with different rotations (80 runs)\n    for trial in range(80):\n        rotation = trial * np.pi / 40  # Different rotations\n        scale = 0.95 + (trial % 5) * 0.02  # Vary scale\n        centers_init, radii_init = initialize_hexagonal(seed=trial, rotation=rotation, scale_factor=scale)\n        \n        # Add small perturbation for diversity\n        if trial > 0:\n            centers_init += np.random.RandomState(trial).normal(0, 0.015, centers_init.shape)\n            centers_init = np.clip(centers_init, 0.05, 0.95)\n        \n        # Try trust-constr\n        centers, radii, sum_radii, valid = optimize_from_init(centers_init, radii_init, method='trust-constr', max_iter=1500)\n        if valid:\n            all_results.append({\n                'centers': centers.copy(),\n                'radii': radii.copy(),\n                'sum_radii': sum_radii\n            })\n    \n    # Strategy 2: Hexagonal with SLSQP (40 runs)\n    for trial in range(40):\n        rotation = trial * np.pi / 20\n        scale = 0.92 + (trial % 8) * 0.02\n        centers_init, radii_init = initialize_hexagonal(seed=trial+1000, rotation=rotation, scale_factor=scale)\n        \n        if trial > 0:\n            centers_init += np.random.RandomState(trial+1000).normal(0, 0.02, centers_init.shape)\n            centers_init = np.clip(centers_init, 0.05, 0.95)\n        \n        # Try SLSQP\n        centers, radii, sum_radii, valid = optimize_from_init(centers_init, radii_init, method='SLSQP', max_iter=1500)\n        if valid:\n            all_results.append({\n                'centers': centers.copy(),\n                'radii': radii.copy(),\n                'sum_radii': sum_radii\n            })\n    \n    # Strategy 3: Grid-based initializations (40 runs)\n    grid_configs = [(4, 7), (5, 6), (6, 5), (7, 4)]\n    for trial in range(40):\n        config = grid_configs[trial % len(grid_configs)]\n        centers_init, radii_init = initialize_grid(seed=trial+2000, rows=config[0], cols=config[1])\n        \n        # Add perturbation\n        centers_init += np.random.RandomState(trial+2000).normal(0, 0.025, centers_init.shape)\n        centers_init = np.clip(centers_init, 0.05, 0.95)\n        \n        method = 'trust-constr' if trial % 2 == 0 else 'SLSQP'\n        centers, radii, sum_radii, valid = optimize_from_init(centers_init, radii_init, method=method, max_iter=1500)\n        if valid:\n            all_results.append({\n                'centers': centers.copy(),\n                'radii': radii.copy(),\n                'sum_radii': sum_radii\n            })\n    \n    # Strategy 4: Random initializations (40 runs)\n    for trial in range(40):\n        centers_init, radii_init = initialize_random(seed=trial+3000)\n        \n        method = 'trust-constr' if trial % 2 == 0 else 'SLSQP'\n        centers, radii, sum_radii, valid = optimize_from_init(centers_init, radii_init, method=method, max_iter=1500)\n        if valid:\n            all_results.append({\n                'centers': centers.copy(),\n                'radii': radii.copy(),\n                'sum_radii': sum_radii\n            })\n    \n    # Strategy 5: Multi-scale perturbations (20 runs)\n    for trial in range(20):\n        centers_init, radii_init = initialize_hexagonal(seed=trial+4000, rotation=trial*np.pi/10)\n        \n        # Apply multi-scale perturbation\n        perturbation_scale = 0.01 + (trial % 5) * 0.01\n        centers_init += np.random.RandomState(trial+4000).normal(0, perturbation_scale, centers_init.shape)\n        centers_init = np.clip(centers_init, 0.05, 0.95)\n        \n        radii_init *= (1 + np.random.RandomState(trial+4000).normal(0, 0.1, radii_init.shape))\n        radii_init = np.clip(radii_init, 0.01, 0.15)\n        \n        centers, radii, sum_radii, valid = optimize_from_init(centers_init, radii_init, method='trust-constr', max_iter=1500)",
  "reasoning": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def initialize_hexagonal(seed=None, rotation=0.0, scale_factor=1.0):\n        \"\"\"Initialize with hexagonal packing pattern.\"\"\"\n        if seed is not None:\n            np.random.seed(seed)\n        \n        # For 26 circles, use a 5x6 hexagonal grid (30 positions, take best 26)\n        rows = 6\n        cols = 5\n        \n        # Hexagonal spacing\n        hex_height = np.sqrt(3) / 2\n        \n        # Estimate radius for tight packing\n        estimated_radius = 0.5 / (cols + 0.5) * scale_factor\n        \n        centers = []\n        for row in range(rows):\n            for col in range(cols):\n                x_offset = 0.5 * estimated_radius if row % 2 == 1 else 0\n                x = estimated_radius + col * 2 * estimated_radius + x_offset\n                y = estimated_radius + row * hex_height * 2 * estimated_radius\n                centers.append([x, y])\n        \n        centers = np.array(centers)\n        \n        # Apply rotation\n        if rotation != 0:\n            cos_r = np.cos(rotation)\n            sin_r = np.sin(rotation)\n            rot_matrix = np.array([[cos_r, -sin_r], [sin_r, cos_r]])\n            center_of_mass = centers.mean(axis=0)\n            centers = (centers - center_of_mass) @ rot_matrix.T + center_of_mass\n        \n        # Scale to fit in unit square with margin\n        margin = 0.02\n        centers_min = centers.min(axis=0)\n        centers_max = centers.max(axis=0)\n        centers = (centers - centers_min) / (centers_max - centers_min)\n        centers = centers * (1 - 2 * margin) + margin\n        \n        # Select 26 most evenly distributed circles\n        if len(centers) > n:\n            indices = []\n            remaining = list(range(len(centers)))\n            \n            # Start with center closest to (0.5, 0.5)\n            dists_to_center = np.linalg.norm(centers - np.array([0.5, 0.5]), axis=1)\n            first_idx = np.argmin(dists_to_center)\n            indices.append(first_idx)\n            remaining.remove(first_idx)\n            \n            # Greedily add circles that maximize minimum distance to selected\n            while len(indices) < n:\n                max_min_dist = -1\n                best_idx = -1\n                for idx in remaining:\n                    min_dist = np.min(np.linalg.norm(centers[indices] - centers[idx], axis=1))\n                    if min_dist > max_min_dist:\n                        max_min_dist = min_dist\n                        best_idx = idx\n                indices.append(best_idx)\n                remaining.remove(best_idx)\n            \n            centers = centers[indices]\n        \n        # Initialize radii based on minimum pairwise distance\n        distances = pdist(centers)\n        min_dist = np.min(distances) if len(distances) > 0 else 0.1\n        radii = np.full(n, min_dist / 2.5)\n        \n        # Adjust radii to respect boundaries\n        for i in range(n):\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = min(radii[i], max_r * 0.95)\n        \n        return centers, radii\n    \n    def initialize_grid(seed=None, rows=5, cols=6):\n        \"\"\"Initialize with regular grid pattern.\"\"\"\n        if seed is not None:\n            np.random.seed(seed)\n        \n        total = rows * cols\n        margin = 0.02\n        \n        x_spacing = (1 - 2 * margin) / (cols - 1) if cols > 1 else 0\n        y_spacing = (1 - 2 * margin) / (rows - 1) if rows > 1 else 0\n        \n        centers = []\n        for i in range(rows):\n            for j in range(cols):\n                x = margin + j * x_spacing\n                y = margin + i * y_spacing\n                centers.append([x, y])\n        \n        centers = np.array(centers)\n        \n        # Select n circles\n        if len(centers) > n:\n            indices = np.random.choice(len(centers), n, replace=False)\n            centers = centers[indices]\n        \n        # Initialize radii\n        distances = pdist(centers)\n        min_dist = np.min(distances) if len(distances) > 0 else 0.1\n        radii = np.full(n, min_dist / 2.5)\n        \n        # Adjust radii to respect boundaries\n        for i in range(n):\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = min(radii[i], max_r * 0.95)\n        \n        return centers, radii\n    \n    def initialize_random(seed=None):\n        \"\"\"Initialize with random positions.\"\"\"\n        if seed is not None:\n            np.random.seed(seed)\n        \n        margin = 0.05\n        centers = np.random.uniform(margin, 1 - margin, (n, 2))\n        \n        # Initialize radii\n        distances = pdist(centers)\n        min_dist = np.min(distances) if len(distances) > 0 else 0.1\n        radii = np.full(n, min_dist / 3.0)\n        \n        # Adjust radii to respect boundaries\n        for i in range(n):\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = min(radii[i], max_r * 0.95)\n        \n        return centers, radii\n    \n    def pack_to_vector(centers, radii):\n        \"\"\"Convert centers and radii to optimization vector.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def vector_to_pack(x):\n        \"\"\"Convert optimization vector to centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Objective: maximize sum of radii (minimize negative sum).\"\"\"\n        _, radii = vector_to_pack(x)\n        return -np.sum(radii)\n    \n    def constraint_no_overlap(x):\n        \"\"\"Constraint: circles must not overlap.\"\"\"\n        centers, radii = vector_to_pack(x)\n        dists = squareform(pdist(centers))\n        np.fill_diagonal(dists, np.inf)\n        \n        # For each pair, distance - sum of radii should be >= 0\n        constraints = []\n        for i in range(n):\n            for j in range(i+1, n):\n                constraints.append(dists[i, j] - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    def constraint_inside_square(x):\n        \"\"\"Constraint: circles must be inside unit square.\"\"\"\n        centers, radii = vector_to_pack(x)\n        constraints = []\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        return np.array(constraints)\n    \n    def verify_solution(centers, radii):\n        \"\"\"Verify that solution satisfies all constraints.\"\"\"\n        # Check inside square\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < -1e-6 or\n                centers[i, 0] + radii[i] > 1 + 1e-6 or\n                centers[i, 1] - radii[i] < -1e-6 or\n                centers[i, 1] + radii[i] > 1 + 1e-6):\n                return False\n        \n        # Check no overlap\n        dists = squareform(pdist(centers))\n        for i in range(n):\n            for j in range(i+1, n):\n                if dists[i, j] < radii[i] + radii[j] - 1e-6:\n                    return False\n        \n        return True\n    \n    def optimize_from_init(centers_init, radii_init, method='trust-constr', max_iter=2000):\n        \"\"\"Run optimization from given initialization.\"\"\"\n        x0 = pack_to_vector(centers_init, radii_init)\n        \n        # Bounds\n        bounds = []\n        for i in range(n):\n            bounds.append((0.0, 1.0))  # x\n            bounds.append((0.0, 1.0))  # y\n        for i in range(n):\n            bounds.append((0.001, 0.5))  # radius\n        \n        # Constraints\n        nlc_overlap = NonlinearConstraint(constraint_no_overlap, 0, np.inf)\n        nlc_inside = NonlinearConstraint(constraint_inside_square, 0, np.inf)\n        \n        # Optimize\n        try:\n            result = minimize(\n                objective,\n                x0,\n                method=method,\n                bounds=bounds,\n                constraints=[nlc_overlap, nlc_inside],\n                options={\n                    'maxiter': max_iter,\n                    'verbose': 0,\n                }\n            )\n            \n            centers_opt, radii_opt = vector_to_pack(result.x)\n            sum_radii = np.sum(radii_opt)\n            valid = verify_solution(centers_opt, radii_opt)\n            \n            return centers_opt, radii_opt, sum_radii, valid\n        except:\n            return centers_init, radii_init, np.sum(radii_init), False\n    \n    # Phase 1: Run 250+ optimizations with different initializations\n    all_results = []\n    \n    # Strategy 1: Hexagonal with different rotations (80 runs)\n    for trial in range(80):\n        rotation = trial * np.pi / 40  # Different rotations\n        scale = 0.95 + (trial % 5) * 0.02  # Vary scale\n        centers_init, radii_init = initialize_hexagonal(seed=trial, rotation=rotation, scale_factor=scale)\n        \n        # Add small perturbation for diversity\n        if trial > 0:\n            centers_init += np.random.RandomState(trial).normal(0, 0.015, centers_init.shape)\n            centers_init = np.clip(centers_init, 0.05, 0.95)\n        \n        # Try trust-constr\n        centers, radii, sum_radii, valid = optimize_from_init(centers_init, radii_init, method='trust-constr', max_iter=1500)\n        if valid:\n            all_results.append({\n                'centers': centers.copy(),\n                'radii': radii.copy(),\n                'sum_radii': sum_radii\n            })\n    \n    # Strategy 2: Hexagonal with SLSQP (40 runs)\n    for trial in range(40):\n        rotation = trial * np.pi / 20\n        scale = 0.92 + (trial % 8) * 0.02\n        centers_init, radii_init = initialize_hexagonal(seed=trial+1000, rotation=rotation, scale_factor=scale)\n        \n        if trial > 0:\n            centers_init += np.random.RandomState(trial+1000).normal(0, 0.02, centers_init.shape)\n            centers_init = np.clip(centers_init, 0.05, 0.95)\n        \n        # Try SLSQP\n        centers, radii, sum_radii, valid = optimize_from_init(centers_init, radii_init, method='SLSQP', max_iter=1500)\n        if valid:\n            all_results.append({\n                'centers': centers.copy(),\n                'radii': radii.copy(),\n                'sum_radii': sum_radii\n            })\n    \n    # Strategy 3: Grid-based initializations (40 runs)\n    grid_configs = [(4, 7), (5, 6), (6, 5), (7, 4)]\n    for trial in range(40):\n        config = grid_configs[trial % len(grid_configs)]\n        centers_init, radii_init = initialize_grid(seed=trial+2000, rows=config[0], cols=config[1])\n        \n        # Add perturbation\n        centers_init += np.random.RandomState(trial+2000).normal(0, 0.025, centers_init.shape)\n        centers_init = np.clip(centers_init, 0.05, 0.95)\n        \n        method = 'trust-constr' if trial % 2 == 0 else 'SLSQP'\n        centers, radii, sum_radii, valid = optimize_from_init(centers_init, radii_init, method=method, max_iter=1500)\n        if valid:\n            all_results.append({\n                'centers': centers.copy(),\n                'radii': radii.copy(),\n                'sum_radii': sum_radii\n            })\n    \n    # Strategy 4: Random initializations (40 runs)\n    for trial in range(40):\n        centers_init, radii_init = initialize_random(seed=trial+3000)\n        \n        method = 'trust-constr' if trial % 2 == 0 else 'SLSQP'\n        centers, radii, sum_radii, valid = optimize_from_init(centers_init, radii_init, method=method, max_iter=1500)\n        if valid:\n            all_results.append({\n                'centers': centers.copy(),\n                'radii': radii.copy(),\n                'sum_radii': sum_radii\n            })\n    \n    # Strategy 5: Multi-scale perturbations (20 runs)\n    for trial in range(20):\n        centers_init, radii_init = initialize_hexagonal(seed=trial+4000, rotation=trial*np.pi/10)\n        \n        # Apply multi-scale perturbation\n        perturbation_scale = 0.01 + (trial % 5) * 0.01\n        centers_init += np.random.RandomState(trial+4000).normal(0, perturbation_scale, centers_init.shape)\n        centers_init = np.clip(centers_init, 0.05, 0.95)\n        \n        radii_init *= (1 + np.random.RandomState(trial+4000).normal(0, 0.1, radii_init.shape))\n        radii_init = np.clip(radii_init, 0.01, 0.15)\n        \n        centers, radii, sum_radii, valid = optimize_from_init(centers_init, radii_init, method='trust-constr', max_iter=1500)",
  "timestamp": "2025-12-16T18:56:59.062801",
  "cost_data": null
}