{
  "trial_id": "trial_4_9",
  "generation": 4,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import basinhopping, minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def objective(x):\n        \"\"\"Objective to minimize (negative sum of radii).\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        # Penalty for invalid configurations\n        penalty = 0.0\n        \n        # Constraint: circles inside unit square\n        for i in range(n):\n            if centers[i, 0] - radii[i] < 0:\n                penalty += 1000 * (0 - (centers[i, 0] - radii[i]))**2\n            if centers[i, 0] + radii[i] > 1:\n                penalty += 1000 * (centers[i, 0] + radii[i] - 1)**2\n            if centers[i, 1] - radii[i] < 0:\n                penalty += 1000 * (0 - (centers[i, 1] - radii[i]))**2\n            if centers[i, 1] + radii[i] > 1:\n                penalty += 1000 * (centers[i, 1] + radii[i] - 1)**2\n        \n        # Constraint: non-negative radii\n        for i in range(n):\n            if radii[i] < 0:\n                penalty += 1000 * radii[i]**2\n        \n        # Constraint: no overlap\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    penalty += 1000 * overlap**2\n        \n        return -np.sum(radii) + penalty\n    \n    def is_valid(x):\n        \"\"\"Check if configuration is valid.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        # Check bounds\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < -1e-6 or \n                centers[i, 0] + radii[i] > 1 + 1e-6 or\n                centers[i, 1] - radii[i] < -1e-6 or \n                centers[i, 1] + radii[i] > 1 + 1e-6):\n                return False\n        \n        # Check non-negative radii\n        if np.any(radii < -1e-6):\n            return False\n        \n        # Check overlap\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                if dist < radii[i] + radii[j] - 1e-6:\n                    return False\n        \n        return True\n    \n    best_sum = -np.inf\n    best_centers = None\n    best_radii = None\n    \n    # Try multiple random starts\n    for seed in range(25):\n        np.random.seed(seed)\n        \n        # Initialize with grid pattern plus small perturbation\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers_init = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size + np.random.randn() * 0.02\n            y = (row + 0.5) / grid_size + np.random.randn() * 0.02\n            centers_init.append([x, y])\n        centers_init = np.array(centers_init)\n        \n        # Initial radii - small uniform values\n        radii_init = np.ones(n) * 0.05 + np.random.rand(n) * 0.01\n        \n        x0 = np.concatenate([centers_init.flatten(), radii_init])\n        \n        # Bounds\n        bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n        \n        # Basin hopping configuration\n        minimizer_kwargs = {\n            'method': 'L-BFGS-B',\n            'bounds': bounds,\n            'options': {\n                'ftol': 1e-9,\n                'gtol': 1e-8,\n                'maxiter': 1000\n            }\n        }\n        \n        try:\n            result = basinhopping(\n                objective,\n                x0,\n                minimizer_kwargs=minimizer_kwargs,\n                niter=500,\n                T=0.1,\n                stepsize=0.01,\n                seed=seed\n            )\n            \n            x_opt = result.x\n            \n            if is_valid(x_opt):\n                centers_opt = x_opt[:2*n].reshape(n, 2)\n                radii_opt = x_opt[2*n:]\n                sum_radii = np.sum(radii_opt)\n                \n                if sum_radii > best_sum:\n                    best_sum = sum_radii\n                    best_centers = centers_opt.copy()\n                    best_radii = radii_opt.copy()\n        except:\n            continue\n    \n    # If no valid solution found, use a simple grid\n    if best_centers is None:\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            centers.append([x, y])\n        best_centers = np.array(centers)\n        best_radii = np.ones(n) * 0.05\n        best_sum = np.sum(best_radii)\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 300.0093729496002,
    "error": "Timeout after 300s"
  },
  "prompt": "Create basin hopping optimizer with aggressive local search.\n\nStrategy:\n1. Use scipy.optimize.basinhopping\n2. Configure for maximization (negate objective)\n3. Settings:\n   - niter=500 (many basin hops)\n   - T=0.1 (low temperature for focused search)\n   - stepsize=0.01 (small steps)\n   - minimizer_kwargs with tight tolerances\n4. Run 20+ times with different seeds\n5. Return best result\n\nRequirements:\n- Basin hopping implementation\n- Multiple restarts\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import basinhopping, minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def objective(x):\n        \"\"\"Objective to minimize (negative sum of radii).\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        # Penalty for invalid configurations\n        penalty = 0.0\n        \n        # Constraint: circles inside unit square\n        for i in range(n):\n            if centers[i, 0] - radii[i] < 0:\n                penalty += 1000 * (0 - (centers[i, 0] - radii[i]))**2\n            if centers[i, 0] + radii[i] > 1:\n                penalty += 1000 * (centers[i, 0] + radii[i] - 1)**2\n            if centers[i, 1] - radii[i] < 0:\n                penalty += 1000 * (0 - (centers[i, 1] - radii[i]))**2\n            if centers[i, 1] + radii[i] > 1:\n                penalty += 1000 * (centers[i, 1] + radii[i] - 1)**2\n        \n        # Constraint: non-negative radii\n        for i in range(n):\n            if radii[i] < 0:\n                penalty += 1000 * radii[i]**2\n        \n        # Constraint: no overlap\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    penalty += 1000 * overlap**2\n        \n        return -np.sum(radii) + penalty\n    \n    def is_valid(x):\n        \"\"\"Check if configuration is valid.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        # Check bounds\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < -1e-6 or \n                centers[i, 0] + radii[i] > 1 + 1e-6 or\n                centers[i, 1] - radii[i] < -1e-6 or \n                centers[i, 1] + radii[i] > 1 + 1e-6):\n                return False\n        \n        # Check non-negative radii\n        if np.any(radii < -1e-6):\n            return False\n        \n        # Check overlap\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                if dist < radii[i] + radii[j] - 1e-6:\n                    return False\n        \n        return True\n    \n    best_sum = -np.inf\n    best_centers = None\n    best_radii = None\n    \n    # Try multiple random starts\n    for seed in range(25):\n        np.random.seed(seed)\n        \n        # Initialize with grid pattern plus small perturbation\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers_init = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size + np.random.randn() * 0.02\n            y = (row + 0.5) / grid_size + np.random.randn() * 0.02\n            centers_init.append([x, y])\n        centers_init = np.array(centers_init)\n        \n        # Initial radii - small uniform values\n        radii_init = np.ones(n) * 0.05 + np.random.rand(n) * 0.01\n        \n        x0 = np.concatenate([centers_init.flatten(), radii_init])\n        \n        # Bounds\n        bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n        \n        # Basin hopping configuration\n        minimizer_kwargs = {\n            'method': 'L-BFGS-B',\n            'bounds': bounds,\n            'options': {\n                'ftol': 1e-9,\n                'gtol': 1e-8,\n                'maxiter': 1000\n            }\n        }\n        \n        try:\n            result = basinhopping(\n                objective,\n                x0,\n                minimizer_kwargs=minimizer_kwargs,\n                niter=500,\n                T=0.1,\n                stepsize=0.01,\n                seed=seed\n            )\n            \n            x_opt = result.x\n            \n            if is_valid(x_opt):\n                centers_opt = x_opt[:2*n].reshape(n, 2)\n                radii_opt = x_opt[2*n:]\n                sum_radii = np.sum(radii_opt)\n                \n                if sum_radii > best_sum:\n                    best_sum = sum_radii\n                    best_centers = centers_opt.copy()\n                    best_radii = radii_opt.copy()\n        except:\n            continue\n    \n    # If no valid solution found, use a simple grid\n    if best_centers is None:\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            centers.append([x, y])\n        best_centers = np.array(centers)\n        best_radii = np.ones(n) * 0.05\n        best_sum = np.sum(best_radii)\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T19:01:42.666071",
  "cost_data": null
}