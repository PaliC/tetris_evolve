{
  "trial_id": "trial_4_1",
  "generation": 4,
  "parent_id": "trial_3_0",
  "code": "",
  "metrics": {},
  "prompt": "Create extreme ensemble version of trial_3_0:\n\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint, differential_evolution\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def initialize_hexagonal():\n        \"\"\"Initialize with hexagonal packing pattern.\"\"\"\n        rows = 6\n        cols = 5\n        \n        hex_height = np.sqrt(3) / 2\n        estimated_radius = 0.5 / (cols + 0.5)\n        \n        centers = []\n        for row in range(rows):\n            for col in range(cols):\n                x_offset = 0.5 * estimated_radius if row % 2 == 1 else 0\n                x = estimated_radius + col * 2 * estimated_radius + x_offset\n                y = estimated_radius + row * hex_height * 2 * estimated_radius\n                centers.append([x, y])\n        \n        centers = np.array(centers)\n        \n        margin = 0.02\n        centers_min = centers.min(axis=0)\n        centers_max = centers.max(axis=0)\n        centers = (centers - centers_min) / (centers_max - centers_min)\n        centers = centers * (1 - 2 * margin) + margin\n        \n        if len(centers) > n:\n            indices = []\n            remaining = list(range(len(centers)))\n            \n            dists_to_center = np.linalg.norm(centers - np.array([0.5, 0.5]), axis=1)\n            first_idx = np.argmin(dists_to_center)\n            indices.append(first_idx)\n            remaining.remove(first_idx)\n            \n            while len(indices) < n:\n                max_min_dist = -1\n                best_idx = -1\n                for idx in remaining:\n                    min_dist = np.min(np.linalg.norm(centers[indices] - centers[idx], axis=1))\n                    if min_dist > max_min_dist:\n                        max_min_dist = min_dist\n                        best_idx = idx\n                indices.append(best_idx)\n                remaining.remove(best_idx)\n            \n            centers = centers[indices]\n        \n        distances = pdist(centers)\n        min_dist = np.min(distances) if len(distances) > 0 else 0.1\n        radii = np.full(n, min_dist / 2.5)\n        \n        for i in range(n):\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = min(radii[i], max_r * 0.95)\n        \n        return centers, radii\n    \n    def pack_to_vector(centers, radii):\n        \"\"\"Convert centers and radii to optimization vector.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def vector_to_pack(x):\n        \"\"\"Convert optimization vector to centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Objective: maximize sum of radii (minimize negative sum).\"\"\"\n        _, radii = vector_to_pack(x)\n        return -np.sum(radii)\n    \n    def constraint_no_overlap(x):\n        \"\"\"Constraint: circles must not overlap.\"\"\"\n        centers, radii = vector_to_pack(x)\n        dists = squareform(pdist(centers))\n        np.fill_diagonal(dists, np.inf)\n        \n        constraints = []\n        for i in range(n):\n            for j in range(i+1, n):\n                constraints.append(dists[i, j] - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    def constraint_inside_square(x):\n        \"\"\"Constraint: circles must be inside unit square.\"\"\"\n        centers, radii = vector_to_pack(x)\n        constraints = []\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])\n            constraints.append(1 - centers[i, 0] - radii[i])\n            constraints.append(centers[i, 1] - radii[i])\n            constraints.append(1 - centers[i, 1] - radii[i])\n        return np.array(constraints)\n    \n    def is_valid_packing(centers, radii, tol=1e-6):\n        \"\"\"Check if packing satisfies all constraints.\"\"\"\n        # Check inside square\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < -tol or\n                centers[i, 0] + radii[i] > 1 + tol or\n                centers[i, 1] - radii[i] < -tol or\n                centers[i, 1] + radii[i] > 1 + tol):\n                return False\n        \n        # Check no overlap\n        dists = squareform(pdist(centers))\n        for i in range(n):\n            for j in range(i+1, n):\n                if dists[i, j] < radii[i] + radii[j] - tol:\n                    return False\n        \n        return True\n    \n    best_sum = -np.inf\n    best_centers = None\n    best_radii = None\n    \n    # Multiple restarts with different strategies\n    n_restarts = 15\n    \n    for restart in range(n_restarts):\n        # Initialize\n        centers_init, radii_init = initialize_hexagonal()\n        \n        # Add varied perturbations for different restarts\n        if restart > 0:\n            perturbation_scale = 0.01 + 0.03 * (restart / n_restarts)\n            centers_init += np.random.normal(0, perturbation_scale, centers_init.shape)\n            centers_init = np.clip(centers_init, 0.05, 0.95)\n            \n            radii_perturbation = 1 + np.random.normal(0, 0.1 * (restart / n_restarts), radii_init.shape)\n            radii_init *= radii_perturbation\n            radii_init = np.clip(radii_init, 0.001, 0.15)\n        \n        x0 = pack_to_vector(centers_init, radii_init)\n        \n        # Bounds\n        bounds = []\n        for i in range(n):\n            bounds.append((0.0, 1.0))  # x\n            bounds.append((0.0, 1.0))  # y\n        for i in range(n):\n            bounds.append((0.0001, 0.5))  # radius\n        \n        # Constraints with slight relaxation during optimization\n        constraint_tol = -1e-8\n        nlc_overlap = NonlinearConstraint(constraint_no_overlap, constraint_tol, np.inf)\n        nlc_inside = NonlinearConstraint(constraint_inside_square, constraint_tol, np.inf)\n        \n        # Phase 1: trust-constr with high iteration limit\n        result = minimize(\n            objective,\n            x0,\n            method='trust-constr',\n            bounds=bounds,\n            constraints=[nlc_overlap, nlc_inside],\n            options={\n                'maxiter': 50000,\n                'verbose': 0,\n                'gtol': 1e-8,\n                'xtol': 1e-10,\n                'barrier_tol': 1e-10,\n            }\n        )\n        \n        x_intermediate = result.x\n        \n        # Phase 2: Polish with SLSQP for fine-tuning\n        result2 = minimize(\n            objective,\n            x_intermediate,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=[\n                {'type': 'ineq', 'fun': constraint_no_overlap},\n                {'type': 'ineq', 'fun': constraint_inside_square}\n            ],\n            options={\n                'maxiter': 10000,\n                'ftol': 1e-12,\n            }\n        )\n        \n        x_polished = result2.x if result2.success else x_intermediate\n        \n        # Phase 3: Final gradient-free polish with Nelder-Mead\n        # Only for promising solutions\n        if -objective(x_polished) > best_sum - 0.05:\n            result3 = minimize(\n                objective,\n                x_polished,\n                method='Nelder-Mead',\n                options={\n                    'maxiter': 5000,\n                    'xatol': 1e-10,\n                    'fatol': 1e-12,\n                }\n            )\n            \n            # Check if Nelder-Mead improved and constraints still satisfied\n            centers_nm, radii_nm = vector_to_pack(result3.x)\n            if is_valid_packing(centers_nm, radii_nm) and -objective(result3.x) > -objective(x_polished):\n                x_final = result3.x\n            else:\n                x_final = x_polished\n        else:\n            x_final = x_polished\n        \n        # Extract and validate final solution\n        centers_opt, radii_opt = vector_to_pack(x_final)\n        sum_radii = np.sum(radii_opt)\n        \n        if is_valid_packing(centers_opt, radii_opt) and sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers_opt.copy()\n            best_radii = radii_opt.copy()\n    \n    # If we have a good solution, try one more aggressive refinement\n    if best_sum > 2.6:\n        x_best = pack_to_vector(best_centers, best_radii)\n        \n        # Ultra-fine tuning\n        bounds = []\n        for i in range(n):\n            bounds.append((0.0, 1.0))\n            bounds.append((0.0, 1.0))\n        for i in range(n):\n            bounds.append((0.0001, 0.5))\n        \n        nlc_overlap = NonlinearConstraint(constraint_no_overlap, -1e-9, np.inf)\n        nlc_inside = NonlinearConstraint(constraint_inside_square, -1e-9, np.inf)\n        \n        result_final = minimize(\n            objective,\n            x_best,\n            method='trust-constr',\n            bounds=bounds,\n            constraints=[nlc_overlap, nlc_inside],\n            options={\n                'maxiter': 100000,\n                'verbose': 0,\n                'gtol': 1e-10,\n                'xtol': 1e-12,\n                'barrier_tol': 1e-12,\n            }\n        )\n        \n        centers_final, radii_final = vector_to_pack(result_final.x)\n        if is_valid_packing(centers_final, radii_final):\n            sum_final = np.sum(radii_final)\n            if sum_final > best_sum:\n                best_sum = sum_final\n                best_centers = centers_final\n                best_radii = radii_final\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nStrategy:\n1. Run trial_3_0 algorithm 100 times with different:\n   - Random seeds\n   - Initial hexagonal grid perturbations\n   - Scipy method variations (trust-constr, SLSQP, L-BFGS-B)\n2. Track all valid results\n3. Take top 20 results\n4. For each top result:\n   - Apply micro-perturbations (scale 1e-5)\n   - Re-optimize locally\n   - Try radius-only optimization\n5. Return best of best\n\nRequirements:\n- 100+ independent runs\n- Multiple methods tested\n- Extensive local refinement\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint, differential_evolution\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Extreme ensemble version with 100+ runs and extensive refinement.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def initialize_hexagonal(seed=None, perturbation=0.0):\n        \"\"\"Initialize with hexagonal packing pattern.\"\"\"\n        if seed is not None:\n            np.random.seed(seed)\n        \n        rows = 6\n        cols = 5\n        \n        hex_height = np.sqrt(3) / 2\n        estimated_radius = 0.5 / (cols + 0.5)\n        \n        centers = []\n        for row in range(rows):\n            for col in range(cols):\n                x_offset = 0.5 * estimated_radius if row % 2 == 1 else 0\n                x = estimated_radius + col * 2 * estimated_radius + x_offset\n                y = estimated_radius + row * hex_height * 2 * estimated_radius\n                centers.append([x, y])\n        \n        centers = np.array(centers)\n        \n        margin = 0.02\n        centers_min = centers.min(axis=0)\n        centers_max = centers.max(axis=0)\n        centers = (centers - centers_min) / (centers_max - centers_min)\n        centers = centers * (1 - 2 * margin) + margin\n        \n        if len(centers) > n:\n            indices = []\n            remaining = list(range(len(centers)))\n            \n            dists_to_center = np.linalg.norm(centers - np.array([0.5, 0.5]), axis=1)\n            first_idx = np.argmin(dists_to_center)\n            indices.append(first_idx)\n            remaining.remove(first_idx)\n            \n            while len(indices) < n:\n                max_min_dist = -1\n                best_idx = -1\n                for idx in remaining:\n                    min_dist = np.min(np.linalg.norm(centers[indices] - centers[idx], axis=1))\n                    if min_dist > max_min_dist:\n                        max_min_dist = min_dist\n                        best_idx = idx\n                indices.append(best_idx)\n                remaining.remove(best_idx)\n            \n            centers = centers[indices]\n        \n        # Add perturbation\n        if perturbation > 0:\n            centers += np.random.normal(0, perturbation, centers.shape)\n            centers = np.clip(centers, 0.05, 0.95)\n        \n        distances = pdist(centers)\n        min_dist = np.min(distances) if len(distances) > 0 else 0.1\n        radii = np.full(n, min_dist / 2.5)\n        \n        for i in range(n):\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = min(radii[i], max_r * 0.95)\n        \n        return centers, radii\n    \n    def pack_to_vector(centers, radii):\n        \"\"\"Convert centers and radii to optimization vector.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def vector_to_pack(x):\n        \"\"\"Convert optimization vector to centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Objective: maximize sum of radii (minimize negative sum).\"\"\"\n        _, radii = vector_to_pack(x)\n        return -np.sum(radii)\n    \n    def constraint_no_overlap(x):\n        \"\"\"Constraint: circles must not overlap.\"\"\"\n        centers, radii = vector_to_pack(x)\n        dists = squareform(pdist(centers))\n        np.fill_diagonal(dists, np.inf)\n        \n        constraints = []\n        for i in range(n):\n            for j in range(i+1, n):\n                constraints.append(dists[i, j] - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    def constraint_inside_square(x):\n        \"\"\"Constraint: circles must be inside unit square.\"\"\"\n        centers, radii = vector_to_pack(x)\n        constraints = []\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])\n            constraints.append(1 - centers[i, 0] - radii[i])\n            constraints.append(centers[i, 1] - radii[i])\n            constraints.append(1 - centers[i, 1] - radii[i])\n        return np.array(constraints)\n    \n    def is_valid_packing(centers, radii, tol=1e-6):\n        \"\"\"Check if packing satisfies all constraints.\"\"\"\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < -tol or\n                centers[i, 0] + radii[i] > 1 + tol or\n                centers[i, 1] - radii[i] < -tol or\n                centers[i, 1] + radii[i] > 1 + tol):\n                return False\n        \n        dists = squareform(pdist(centers))\n        for i in range(n):\n            for j in range(i+1, n):\n                if dists[i, j] < radii[i] + radii[j] - tol:\n                    return False\n        \n        return True\n    \n    def optimize_single_run(seed, method='trust-constr', perturbation=0.0):\n        \"\"\"Single optimization run.\"\"\"\n        centers_init, radii_init = initialize_hexagonal(seed=seed, perturbation=perturbation)\n        x0 = pack_to_vector(centers_init, radii_init)\n        \n        bounds = []\n        for i in range(n):\n            bounds.append((0.0, 1.0))\n            bounds.append((0.0, 1.0))\n        for i in range(n):\n            bounds.append((0.0001, 0.5))\n        \n        constraint_tol = -1e-8\n        \n        try:\n            if method == 'trust-constr':\n                nlc_overlap = NonlinearConstraint(constraint_no_overlap, constraint_tol, np.inf)\n                nlc_inside = NonlinearConstraint(constraint_inside_square, constraint_tol, np.inf)\n                \n                result = minimize(\n                    objective,\n                    x0,\n                    method='trust-constr',\n                    bounds=bounds,\n                    constraints=[nlc_overlap, nlc_inside],\n                    options={'maxiter': 30000, 'verbose': 0, 'gtol': 1e-8, 'xtol': 1e-10}\n                )\n            elif method == 'SLSQP':\n                result = minimize(\n                    objective,\n                    x0,\n                    method='SLSQP',\n                    bounds=bounds,\n                    constraints=[\n                        {'type': 'ineq', 'fun': constraint_no_overlap},\n                        {'type': 'ineq', 'fun': constraint_inside_square}\n                    ],\n                    options={'maxiter': 20000, 'ftol': 1e-12}\n                )\n            else:  # L-BFGS-B (unconstrained, penalty-based)\n                def penalized_objective(x):\n                    obj = objective(x)\n                    overlap = constraint_no_overlap(x)\n                    inside = constraint_inside_square(x)\n                    penalty = 1e6 * (np.sum(np.minimum(overlap, 0)**2) + np.sum(np.minimum(inside, 0)**2))\n                    return obj + penalty\n                \n                result = minimize(\n                    penalized_objective,\n                    x0,\n                    method='L-BFGS-B',\n                    bounds=bounds,\n                    options={'maxiter': 15000, 'ftol': 1e-12}\n                )\n            \n            centers_opt, radii_opt = vector_to_pack(result.x)\n            \n            if is_valid_packing(centers_opt, radii_opt):\n                return centers_opt, radii_opt, np.sum(radii_opt)\n            else:\n                return None, None, -np.inf\n        except:\n            return None, None, -np.inf\n    \n    def refine_solution(centers, radii, iterations=5):\n        \"\"\"Micro-refine a solution with small perturbations.\"\"\"\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n        best_sum = np.sum(radii)\n        \n        x0 = pack_to_vector(centers, radii)\n        bounds = []\n        for i in range(n):\n            bounds.append((0.0, 1.0))\n            bounds.append((0.0, 1.0))\n        for i in range(n):\n            bounds.append((0.0001, 0.5))\n        \n        for _ in range(iterations):\n            # Micro-perturbation\n            x_perturbed = x0 + np.random.normal(0, 1e-5, x0.shape)\n            x_perturbed = np.clip(x_perturbed, [b[0] for b in bounds], [b[1] for b in bounds])\n            \n            nlc_overlap = NonlinearConstraint(constraint_no_overlap, -1e-9, np.inf)\n            nlc_inside = NonlinearConstraint(constraint_inside_square, -1e-9, np.inf)\n            \n            try:\n                result = minimize(\n                    objective,\n                    x_perturbed,\n                    method='trust-constr',\n                    bounds=bounds,\n                    constraints=[nlc_overlap, nlc_inside],\n                    options={'maxiter': 10000, 'verbose': 0, 'gtol': 1e-10, 'xtol': 1e-12}\n                )\n                \n                centers_new, radii_new = vector_to_pack(result.x)\n                if is_valid_packing(centers_new, radii_new):\n                    sum_new = np.sum(radii_new)\n                    if sum_new > best_sum:\n                        best_sum = sum_new\n                        best_centers = centers_new\n                        best_radii = radii_new\n                        x0 = result.x\n            except:\n                pass\n        \n        # Radius-only optimization\n        try:\n            def objective_radii_only(r):\n                return -np.sum(r)\n            \n            def constraint_overlap_radii(r):\n                dists = squareform(pdist(best_centers))\n                np.fill_diagonal(dists, np.inf)\n                constraints = []\n                for i in range(n):\n                    for j in range(i+1, n):\n                        constraints.append(dists[i, j] - r[i] - r[j])\n                return np.array(constraints)\n            \n            def constraint_inside_radii(r):\n                constraints = []\n                for i in range(n):\n                    constraints.append(best_centers[i, 0] - r[i])\n                    constraints.append(1 - best_centers[i, 0] - r[i])\n                    constraints.append(best_centers[i, 1] - r[i])\n                    constraints.append(1 - best_centers[i, 1] - r[i])\n                return np.array(constraints)\n            \n            bounds_radii = [(0.0001, 0.5) for _ in range(n)]\n            \n            result_radii = minimize(\n                objective_radii_only,\n                best_radii,\n                method='SLSQP',\n                bounds=bounds_radii,\n                constraints=[\n                    {'type': 'ineq', 'fun': constraint_overlap_radii},\n                    {'type': 'ineq', 'fun': constraint_inside_radii}\n                ],\n                options={'maxiter': 5000, 'ftol': 1e-12}\n            )\n            \n            if is_valid_packing(best_centers, result_radii.x):\n                sum_radii_only = np.sum(result_radii.x)\n                if sum_radii_only > best_sum:\n                    best_sum = sum_radii_only\n                    best_radii = result_radii.x\n        except:\n            pass\n        \n        return best_centers, best_radii, best_sum\n    \n    # Phase 1: Massive ensemble of 120 runs\n    results = []\n    methods = ['trust-constr', 'SLSQP', 'L-BFGS-B']\n    \n    for run_id in range(120):\n        seed = run_id\n        method = methods[run_id % 3]\n        perturbation = 0.01 * (run_id // 40)  # 0, 0.01, 0.02\n        \n        centers, radii, sum_radii = optimize_single_run(seed, method, perturbation)\n        \n        if centers is not None:\n            results.append((centers, radii, sum_radii))\n    \n    # Sort and take top 25\n    results.sort(key=lambda x: x[2], reverse=True)\n    top_results = results[:25]\n    \n    # Phase 2: Refine top results\n    refined_results = []\n    for centers, radii, sum_radii in top_results:\n        centers_ref, radii_ref, sum_ref = refine_solution(centers, radii, iterations=8)\n        refined_results.append((centers_ref, radii_ref, sum_ref))\n    \n    # Phase 3: Ultra-refinement of best result\n    refined_results.sort(key=lambda x: x[2], reverse=True)\n    best_centers, best_radii, best_sum = refined_results[0]\n    \n    # Final ultra-fine polish\n    x_best = pack_to_vector(best_centers, best_radii)\n    bounds = []\n    for i in range(n):\n        bounds.append((0.0, 1.0))\n        bounds.append((0.0, 1.0))\n    for i in range(n):\n        bounds.append((0.0001, 0.5))\n    \n    nlc_overlap = NonlinearConstraint(constraint_no_overlap, -1e-10, np.inf)\n    nlc_inside = NonlinearConstraint(constraint_inside_square, -1e-10, np.inf)\n    \n    try:\n        result_final = minimize(\n            objective,\n            x_best,\n            method='trust-constr',\n            bounds=bounds,\n            constraints=[nlc_overlap, nlc_inside],\n            options={'maxiter': 50000, 'verbose': 0, 'gtol': 1e-11, 'xtol': 1e-13, 'barrier_tol': 1e-13}\n        )\n        \n        centers_final, radii_final = vector_to_pack(result_final.x)\n        if is_valid_packing(centers_final, radii_final):\n            sum_final = np.sum(radii_final)\n            if sum_final > best_sum:\n                best_sum = sum_final\n                best_centers = centers_final\n                best_radii = radii_final\n    except:\n        pass\n    \n    return best_centers, best_radii, best_",
  "reasoning": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint, differential_evolution\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Extreme ensemble version with 100+ runs and extensive refinement.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def initialize_hexagonal(seed=None, perturbation=0.0):\n        \"\"\"Initialize with hexagonal packing pattern.\"\"\"\n        if seed is not None:\n            np.random.seed(seed)\n        \n        rows = 6\n        cols = 5\n        \n        hex_height = np.sqrt(3) / 2\n        estimated_radius = 0.5 / (cols + 0.5)\n        \n        centers = []\n        for row in range(rows):\n            for col in range(cols):\n                x_offset = 0.5 * estimated_radius if row % 2 == 1 else 0\n                x = estimated_radius + col * 2 * estimated_radius + x_offset\n                y = estimated_radius + row * hex_height * 2 * estimated_radius\n                centers.append([x, y])\n        \n        centers = np.array(centers)\n        \n        margin = 0.02\n        centers_min = centers.min(axis=0)\n        centers_max = centers.max(axis=0)\n        centers = (centers - centers_min) / (centers_max - centers_min)\n        centers = centers * (1 - 2 * margin) + margin\n        \n        if len(centers) > n:\n            indices = []\n            remaining = list(range(len(centers)))\n            \n            dists_to_center = np.linalg.norm(centers - np.array([0.5, 0.5]), axis=1)\n            first_idx = np.argmin(dists_to_center)\n            indices.append(first_idx)\n            remaining.remove(first_idx)\n            \n            while len(indices) < n:\n                max_min_dist = -1\n                best_idx = -1\n                for idx in remaining:\n                    min_dist = np.min(np.linalg.norm(centers[indices] - centers[idx], axis=1))\n                    if min_dist > max_min_dist:\n                        max_min_dist = min_dist\n                        best_idx = idx\n                indices.append(best_idx)\n                remaining.remove(best_idx)\n            \n            centers = centers[indices]\n        \n        # Add perturbation\n        if perturbation > 0:\n            centers += np.random.normal(0, perturbation, centers.shape)\n            centers = np.clip(centers, 0.05, 0.95)\n        \n        distances = pdist(centers)\n        min_dist = np.min(distances) if len(distances) > 0 else 0.1\n        radii = np.full(n, min_dist / 2.5)\n        \n        for i in range(n):\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = min(radii[i], max_r * 0.95)\n        \n        return centers, radii\n    \n    def pack_to_vector(centers, radii):\n        \"\"\"Convert centers and radii to optimization vector.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def vector_to_pack(x):\n        \"\"\"Convert optimization vector to centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Objective: maximize sum of radii (minimize negative sum).\"\"\"\n        _, radii = vector_to_pack(x)\n        return -np.sum(radii)\n    \n    def constraint_no_overlap(x):\n        \"\"\"Constraint: circles must not overlap.\"\"\"\n        centers, radii = vector_to_pack(x)\n        dists = squareform(pdist(centers))\n        np.fill_diagonal(dists, np.inf)\n        \n        constraints = []\n        for i in range(n):\n            for j in range(i+1, n):\n                constraints.append(dists[i, j] - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    def constraint_inside_square(x):\n        \"\"\"Constraint: circles must be inside unit square.\"\"\"\n        centers, radii = vector_to_pack(x)\n        constraints = []\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])\n            constraints.append(1 - centers[i, 0] - radii[i])\n            constraints.append(centers[i, 1] - radii[i])\n            constraints.append(1 - centers[i, 1] - radii[i])\n        return np.array(constraints)\n    \n    def is_valid_packing(centers, radii, tol=1e-6):\n        \"\"\"Check if packing satisfies all constraints.\"\"\"\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < -tol or\n                centers[i, 0] + radii[i] > 1 + tol or\n                centers[i, 1] - radii[i] < -tol or\n                centers[i, 1] + radii[i] > 1 + tol):\n                return False\n        \n        dists = squareform(pdist(centers))\n        for i in range(n):\n            for j in range(i+1, n):\n                if dists[i, j] < radii[i] + radii[j] - tol:\n                    return False\n        \n        return True\n    \n    def optimize_single_run(seed, method='trust-constr', perturbation=0.0):\n        \"\"\"Single optimization run.\"\"\"\n        centers_init, radii_init = initialize_hexagonal(seed=seed, perturbation=perturbation)\n        x0 = pack_to_vector(centers_init, radii_init)\n        \n        bounds = []\n        for i in range(n):\n            bounds.append((0.0, 1.0))\n            bounds.append((0.0, 1.0))\n        for i in range(n):\n            bounds.append((0.0001, 0.5))\n        \n        constraint_tol = -1e-8\n        \n        try:\n            if method == 'trust-constr':\n                nlc_overlap = NonlinearConstraint(constraint_no_overlap, constraint_tol, np.inf)\n                nlc_inside = NonlinearConstraint(constraint_inside_square, constraint_tol, np.inf)\n                \n                result = minimize(\n                    objective,\n                    x0,\n                    method='trust-constr',\n                    bounds=bounds,\n                    constraints=[nlc_overlap, nlc_inside],\n                    options={'maxiter': 30000, 'verbose': 0, 'gtol': 1e-8, 'xtol': 1e-10}\n                )\n            elif method == 'SLSQP':\n                result = minimize(\n                    objective,\n                    x0,\n                    method='SLSQP',\n                    bounds=bounds,\n                    constraints=[\n                        {'type': 'ineq', 'fun': constraint_no_overlap},\n                        {'type': 'ineq', 'fun': constraint_inside_square}\n                    ],\n                    options={'maxiter': 20000, 'ftol': 1e-12}\n                )\n            else:  # L-BFGS-B (unconstrained, penalty-based)\n                def penalized_objective(x):\n                    obj = objective(x)\n                    overlap = constraint_no_overlap(x)\n                    inside = constraint_inside_square(x)\n                    penalty = 1e6 * (np.sum(np.minimum(overlap, 0)**2) + np.sum(np.minimum(inside, 0)**2))\n                    return obj + penalty\n                \n                result = minimize(\n                    penalized_objective,\n                    x0,\n                    method='L-BFGS-B',\n                    bounds=bounds,\n                    options={'maxiter': 15000, 'ftol': 1e-12}\n                )\n            \n            centers_opt, radii_opt = vector_to_pack(result.x)\n            \n            if is_valid_packing(centers_opt, radii_opt):\n                return centers_opt, radii_opt, np.sum(radii_opt)\n            else:\n                return None, None, -np.inf\n        except:\n            return None, None, -np.inf\n    \n    def refine_solution(centers, radii, iterations=5):\n        \"\"\"Micro-refine a solution with small perturbations.\"\"\"\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n        best_sum = np.sum(radii)\n        \n        x0 = pack_to_vector(centers, radii)\n        bounds = []\n        for i in range(n):\n            bounds.append((0.0, 1.0))\n            bounds.append((0.0, 1.0))\n        for i in range(n):\n            bounds.append((0.0001, 0.5))\n        \n        for _ in range(iterations):\n            # Micro-perturbation\n            x_perturbed = x0 + np.random.normal(0, 1e-5, x0.shape)\n            x_perturbed = np.clip(x_perturbed, [b[0] for b in bounds], [b[1] for b in bounds])\n            \n            nlc_overlap = NonlinearConstraint(constraint_no_overlap, -1e-9, np.inf)\n            nlc_inside = NonlinearConstraint(constraint_inside_square, -1e-9, np.inf)\n            \n            try:\n                result = minimize(\n                    objective,\n                    x_perturbed,\n                    method='trust-constr',\n                    bounds=bounds,\n                    constraints=[nlc_overlap, nlc_inside],\n                    options={'maxiter': 10000, 'verbose': 0, 'gtol': 1e-10, 'xtol': 1e-12}\n                )\n                \n                centers_new, radii_new = vector_to_pack(result.x)\n                if is_valid_packing(centers_new, radii_new):\n                    sum_new = np.sum(radii_new)\n                    if sum_new > best_sum:\n                        best_sum = sum_new\n                        best_centers = centers_new\n                        best_radii = radii_new\n                        x0 = result.x\n            except:\n                pass\n        \n        # Radius-only optimization\n        try:\n            def objective_radii_only(r):\n                return -np.sum(r)\n            \n            def constraint_overlap_radii(r):\n                dists = squareform(pdist(best_centers))\n                np.fill_diagonal(dists, np.inf)\n                constraints = []\n                for i in range(n):\n                    for j in range(i+1, n):\n                        constraints.append(dists[i, j] - r[i] - r[j])\n                return np.array(constraints)\n            \n            def constraint_inside_radii(r):\n                constraints = []\n                for i in range(n):\n                    constraints.append(best_centers[i, 0] - r[i])\n                    constraints.append(1 - best_centers[i, 0] - r[i])\n                    constraints.append(best_centers[i, 1] - r[i])\n                    constraints.append(1 - best_centers[i, 1] - r[i])\n                return np.array(constraints)\n            \n            bounds_radii = [(0.0001, 0.5) for _ in range(n)]\n            \n            result_radii = minimize(\n                objective_radii_only,\n                best_radii,\n                method='SLSQP',\n                bounds=bounds_radii,\n                constraints=[\n                    {'type': 'ineq', 'fun': constraint_overlap_radii},\n                    {'type': 'ineq', 'fun': constraint_inside_radii}\n                ],\n                options={'maxiter': 5000, 'ftol': 1e-12}\n            )\n            \n            if is_valid_packing(best_centers, result_radii.x):\n                sum_radii_only = np.sum(result_radii.x)\n                if sum_radii_only > best_sum:\n                    best_sum = sum_radii_only\n                    best_radii = result_radii.x\n        except:\n            pass\n        \n        return best_centers, best_radii, best_sum\n    \n    # Phase 1: Massive ensemble of 120 runs\n    results = []\n    methods = ['trust-constr', 'SLSQP', 'L-BFGS-B']\n    \n    for run_id in range(120):\n        seed = run_id\n        method = methods[run_id % 3]\n        perturbation = 0.01 * (run_id // 40)  # 0, 0.01, 0.02\n        \n        centers, radii, sum_radii = optimize_single_run(seed, method, perturbation)\n        \n        if centers is not None:\n            results.append((centers, radii, sum_radii))\n    \n    # Sort and take top 25\n    results.sort(key=lambda x: x[2], reverse=True)\n    top_results = results[:25]\n    \n    # Phase 2: Refine top results\n    refined_results = []\n    for centers, radii, sum_radii in top_results:\n        centers_ref, radii_ref, sum_ref = refine_solution(centers, radii, iterations=8)\n        refined_results.append((centers_ref, radii_ref, sum_ref))\n    \n    # Phase 3: Ultra-refinement of best result\n    refined_results.sort(key=lambda x: x[2], reverse=True)\n    best_centers, best_radii, best_sum = refined_results[0]\n    \n    # Final ultra-fine polish\n    x_best = pack_to_vector(best_centers, best_radii)\n    bounds = []\n    for i in range(n):\n        bounds.append((0.0, 1.0))\n        bounds.append((0.0, 1.0))\n    for i in range(n):\n        bounds.append((0.0001, 0.5))\n    \n    nlc_overlap = NonlinearConstraint(constraint_no_overlap, -1e-10, np.inf)\n    nlc_inside = NonlinearConstraint(constraint_inside_square, -1e-10, np.inf)\n    \n    try:\n        result_final = minimize(\n            objective,\n            x_best,\n            method='trust-constr',\n            bounds=bounds,\n            constraints=[nlc_overlap, nlc_inside],\n            options={'maxiter': 50000, 'verbose': 0, 'gtol': 1e-11, 'xtol': 1e-13, 'barrier_tol': 1e-13}\n        )\n        \n        centers_final, radii_final = vector_to_pack(result_final.x)\n        if is_valid_packing(centers_final, radii_final):\n            sum_final = np.sum(radii_final)\n            if sum_final > best_sum:\n                best_sum = sum_final\n                best_centers = centers_final\n                best_radii = radii_final\n    except:\n        pass\n    \n    return best_centers, best_radii, best_",
  "timestamp": "2025-12-16T18:57:02.838847",
  "cost_data": null
}