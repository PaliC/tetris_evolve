{
  "trial_id": "trial_2_12",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, LinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using analytical gradients.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Initialize with a grid-based layout\n    grid_size = int(np.ceil(np.sqrt(n)))\n    initial_centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        initial_centers.append([x, y])\n    initial_centers = np.array(initial_centers)\n    \n    # Initialize radii to maximum possible given grid spacing\n    initial_radius = 0.45 / grid_size\n    initial_radii = np.full(n, initial_radius)\n    \n    # Combine into single parameter vector: [centers (flattened), radii]\n    x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n    \n    def unpack_params(x):\n        \"\"\"Unpack parameter vector into centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Objective: maximize sum of radii (minimize negative sum).\"\"\"\n        _, radii = unpack_params(x)\n        return -np.sum(radii)\n    \n    def gradient(x):\n        \"\"\"Analytical gradient of objective.\"\"\"\n        grad = np.zeros_like(x)\n        # Gradient w.r.t. centers is 0\n        # Gradient w.r.t. radii is -1 (since we minimize negative sum)\n        grad[2*n:] = -1.0\n        return grad\n    \n    def constraints_and_jacobian(x):\n        \"\"\"\n        Compute constraint violations and Jacobian.\n        \n        Constraints:\n        1. Centers must be inside square: r_i <= x_i <= 1-r_i, r_i <= y_i <= 1-r_i\n        2. Non-overlap: ||c_i - c_j|| >= r_i + r_j for all i < j\n        3. Non-negative radii: r_i >= 0\n        \"\"\"\n        centers, radii = unpack_params(x)\n        \n        constraints = []\n        jacobian_rows = []\n        \n        # Boundary constraints: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n        for i in range(n):\n            # x_i >= r_i\n            constraints.append(centers[i, 0] - radii[i])\n            jac = np.zeros(3*n)\n            jac[2*i] = 1.0\n            jac[2*n + i] = -1.0\n            jacobian_rows.append(jac)\n            \n            # x_i <= 1 - r_i\n            constraints.append(1.0 - centers[i, 0] - radii[i])\n            jac = np.zeros(3*n)\n            jac[2*i] = -1.0\n            jac[2*n + i] = -1.0\n            jacobian_rows.append(jac)\n            \n            # y_i >= r_i\n            constraints.append(centers[i, 1] - radii[i])\n            jac = np.zeros(3*n)\n            jac[2*i + 1] = 1.0\n            jac[2*n + i] = -1.0\n            jacobian_rows.append(jac)\n            \n            # y_i <= 1 - r_i\n            constraints.append(1.0 - centers[i, 1] - radii[i])\n            jac = np.zeros(3*n)\n            jac[2*i + 1] = -1.0\n            jac[2*n + i] = -1.0\n            jacobian_rows.append(jac)\n            \n            # r_i >= 0\n            constraints.append(radii[i])\n            jac = np.zeros(3*n)\n            jac[2*n + i] = 1.0\n            jacobian_rows.append(jac)\n        \n        # Non-overlap constraints: ||c_i - c_j||^2 >= (r_i + r_j)^2\n        for i in range(n):\n            for j in range(i+1, n):\n                diff = centers[i] - centers[j]\n                dist_sq = np.sum(diff**2)\n                dist = np.sqrt(dist_sq + 1e-10)\n                \n                # Constraint: dist - (r_i + r_j) >= 0\n                constraints.append(dist - radii[i] - radii[j])\n                \n                # Jacobian\n                jac = np.zeros(3*n)\n                if dist > 1e-10:\n                    jac[2*i] = diff[0] / dist\n                    jac[2*i + 1] = diff[1] / dist\n                    jac[2*j] = -diff[0] / dist\n                    jac[2*j + 1] = -diff[1] / dist\n                jac[2*n + i] = -1.0\n                jac[2*n + j] = -1.0\n                jacobian_rows.append(jac)\n        \n        return np.array(constraints), np.array(jacobian_rows)\n    \n    def constraint_func(x):\n        \"\"\"Constraint function for optimizer.\"\"\"\n        cons, _ = constraints_and_jacobian(x)\n        return cons\n    \n    def constraint_jacobian(x):\n        \"\"\"Jacobian of constraints.\"\"\"\n        _, jac = constraints_and_jacobian(x)\n        return jac\n    \n    # Set up constraint\n    num_constraints = 5*n + n*(n-1)//2\n    constraint = {\n        'type': 'ineq',\n        'fun': constraint_func,\n        'jac': constraint_jacobian\n    }\n    \n    # Optimize using SLSQP with analytical gradients\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        jac=gradient,\n        constraints=constraint,\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n    \n    # Try multiple random restarts for better solution\n    best_result = result\n    best_obj = result.fun\n    \n    for restart in range(5):\n        # Random initialization with some structure\n        perturb = np.random.randn(3*n) * 0.05\n        x_init = x0 + perturb\n        \n        # Ensure initial feasibility\n        centers_init, radii_init = unpack_params(x_init)\n        radii_init = np.maximum(radii_init, 0.01)\n        centers_init = np.clip(centers_init, radii_init[:, None], 1 - radii_init[:, None])\n        x_init = np.concatenate([centers_init.flatten(), radii_init])\n        \n        result_restart = minimize(\n            objective,\n            x_init,\n            method='SLSQP',\n            jac=gradient,\n            constraints=constraint,\n            options={'maxiter': 1000, 'ftol': 1e-9}\n        )\n        \n        if result_restart.fun < best_obj:\n            best_result = result_restart\n            best_obj = result_restart.fun\n    \n    # Extract final solution\n    final_centers, final_radii = unpack_params(best_result.x)\n    sum_radii = np.sum(final_radii)\n    \n    return final_centers, final_radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.5836388871673432,
    "target_ratio": 0.9805081165720468,
    "combined_score": 0.9805081165720468,
    "eval_time": 0.6306250095367432,
    "error": null
  },
  "prompt": "Create optimization using analytical gradients for faster convergence.\n\nStrategy:\n1. Formulate objective: maximize sum of radii\n2. Compute analytical gradients:\n   - Gradient of sum w.r.t. positions\n   - Gradient of sum w.r.t. radii\n3. Use gradient ascent with line search\n4. Project onto feasible region after each step\n5. Implement constraint handling via projection\n\nRequirements:\n- Analytical gradient computation\n- Efficient projection methods\n- Fast convergence\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, LinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using analytical gradients.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Initialize with a grid-based layout\n    grid_size = int(np.ceil(np.sqrt(n)))\n    initial_centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        initial_centers.append([x, y])\n    initial_centers = np.array(initial_centers)\n    \n    # Initialize radii to maximum possible given grid spacing\n    initial_radius = 0.45 / grid_size\n    initial_radii = np.full(n, initial_radius)\n    \n    # Combine into single parameter vector: [centers (flattened), radii]\n    x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n    \n    def unpack_params(x):\n        \"\"\"Unpack parameter vector into centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Objective: maximize sum of radii (minimize negative sum).\"\"\"\n        _, radii = unpack_params(x)\n        return -np.sum(radii)\n    \n    def gradient(x):\n        \"\"\"Analytical gradient of objective.\"\"\"\n        grad = np.zeros_like(x)\n        # Gradient w.r.t. centers is 0\n        # Gradient w.r.t. radii is -1 (since we minimize negative sum)\n        grad[2*n:] = -1.0\n        return grad\n    \n    def constraints_and_jacobian(x):\n        \"\"\"\n        Compute constraint violations and Jacobian.\n        \n        Constraints:\n        1. Centers must be inside square: r_i <= x_i <= 1-r_i, r_i <= y_i <= 1-r_i\n        2. Non-overlap: ||c_i - c_j|| >= r_i + r_j for all i < j\n        3. Non-negative radii: r_i >= 0\n        \"\"\"\n        centers, radii = unpack_params(x)\n        \n        constraints = []\n        jacobian_rows = []\n        \n        # Boundary constraints: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n        for i in range(n):\n            # x_i >= r_i\n            constraints.append(centers[i, 0] - radii[i])\n            jac = np.zeros(3*n)\n            jac[2*i] = 1.0\n            jac[2*n + i] = -1.0\n            jacobian_rows.append(jac)\n            \n            # x_i <= 1 - r_i\n            constraints.append(1.0 - centers[i, 0] - radii[i])\n            jac = np.zeros(3*n)\n            jac[2*i] = -1.0\n            jac[2*n + i] = -1.0\n            jacobian_rows.append(jac)\n            \n            # y_i >= r_i\n            constraints.append(centers[i, 1] - radii[i])\n            jac = np.zeros(3*n)\n            jac[2*i + 1] = 1.0\n            jac[2*n + i] = -1.0\n            jacobian_rows.append(jac)\n            \n            # y_i <= 1 - r_i\n            constraints.append(1.0 - centers[i, 1] - radii[i])\n            jac = np.zeros(3*n)\n            jac[2*i + 1] = -1.0\n            jac[2*n + i] = -1.0\n            jacobian_rows.append(jac)\n            \n            # r_i >= 0\n            constraints.append(radii[i])\n            jac = np.zeros(3*n)\n            jac[2*n + i] = 1.0\n            jacobian_rows.append(jac)\n        \n        # Non-overlap constraints: ||c_i - c_j||^2 >= (r_i + r_j)^2\n        for i in range(n):\n            for j in range(i+1, n):\n                diff = centers[i] - centers[j]\n                dist_sq = np.sum(diff**2)\n                dist = np.sqrt(dist_sq + 1e-10)\n                \n                # Constraint: dist - (r_i + r_j) >= 0\n                constraints.append(dist - radii[i] - radii[j])\n                \n                # Jacobian\n                jac = np.zeros(3*n)\n                if dist > 1e-10:\n                    jac[2*i] = diff[0] / dist\n                    jac[2*i + 1] = diff[1] / dist\n                    jac[2*j] = -diff[0] / dist\n                    jac[2*j + 1] = -diff[1] / dist\n                jac[2*n + i] = -1.0\n                jac[2*n + j] = -1.0\n                jacobian_rows.append(jac)\n        \n        return np.array(constraints), np.array(jacobian_rows)\n    \n    def constraint_func(x):\n        \"\"\"Constraint function for optimizer.\"\"\"\n        cons, _ = constraints_and_jacobian(x)\n        return cons\n    \n    def constraint_jacobian(x):\n        \"\"\"Jacobian of constraints.\"\"\"\n        _, jac = constraints_and_jacobian(x)\n        return jac\n    \n    # Set up constraint\n    num_constraints = 5*n + n*(n-1)//2\n    constraint = {\n        'type': 'ineq',\n        'fun': constraint_func,\n        'jac': constraint_jacobian\n    }\n    \n    # Optimize using SLSQP with analytical gradients\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        jac=gradient,\n        constraints=constraint,\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n    \n    # Try multiple random restarts for better solution\n    best_result = result\n    best_obj = result.fun\n    \n    for restart in range(5):\n        # Random initialization with some structure\n        perturb = np.random.randn(3*n) * 0.05\n        x_init = x0 + perturb\n        \n        # Ensure initial feasibility\n        centers_init, radii_init = unpack_params(x_init)\n        radii_init = np.maximum(radii_init, 0.01)\n        centers_init = np.clip(centers_init, radii_init[:, None], 1 - radii_init[:, None])\n        x_init = np.concatenate([centers_init.flatten(), radii_init])\n        \n        result_restart = minimize(\n            objective,\n            x_init,\n            method='SLSQP',\n            jac=gradient,\n            constraints=constraint,\n            options={'maxiter': 1000, 'ftol': 1e-9}\n        )\n        \n        if result_restart.fun < best_obj:\n            best_result = result_restart\n            best_obj = result_restart.fun\n    \n    # Extract final solution\n    final_centers, final_radii = unpack_params(best_result.x)\n    sum_radii = np.sum(final_radii)\n    \n    return final_centers, final_radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T17:59:57.079907",
  "cost_data": null
}