{
  "trial_id": "trial_2_6",
  "generation": 2,
  "parent_id": "trial_1_13",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, differential_evolution\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses iterative radius expansion with hexagonal initialization and multi-circle expansion.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n_circles = 26\n    \n    # Initialize with hexagonal grid pattern\n    centers, radii = initialize_hexagonal_grid(n_circles)\n    \n    # Iterative expansion with binary search and multi-circle strategy\n    centers, radii = iterative_expansion(centers, radii, max_iterations=100)\n    \n    # Global optimization refinement\n    centers, radii = global_optimization_refinement(centers, radii)\n    \n    # Final local polish\n    centers, radii = local_polish(centers, radii)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\n\ndef initialize_hexagonal_grid(n_circles):\n    \"\"\"\n    Initialize circles in a hexagonal grid pattern for better packing.\n    \n    Args:\n        n_circles: number of circles\n        \n    Returns:\n        centers: np.array of shape (n_circles, 2)\n        radii: np.array of shape (n_circles,)\n    \"\"\"\n    # Determine grid dimensions (approximate square layout)\n    cols = int(np.ceil(np.sqrt(n_circles * 1.15)))  # Hexagonal needs more columns\n    rows = int(np.ceil(n_circles / cols))\n    \n    # Hexagonal spacing\n    x_spacing = 1.0 / (cols + 0.5)\n    y_spacing = 1.0 / (rows + 0.5)\n    \n    centers = []\n    for i in range(n_circles):\n        row = i // cols\n        col = i % cols\n        \n        # Hexagonal offset for alternating rows\n        x_offset = (row % 2) * x_spacing * 0.5\n        x = x_spacing * 0.75 + col * x_spacing + x_offset\n        y = y_spacing * 0.75 + row * y_spacing * 0.866  # sqrt(3)/2 for hex\n        \n        # Keep within bounds\n        x = np.clip(x, 0.05, 0.95)\n        y = np.clip(y, 0.05, 0.95)\n        \n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    \n    # Initialize with small radii\n    min_spacing = min(x_spacing, y_spacing)\n    radii = np.full(n_circles, min_spacing * 0.25)\n    \n    return centers, radii\n\n\ndef check_feasibility(centers, radii, tolerance=1e-6):\n    \"\"\"\n    Check if configuration is feasible (no overlaps, within bounds).\n    \n    Args:\n        centers: np.array of shape (n, 2)\n        radii: np.array of shape (n,)\n        tolerance: numerical tolerance\n        \n    Returns:\n        bool: True if feasible\n    \"\"\"\n    n = len(radii)\n    \n    # Check boundaries\n    for i in range(n):\n        if (centers[i, 0] - radii[i] < -tolerance or \n            centers[i, 0] + radii[i] > 1.0 + tolerance or\n            centers[i, 1] - radii[i] < -tolerance or \n            centers[i, 1] + radii[i] > 1.0 + tolerance):\n            return False\n    \n    # Check overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - tolerance:\n                return False\n    \n    return True\n\n\ndef iterative_expansion(centers, radii, max_iterations=100):\n    \"\"\"\n    Iteratively expand circles using binary search and smart selection.\n    \n    Args:\n        centers: initial centers\n        radii: initial radii\n        max_iterations: maximum expansion iterations\n        \n    Returns:\n        centers: updated centers\n        radii: updated radii\n    \"\"\"\n    n_circles = len(radii)\n    \n    for iteration in range(max_iterations):\n        # Compute expansion potential for each circle\n        expansion_potential = compute_expansion_potential(centers, radii)\n        \n        # Select circles to expand (top candidates)\n        n_expand = max(1, n_circles // 4)  # Expand 25% of circles each iteration\n        expand_indices = np.argsort(expansion_potential)[-n_expand:]\n        \n        # Binary search for maximum feasible expansion\n        low, high = 0.0, 0.05\n        best_expansion = 0.0\n        \n        for _ in range(15):  # Binary search iterations\n            mid = (low + high) / 2\n            radii_test = radii.copy()\n            radii_test[expand_indices] += mid\n            \n            if check_feasibility(centers, radii_test, tolerance=1e-7):\n                best_expansion = mid\n                low = mid\n            else:\n                high = mid\n        \n        # Apply best expansion\n        if best_expansion > 1e-8:\n            radii[expand_indices] += best_expansion\n        else:\n            # No expansion possible, try position jittering\n            centers = jitter_positions(centers, radii)\n            \n            # Check if jittering helped\n            expansion_potential_new = compute_expansion_potential(centers, radii)\n            if np.max(expansion_potential_new) <= np.max(expansion_potential) + 1e-8:\n                break  # Converged\n    \n    return centers, radii\n\n\ndef compute_expansion_potential(centers, radii):\n    \"\"\"\n    Compute how much each circle could potentially expand.\n    \n    Args:\n        centers: np.array of shape (n, 2)\n        radii: np.array of shape (n,)\n        \n    Returns:\n        potential: np.array of shape (n,) - expansion potential for each circle\n    \"\"\"\n    n = len(radii)\n    potential = np.full(n, 1.0)  # Start with max potential\n    \n    for i in range(n):\n        # Check distance to boundaries\n        dist_left = centers[i, 0] - radii[i]\n        dist_right = 1.0 - (centers[i, 0] + radii[i])\n        dist_bottom = centers[i, 1] - radii[i]\n        dist_top = 1.0 - (centers[i, 1] + radii[i])\n        \n        boundary_limit = min(dist_left, dist_right, dist_bottom, dist_top)\n        potential[i] = min(potential[i], boundary_limit)\n        \n        # Check distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                gap = dist - radii[i] - radii[j]\n                potential[i] = min(potential[i], gap)\n    \n    return np.maximum(potential, 0.0)\n\n\ndef jitter_positions(centers, radii, jitter_strength=0.01):\n    \"\"\"\n    Apply small random perturbations to circle positions.\n    \n    Args:\n        centers: np.array of shape (n, 2)\n        radii: np.array of shape (n,)\n        jitter_strength: maximum perturbation magnitude\n        \n    Returns:\n        centers: jittered centers\n    \"\"\"\n    n = len(radii)\n    \n    for attempt in range(10):\n        centers_new = centers + np.random.randn(n, 2) * jitter_strength\n        \n        # Ensure boundaries are respected\n        for i in range(n):\n            centers_new[i, 0] = np.clip(centers_new[i, 0], radii[i], 1.0 - radii[i])\n            centers_new[i, 1] = np.clip(centers_new[i, 1], radii[i], 1.0 - radii[i])\n        \n        if check_feasibility(centers_new, radii):\n            return centers_new\n    \n    return centers  # Return original if no valid jitter found\n\n\ndef global_optimization_refinement(centers, radii):\n    \"\"\"\n    Apply global optimization to refine the packing.\n    \n    Args:\n        centers: np.array of shape (n, 2)\n        radii: np.array of shape (n,)\n        \n    Returns:\n        centers: refined centers\n        radii: refined radii\n    \"\"\"\n    n_circles = len(radii)\n    \n    def objective(params):\n        radii = params[:n_circles]\n        return -np.sum(radii)\n    \n    def constraints_func(params):\n        radii = params[:n_circles]\n        centers = params[n_circles:].reshape(n_circles, 2)\n        \n        violations = []\n        \n        # Boundaries\n        for i in range(n_circles):\n            violations.append(centers[i, 0] - radii[i])\n            violations.append(1.0 - (centers[i, 0] + radii[i]))\n            violations.append(centers[i, 1] - radii[i])\n            violations.append(1.0 - (centers[i, 1] + radii[i]))\n        \n        # Non-overlap\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                violations.append(dist - (radii[i] + radii[j]))\n        \n        return np.array(violations)\n    \n    x0 = np.concatenate([radii, centers.flatten()])\n    \n    bounds = [(0.001, 0.5) for _ in range(n_circles)]\n    for _ in range(n_circles):\n        bounds.append((0.0, 1.0))\n        bounds.append((0.0, 1.0))\n    \n    # SLSQP optimization\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraints_func},\n        options={'maxiter': 500, 'ftol': 1e-9}\n    )\n    \n    if result.success:\n        radii_new = result.x[:n_circles]\n        centers_new = result.x[n_circles:].reshape(n_circles, 2)\n        \n        if check_feasibility(centers_new, radii_new):\n            return centers_new, radii_new\n    \n    return centers, radii\n\n\ndef local_polish(centers, radii):\n    \"\"\"\n    Final local optimization polish with tight tolerances.\n    \n    Args:\n        centers: np.array of shape (n, 2)\n        radii: np.array of shape (n,)\n        \n    Returns:\n        centers: polished centers\n        radii: polished radii\n    \"\"\"\n    n_circles = len(radii)\n    \n    def objective(params):\n        radii = params[:n_circles]\n        return -np.sum(radii)\n    \n    def constraints_func(params):\n        radii = params[:n_circles]\n        centers = params[n_circles:].reshape(n_circles, 2)\n        \n        violations = []\n        \n        for i in range(n_circles):\n            violations.append(centers[i, 0] - radii[i])\n            violations.append(1.0 - (centers[i, 0] + radii[i]))\n            violations.append(centers[i, 1] - radii[i])\n            violations.append(1.0 - (centers[i, 1] + radii[i]))\n        \n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                violations.append(dist - (radii[i] + radii[j]))\n        \n        return np.array(violations)\n    \n    x0 = np.concatenate([radii, centers.flatten()])\n    \n    bounds = [(0.001, 0.5) for _ in range(n_circles)]\n    for _ in range(n_circles):\n        bounds.append((0.0, 1.0))\n        bounds.append((0.0, 1.0))\n    \n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraints_func},\n        options={'maxiter': 1000, 'ftol': 1e-12}\n    )\n    \n    if result.success:\n        radii_new = result.x[:n_circles]\n        centers_new = result.x[n_circles:].reshape(n_circles, 2)\n        \n        if check_feasibility(centers_new, radii_new):\n            return centers_new, radii_new\n    \n    return centers, radii\n\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.5511896274132986,
    "target_ratio": 0.9681934069879692,
    "combined_score": 0.9681934069879692,
    "eval_time": 0.9537651538848877,
    "error": null
  },
  "prompt": "Enhance this iterative radius expansion algorithm:\n\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses divide-and-conquer with quadrant-based optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    \n    # Divide into 4 quadrants with allocation: 7, 7, 6, 6 circles\n    quadrant_counts = [7, 7, 6, 6]\n    quadrant_bounds = [\n        (0.0, 0.5, 0.0, 0.5),  # Bottom-left\n        (0.5, 1.0, 0.0, 0.5),  # Bottom-right\n        (0.0, 0.5, 0.5, 1.0),  # Top-left\n        (0.5, 1.0, 0.5, 1.0),  # Top-right\n    ]\n    \n    all_centers = []\n    all_radii = []\n    \n    # Step 1: Optimize each quadrant independently\n    for q_idx, (n_circles, bounds) in enumerate(zip(quadrant_counts, quadrant_bounds)):\n        x_min, x_max, y_min, y_max = bounds\n        centers, radii = optimize_quadrant(n_circles, x_min, x_max, y_min, y_max)\n        all_centers.append(centers)\n        all_radii.append(radii)\n    \n    # Combine all quadrants\n    centers = np.vstack(all_centers)\n    radii = np.hstack(all_radii)\n    \n    # Step 2: Global refinement with boundary relaxation\n    centers, radii = global_refinement(centers, radii)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\n\ndef optimize_quadrant(n_circles, x_min, x_max, y_min, y_max):\n    \"\"\"\n    Optimize circle packing within a single quadrant.\n    \n    Args:\n        n_circles: number of circles to pack\n        x_min, x_max, y_min, y_max: quadrant boundaries\n        \n    Returns:\n        centers: np.array of shape (n_circles, 2)\n        radii: np.array of shape (n_circles,)\n    \"\"\"\n    \n    def objective(params):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        radii = params[:n_circles]\n        return -np.sum(radii)\n    \n    def constraints_func(params):\n        \"\"\"Return constraint violations (should be >= 0).\"\"\"\n        radii = params[:n_circles]\n        centers = params[n_circles:].reshape(n_circles, 2)\n        \n        violations = []\n        \n        # Boundary constraints\n        for i in range(n_circles):\n            violations.append(centers[i, 0] - radii[i] - x_min)  # left\n            violations.append(x_max - (centers[i, 0] + radii[i]))  # right\n            violations.append(centers[i, 1] - radii[i] - y_min)  # bottom\n            violations.append(y_max - (centers[i, 1] + radii[i]))  # top\n        \n        # Non-overlap constraints\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                violations.append(dist - (radii[i] + radii[j]))\n        \n        return np.array(violations)\n    \n    # Initial guess: grid layout with small radii\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    x_spacing = (x_max - x_min) / (grid_size + 1)\n    y_spacing = (y_max - y_min) / (grid_size + 1)\n    \n    centers_init = []\n    for i in range(n_circles):\n        row = i // grid_size\n        col = i % grid_size\n        x = x_min + (col + 1) * x_spacing\n        y = y_min + (row + 1) * y_spacing\n        centers_init.append([x, y])\n    centers_init = np.array(centers_init)\n    \n    # Initial radii: conservative estimate\n    min_spacing = min(x_spacing, y_spacing)\n    radii_init = np.full(n_circles, min_spacing * 0.3)\n    \n    # Combine into single parameter vector\n    x0 = np.concatenate([radii_init, centers_init.flatten()])\n    \n    # Bounds\n    bounds = [(0.001, 0.5) for _ in range(n_circles)]  # radii bounds\n    for _ in range(n_circles):\n        bounds.append((x_min, x_max))  # x bounds\n        bounds.append((y_min, y_max))  # y bounds\n    \n    # Use differential evolution for global optimization\n    result = differential_evolution(\n        objective,\n        bounds,\n        maxiter=300,\n        popsize=15,\n        seed=42,\n        atol=1e-6,\n        tol=1e-6,\n        workers=1\n    )\n    \n    # Extract solution\n    radii = result.x[:n_circles]\n    centers = result.x[n_circles:].reshape(n_circles, 2)\n    \n    # Local refinement\n    from scipy.optimize import NonlinearConstraint\n    \n    nlc = NonlinearConstraint(constraints_func, 0, np.inf)\n    \n    result_local = minimize(\n        objective,\n        result.x,\n        method='SLSQP',\n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraints_func},\n        options={'maxiter': 500, 'ftol': 1e-9}\n    )\n    \n    if result_local.success or result_local.fun < result.fun:\n        radii = result_local.x[:n_circles]\n        centers = result_local.x[n_circles:].reshape(n_circles, 2)\n    \n    return centers, radii\n\n\ndef global_refinement(centers, radii):\n    \"\"\"\n    Global refinement allowing boundary adjustments.\n    \n    Args:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        \n    Returns:\n        centers: refined centers\n        radii: refined radii\n    \"\"\"\n    n_circles = len(radii)\n    \n    def objective(params):\n        radii = params[:n_circles]\n        return -np.sum(radii)\n    \n    def constraints_func(params):\n        radii = params[:n_circles]\n        centers = params[n_circles:].reshape(n_circles, 2)\n        \n        violations = []\n        \n        # Unit square boundaries\n        for i in range(n_circles):\n            violations.append(centers[i, 0] - radii[i])  # left\n            violations.append(1.0 - (centers[i, 0] + radii[i]))  # right\n            violations.append(centers[i, 1] - radii[i])  # bottom\n            violations.append(1.0 - (centers[i, 1] + radii[i]))  # top\n        \n        # Non-overlap\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                violations.append(dist - (radii[i] + radii[j]))\n        \n        return np.array(violations)\n    \n    # Initial parameters\n    x0 = np.concatenate([radii, centers.flatten()])\n    \n    # Bounds\n    bounds = [(0.001, 0.5) for _ in range(n_circles)]  # radii\n    for _ in range(n_circles):\n        bounds.append((0.0, 1.0))  # x\n        bounds.append((0.0, 1.0))  # y\n    \n    # Global refinement with SLSQP\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraints_func},\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n    \n    radii_refined = result.x[:n_circles]\n    centers_refined = result.x[n_circles:].reshape(n_circles, 2)\n    \n    return centers_refined, radii_refined\n\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nImprovements:\n1. Use better initial positions (hexagonal grid)\n2. Smarter expansion strategy: expand multiple circles simultaneously\n3. Add position jittering between expansion rounds\n4. Apply scipy optimization after expansion converges\n5. Implement binary search for expansion amount per iteration\n\nRequirements:\n- Keep iterative expansion core\n- Add optimization refinement\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses iterative radius expansion with hexagonal initialization and multi-circle expansion.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n_circles = 26\n    \n    # Initialize with hexagonal grid pattern\n    centers, radii = initialize_hexagonal_grid(n_circles)\n    \n    # Iterative expansion with binary search and multi-circle strategy\n    centers, radii = iterative_expansion(centers, radii, max_iterations=100)\n    \n    # Global optimization refinement\n    centers, radii = global_optimization_refinement(centers, radii)\n    \n    # Final local polish\n    centers, radii = local_polish(centers, radii)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\n\ndef initialize_hexagonal_grid(n_circles):\n    \"\"\"\n    Initialize circles in a hexagonal grid pattern for better packing.\n    \n    Args:\n        n_circles: number of circles\n        \n    Returns:\n        centers: np.array of shape (n_circles, 2)\n        radii: np.array of shape (n_circles,)\n    \"\"\"\n    # Determine grid dimensions (approximate square layout)\n    cols = int(np.ceil(np.sqrt(n_circles * 1.15)))  # Hexagonal needs more columns\n    rows = int(np.ceil(n_circles / cols))\n    \n    # Hexagonal spacing\n    x_spacing = 1.0 / (cols + 0.5)\n    y_spacing = 1.0 / (rows + 0.5)\n    \n    centers = []\n    for i in range(n_circles):\n        row = i // cols\n        col = i % cols\n        \n        # Hexagonal offset for alternating rows\n        x_offset = (row % 2) * x_spacing * 0.5\n        x = x_spacing * 0.75 + col * x_spacing + x_offset\n        y = y_spacing * 0.75 + row * y_spacing * 0.866  # sqrt(3)/2 for hex\n        \n        # Keep within bounds\n        x = np.clip(x, 0.05, 0.95)\n        y = np.clip(y, 0.05, 0.95)\n        \n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    \n    # Initialize with small radii\n    min_spacing = min(x_spacing, y_spacing)\n    radii = np.full(n_circles, min_spacing * 0.25)\n    \n    return centers, radii\n\n\ndef check_feasibility(centers, radii, tolerance=1e-6):\n    \"\"\"\n    Check if configuration is feasible (no overlaps, within bounds).\n    \n    Args:\n        centers: np.array of shape (n, 2)\n        radii: np.array of shape (n,)\n        tolerance: numerical tolerance\n        \n    Returns:\n        bool: True if feasible\n    \"\"\"\n    n = len(radii)\n    \n    # Check boundaries\n    for i in range(n):\n        if (centers[i, 0] - radii[i] < -tolerance or \n            centers[i, 0] + radii[i] > 1.0 + tolerance or\n            centers[i, 1] - radii[i] < -tolerance or \n            centers[i, 1] + radii[i] > 1.0 + tolerance):\n            return False\n    \n    # Check overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - tolerance:\n                return False\n    \n    return True\n\n\ndef iterative_expansion(centers, radii, max_iterations=100):\n    \"\"\"\n    Iteratively expand circles using binary search and smart selection.\n    \n    Args:\n        centers: initial centers\n        radii: initial radii\n        max_iterations: maximum expansion iterations\n        \n    Returns:\n        centers: updated centers\n        radii: updated radii\n    \"\"\"\n    n_circles = len(radii)\n    \n    for iteration in range(max_iterations):\n        # Compute expansion potential for each circle\n        expansion_potential = compute_expansion_potential(centers, radii)\n        \n        # Select circles to expand (top candidates)\n        n_expand = max(1, n_circles // 4)  # Expand 25% of circles each iteration\n        expand_indices = np.argsort(expansion_potential)[-n_expand:]\n        \n        # Binary search for maximum feasible expansion\n        low, high = 0.0, 0.05\n        best_expansion = 0.0\n        \n        for _ in range(15):  # Binary search iterations\n            mid = (low + high) / 2\n            radii_test = radii.copy()\n            radii_test[expand_indices] += mid\n            \n            if check_feasibility(centers, radii_test, tolerance=1e-7):\n                best_expansion = mid\n                low = mid\n            else:\n                high = mid\n        \n        # Apply best expansion\n        if best_expansion > 1e-8:\n            radii[expand_indices] += best_expansion\n        else:\n            # No expansion possible, try position jittering\n            centers = jitter_positions(centers, radii)\n            \n            # Check if jittering helped\n            expansion_potential_new = compute_expansion_potential(centers, radii)\n            if np.max(expansion_potential_new) <= np.max(expansion_potential) + 1e-8:\n                break  # Converged\n    \n    return centers, radii\n\n\ndef compute_expansion_potential(centers, radii):\n    \"\"\"\n    Compute how much each circle could potentially expand.\n    \n    Args:\n        centers: np.array of shape (n, 2)\n        radii: np.array of shape (n,)\n        \n    Returns:\n        potential: np.array of shape (n,) - expansion potential for each circle\n    \"\"\"\n    n = len(radii)\n    potential = np.full(n, 1.0)  # Start with max potential\n    \n    for i in range(n):\n        # Check distance to boundaries\n        dist_left = centers[i, 0] - radii[i]\n        dist_right = 1.0 - (centers[i, 0] + radii[i])\n        dist_bottom = centers[i, 1] - radii[i]\n        dist_top = 1.0 - (centers[i, 1] + radii[i])\n        \n        boundary_limit = min(dist_left, dist_right, dist_bottom, dist_top)\n        potential[i] = min(potential[i], boundary_limit)\n        \n        # Check distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                gap = dist - radii[i] - radii[j]\n                potential[i] = min(potential[i], gap)\n    \n    return np.maximum(potential, 0.0)\n\n\ndef jitter_positions(centers, radii, jitter_strength=0.01):\n    \"\"\"\n    Apply small random perturbations to circle positions.\n    \n    Args:\n        centers: np.array of shape (n, 2)\n        radii: np.array of shape (n,)\n        jitter_strength: maximum perturbation magnitude\n        \n    Returns:\n        centers: jittered centers\n    \"\"\"\n    n = len(radii)\n    \n    for attempt in range(10):\n        centers_new = centers + np.random.randn(n, 2) * jitter_strength\n        \n        # Ensure boundaries are respected\n        for i in range(n):\n            centers_new[i, 0] = np.clip(centers_new[i, 0], radii[i], 1.0 - radii[i])\n            centers_new[i, 1] = np.clip(centers_new[i, 1], radii[i], 1.0 - radii[i])\n        \n        if check_feasibility(centers_new, radii):\n            return centers_new\n    \n    return centers  # Return original if no valid jitter found\n\n\ndef global_optimization_refinement(centers, radii):\n    \"\"\"\n    Apply global optimization to refine the packing.\n    \n    Args:\n        centers: np.array of shape (n, 2)\n        radii: np.array of shape (n,)\n        \n    Returns:\n        centers: refined centers\n        radii: refined radii\n    \"\"\"\n    n_circles = len(radii)\n    \n    def objective(params):\n        radii = params[:n_circles]\n        return -np.sum(radii)\n    \n    def constraints_func(params):\n        radii = params[:n_circles]\n        centers = params[n_circles:].reshape(n_circles, 2)\n        \n        violations = []\n        \n        # Boundaries\n        for i in range(n_circles):\n            violations.append(centers[i, 0] - radii[i])\n            violations.append(1.0 - (centers[i, 0] + radii[i]))\n            violations.append(centers[i, 1] - radii[i])\n            violations.append(1.0 - (centers[i, 1] + radii[i]))\n        \n        # Non-overlap\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                violations.append(dist - (radii[i] + radii[j]))\n        \n        return np.array(violations)\n    \n    x0 = np.concatenate([radii, centers.flatten()])\n    \n    bounds = [(0.001, 0.5) for _ in range(n_circles)]\n    for _ in range(n_circles):\n        bounds.append((0.0, 1.0))\n        bounds.append((0.0, 1.0))\n    \n    # SLSQP optimization\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraints_func},\n        options={'maxiter': 500, 'ftol': 1e-9}\n    )\n    \n    if result.success:\n        radii_new = result.x[:n_circles]\n        centers_new = result.x[n_circles:].reshape(n_circles, 2)\n        \n        if check_feasibility(centers_new, radii_new):\n            return centers_new, radii_new\n    \n    return centers, radii\n\n\ndef local_polish(centers, radii):\n    \"\"\"\n    Final local optimization polish with tight tolerances.\n    \n    Args:\n        centers: np.array of shape (n, 2)\n        radii: np.array of shape (n,)\n        \n    Returns:\n        centers: polished centers\n        radii: polished radii\n    \"\"\"\n    n_circles = len(radii)\n    \n    def objective(params):\n        radii = params[:n_circles]\n        return -np.sum(radii)\n    \n    def constraints_func(params):\n        radii = params[:n_circles]\n        centers = params[n_circles:].reshape(n_circles, 2)\n        \n        violations = []\n        \n        for i in range(n_circles):\n            violations.append(centers[i, 0] - radii[i])\n            violations.append(1.0 - (centers[i, 0] + radii[i]))\n            violations.append(centers[i, 1] - radii[i])\n            violations.append(1.0 - (centers[i, 1] + radii[i]))\n        \n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                violations.append(dist - (radii[i] + radii[j]))\n        \n        return np.array(violations)\n    \n    x0 = np.concatenate([radii, centers.flatten()])\n    \n    bounds = [(0.001, 0.5) for _ in range(n_circles)]\n    for _ in range(n_circles):\n        bounds.append((0.0, 1.0))\n        bounds.append((0.0, 1.0))\n    \n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraints_func},\n        options={'maxiter': 1000, 'ftol': 1e-12}\n    )\n    \n    if result.success:\n        radii_new = result.x[:n_circles]\n        centers_new = result.x[n_circles:].reshape(n_circles, 2)\n        \n        if check_feasibility(centers_new, radii_new):\n            return centers_new, radii_new\n    \n    return centers, radii\n\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T18:00:07.628029",
  "cost_data": null
}