{
  "trial_id": "trial_2_2",
  "generation": 2,
  "parent_id": "trial_1_6",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using adaptive hybrid optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Phase 1: Adaptive force-directed layout with temperature-based acceptance\n    def adaptive_force_directed_layout(n_iterations=15000):\n        \"\"\"Use adaptive force-directed approach with simulated annealing.\"\"\"\n        # Start with optimized grid layout\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            centers.append([x, y])\n        centers = np.array(centers)\n        \n        # Initialize with conservative uniform radii\n        radii = np.ones(n) * 0.035\n        \n        # Adaptive parameters\n        initial_dt = 0.002\n        final_dt = 0.0001\n        initial_damping = 0.85\n        final_damping = 0.95\n        initial_temp = 0.02  # Temperature for constraint violation acceptance\n        final_temp = 0.0\n        \n        velocities = np.zeros_like(centers)\n        \n        # Track best configuration\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n        best_sum = np.sum(radii)\n        \n        for iteration in range(n_iterations):\n            # Adaptive parameters with exponential decay\n            progress = iteration / n_iterations\n            dt = initial_dt * np.exp(-5 * progress) + final_dt\n            damping = initial_damping + (final_damping - initial_damping) * progress\n            temperature = initial_temp * (1 - progress)**2\n            \n            # Adaptive force strength (decreases as system settles)\n            force_scale = 10.0 * (1 + 5 * np.exp(-3 * progress))\n            \n            forces = np.zeros_like(centers)\n            \n            # Repulsion between overlapping circles with adaptive strength\n            for i in range(n):\n                for j in range(i + 1, n):\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    min_dist = radii[i] + radii[j]\n                    \n                    # Adaptive buffer zone (tighter as we progress)\n                    buffer = 0.02 * (1 - progress)\n                    \n                    if dist < min_dist + buffer:\n                        if dist > 1e-6:\n                            overlap = min_dist - dist\n                            force_mag = overlap * force_scale\n                            force_dir = diff / dist\n                            forces[i] += force_mag * force_dir\n                            forces[j] -= force_mag * force_dir\n            \n            # Adaptive boundary forces (stronger as we progress)\n            boundary_scale = 5.0 * (1 + 10 * progress)\n            for i in range(n):\n                r = radii[i]\n                margin = 0.01 * (1 - progress)  # Shrinking margin\n                \n                if centers[i, 0] - r < margin:\n                    forces[i, 0] += (r + margin - centers[i, 0]) * boundary_scale\n                if centers[i, 0] + r > 1 - margin:\n                    forces[i, 0] -= (centers[i, 0] + r - 1 + margin) * boundary_scale\n                if centers[i, 1] - r < margin:\n                    forces[i, 1] += (r + margin - centers[i, 1]) * boundary_scale\n                if centers[i, 1] + r > 1 - margin:\n                    forces[i, 1] -= (centers[i, 1] + r - 1 + margin) * boundary_scale\n            \n            # Update velocities and positions\n            velocities = velocities * damping + forces * dt\n            centers += velocities * dt\n            centers = np.clip(centers, 0, 1)\n            \n            # Adaptive radius growth with temperature-based acceptance\n            if iteration % 50 == 0:\n                # Growth rate decreases as we progress\n                growth_rate = 1.02 * np.exp(-2 * progress) + 1.001\n                \n                for i in range(n):\n                    test_radius = radii[i] * growth_rate\n                    \n                    # Check if increase is valid with temperature-based tolerance\n                    violation = 0.0\n                    \n                    # Check bounds with temperature tolerance\n                    if centers[i, 0] - test_radius < -temperature:\n                        violation += abs(centers[i, 0] - test_radius)\n                    if centers[i, 0] + test_radius > 1 + temperature:\n                        violation += abs(centers[i, 0] + test_radius - 1)\n                    if centers[i, 1] - test_radius < -temperature:\n                        violation += abs(centers[i, 1] - test_radius)\n                    if centers[i, 1] + test_radius > 1 + temperature:\n                        violation += abs(centers[i, 1] + test_radius - 1)\n                    \n                    # Check overlaps with temperature tolerance\n                    max_overlap = 0.0\n                    for j in range(n):\n                        if i != j:\n                            dist = np.linalg.norm(centers[i] - centers[j])\n                            overlap = (test_radius + radii[j]) - dist\n                            if overlap > max_overlap:\n                                max_overlap = overlap\n                    \n                    violation += max_overlap\n                    \n                    # Accept if violation within temperature threshold\n                    if violation <= temperature:\n                        radii[i] = test_radius\n            \n            # Track best valid configuration\n            if iteration % 500 == 0 and progress > 0.5:\n                # Check if current configuration is valid\n                is_valid = True\n                for i in range(n):\n                    if (centers[i, 0] - radii[i] < -1e-6 or \n                        centers[i, 0] + radii[i] > 1 + 1e-6 or\n                        centers[i, 1] - radii[i] < -1e-6 or \n                        centers[i, 1] + radii[i] > 1 + 1e-6):\n                        is_valid = False\n                        break\n                    for j in range(i + 1, n):\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        if dist < radii[i] + radii[j] - 1e-6:\n                            is_valid = False\n                            break\n                    if not is_valid:\n                        break\n                \n                current_sum = np.sum(radii)\n                if is_valid and current_sum > best_sum:\n                    best_sum = current_sum\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n        \n        return best_centers, best_radii\n    \n    # Phase 2: Multi-start scipy optimization with smart initialization\n    def adaptive_scipy_optimization(centers_init, radii_init, n_attempts=5):\n        \"\"\"Refine packing using scipy optimization with multiple adaptive starts.\"\"\"\n        \n        def objective(x):\n            radii = x[2*n:]\n            return -np.sum(radii)\n        \n        def create_constraints():\n            constraints = []\n            \n            # Boundary constraints\n            for i in range(n):\n                constraints.append({'type': 'ineq', 'fun': lambda x, i=i: x[2*i] - x[2*n + i]})\n                constraints.append({'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i] - x[2*n + i]})\n                constraints.append({'type': 'ineq', 'fun': lambda x, i=i: x[2*i + 1] - x[2*n + i]})\n                constraints.append({'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i + 1] - x[2*n + i]})\n            \n            # Non-overlap constraints\n            for i in range(n):\n                for j in range(i + 1, n):\n                    def overlap_constraint(x, i=i, j=j):\n                        cx_i, cy_i = x[2*i], x[2*i + 1]\n                        cx_j, cy_j = x[2*j], x[2*j + 1]\n                        r_i, r_j = x[2*n + i], x[2*n + j]\n                        dist = np.sqrt((cx_i - cx_j)**2 + (cy_i - cy_j)**2)\n                        return dist - (r_i + r_j)\n                    constraints.append({'type': 'ineq', 'fun': overlap_constraint})\n            \n            # Non-negative radii\n            for i in range(n):\n                constraints.append({'type': 'ineq', 'fun': lambda x, i=i: x[2*n + i]})\n            \n            return constraints\n        \n        bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n        constraints = create_constraints()\n        \n        best_result = None\n        best_value = float('inf')\n        \n        for attempt in range(n_attempts):\n            if attempt == 0:\n                # First attempt: use force-directed result\n                x_init = np.concatenate([centers_init.flatten(), radii_init])\n            else:\n                # Subsequent attempts: adaptive perturbations\n                perturbation_scale = 0.01 * np.exp(-attempt)\n                x_init = np.concatenate([centers_init.flatten(), radii_init])\n                x_init += np.random.randn(len(x_init)) * perturbation_scale\n                x_init[:2*n] = np.clip(x_init[:2*n], 0, 1)\n                x_init[2*n:] = np.clip(x_init[2*n:], 0, 0.5)\n            \n            # Adaptive optimization parameters\n            max_iter = 1500 if attempt == 0 else 1000\n            ftol = 1e-10 if attempt < 2 else 1e-9\n            \n            result = minimize(\n                objective,\n                x_init,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': max_iter, 'ftol': ftol}\n            )\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_result = result\n        \n        solution = best_result.x\n        centers = solution[:2*n].reshape(n, 2)\n        radii = solution[2*n:]\n        \n        return centers, radii\n    \n    # Execute adaptive pipeline\n    initial_centers, initial_radii = adaptive_force_directed_layout()\n    final_centers, final_radii = adaptive_scipy_optimization(initial_centers, initial_radii)\n    sum_radii = np.sum(final_radii)\n    \n    return final_centers, final_radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 67.55160403251648,
    "error": "Circle 0 at (1.0, 1.0) with radius 0.5 extends outside x-bounds"
  },
  "prompt": "Optimize this hybrid with adaptive parameters:\n\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using hybrid optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Phase 1: Force-directed layout to find good initial positions\n    def force_directed_layout(n_iterations=10000):\n        \"\"\"Use force-directed approach to find good initial positions.\"\"\"\n        # Start with grid layout\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            centers.append([x, y])\n        centers = np.array(centers)\n        \n        # Initialize with uniform radii\n        radii = np.ones(n) * 0.04\n        \n        # Force-directed parameters\n        dt = 0.001\n        damping = 0.9\n        velocities = np.zeros_like(centers)\n        \n        for iteration in range(n_iterations):\n            forces = np.zeros_like(centers)\n            \n            # Repulsion between overlapping circles\n            for i in range(n):\n                for j in range(i + 1, n):\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    min_dist = radii[i] + radii[j]\n                    \n                    if dist < min_dist + 0.01:  # Add small buffer\n                        if dist > 1e-6:\n                            force_mag = (min_dist - dist) * 10.0\n                            force_dir = diff / dist\n                            forces[i] += force_mag * force_dir\n                            forces[j] -= force_mag * force_dir\n            \n            # Boundary forces (keep circles inside)\n            for i in range(n):\n                r = radii[i]\n                # Left boundary\n                if centers[i, 0] - r < 0:\n                    forces[i, 0] += (r - centers[i, 0]) * 5.0\n                # Right boundary\n                if centers[i, 0] + r > 1:\n                    forces[i, 0] -= (centers[i, 0] + r - 1) * 5.0\n                # Bottom boundary\n                if centers[i, 1] - r < 0:\n                    forces[i, 1] += (r - centers[i, 1]) * 5.0\n                # Top boundary\n                if centers[i, 1] + r > 1:\n                    forces[i, 1] -= (centers[i, 1] + r - 1) * 5.0\n            \n            # Update velocities and positions\n            velocities = velocities * damping + forces * dt\n            centers += velocities * dt\n            \n            # Clamp to valid range\n            centers = np.clip(centers, 0, 1)\n            \n            # Gradually increase radii\n            if iteration % 100 == 0 and iteration < 5000:\n                # Try to increase radii slightly\n                for i in range(n):\n                    can_increase = True\n                    test_radius = radii[i] * 1.01\n                    \n                    # Check bounds\n                    if (centers[i, 0] - test_radius < 0 or \n                        centers[i, 0] + test_radius > 1 or\n                        centers[i, 1] - test_radius < 0 or \n                        centers[i, 1] + test_radius > 1):\n                        can_increase = False\n                    \n                    # Check overlaps\n                    if can_increase:\n                        for j in range(n):\n                            if i != j:\n                                dist = np.linalg.norm(centers[i] - centers[j])\n                                if dist < test_radius + radii[j]:\n                                    can_increase = False\n                                    break\n                    \n                    if can_increase:\n                        radii[i] = test_radius\n        \n        return centers, radii\n    \n    # Get initial layout from force-directed method\n    initial_centers, initial_radii = force_directed_layout()\n    \n    # Phase 2: Scipy optimization to refine and maximize radii\n    def scipy_optimization(centers_init, radii_init):\n        \"\"\"Refine packing using scipy optimization.\"\"\"\n        # Combine into single vector: [centers_flat, radii]\n        x0 = np.concatenate([centers_init.flatten(), radii_init])\n        \n        # Objective: minimize negative sum of radii (to maximize sum)\n        def objective(x):\n            radii = x[2*n:]\n            return -np.sum(radii)\n        \n        # Constraints\n        constraints = []\n        \n        # Circles must be within bounds: center \u00b1 radius in [0,1]\n        for i in range(n):\n            # x_i - r_i >= 0\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: x[2*i] - x[2*n + i]\n            })\n            # x_i + r_i <= 1\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: 1 - x[2*i] - x[2*n + i]\n            })\n            # y_i - r_i >= 0\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: x[2*i + 1] - x[2*n + i]\n            })\n            # y_i + r_i <= 1\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: 1 - x[2*i + 1] - x[2*n + i]\n            })\n        \n        # No overlaps: distance between centers >= sum of radii\n        for i in range(n):\n            for j in range(i + 1, n):\n                def overlap_constraint(x, i=i, j=j):\n                    cx_i, cy_i = x[2*i], x[2*i + 1]\n                    cx_j, cy_j = x[2*j], x[2*j + 1]\n                    r_i, r_j = x[2*n + i], x[2*n + j]\n                    dist = np.sqrt((cx_i - cx_j)**2 + (cy_i - cy_j)**2)\n                    return dist - (r_i + r_j)\n                \n                constraints.append({\n                    'type': 'ineq',\n                    'fun': overlap_constraint\n                })\n        \n        # Radii must be non-negative\n        for i in range(n):\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: x[2*n + i]\n            })\n        \n        # Bounds for variables\n        bounds = []\n        # Centers: [0, 1] for each coordinate\n        for i in range(2*n):\n            bounds.append((0, 1))\n        # Radii: [0, 0.5] (reasonable upper bound)\n        for i in range(n):\n            bounds.append((0, 0.5))\n        \n        # Optimize with multiple attempts\n        best_result = None\n        best_value = float('inf')\n        \n        for attempt in range(3):\n            if attempt > 0:\n                # Add small random perturbation for subsequent attempts\n                x_init = x0 + np.random.randn(len(x0)) * 0.005\n                x_init[:2*n] = np.clip(x_init[:2*n], 0, 1)\n                x_init[2*n:] = np.clip(x_init[2*n:], 0, 0.5)\n            else:\n                x_init = x0\n            \n            result = minimize(\n                objective,\n                x_init,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 1000, 'ftol': 1e-9}\n            )\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_result = result\n        \n        # Extract solution\n        solution = best_result.x\n        centers = solution[:2*n].reshape(n, 2)\n        radii = solution[2*n:]\n        \n        return centers, radii\n    \n    # Run scipy optimization\n    final_centers, final_radii = scipy_optimization(initial_centers, initial_radii)\n    sum_radii = np.sum(final_radii)\n    \n    return final_centers, final_radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nAdd adaptive mechanisms:\n1. Adaptive force strength: decrease as circles settle\n2. Adaptive learning rate: start high, decay exponentially\n3. Temperature-based acceptance: allow small constraint violations early, enforce strictly later\n4. Multi-resolution: start with fewer circles, gradually add more\n5. Smart scipy initialization from best force-directed state\n\nRequirements:\n- Adaptive parameter control\n- Multi-stage refinement\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using adaptive hybrid optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Phase 1: Adaptive force-directed layout with temperature-based acceptance\n    def adaptive_force_directed_layout(n_iterations=15000):\n        \"\"\"Use adaptive force-directed approach with simulated annealing.\"\"\"\n        # Start with optimized grid layout\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            centers.append([x, y])\n        centers = np.array(centers)\n        \n        # Initialize with conservative uniform radii\n        radii = np.ones(n) * 0.035\n        \n        # Adaptive parameters\n        initial_dt = 0.002\n        final_dt = 0.0001\n        initial_damping = 0.85\n        final_damping = 0.95\n        initial_temp = 0.02  # Temperature for constraint violation acceptance\n        final_temp = 0.0\n        \n        velocities = np.zeros_like(centers)\n        \n        # Track best configuration\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n        best_sum = np.sum(radii)\n        \n        for iteration in range(n_iterations):\n            # Adaptive parameters with exponential decay\n            progress = iteration / n_iterations\n            dt = initial_dt * np.exp(-5 * progress) + final_dt\n            damping = initial_damping + (final_damping - initial_damping) * progress\n            temperature = initial_temp * (1 - progress)**2\n            \n            # Adaptive force strength (decreases as system settles)\n            force_scale = 10.0 * (1 + 5 * np.exp(-3 * progress))\n            \n            forces = np.zeros_like(centers)\n            \n            # Repulsion between overlapping circles with adaptive strength\n            for i in range(n):\n                for j in range(i + 1, n):\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    min_dist = radii[i] + radii[j]\n                    \n                    # Adaptive buffer zone (tighter as we progress)\n                    buffer = 0.02 * (1 - progress)\n                    \n                    if dist < min_dist + buffer:\n                        if dist > 1e-6:\n                            overlap = min_dist - dist\n                            force_mag = overlap * force_scale\n                            force_dir = diff / dist\n                            forces[i] += force_mag * force_dir\n                            forces[j] -= force_mag * force_dir\n            \n            # Adaptive boundary forces (stronger as we progress)\n            boundary_scale = 5.0 * (1 + 10 * progress)\n            for i in range(n):\n                r = radii[i]\n                margin = 0.01 * (1 - progress)  # Shrinking margin\n                \n                if centers[i, 0] - r < margin:\n                    forces[i, 0] += (r + margin - centers[i, 0]) * boundary_scale\n                if centers[i, 0] + r > 1 - margin:\n                    forces[i, 0] -= (centers[i, 0] + r - 1 + margin) * boundary_scale\n                if centers[i, 1] - r < margin:\n                    forces[i, 1] += (r + margin - centers[i, 1]) * boundary_scale\n                if centers[i, 1] + r > 1 - margin:\n                    forces[i, 1] -= (centers[i, 1] + r - 1 + margin) * boundary_scale\n            \n            # Update velocities and positions\n            velocities = velocities * damping + forces * dt\n            centers += velocities * dt\n            centers = np.clip(centers, 0, 1)\n            \n            # Adaptive radius growth with temperature-based acceptance\n            if iteration % 50 == 0:\n                # Growth rate decreases as we progress\n                growth_rate = 1.02 * np.exp(-2 * progress) + 1.001\n                \n                for i in range(n):\n                    test_radius = radii[i] * growth_rate\n                    \n                    # Check if increase is valid with temperature-based tolerance\n                    violation = 0.0\n                    \n                    # Check bounds with temperature tolerance\n                    if centers[i, 0] - test_radius < -temperature:\n                        violation += abs(centers[i, 0] - test_radius)\n                    if centers[i, 0] + test_radius > 1 + temperature:\n                        violation += abs(centers[i, 0] + test_radius - 1)\n                    if centers[i, 1] - test_radius < -temperature:\n                        violation += abs(centers[i, 1] - test_radius)\n                    if centers[i, 1] + test_radius > 1 + temperature:\n                        violation += abs(centers[i, 1] + test_radius - 1)\n                    \n                    # Check overlaps with temperature tolerance\n                    max_overlap = 0.0\n                    for j in range(n):\n                        if i != j:\n                            dist = np.linalg.norm(centers[i] - centers[j])\n                            overlap = (test_radius + radii[j]) - dist\n                            if overlap > max_overlap:\n                                max_overlap = overlap\n                    \n                    violation += max_overlap\n                    \n                    # Accept if violation within temperature threshold\n                    if violation <= temperature:\n                        radii[i] = test_radius\n            \n            # Track best valid configuration\n            if iteration % 500 == 0 and progress > 0.5:\n                # Check if current configuration is valid\n                is_valid = True\n                for i in range(n):\n                    if (centers[i, 0] - radii[i] < -1e-6 or \n                        centers[i, 0] + radii[i] > 1 + 1e-6 or\n                        centers[i, 1] - radii[i] < -1e-6 or \n                        centers[i, 1] + radii[i] > 1 + 1e-6):\n                        is_valid = False\n                        break\n                    for j in range(i + 1, n):\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        if dist < radii[i] + radii[j] - 1e-6:\n                            is_valid = False\n                            break\n                    if not is_valid:\n                        break\n                \n                current_sum = np.sum(radii)\n                if is_valid and current_sum > best_sum:\n                    best_sum = current_sum\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n        \n        return best_centers, best_radii\n    \n    # Phase 2: Multi-start scipy optimization with smart initialization\n    def adaptive_scipy_optimization(centers_init, radii_init, n_attempts=5):\n        \"\"\"Refine packing using scipy optimization with multiple adaptive starts.\"\"\"\n        \n        def objective(x):\n            radii = x[2*n:]\n            return -np.sum(radii)\n        \n        def create_constraints():\n            constraints = []\n            \n            # Boundary constraints\n            for i in range(n):\n                constraints.append({'type': 'ineq', 'fun': lambda x, i=i: x[2*i] - x[2*n + i]})\n                constraints.append({'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i] - x[2*n + i]})\n                constraints.append({'type': 'ineq', 'fun': lambda x, i=i: x[2*i + 1] - x[2*n + i]})\n                constraints.append({'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i + 1] - x[2*n + i]})\n            \n            # Non-overlap constraints\n            for i in range(n):\n                for j in range(i + 1, n):\n                    def overlap_constraint(x, i=i, j=j):\n                        cx_i, cy_i = x[2*i], x[2*i + 1]\n                        cx_j, cy_j = x[2*j], x[2*j + 1]\n                        r_i, r_j = x[2*n + i], x[2*n + j]\n                        dist = np.sqrt((cx_i - cx_j)**2 + (cy_i - cy_j)**2)\n                        return dist - (r_i + r_j)\n                    constraints.append({'type': 'ineq', 'fun': overlap_constraint})\n            \n            # Non-negative radii\n            for i in range(n):\n                constraints.append({'type': 'ineq', 'fun': lambda x, i=i: x[2*n + i]})\n            \n            return constraints\n        \n        bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n        constraints = create_constraints()\n        \n        best_result = None\n        best_value = float('inf')\n        \n        for attempt in range(n_attempts):\n            if attempt == 0:\n                # First attempt: use force-directed result\n                x_init = np.concatenate([centers_init.flatten(), radii_init])\n            else:\n                # Subsequent attempts: adaptive perturbations\n                perturbation_scale = 0.01 * np.exp(-attempt)\n                x_init = np.concatenate([centers_init.flatten(), radii_init])\n                x_init += np.random.randn(len(x_init)) * perturbation_scale\n                x_init[:2*n] = np.clip(x_init[:2*n], 0, 1)\n                x_init[2*n:] = np.clip(x_init[2*n:], 0, 0.5)\n            \n            # Adaptive optimization parameters\n            max_iter = 1500 if attempt == 0 else 1000\n            ftol = 1e-10 if attempt < 2 else 1e-9\n            \n            result = minimize(\n                objective,\n                x_init,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': max_iter, 'ftol': ftol}\n            )\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_result = result\n        \n        solution = best_result.x\n        centers = solution[:2*n].reshape(n, 2)\n        radii = solution[2*n:]\n        \n        return centers, radii\n    \n    # Execute adaptive pipeline\n    initial_centers, initial_radii = adaptive_force_directed_layout()\n    final_centers, final_radii = adaptive_scipy_optimization(initial_centers, initial_radii)\n    sum_radii = np.sum(final_radii)\n    \n    return final_centers, final_radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T18:01:10.530112",
  "cost_data": null
}