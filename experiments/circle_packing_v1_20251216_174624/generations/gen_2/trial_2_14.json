{
  "trial_id": "trial_2_14",
  "generation": 2,
  "parent_id": "trial_1_9",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Multi-resolution hierarchy: coarse to fine\n    # Level 1: 3x3 grid (9 circles)\n    centers_9, radii_9, sum_9 = optimize_level(9, grid_shape=(3, 3), iterations=300)\n    \n    # Level 2: 4x4 grid (16 circles) - interpolate from level 1\n    centers_16 = interpolate_grid(centers_9, radii_9, 16, (4, 4))\n    centers_16, radii_16, sum_16 = optimize_level_from_init(centers_16, iterations=400)\n    \n    # Level 3: 5x5 grid (25 circles) - interpolate from level 2\n    centers_25 = interpolate_grid(centers_16, radii_16, 25, (5, 5))\n    centers_25, radii_25, sum_25 = optimize_level_from_init(centers_25, iterations=500)\n    \n    # Level 4: Full resolution (26 circles) - add one more circle optimally\n    centers_26 = add_circle_optimally(centers_25, radii_25)\n    centers_26, radii_26, sum_26 = optimize_level_from_init(centers_26, iterations=600)\n    \n    if sum_26 > best_sum:\n        best_sum = sum_26\n        best_centers = centers_26.copy()\n        best_radii = radii_26.copy()\n    \n    # Try alternative initialization: 4x7 grid\n    centers_alt = initialize_grid(n, 4, 7)\n    centers_alt, radii_alt, sum_alt = optimize_level_from_init(centers_alt, iterations=600)\n    \n    if sum_alt > best_sum:\n        best_sum = sum_alt\n        best_centers = centers_alt.copy()\n        best_radii = radii_alt.copy()\n    \n    # Try another alternative: 5x6 grid\n    centers_alt2 = initialize_grid(n, 5, 6)\n    centers_alt2, radii_alt2, sum_alt2 = optimize_level_from_init(centers_alt2, iterations=600)\n    \n    if sum_alt2 > best_sum:\n        best_sum = sum_alt2\n        best_centers = centers_alt2.copy()\n        best_radii = radii_alt2.copy()\n    \n    # Intensive refinement on best solution\n    best_centers, best_radii, best_sum = intensive_refinement(best_centers, best_radii, best_sum)\n    \n    # Final global optimization\n    centers_final, radii_final, sum_final = scipy_global_optimization(best_centers)\n    \n    if sum_final > best_sum:\n        best_sum = sum_final\n        best_centers = centers_final.copy()\n        best_radii = radii_final.copy()\n    \n    return best_centers, best_radii, best_sum\n\n\ndef initialize_grid(n, rows, cols):\n    \"\"\"Initialize centers on a regular grid.\"\"\"\n    centers = []\n    margin = 0.06\n    x_spacing = (1 - 2*margin) / (cols - 1) if cols > 1 else 0\n    y_spacing = (1 - 2*margin) / (rows - 1) if rows > 1 else 0\n    \n    count = 0\n    for i in range(rows):\n        for j in range(cols):\n            if count >= n:\n                break\n            x = margin + j * x_spacing if cols > 1 else 0.5\n            y = margin + i * y_spacing if rows > 1 else 0.5\n            centers.append([x, y])\n            count += 1\n        if count >= n:\n            break\n    \n    return np.array(centers)\n\n\ndef compute_optimal_radii(centers):\n    \"\"\"Compute maximum radii for given centers.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        x, y = centers[i]\n        r_max = min(x, 1-x, y, 1-y)\n        \n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                r_max = min(r_max, dist / 2)\n        \n        radii[i] = max(0, r_max)\n    \n    return radii\n\n\ndef optimize_level(n, grid_shape, iterations=500):\n    \"\"\"Optimize a specific level with n circles.\"\"\"\n    rows, cols = grid_shape\n    centers = initialize_grid(n, rows, cols)\n    return optimize_level_from_init(centers, iterations)\n\n\ndef optimize_level_from_init(centers, iterations=500):\n    \"\"\"Optimize given initial centers.\"\"\"\n    n = len(centers)\n    \n    # Phase 1: Simulated annealing with decreasing temperature\n    current_centers = centers.copy()\n    current_radii = compute_optimal_radii(current_centers)\n    current_sum = np.sum(current_radii)\n    \n    best_centers = current_centers.copy()\n    best_radii = current_radii.copy()\n    best_sum = current_sum\n    \n    temp_schedule = np.linspace(0.15, 0.01, iterations)\n    \n    for iter in range(iterations):\n        temp = temp_schedule[iter]\n        \n        # Adaptive perturbation based on iteration\n        perturbation = 0.03 * (1 - iter / iterations) + 0.005\n        \n        # Perturb random subset\n        num_perturb = max(1, int(n * (0.3 - 0.2 * iter / iterations)))\n        indices = np.random.choice(n, num_perturb, replace=False)\n        \n        new_centers = current_centers.copy()\n        for idx in indices:\n            new_centers[idx] += np.random.normal(0, perturbation, 2)\n            new_centers[idx] = np.clip(new_centers[idx], 0.01, 0.99)\n        \n        new_radii = compute_optimal_radii(new_centers)\n        new_sum = np.sum(new_radii)\n        \n        delta = new_sum - current_sum\n        if delta > 0 or np.random.random() < np.exp(delta / temp):\n            current_centers = new_centers\n            current_radii = new_radii\n            current_sum = new_sum\n            \n            if new_sum > best_sum:\n                best_centers = new_centers.copy()\n                best_radii = new_radii.copy()\n                best_sum = new_sum\n    \n    # Phase 2: Local optimization with scipy\n    centers_opt, radii_opt, sum_opt = scipy_local_optimization(best_centers)\n    \n    if sum_opt > best_sum:\n        best_centers = centers_opt\n        best_radii = radii_opt\n        best_sum = sum_opt\n    \n    return best_centers, best_radii, best_sum\n\n\ndef interpolate_grid(centers_coarse, radii_coarse, n_target, grid_shape):\n    \"\"\"Interpolate from coarse grid to finer grid.\"\"\"\n    n_coarse = len(centers_coarse)\n    rows, cols = grid_shape\n    \n    # Start with regular grid\n    centers_fine = initialize_grid(n_target, rows, cols)\n    \n    # Adjust positions based on coarse solution\n    # Find nearest coarse circle for each fine circle\n    if n_coarse > 0:\n        for i in range(min(n_target, n_coarse)):\n            # Keep coarse positions for first n_coarse circles\n            if i < n_coarse:\n                centers_fine[i] = centers_coarse[i]\n    \n    # Add small random perturbations to break symmetry\n    centers_fine += np.random.normal(0, 0.01, centers_fine.shape)\n    centers_fine = np.clip(centers_fine, 0.02, 0.98)\n    \n    return centers_fine\n\n\ndef add_circle_optimally(centers, radii):\n    \"\"\"Add one more circle to existing packing.\"\"\"\n    n = len(centers)\n    \n    # Try multiple candidate positions\n    best_pos = None\n    best_radius = 0\n    \n    # Grid search for good position\n    for x in np.linspace(0.1, 0.9, 15):\n        for y in np.linspace(0.1, 0.9, 15):\n            candidate = np.array([x, y])\n            \n            # Compute potential radius\n            r_max = min(x, 1-x, y, 1-y)\n            for i in range(n):\n                dist = np.linalg.norm(candidate - centers[i])\n                r_max = min(r_max, dist - radii[i])\n            \n            if r_max > best_radius:\n                best_radius = r_max\n                best_pos = candidate\n    \n    # Add new circle\n    centers_new = np.vstack([centers, best_pos])\n    \n    return centers_new\n\n\ndef intensive_refinement(centers, radii, current_sum):\n    \"\"\"Intensive refinement with multiple strategies.\"\"\"\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = current_sum\n    \n    # Strategy 1: Focus on low-radius circles\n    for _ in range(3):\n        centers_ref, radii_ref, sum_ref = refine_small_circles(best_centers, best_radii)\n        if sum_ref > best_sum:\n            best_centers = centers_ref\n            best_radii = radii_ref\n            best_sum = sum_ref\n    \n    # Strategy 2: Pairwise swaps\n    centers_swap, radii_swap, sum_swap = pairwise_optimization(best_centers)\n    if sum_swap > best_sum:\n        best_centers = centers_swap\n        best_radii = radii_swap\n        best_sum = sum_swap\n    \n    # Strategy 3: Gradient-based local search\n    centers_grad, radii_grad, sum_grad = scipy_local_optimization(best_centers, maxiter=500)\n    if sum_grad > best_sum:\n        best_centers = centers_grad\n        best_radii = radii_grad\n        best_sum = sum_grad\n    \n    return best_centers, best_radii, best_sum\n\n\ndef refine_small_circles(centers, radii):\n    \"\"\"Focus refinement on circles with smallest radii.\"\"\"\n    n = len(centers)\n    \n    # Identify smallest circles\n    sorted_indices = np.argsort(radii)\n    num_small = max(5, n // 4)\n    small_indices = sorted_indices[:num_small]\n    \n    current_centers = centers.copy()\n    current_radii = radii.copy()\n    current_sum = np.sum(current_radii)\n    \n    best_centers = current_centers.copy()\n    best_radii = current_radii.copy()\n    best_sum = current_sum\n    \n    for _ in range(200):\n        new_centers = current_centers.copy()\n        \n        # Perturb small circles more aggressively\n        for idx in small_indices:\n            new_centers[idx] += np.random.normal(0, 0.02, 2)\n            new_centers[idx] = np.clip(new_centers[idx], 0.01, 0.99)\n        \n        new_radii = compute_optimal_radii(new_centers)\n        new_sum = np.sum(new_radii)\n        \n        if new_sum > best_sum:\n            best_centers = new_centers.copy()\n            best_radii = new_radii.copy()\n            best_sum = new_sum\n            current_centers = new_centers\n            current_radii = new_radii\n            current_sum = new_sum\n    \n    return best_centers, best_radii, best_sum\n\n\ndef pairwise_optimization(centers):\n    \"\"\"Optimize pairs of circles.\"\"\"\n    n = len(centers)\n    best_centers = centers.copy()\n    best_radii = compute_optimal_radii(best_centers)\n    best_sum = np.sum(best_radii)\n    \n    # Try swapping positions of pairs\n    for i in range(n):\n        for j in range(i+1, n):\n            new_centers = best_centers.copy()\n            new_centers[i], new_centers[j] = new_centers[j].copy(), new_centers[i].copy()\n            \n            new_radii = compute_optimal_radii(new_centers)\n            new_sum = np.sum(new_radii)\n            \n            if new_sum > best_sum:\n                best_centers = new_centers\n                best_radii = new_radii\n                best_sum = new_sum\n    \n    return best_centers, best_radii, best_sum\n\n\ndef scipy_local_optimization(centers, maxiter=300):\n    \"\"\"Local optimization using scipy.\"\"\"\n    n = len(centers)\n    x0 = centers.flatten()\n    \n    def objective(x):\n        centers_2d = x.reshape(n, 2)\n        radii = compute_optimal_radii(centers_2d)\n        return -np.sum(radii)\n    \n    bounds = [(0.005, 0.995) for _ in range(2*n)]\n    \n    result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds,\n                     options={'maxiter': maxiter, 'ftol': 1e-10})\n    \n    centers_opt = result.x.reshape(n, 2)\n    radii_opt = compute_optimal_radii(centers_opt)\n    sum_opt = np.sum(radii_opt)\n    \n    return centers_opt, radii_opt, sum_opt\n\n\ndef scipy_global_optimization(centers):\n    \"\"\"Global optimization using differential evolution.\"\"\"\n    n = len(centers)\n    \n    def objective(x):\n        centers_2d = x.reshape(n, 2)\n        radii = compute_optimal_radii(centers_2d)\n        return -np.sum(radii)\n    \n    bounds = [(0.005, 0.995) for _ in range(2*n)]\n    \n    result = differential_evolution(objective, bounds, maxiter=100, \n                                   seed=42, workers=1, polish=True,\n                                   atol=1e-10, tol=1e-10)\n    \n    centers_opt = result.x.reshape(n, 2)\n    radii_opt = compute_optimal_radii(centers_opt)\n    sum_opt = np.sum(radii_opt)\n    \n    return centers_opt, radii_opt, sum_opt\n\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.466535495570408,
    "target_ratio": 0.9360666017345003,
    "combined_score": 0.9360666017345003,
    "eval_time": 496.6929249763489,
    "error": null
  },
  "prompt": "Improve this multi-resolution approach:\n\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # Stage 1: Initialize with coarse grid\n    grid_rows = 4\n    grid_cols = 7\n    centers = initialize_grid(n, grid_rows, grid_cols)\n    \n    # Stage 2: Compute initial radii\n    radii = compute_optimal_radii(centers)\n    best_sum = np.sum(radii)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    \n    # Stage 3: Multi-resolution refinement\n    # Phase 1: Small perturbations\n    centers, radii, sum_radii = refine_packing(centers, iterations=500, \n                                                 perturbation=0.01, temp=0.1)\n    if sum_radii > best_sum:\n        best_sum = sum_radii\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n    \n    # Phase 2: Medium perturbations\n    centers, radii, sum_radii = refine_packing(best_centers, iterations=500, \n                                                 perturbation=0.02, temp=0.05)\n    if sum_radii > best_sum:\n        best_sum = sum_radii\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n    \n    # Phase 3: Larger perturbations with cooling\n    for scale in [0.03, 0.04, 0.05]:\n        centers, radii, sum_radii = refine_packing(best_centers, iterations=300, \n                                                     perturbation=scale, temp=0.02)\n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    # Stage 4: Global optimization with scipy\n    centers, radii, sum_radii = scipy_optimization(best_centers, method='local')\n    if sum_radii > best_sum:\n        best_sum = sum_radii\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n    \n    # Stage 5: Final polish with differential evolution on subset\n    centers, radii, sum_radii = scipy_optimization(best_centers, method='global')\n    if sum_radii > best_sum:\n        best_sum = sum_radii\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\n\ndef initialize_grid(n, rows, cols):\n    \"\"\"Initialize centers on a regular grid.\"\"\"\n    centers = []\n    margin = 0.08\n    x_spacing = (1 - 2*margin) / (cols - 1)\n    y_spacing = (1 - 2*margin) / (rows - 1)\n    \n    count = 0\n    for i in range(rows):\n        for j in range(cols):\n            if count >= n:\n                break\n            x = margin + j * x_spacing\n            y = margin + i * y_spacing\n            centers.append([x, y])\n            count += 1\n        if count >= n:\n            break\n    \n    return np.array(centers)\n\n\ndef compute_optimal_radii(centers):\n    \"\"\"Compute maximum radii for given centers.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Distance to boundaries\n        x, y = centers[i]\n        r_max = min(x, 1-x, y, 1-y)\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                r_max = min(r_max, dist / 2)\n        \n        radii[i] = max(0, r_max)\n    \n    return radii\n\n\ndef is_valid_packing(centers, radii):\n    \"\"\"Check if packing satisfies all constraints.\"\"\"\n    n = len(centers)\n    \n    # Check boundary constraints\n    for i in range(n):\n        x, y = centers[i]\n        r = radii[i]\n        if x - r < 0 or x + r > 1 or y - r < 0 or y + r > 1:\n            return False\n    \n    # Check overlap constraints\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-10:\n                return False\n    \n    return True\n\n\ndef refine_packing(centers, iterations=1000, perturbation=0.01, temp=0.1):\n    \"\"\"Refine packing using simulated annealing-like approach.\"\"\"\n    n = len(centers)\n    current_centers = centers.copy()\n    current_radii = compute_optimal_radii(current_centers)\n    current_sum = np.sum(current_radii)\n    \n    best_centers = current_centers.copy()\n    best_radii = current_radii.copy()\n    best_sum = current_sum\n    \n    for iter in range(iterations):\n        # Perturb a random subset of centers\n        num_perturb = np.random.randint(1, max(2, n//5))\n        indices = np.random.choice(n, num_perturb, replace=False)\n        \n        new_centers = current_centers.copy()\n        for idx in indices:\n            new_centers[idx] += np.random.normal(0, perturbation, 2)\n            # Keep within bounds with margin\n            new_centers[idx] = np.clip(new_centers[idx], 0.02, 0.98)\n        \n        # Compute new radii\n        new_radii = compute_optimal_radii(new_centers)\n        new_sum = np.sum(new_radii)\n        \n        # Accept if improvement or with probability based on temperature\n        if new_sum > current_sum or (temp > 0 and np.random.random() < np.exp((new_sum - current_sum) / temp)):\n            current_centers = new_centers\n            current_radii = new_radii\n            current_sum = new_sum\n            \n            if new_sum > best_sum:\n                best_centers = new_centers.copy()\n                best_radii = new_radii.copy()\n                best_sum = new_sum\n    \n    return best_centers, best_radii, best_sum\n\n\ndef scipy_optimization(centers, method='local'):\n    \"\"\"Use scipy optimization for final refinement.\"\"\"\n    n = len(centers)\n    x0 = centers.flatten()\n    \n    def objective(x):\n        centers_2d = x.reshape(n, 2)\n        radii = compute_optimal_radii(centers_2d)\n        return -np.sum(radii)  # Negative because we minimize\n    \n    def constraint_boundary(x):\n        centers_2d = x.reshape(n, 2)\n        radii = compute_optimal_radii(centers_2d)\n        violations = []\n        for i in range(n):\n            cx, cy = centers_2d[i]\n            r = radii[i]\n            violations.extend([cx - r, 1 - cx - r, cy - r, 1 - cy - r])\n        return np.array(violations)\n    \n    bounds = [(0.01, 0.99) for _ in range(2*n)]\n    \n    if method == 'local':\n        # Local optimization\n        result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds,\n                         options={'maxiter': 200, 'ftol': 1e-9})\n        centers_opt = result.x.reshape(n, 2)\n    else:\n        # Global optimization with differential evolution (limited iterations)\n        result = differential_evolution(objective, bounds, maxiter=50, \n                                       seed=42, workers=1, polish=True)\n        centers_opt = result.x.reshape(n, 2)\n    \n    radii_opt = compute_optimal_radii(centers_opt)\n    sum_opt = np.sum(radii_opt)\n    \n    return centers_opt, radii_opt, sum_opt\n\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nEnhancements:\n1. Better coarse-to-fine strategy: start with 3x3 grid, progressively refine\n2. At each resolution level, optimize thoroughly before refining\n3. Use scipy optimization at each level\n4. Implement smooth interpolation when refining grid\n5. Final high-resolution optimization with all circles\n\nRequirements:\n- Multi-resolution hierarchy\n- Optimization at each level\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Multi-resolution hierarchy: coarse to fine\n    # Level 1: 3x3 grid (9 circles)\n    centers_9, radii_9, sum_9 = optimize_level(9, grid_shape=(3, 3), iterations=300)\n    \n    # Level 2: 4x4 grid (16 circles) - interpolate from level 1\n    centers_16 = interpolate_grid(centers_9, radii_9, 16, (4, 4))\n    centers_16, radii_16, sum_16 = optimize_level_from_init(centers_16, iterations=400)\n    \n    # Level 3: 5x5 grid (25 circles) - interpolate from level 2\n    centers_25 = interpolate_grid(centers_16, radii_16, 25, (5, 5))\n    centers_25, radii_25, sum_25 = optimize_level_from_init(centers_25, iterations=500)\n    \n    # Level 4: Full resolution (26 circles) - add one more circle optimally\n    centers_26 = add_circle_optimally(centers_25, radii_25)\n    centers_26, radii_26, sum_26 = optimize_level_from_init(centers_26, iterations=600)\n    \n    if sum_26 > best_sum:\n        best_sum = sum_26\n        best_centers = centers_26.copy()\n        best_radii = radii_26.copy()\n    \n    # Try alternative initialization: 4x7 grid\n    centers_alt = initialize_grid(n, 4, 7)\n    centers_alt, radii_alt, sum_alt = optimize_level_from_init(centers_alt, iterations=600)\n    \n    if sum_alt > best_sum:\n        best_sum = sum_alt\n        best_centers = centers_alt.copy()\n        best_radii = radii_alt.copy()\n    \n    # Try another alternative: 5x6 grid\n    centers_alt2 = initialize_grid(n, 5, 6)\n    centers_alt2, radii_alt2, sum_alt2 = optimize_level_from_init(centers_alt2, iterations=600)\n    \n    if sum_alt2 > best_sum:\n        best_sum = sum_alt2\n        best_centers = centers_alt2.copy()\n        best_radii = radii_alt2.copy()\n    \n    # Intensive refinement on best solution\n    best_centers, best_radii, best_sum = intensive_refinement(best_centers, best_radii, best_sum)\n    \n    # Final global optimization\n    centers_final, radii_final, sum_final = scipy_global_optimization(best_centers)\n    \n    if sum_final > best_sum:\n        best_sum = sum_final\n        best_centers = centers_final.copy()\n        best_radii = radii_final.copy()\n    \n    return best_centers, best_radii, best_sum\n\n\ndef initialize_grid(n, rows, cols):\n    \"\"\"Initialize centers on a regular grid.\"\"\"\n    centers = []\n    margin = 0.06\n    x_spacing = (1 - 2*margin) / (cols - 1) if cols > 1 else 0\n    y_spacing = (1 - 2*margin) / (rows - 1) if rows > 1 else 0\n    \n    count = 0\n    for i in range(rows):\n        for j in range(cols):\n            if count >= n:\n                break\n            x = margin + j * x_spacing if cols > 1 else 0.5\n            y = margin + i * y_spacing if rows > 1 else 0.5\n            centers.append([x, y])\n            count += 1\n        if count >= n:\n            break\n    \n    return np.array(centers)\n\n\ndef compute_optimal_radii(centers):\n    \"\"\"Compute maximum radii for given centers.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        x, y = centers[i]\n        r_max = min(x, 1-x, y, 1-y)\n        \n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                r_max = min(r_max, dist / 2)\n        \n        radii[i] = max(0, r_max)\n    \n    return radii\n\n\ndef optimize_level(n, grid_shape, iterations=500):\n    \"\"\"Optimize a specific level with n circles.\"\"\"\n    rows, cols = grid_shape\n    centers = initialize_grid(n, rows, cols)\n    return optimize_level_from_init(centers, iterations)\n\n\ndef optimize_level_from_init(centers, iterations=500):\n    \"\"\"Optimize given initial centers.\"\"\"\n    n = len(centers)\n    \n    # Phase 1: Simulated annealing with decreasing temperature\n    current_centers = centers.copy()\n    current_radii = compute_optimal_radii(current_centers)\n    current_sum = np.sum(current_radii)\n    \n    best_centers = current_centers.copy()\n    best_radii = current_radii.copy()\n    best_sum = current_sum\n    \n    temp_schedule = np.linspace(0.15, 0.01, iterations)\n    \n    for iter in range(iterations):\n        temp = temp_schedule[iter]\n        \n        # Adaptive perturbation based on iteration\n        perturbation = 0.03 * (1 - iter / iterations) + 0.005\n        \n        # Perturb random subset\n        num_perturb = max(1, int(n * (0.3 - 0.2 * iter / iterations)))\n        indices = np.random.choice(n, num_perturb, replace=False)\n        \n        new_centers = current_centers.copy()\n        for idx in indices:\n            new_centers[idx] += np.random.normal(0, perturbation, 2)\n            new_centers[idx] = np.clip(new_centers[idx], 0.01, 0.99)\n        \n        new_radii = compute_optimal_radii(new_centers)\n        new_sum = np.sum(new_radii)\n        \n        delta = new_sum - current_sum\n        if delta > 0 or np.random.random() < np.exp(delta / temp):\n            current_centers = new_centers\n            current_radii = new_radii\n            current_sum = new_sum\n            \n            if new_sum > best_sum:\n                best_centers = new_centers.copy()\n                best_radii = new_radii.copy()\n                best_sum = new_sum\n    \n    # Phase 2: Local optimization with scipy\n    centers_opt, radii_opt, sum_opt = scipy_local_optimization(best_centers)\n    \n    if sum_opt > best_sum:\n        best_centers = centers_opt\n        best_radii = radii_opt\n        best_sum = sum_opt\n    \n    return best_centers, best_radii, best_sum\n\n\ndef interpolate_grid(centers_coarse, radii_coarse, n_target, grid_shape):\n    \"\"\"Interpolate from coarse grid to finer grid.\"\"\"\n    n_coarse = len(centers_coarse)\n    rows, cols = grid_shape\n    \n    # Start with regular grid\n    centers_fine = initialize_grid(n_target, rows, cols)\n    \n    # Adjust positions based on coarse solution\n    # Find nearest coarse circle for each fine circle\n    if n_coarse > 0:\n        for i in range(min(n_target, n_coarse)):\n            # Keep coarse positions for first n_coarse circles\n            if i < n_coarse:\n                centers_fine[i] = centers_coarse[i]\n    \n    # Add small random perturbations to break symmetry\n    centers_fine += np.random.normal(0, 0.01, centers_fine.shape)\n    centers_fine = np.clip(centers_fine, 0.02, 0.98)\n    \n    return centers_fine\n\n\ndef add_circle_optimally(centers, radii):\n    \"\"\"Add one more circle to existing packing.\"\"\"\n    n = len(centers)\n    \n    # Try multiple candidate positions\n    best_pos = None\n    best_radius = 0\n    \n    # Grid search for good position\n    for x in np.linspace(0.1, 0.9, 15):\n        for y in np.linspace(0.1, 0.9, 15):\n            candidate = np.array([x, y])\n            \n            # Compute potential radius\n            r_max = min(x, 1-x, y, 1-y)\n            for i in range(n):\n                dist = np.linalg.norm(candidate - centers[i])\n                r_max = min(r_max, dist - radii[i])\n            \n            if r_max > best_radius:\n                best_radius = r_max\n                best_pos = candidate\n    \n    # Add new circle\n    centers_new = np.vstack([centers, best_pos])\n    \n    return centers_new\n\n\ndef intensive_refinement(centers, radii, current_sum):\n    \"\"\"Intensive refinement with multiple strategies.\"\"\"\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = current_sum\n    \n    # Strategy 1: Focus on low-radius circles\n    for _ in range(3):\n        centers_ref, radii_ref, sum_ref = refine_small_circles(best_centers, best_radii)\n        if sum_ref > best_sum:\n            best_centers = centers_ref\n            best_radii = radii_ref\n            best_sum = sum_ref\n    \n    # Strategy 2: Pairwise swaps\n    centers_swap, radii_swap, sum_swap = pairwise_optimization(best_centers)\n    if sum_swap > best_sum:\n        best_centers = centers_swap\n        best_radii = radii_swap\n        best_sum = sum_swap\n    \n    # Strategy 3: Gradient-based local search\n    centers_grad, radii_grad, sum_grad = scipy_local_optimization(best_centers, maxiter=500)\n    if sum_grad > best_sum:\n        best_centers = centers_grad\n        best_radii = radii_grad\n        best_sum = sum_grad\n    \n    return best_centers, best_radii, best_sum\n\n\ndef refine_small_circles(centers, radii):\n    \"\"\"Focus refinement on circles with smallest radii.\"\"\"\n    n = len(centers)\n    \n    # Identify smallest circles\n    sorted_indices = np.argsort(radii)\n    num_small = max(5, n // 4)\n    small_indices = sorted_indices[:num_small]\n    \n    current_centers = centers.copy()\n    current_radii = radii.copy()\n    current_sum = np.sum(current_radii)\n    \n    best_centers = current_centers.copy()\n    best_radii = current_radii.copy()\n    best_sum = current_sum\n    \n    for _ in range(200):\n        new_centers = current_centers.copy()\n        \n        # Perturb small circles more aggressively\n        for idx in small_indices:\n            new_centers[idx] += np.random.normal(0, 0.02, 2)\n            new_centers[idx] = np.clip(new_centers[idx], 0.01, 0.99)\n        \n        new_radii = compute_optimal_radii(new_centers)\n        new_sum = np.sum(new_radii)\n        \n        if new_sum > best_sum:\n            best_centers = new_centers.copy()\n            best_radii = new_radii.copy()\n            best_sum = new_sum\n            current_centers = new_centers\n            current_radii = new_radii\n            current_sum = new_sum\n    \n    return best_centers, best_radii, best_sum\n\n\ndef pairwise_optimization(centers):\n    \"\"\"Optimize pairs of circles.\"\"\"\n    n = len(centers)\n    best_centers = centers.copy()\n    best_radii = compute_optimal_radii(best_centers)\n    best_sum = np.sum(best_radii)\n    \n    # Try swapping positions of pairs\n    for i in range(n):\n        for j in range(i+1, n):\n            new_centers = best_centers.copy()\n            new_centers[i], new_centers[j] = new_centers[j].copy(), new_centers[i].copy()\n            \n            new_radii = compute_optimal_radii(new_centers)\n            new_sum = np.sum(new_radii)\n            \n            if new_sum > best_sum:\n                best_centers = new_centers\n                best_radii = new_radii\n                best_sum = new_sum\n    \n    return best_centers, best_radii, best_sum\n\n\ndef scipy_local_optimization(centers, maxiter=300):\n    \"\"\"Local optimization using scipy.\"\"\"\n    n = len(centers)\n    x0 = centers.flatten()\n    \n    def objective(x):\n        centers_2d = x.reshape(n, 2)\n        radii = compute_optimal_radii(centers_2d)\n        return -np.sum(radii)\n    \n    bounds = [(0.005, 0.995) for _ in range(2*n)]\n    \n    result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds,\n                     options={'maxiter': maxiter, 'ftol': 1e-10})\n    \n    centers_opt = result.x.reshape(n, 2)\n    radii_opt = compute_optimal_radii(centers_opt)\n    sum_opt = np.sum(radii_opt)\n    \n    return centers_opt, radii_opt, sum_opt\n\n\ndef scipy_global_optimization(centers):\n    \"\"\"Global optimization using differential evolution.\"\"\"\n    n = len(centers)\n    \n    def objective(x):\n        centers_2d = x.reshape(n, 2)\n        radii = compute_optimal_radii(centers_2d)\n        return -np.sum(radii)\n    \n    bounds = [(0.005, 0.995) for _ in range(2*n)]\n    \n    result = differential_evolution(objective, bounds, maxiter=100, \n                                   seed=42, workers=1, polish=True,\n                                   atol=1e-10, tol=1e-10)\n    \n    centers_opt = result.x.reshape(n, 2)\n    radii_opt = compute_optimal_radii(centers_opt)\n    sum_opt = np.sum(radii_opt)\n    \n    return centers_opt, radii_opt, sum_opt\n\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T18:08:28.889442",
  "cost_data": null
}