{
  "trial_id": "trial_2_11",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using\n    advanced simulated annealing with multiple intelligent move operators.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # Initialize with grid-based layout\n    def initialize_solution():\n        # Start with 5x5 grid plus one extra\n        grid_size = 5\n        spacing = 1.0 / (grid_size + 1)\n        centers = []\n        \n        for i in range(grid_size):\n            for j in range(grid_size):\n                x = spacing * (i + 1)\n                y = spacing * (j + 1)\n                centers.append([x, y])\n        \n        # Add the 26th circle\n        centers.append([0.5, 0.5])\n        centers = np.array(centers[:n])\n        \n        # Initialize radii uniformly\n        radii = np.ones(n) * 0.08\n        \n        return centers, radii\n    \n    def check_feasibility(centers, radii):\n        \"\"\"Check if solution satisfies all constraints.\"\"\"\n        # Check bounds\n        if np.any(centers - radii[:, np.newaxis] < 0) or \\\n           np.any(centers + radii[:, np.newaxis] > 1):\n            return False\n        \n        # Check overlaps\n        dists = cdist(centers, centers)\n        radii_sum = radii[:, np.newaxis] + radii[np.newaxis, :]\n        np.fill_diagonal(dists, np.inf)\n        \n        if np.any(dists < radii_sum - 1e-6):\n            return False\n        \n        return True\n    \n    def compute_max_radii(centers):\n        \"\"\"Compute maximum feasible radii for given centers.\"\"\"\n        n = len(centers)\n        radii = np.zeros(n)\n        \n        for i in range(n):\n            # Distance to boundaries\n            max_r = min(centers[i, 0], 1 - centers[i, 0],\n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, (dist - radii[j]) / 2)\n            \n            radii[i] = max(0, max_r)\n        \n        return radii\n    \n    def objective(centers, radii):\n        \"\"\"Negative sum of radii (for minimization).\"\"\"\n        return -np.sum(radii)\n    \n    def perturb_positions(centers, radii, temp):\n        \"\"\"Move operator 1: Small position perturbation.\"\"\"\n        new_centers = centers.copy()\n        new_radii = radii.copy()\n        \n        # Perturb 1-3 circles\n        n_perturb = np.random.randint(1, 4)\n        indices = np.random.choice(len(centers), n_perturb, replace=False)\n        \n        scale = 0.05 * temp\n        for idx in indices:\n            new_centers[idx] += np.random.normal(0, scale, 2)\n            new_centers[idx] = np.clip(new_centers[idx], 0.01, 0.99)\n        \n        # Recompute radii\n        new_radii = compute_max_radii(new_centers)\n        \n        return new_centers, new_radii\n    \n    def swap_circles(centers, radii, temp):\n        \"\"\"Move operator 2: Swap positions of two circles.\"\"\"\n        new_centers = centers.copy()\n        new_radii = radii.copy()\n        \n        i, j = np.random.choice(len(centers), 2, replace=False)\n        new_centers[i], new_centers[j] = new_centers[j].copy(), new_centers[i].copy()\n        \n        # Recompute radii\n        new_radii = compute_max_radii(new_centers)\n        \n        return new_centers, new_radii\n    \n    def redistribute_radii(centers, radii, temp):\n        \"\"\"Move operator 3: Adjust radii distribution.\"\"\"\n        new_centers = centers.copy()\n        new_radii = radii.copy()\n        \n        # Select two circles\n        i, j = np.random.choice(len(centers), 2, replace=False)\n        \n        # Try to increase one and decrease the other\n        delta = 0.01 * temp\n        new_radii[i] += delta\n        new_radii[j] = max(0, new_radii[j] - delta)\n        \n        # Check feasibility and adjust\n        if not check_feasibility(new_centers, new_radii):\n            new_radii = compute_max_radii(new_centers)\n        \n        return new_centers, new_radii\n    \n    def rearrange_cluster(centers, radii, temp):\n        \"\"\"Move operator 4: Move a cluster of nearby circles.\"\"\"\n        new_centers = centers.copy()\n        new_radii = radii.copy()\n        \n        # Select a random center\n        center_idx = np.random.randint(len(centers))\n        center_pos = centers[center_idx]\n        \n        # Find nearby circles\n        dists = np.linalg.norm(centers - center_pos, axis=1)\n        threshold = 0.2\n        cluster = np.where(dists < threshold)[0]\n        \n        if len(cluster) > 1:\n            # Move the entire cluster\n            shift = np.random.normal(0, 0.03 * temp, 2)\n            for idx in cluster:\n                new_centers[idx] += shift\n                new_centers[idx] = np.clip(new_centers[idx], 0.01, 0.99)\n            \n            # Recompute radii\n            new_radii = compute_max_radii(new_centers)\n        \n        return new_centers, new_radii\n    \n    # Simulated annealing\n    centers, radii = initialize_solution()\n    radii = compute_max_radii(centers)\n    \n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_score = np.sum(radii)\n    \n    current_score = best_score\n    \n    # Temperature schedule\n    T_init = 1.0\n    T_min = 0.001\n    n_iterations = 50000\n    \n    # Move operator weights (adaptive)\n    op_weights = np.array([0.4, 0.2, 0.2, 0.2])\n    op_success = np.ones(4)\n    op_attempts = np.ones(4)\n    \n    for iteration in range(n_iterations):\n        # Adaptive temperature\n        T = T_init * (T_min / T_init) ** (iteration / n_iterations)\n        \n        # Select move operator based on success rates\n        if iteration > 1000 and iteration % 500 == 0:\n            success_rate = op_success / op_attempts\n            op_weights = success_rate / np.sum(success_rate)\n        \n        op_idx = np.random.choice(4, p=op_weights)\n        op_attempts[op_idx] += 1\n        \n        # Apply move operator\n        if op_idx == 0:\n            new_centers, new_radii = perturb_positions(centers, radii, T)\n        elif op_idx == 1:\n            new_centers, new_radii = swap_circles(centers, radii, T)\n        elif op_idx == 2:\n            new_centers, new_radii = redistribute_radii(centers, radii, T)\n        else:\n            new_centers, new_radii = rearrange_cluster(centers, radii, T)\n        \n        # Check feasibility\n        if not check_feasibility(new_centers, new_radii):\n            continue\n        \n        new_score = np.sum(new_radii)\n        delta = new_score - current_score\n        \n        # Accept or reject\n        if delta > 0 or np.random.random() < np.exp(delta / T):\n            centers = new_centers\n            radii = new_radii\n            current_score = new_score\n            op_success[op_idx] += 1\n            \n            # Update best\n            if current_score > best_score:\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                best_score = current_score\n    \n    # Final local optimization using scipy\n    def scipy_objective(x):\n        n = len(best_radii)\n        centers = x.reshape(n, 2)\n        radii = compute_max_radii(centers)\n        \n        # Penalty for constraint violations\n        penalty = 0\n        if not check_feasibility(centers, radii):\n            penalty = 1000\n        \n        return -np.sum(radii) + penalty\n    \n    x0 = best_centers.flatten()\n    bounds = [(0.01, 0.99)] * len(x0)\n    \n    result = minimize(scipy_objective, x0, method='L-BFGS-B', \n                     bounds=bounds, options={'maxiter': 1000})\n    \n    if result.success:\n        final_centers = result.x.reshape(n, 2)\n        final_radii = compute_max_radii(final_centers)\n        \n        if check_feasibility(final_centers, final_radii) and \\\n           np.sum(final_radii) > best_score:\n            best_centers = final_centers\n            best_radii = final_radii\n            best_score = np.sum(final_radii)\n    \n    return best_centers, best_radii, best_score\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.3624493643953641,
    "target_ratio": 0.5170585823132312,
    "combined_score": 0.5170585823132312,
    "eval_time": 55.564687967300415,
    "error": null
  },
  "prompt": "Create advanced simulated annealing with intelligent move operators.\n\nMove operators:\n1. Small position perturbation (local search)\n2. Circle swap (exchange two circles)\n3. Radius redistribution (decrease one, increase another)\n4. Cluster rearrangement (move group of nearby circles)\n\nStrategy:\n- Start with good initialization\n- Use adaptive temperature schedule\n- Select move operator based on current state\n- Run for 50000 iterations\n- Final scipy polish\n\nRequirements:\n- Multiple move operators\n- Smart operator selection\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using\n    advanced simulated annealing with multiple intelligent move operators.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # Initialize with grid-based layout\n    def initialize_solution():\n        # Start with 5x5 grid plus one extra\n        grid_size = 5\n        spacing = 1.0 / (grid_size + 1)\n        centers = []\n        \n        for i in range(grid_size):\n            for j in range(grid_size):\n                x = spacing * (i + 1)\n                y = spacing * (j + 1)\n                centers.append([x, y])\n        \n        # Add the 26th circle\n        centers.append([0.5, 0.5])\n        centers = np.array(centers[:n])\n        \n        # Initialize radii uniformly\n        radii = np.ones(n) * 0.08\n        \n        return centers, radii\n    \n    def check_feasibility(centers, radii):\n        \"\"\"Check if solution satisfies all constraints.\"\"\"\n        # Check bounds\n        if np.any(centers - radii[:, np.newaxis] < 0) or \\\n           np.any(centers + radii[:, np.newaxis] > 1):\n            return False\n        \n        # Check overlaps\n        dists = cdist(centers, centers)\n        radii_sum = radii[:, np.newaxis] + radii[np.newaxis, :]\n        np.fill_diagonal(dists, np.inf)\n        \n        if np.any(dists < radii_sum - 1e-6):\n            return False\n        \n        return True\n    \n    def compute_max_radii(centers):\n        \"\"\"Compute maximum feasible radii for given centers.\"\"\"\n        n = len(centers)\n        radii = np.zeros(n)\n        \n        for i in range(n):\n            # Distance to boundaries\n            max_r = min(centers[i, 0], 1 - centers[i, 0],\n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, (dist - radii[j]) / 2)\n            \n            radii[i] = max(0, max_r)\n        \n        return radii\n    \n    def objective(centers, radii):\n        \"\"\"Negative sum of radii (for minimization).\"\"\"\n        return -np.sum(radii)\n    \n    def perturb_positions(centers, radii, temp):\n        \"\"\"Move operator 1: Small position perturbation.\"\"\"\n        new_centers = centers.copy()\n        new_radii = radii.copy()\n        \n        # Perturb 1-3 circles\n        n_perturb = np.random.randint(1, 4)\n        indices = np.random.choice(len(centers), n_perturb, replace=False)\n        \n        scale = 0.05 * temp\n        for idx in indices:\n            new_centers[idx] += np.random.normal(0, scale, 2)\n            new_centers[idx] = np.clip(new_centers[idx], 0.01, 0.99)\n        \n        # Recompute radii\n        new_radii = compute_max_radii(new_centers)\n        \n        return new_centers, new_radii\n    \n    def swap_circles(centers, radii, temp):\n        \"\"\"Move operator 2: Swap positions of two circles.\"\"\"\n        new_centers = centers.copy()\n        new_radii = radii.copy()\n        \n        i, j = np.random.choice(len(centers), 2, replace=False)\n        new_centers[i], new_centers[j] = new_centers[j].copy(), new_centers[i].copy()\n        \n        # Recompute radii\n        new_radii = compute_max_radii(new_centers)\n        \n        return new_centers, new_radii\n    \n    def redistribute_radii(centers, radii, temp):\n        \"\"\"Move operator 3: Adjust radii distribution.\"\"\"\n        new_centers = centers.copy()\n        new_radii = radii.copy()\n        \n        # Select two circles\n        i, j = np.random.choice(len(centers), 2, replace=False)\n        \n        # Try to increase one and decrease the other\n        delta = 0.01 * temp\n        new_radii[i] += delta\n        new_radii[j] = max(0, new_radii[j] - delta)\n        \n        # Check feasibility and adjust\n        if not check_feasibility(new_centers, new_radii):\n            new_radii = compute_max_radii(new_centers)\n        \n        return new_centers, new_radii\n    \n    def rearrange_cluster(centers, radii, temp):\n        \"\"\"Move operator 4: Move a cluster of nearby circles.\"\"\"\n        new_centers = centers.copy()\n        new_radii = radii.copy()\n        \n        # Select a random center\n        center_idx = np.random.randint(len(centers))\n        center_pos = centers[center_idx]\n        \n        # Find nearby circles\n        dists = np.linalg.norm(centers - center_pos, axis=1)\n        threshold = 0.2\n        cluster = np.where(dists < threshold)[0]\n        \n        if len(cluster) > 1:\n            # Move the entire cluster\n            shift = np.random.normal(0, 0.03 * temp, 2)\n            for idx in cluster:\n                new_centers[idx] += shift\n                new_centers[idx] = np.clip(new_centers[idx], 0.01, 0.99)\n            \n            # Recompute radii\n            new_radii = compute_max_radii(new_centers)\n        \n        return new_centers, new_radii\n    \n    # Simulated annealing\n    centers, radii = initialize_solution()\n    radii = compute_max_radii(centers)\n    \n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_score = np.sum(radii)\n    \n    current_score = best_score\n    \n    # Temperature schedule\n    T_init = 1.0\n    T_min = 0.001\n    n_iterations = 50000\n    \n    # Move operator weights (adaptive)\n    op_weights = np.array([0.4, 0.2, 0.2, 0.2])\n    op_success = np.ones(4)\n    op_attempts = np.ones(4)\n    \n    for iteration in range(n_iterations):\n        # Adaptive temperature\n        T = T_init * (T_min / T_init) ** (iteration / n_iterations)\n        \n        # Select move operator based on success rates\n        if iteration > 1000 and iteration % 500 == 0:\n            success_rate = op_success / op_attempts\n            op_weights = success_rate / np.sum(success_rate)\n        \n        op_idx = np.random.choice(4, p=op_weights)\n        op_attempts[op_idx] += 1\n        \n        # Apply move operator\n        if op_idx == 0:\n            new_centers, new_radii = perturb_positions(centers, radii, T)\n        elif op_idx == 1:\n            new_centers, new_radii = swap_circles(centers, radii, T)\n        elif op_idx == 2:\n            new_centers, new_radii = redistribute_radii(centers, radii, T)\n        else:\n            new_centers, new_radii = rearrange_cluster(centers, radii, T)\n        \n        # Check feasibility\n        if not check_feasibility(new_centers, new_radii):\n            continue\n        \n        new_score = np.sum(new_radii)\n        delta = new_score - current_score\n        \n        # Accept or reject\n        if delta > 0 or np.random.random() < np.exp(delta / T):\n            centers = new_centers\n            radii = new_radii\n            current_score = new_score\n            op_success[op_idx] += 1\n            \n            # Update best\n            if current_score > best_score:\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                best_score = current_score\n    \n    # Final local optimization using scipy\n    def scipy_objective(x):\n        n = len(best_radii)\n        centers = x.reshape(n, 2)\n        radii = compute_max_radii(centers)\n        \n        # Penalty for constraint violations\n        penalty = 0\n        if not check_feasibility(centers, radii):\n            penalty = 1000\n        \n        return -np.sum(radii) + penalty\n    \n    x0 = best_centers.flatten()\n    bounds = [(0.01, 0.99)] * len(x0)\n    \n    result = minimize(scipy_objective, x0, method='L-BFGS-B', \n                     bounds=bounds, options={'maxiter': 1000})\n    \n    if result.success:\n        final_centers = result.x.reshape(n, 2)\n        final_radii = compute_max_radii(final_centers)\n        \n        if check_feasibility(final_centers, final_radii) and \\\n           np.sum(final_radii) > best_score:\n            best_centers = final_centers\n            best_radii = final_radii\n            best_score = np.sum(final_radii)\n    \n    return best_centers, best_radii, best_score\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T18:00:57.377052",
  "cost_data": null
}