{
  "trial_id": "trial_2_13",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # PHASE 1: Optimize positions with fixed conservative radii\n    initial_radius = 0.08\n    \n    # Initialize positions in a grid pattern\n    grid_size = int(np.ceil(np.sqrt(n)))\n    positions = []\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if len(positions) < n:\n                x = (i + 0.5) / grid_size\n                y = (j + 0.5) / grid_size\n                positions.append([x, y])\n    centers = np.array(positions[:n])\n    \n    # Optimize positions to maximize minimum pairwise distance\n    def position_objective(flat_centers):\n        centers_2d = flat_centers.reshape(n, 2)\n        \n        # Penalty for being outside square (with margin for radius)\n        margin = initial_radius\n        boundary_penalty = 0\n        boundary_penalty += np.sum(np.maximum(0, margin - centers_2d[:, 0])**2)\n        boundary_penalty += np.sum(np.maximum(0, centers_2d[:, 0] - (1 - margin))**2)\n        boundary_penalty += np.sum(np.maximum(0, margin - centers_2d[:, 1])**2)\n        boundary_penalty += np.sum(np.maximum(0, centers_2d[:, 1] - (1 - margin))**2)\n        \n        # Maximize minimum distance (minimize negative of min distance)\n        distances = cdist(centers_2d, centers_2d)\n        np.fill_diagonal(distances, np.inf)\n        min_distance = np.min(distances)\n        \n        return -min_distance + 1000 * boundary_penalty\n    \n    # Run optimization with multiple restarts\n    best_centers = centers.copy()\n    best_obj = float('inf')\n    \n    for restart in range(3):\n        if restart > 0:\n            # Random restart\n            centers = np.random.uniform(initial_radius, 1 - initial_radius, (n, 2))\n        \n        result = minimize(\n            position_objective,\n            centers.flatten(),\n            method='L-BFGS-B',\n            bounds=[(initial_radius, 1 - initial_radius)] * (2 * n),\n            options={'maxiter': 1000}\n        )\n        \n        if result.fun < best_obj:\n            best_obj = result.fun\n            best_centers = result.x.reshape(n, 2)\n    \n    centers = best_centers\n    \n    # PHASE 2: Aggressive radius maximization with fixed positions\n    radii = np.full(n, initial_radius)\n    \n    # Calculate all pairwise distances\n    distances = cdist(centers, centers)\n    np.fill_diagonal(distances, np.inf)\n    \n    # Calculate distance to boundaries\n    dist_to_left = centers[:, 0]\n    dist_to_right = 1 - centers[:, 0]\n    dist_to_bottom = centers[:, 1]\n    dist_to_top = 1 - centers[:, 1]\n    boundary_distances = np.minimum(\n        np.minimum(dist_to_left, dist_to_right),\n        np.minimum(dist_to_bottom, dist_to_top)\n    )\n    \n    # Iteratively maximize radii\n    max_iterations = 50\n    for iteration in range(max_iterations):\n        improved = False\n        \n        # Try to increase each circle's radius\n        for i in range(n):\n            # Find maximum safe radius for circle i\n            # Constraint 1: Distance to other circles\n            max_radius_circles = np.min(distances[i, :] - radii) if n > 1 else np.inf\n            \n            # Constraint 2: Distance to boundaries\n            max_radius_boundary = boundary_distances[i]\n            \n            # Take minimum of constraints\n            max_safe_radius = min(max_radius_circles, max_radius_boundary)\n            \n            # Binary search for optimal radius\n            low, high = radii[i], max_safe_radius\n            if high > low + 1e-6:\n                # Try aggressive increase\n                new_radius = high * 0.99  # Leave small safety margin\n                \n                # Verify feasibility\n                is_feasible = True\n                \n                # Check boundaries\n                if (centers[i, 0] - new_radius < 0 or centers[i, 0] + new_radius > 1 or\n                    centers[i, 1] - new_radius < 0 or centers[i, 1] + new_radius > 1):\n                    is_feasible = False\n                \n                # Check overlaps with other circles\n                if is_feasible:\n                    for j in range(n):\n                        if i != j:\n                            dist = distances[i, j]\n                            if dist < new_radius + radii[j] - 1e-9:\n                                is_feasible = False\n                                break\n                \n                if is_feasible and new_radius > radii[i]:\n                    radii[i] = new_radius\n                    improved = True\n        \n        if not improved:\n            break\n    \n    # Fine-tune with simultaneous optimization\n    def radius_objective(r):\n        # Maximize sum of radii\n        obj = -np.sum(r)\n        \n        # Penalty for constraint violations\n        penalty = 0\n        \n        # Boundary constraints\n        for i in range(n):\n            penalty += max(0, r[i] - centers[i, 0])**2 * 1e6\n            penalty += max(0, r[i] - (1 - centers[i, 0]))**2 * 1e6\n            penalty += max(0, r[i] - centers[i, 1])**2 * 1e6\n            penalty += max(0, r[i] - (1 - centers[i, 1]))**2 * 1e6\n        \n        # Overlap constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = distances[i, j]\n                overlap = r[i] + r[j] - dist\n                if overlap > 0:\n                    penalty += overlap**2 * 1e6\n        \n        return obj + penalty\n    \n    # Optimize radii\n    bounds = [(0, min(boundary_distances[i], np.min(distances[i, :]))) for i in range(n)]\n    result = minimize(\n        radius_objective,\n        radii,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 500}\n    )\n    \n    radii = result.x\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.155320661976659,
    "target_ratio": 0.8179585054939883,
    "combined_score": 0.8179585054939883,
    "eval_time": 0.6225080490112305,
    "error": null
  },
  "prompt": "Create two-phase optimizer with aggressive radius maximization.\n\nPhase 1 - Position optimization:\n1. Fix radii at conservative values (e.g., all 0.08)\n2. Optimize positions to maximize minimum distance between circles\n3. Use scipy or gradient descent\n\nPhase 2 - Radius maximization:\n1. Fix positions from phase 1\n2. For each circle, binary search for maximum safe radius\n3. Iteratively increase radii while maintaining feasibility\n4. Use linear programming if possible\n\nRequirements:\n- Clear two-phase structure\n- Aggressive radius maximization\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # PHASE 1: Optimize positions with fixed conservative radii\n    initial_radius = 0.08\n    \n    # Initialize positions in a grid pattern\n    grid_size = int(np.ceil(np.sqrt(n)))\n    positions = []\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if len(positions) < n:\n                x = (i + 0.5) / grid_size\n                y = (j + 0.5) / grid_size\n                positions.append([x, y])\n    centers = np.array(positions[:n])\n    \n    # Optimize positions to maximize minimum pairwise distance\n    def position_objective(flat_centers):\n        centers_2d = flat_centers.reshape(n, 2)\n        \n        # Penalty for being outside square (with margin for radius)\n        margin = initial_radius\n        boundary_penalty = 0\n        boundary_penalty += np.sum(np.maximum(0, margin - centers_2d[:, 0])**2)\n        boundary_penalty += np.sum(np.maximum(0, centers_2d[:, 0] - (1 - margin))**2)\n        boundary_penalty += np.sum(np.maximum(0, margin - centers_2d[:, 1])**2)\n        boundary_penalty += np.sum(np.maximum(0, centers_2d[:, 1] - (1 - margin))**2)\n        \n        # Maximize minimum distance (minimize negative of min distance)\n        distances = cdist(centers_2d, centers_2d)\n        np.fill_diagonal(distances, np.inf)\n        min_distance = np.min(distances)\n        \n        return -min_distance + 1000 * boundary_penalty\n    \n    # Run optimization with multiple restarts\n    best_centers = centers.copy()\n    best_obj = float('inf')\n    \n    for restart in range(3):\n        if restart > 0:\n            # Random restart\n            centers = np.random.uniform(initial_radius, 1 - initial_radius, (n, 2))\n        \n        result = minimize(\n            position_objective,\n            centers.flatten(),\n            method='L-BFGS-B',\n            bounds=[(initial_radius, 1 - initial_radius)] * (2 * n),\n            options={'maxiter': 1000}\n        )\n        \n        if result.fun < best_obj:\n            best_obj = result.fun\n            best_centers = result.x.reshape(n, 2)\n    \n    centers = best_centers\n    \n    # PHASE 2: Aggressive radius maximization with fixed positions\n    radii = np.full(n, initial_radius)\n    \n    # Calculate all pairwise distances\n    distances = cdist(centers, centers)\n    np.fill_diagonal(distances, np.inf)\n    \n    # Calculate distance to boundaries\n    dist_to_left = centers[:, 0]\n    dist_to_right = 1 - centers[:, 0]\n    dist_to_bottom = centers[:, 1]\n    dist_to_top = 1 - centers[:, 1]\n    boundary_distances = np.minimum(\n        np.minimum(dist_to_left, dist_to_right),\n        np.minimum(dist_to_bottom, dist_to_top)\n    )\n    \n    # Iteratively maximize radii\n    max_iterations = 50\n    for iteration in range(max_iterations):\n        improved = False\n        \n        # Try to increase each circle's radius\n        for i in range(n):\n            # Find maximum safe radius for circle i\n            # Constraint 1: Distance to other circles\n            max_radius_circles = np.min(distances[i, :] - radii) if n > 1 else np.inf\n            \n            # Constraint 2: Distance to boundaries\n            max_radius_boundary = boundary_distances[i]\n            \n            # Take minimum of constraints\n            max_safe_radius = min(max_radius_circles, max_radius_boundary)\n            \n            # Binary search for optimal radius\n            low, high = radii[i], max_safe_radius\n            if high > low + 1e-6:\n                # Try aggressive increase\n                new_radius = high * 0.99  # Leave small safety margin\n                \n                # Verify feasibility\n                is_feasible = True\n                \n                # Check boundaries\n                if (centers[i, 0] - new_radius < 0 or centers[i, 0] + new_radius > 1 or\n                    centers[i, 1] - new_radius < 0 or centers[i, 1] + new_radius > 1):\n                    is_feasible = False\n                \n                # Check overlaps with other circles\n                if is_feasible:\n                    for j in range(n):\n                        if i != j:\n                            dist = distances[i, j]\n                            if dist < new_radius + radii[j] - 1e-9:\n                                is_feasible = False\n                                break\n                \n                if is_feasible and new_radius > radii[i]:\n                    radii[i] = new_radius\n                    improved = True\n        \n        if not improved:\n            break\n    \n    # Fine-tune with simultaneous optimization\n    def radius_objective(r):\n        # Maximize sum of radii\n        obj = -np.sum(r)\n        \n        # Penalty for constraint violations\n        penalty = 0\n        \n        # Boundary constraints\n        for i in range(n):\n            penalty += max(0, r[i] - centers[i, 0])**2 * 1e6\n            penalty += max(0, r[i] - (1 - centers[i, 0]))**2 * 1e6\n            penalty += max(0, r[i] - centers[i, 1])**2 * 1e6\n            penalty += max(0, r[i] - (1 - centers[i, 1]))**2 * 1e6\n        \n        # Overlap constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = distances[i, j]\n                overlap = r[i] + r[j] - dist\n                if overlap > 0:\n                    penalty += overlap**2 * 1e6\n        \n        return obj + penalty\n    \n    # Optimize radii\n    bounds = [(0, min(boundary_distances[i], np.min(distances[i, :]))) for i in range(n)]\n    result = minimize(\n        radius_objective,\n        radii,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 500}\n    )\n    \n    radii = result.x\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T17:59:54.994211",
  "cost_data": null
}