{
  "trial_id": "trial_2_9",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, differential_evolution\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using\n    iterative large neighborhood search.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Start with hexagonal-inspired initial packing\n    centers, radii = initialize_hexagonal_packing(n)\n    \n    # Iterative large neighborhood search\n    best_sum = np.sum(radii)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    \n    # Multiple passes with different neighborhood sizes\n    for pass_num in range(3):\n        # Vary neighborhood size\n        if pass_num == 0:\n            neighborhood_size = 4\n        elif pass_num == 1:\n            neighborhood_size = 5\n        else:\n            neighborhood_size = 3\n        \n        # Systematic subset selection\n        for start_idx in range(n):\n            # Select circular neighborhood\n            indices = [(start_idx + i) % n for i in range(neighborhood_size)]\n            \n            # Optimize this subset\n            new_centers, new_radii = optimize_subset(\n                centers.copy(), radii.copy(), indices\n            )\n            \n            new_sum = np.sum(new_radii)\n            if new_sum > best_sum:\n                best_sum = new_sum\n                best_centers = new_centers.copy()\n                best_radii = new_radii.copy()\n                centers = new_centers.copy()\n                radii = new_radii.copy()\n    \n    # Final global optimization\n    centers, radii = global_optimization(best_centers, best_radii)\n    sum_radii = np.sum(radii)\n    \n    if sum_radii > best_sum:\n        return centers, radii, sum_radii\n    else:\n        return best_centers, best_radii, best_sum\n\ndef initialize_hexagonal_packing(n):\n    \"\"\"Initialize with hexagonal-inspired packing.\"\"\"\n    # Try to fit circles in a hexagonal pattern\n    rows = 5\n    cols = 6\n    \n    centers = []\n    \n    # Hexagonal grid\n    for row in range(rows):\n        for col in range(cols):\n            if len(centers) >= n:\n                break\n            x = (col + 0.5 * (row % 2)) / cols\n            y = row / (rows - 1) if rows > 1 else 0.5\n            # Add some perturbation\n            x = np.clip(x + 0.01 * np.random.randn(), 0.1, 0.9)\n            y = np.clip(y + 0.01 * np.random.randn(), 0.1, 0.9)\n            centers.append([x, y])\n        if len(centers) >= n:\n            break\n    \n    centers = np.array(centers[:n])\n    \n    # Compute initial radii\n    radii = compute_max_radii(centers)\n    \n    return centers, radii\n\ndef compute_max_radii(centers):\n    \"\"\"Compute maximum radius for each circle given centers.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Distance to boundaries\n        r_max = min(centers[i, 0], 1 - centers[i, 0], \n                   centers[i, 1], 1 - centers[i, 1])\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                r_max = min(r_max, dist / 2)\n        \n        radii[i] = max(0, r_max)\n    \n    return radii\n\ndef optimize_subset(centers, radii, indices):\n    \"\"\"Optimize a subset of circles.\"\"\"\n    n = len(centers)\n    fixed_indices = [i for i in range(n) if i not in indices]\n    \n    def objective(x):\n        # x contains: [centers_subset, radii_subset]\n        n_subset = len(indices)\n        centers_subset = x[:2*n_subset].reshape(n_subset, 2)\n        radii_subset = x[2*n_subset:]\n        \n        # Update full arrays\n        new_centers = centers.copy()\n        new_radii = radii.copy()\n        for idx, i in enumerate(indices):\n            new_centers[i] = centers_subset[idx]\n            new_radii[i] = radii_subset[idx]\n        \n        # Penalty for constraint violations\n        penalty = 0\n        \n        # Boundary constraints\n        for i in indices:\n            penalty += max(0, new_radii[i] - new_centers[i, 0]) * 100\n            penalty += max(0, new_radii[i] - new_centers[i, 1]) * 100\n            penalty += max(0, new_radii[i] - (1 - new_centers[i, 0])) * 100\n            penalty += max(0, new_radii[i] - (1 - new_centers[i, 1])) * 100\n            penalty += max(0, -new_radii[i]) * 100\n        \n        # Overlap constraints\n        for i in indices:\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(new_centers[i] - new_centers[j])\n                    overlap = (new_radii[i] + new_radii[j]) - dist\n                    if overlap > 0:\n                        penalty += overlap * 100\n        \n        return -np.sum(new_radii) + penalty\n    \n    # Initial guess\n    x0 = []\n    for i in indices:\n        x0.extend([centers[i, 0], centers[i, 1]])\n    for i in indices:\n        x0.append(radii[i])\n    x0 = np.array(x0)\n    \n    # Bounds\n    bounds = []\n    for _ in indices:\n        bounds.extend([(0.0, 1.0), (0.0, 1.0)])\n    for _ in indices:\n        bounds.append((0.0, 0.5))\n    \n    # Optimize\n    result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds,\n                     options={'maxiter': 200})\n    \n    if result.success or result.fun < objective(x0):\n        x_opt = result.x\n        n_subset = len(indices)\n        centers_subset = x_opt[:2*n_subset].reshape(n_subset, 2)\n        radii_subset = x_opt[2*n_subset:]\n        \n        new_centers = centers.copy()\n        new_radii = radii.copy()\n        for idx, i in enumerate(indices):\n            new_centers[i] = centers_subset[idx]\n            new_radii[i] = radii_subset[idx]\n        \n        return new_centers, new_radii\n    \n    return centers, radii\n\ndef global_optimization(centers, radii):\n    \"\"\"Final global optimization pass.\"\"\"\n    n = len(centers)\n    \n    def objective(x):\n        centers_new = x[:2*n].reshape(n, 2)\n        radii_new = x[2*n:]\n        \n        penalty = 0\n        \n        # Boundary constraints\n        for i in range(n):\n            penalty += max(0, radii_new[i] - centers_new[i, 0]) * 1000\n            penalty += max(0, radii_new[i] - centers_new[i, 1]) * 1000\n            penalty += max(0, radii_new[i] - (1 - centers_new[i, 0])) * 1000\n            penalty += max(0, radii_new[i] - (1 - centers_new[i, 1])) * 1000\n            penalty += max(0, -radii_new[i]) * 1000\n        \n        # Overlap constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers_new[i] - centers_new[j])\n                overlap = (radii_new[i] + radii_new[j]) - dist\n                if overlap > 0:\n                    penalty += overlap * 1000\n        \n        return -np.sum(radii_new) + penalty\n    \n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    bounds = [(0.0, 1.0)] * (2*n) + [(0.0, 0.5)] * n\n    \n    result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds,\n                     options={'maxiter': 1000})\n    \n    if result.success or result.fun < objective(x0):\n        x_opt = result.x\n        centers_new = x_opt[:2*n].reshape(n, 2)\n        radii_new = x_opt[2*n:]\n        return centers_new, radii_new\n    \n    return centers, radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.7919658336609618,
    "target_ratio": 0.6800629349756971,
    "combined_score": 0.6800629349756971,
    "eval_time": 16.523878812789917,
    "error": null
  },
  "prompt": "Create an iterative local search with large neighborhood moves.\n\nStrategy:\n1. Start with good initial packing (hexagonal or from trial_1_6 approach)\n2. In each iteration:\n   - Select subset of circles (3-5 circles)\n   - Re-optimize just those circles using scipy\n   - Accept if improvement\n3. Try different subsets systematically\n4. Run multiple passes over all circles\n5. Final global optimization pass\n\nRequirements:\n- Large neighborhood search\n- Systematic subset selection\n- Multiple passes\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using\n    iterative large neighborhood search.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Start with hexagonal-inspired initial packing\n    centers, radii = initialize_hexagonal_packing(n)\n    \n    # Iterative large neighborhood search\n    best_sum = np.sum(radii)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    \n    # Multiple passes with different neighborhood sizes\n    for pass_num in range(3):\n        # Vary neighborhood size\n        if pass_num == 0:\n            neighborhood_size = 4\n        elif pass_num == 1:\n            neighborhood_size = 5\n        else:\n            neighborhood_size = 3\n        \n        # Systematic subset selection\n        for start_idx in range(n):\n            # Select circular neighborhood\n            indices = [(start_idx + i) % n for i in range(neighborhood_size)]\n            \n            # Optimize this subset\n            new_centers, new_radii = optimize_subset(\n                centers.copy(), radii.copy(), indices\n            )\n            \n            new_sum = np.sum(new_radii)\n            if new_sum > best_sum:\n                best_sum = new_sum\n                best_centers = new_centers.copy()\n                best_radii = new_radii.copy()\n                centers = new_centers.copy()\n                radii = new_radii.copy()\n    \n    # Final global optimization\n    centers, radii = global_optimization(best_centers, best_radii)\n    sum_radii = np.sum(radii)\n    \n    if sum_radii > best_sum:\n        return centers, radii, sum_radii\n    else:\n        return best_centers, best_radii, best_sum\n\ndef initialize_hexagonal_packing(n):\n    \"\"\"Initialize with hexagonal-inspired packing.\"\"\"\n    # Try to fit circles in a hexagonal pattern\n    rows = 5\n    cols = 6\n    \n    centers = []\n    \n    # Hexagonal grid\n    for row in range(rows):\n        for col in range(cols):\n            if len(centers) >= n:\n                break\n            x = (col + 0.5 * (row % 2)) / cols\n            y = row / (rows - 1) if rows > 1 else 0.5\n            # Add some perturbation\n            x = np.clip(x + 0.01 * np.random.randn(), 0.1, 0.9)\n            y = np.clip(y + 0.01 * np.random.randn(), 0.1, 0.9)\n            centers.append([x, y])\n        if len(centers) >= n:\n            break\n    \n    centers = np.array(centers[:n])\n    \n    # Compute initial radii\n    radii = compute_max_radii(centers)\n    \n    return centers, radii\n\ndef compute_max_radii(centers):\n    \"\"\"Compute maximum radius for each circle given centers.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Distance to boundaries\n        r_max = min(centers[i, 0], 1 - centers[i, 0], \n                   centers[i, 1], 1 - centers[i, 1])\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                r_max = min(r_max, dist / 2)\n        \n        radii[i] = max(0, r_max)\n    \n    return radii\n\ndef optimize_subset(centers, radii, indices):\n    \"\"\"Optimize a subset of circles.\"\"\"\n    n = len(centers)\n    fixed_indices = [i for i in range(n) if i not in indices]\n    \n    def objective(x):\n        # x contains: [centers_subset, radii_subset]\n        n_subset = len(indices)\n        centers_subset = x[:2*n_subset].reshape(n_subset, 2)\n        radii_subset = x[2*n_subset:]\n        \n        # Update full arrays\n        new_centers = centers.copy()\n        new_radii = radii.copy()\n        for idx, i in enumerate(indices):\n            new_centers[i] = centers_subset[idx]\n            new_radii[i] = radii_subset[idx]\n        \n        # Penalty for constraint violations\n        penalty = 0\n        \n        # Boundary constraints\n        for i in indices:\n            penalty += max(0, new_radii[i] - new_centers[i, 0]) * 100\n            penalty += max(0, new_radii[i] - new_centers[i, 1]) * 100\n            penalty += max(0, new_radii[i] - (1 - new_centers[i, 0])) * 100\n            penalty += max(0, new_radii[i] - (1 - new_centers[i, 1])) * 100\n            penalty += max(0, -new_radii[i]) * 100\n        \n        # Overlap constraints\n        for i in indices:\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(new_centers[i] - new_centers[j])\n                    overlap = (new_radii[i] + new_radii[j]) - dist\n                    if overlap > 0:\n                        penalty += overlap * 100\n        \n        return -np.sum(new_radii) + penalty\n    \n    # Initial guess\n    x0 = []\n    for i in indices:\n        x0.extend([centers[i, 0], centers[i, 1]])\n    for i in indices:\n        x0.append(radii[i])\n    x0 = np.array(x0)\n    \n    # Bounds\n    bounds = []\n    for _ in indices:\n        bounds.extend([(0.0, 1.0), (0.0, 1.0)])\n    for _ in indices:\n        bounds.append((0.0, 0.5))\n    \n    # Optimize\n    result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds,\n                     options={'maxiter': 200})\n    \n    if result.success or result.fun < objective(x0):\n        x_opt = result.x\n        n_subset = len(indices)\n        centers_subset = x_opt[:2*n_subset].reshape(n_subset, 2)\n        radii_subset = x_opt[2*n_subset:]\n        \n        new_centers = centers.copy()\n        new_radii = radii.copy()\n        for idx, i in enumerate(indices):\n            new_centers[i] = centers_subset[idx]\n            new_radii[i] = radii_subset[idx]\n        \n        return new_centers, new_radii\n    \n    return centers, radii\n\ndef global_optimization(centers, radii):\n    \"\"\"Final global optimization pass.\"\"\"\n    n = len(centers)\n    \n    def objective(x):\n        centers_new = x[:2*n].reshape(n, 2)\n        radii_new = x[2*n:]\n        \n        penalty = 0\n        \n        # Boundary constraints\n        for i in range(n):\n            penalty += max(0, radii_new[i] - centers_new[i, 0]) * 1000\n            penalty += max(0, radii_new[i] - centers_new[i, 1]) * 1000\n            penalty += max(0, radii_new[i] - (1 - centers_new[i, 0])) * 1000\n            penalty += max(0, radii_new[i] - (1 - centers_new[i, 1])) * 1000\n            penalty += max(0, -radii_new[i]) * 1000\n        \n        # Overlap constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers_new[i] - centers_new[j])\n                overlap = (radii_new[i] + radii_new[j]) - dist\n                if overlap > 0:\n                    penalty += overlap * 1000\n        \n        return -np.sum(radii_new) + penalty\n    \n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    bounds = [(0.0, 1.0)] * (2*n) + [(0.0, 0.5)] * n\n    \n    result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds,\n                     options={'maxiter': 1000})\n    \n    if result.success or result.fun < objective(x0):\n        x_opt = result.x\n        centers_new = x_opt[:2*n].reshape(n, 2)\n        radii_new = x_opt[2*n:]\n        return centers_new, radii_new\n    \n    return centers, radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T18:00:13.961923",
  "cost_data": null
}