{
  "trial_id": "trial_2_3",
  "generation": 2,
  "parent_id": "trial_1_11",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, differential_evolution\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def greedy_packing(seed):\n        np.random.seed(seed)\n        centers = []\n        radii = []\n        \n        for i in range(n):\n            best_pos = None\n            best_radius = 0\n            \n            # Adaptive candidate generation\n            n_random = 3000\n            n_grid = 30\n            \n            # Random candidates\n            candidates = np.random.rand(n_random, 2)\n            \n            # Dense grid candidates\n            x_grid = np.linspace(0.02, 0.98, n_grid)\n            y_grid = np.linspace(0.02, 0.98, n_grid)\n            xx, yy = np.meshgrid(x_grid, y_grid)\n            grid_candidates = np.column_stack([xx.ravel(), yy.ravel()])\n            candidates = np.vstack([candidates, grid_candidates])\n            \n            # Strategic candidates: focus on corners and edges for first few circles\n            if i < 8:\n                corner_candidates = np.array([\n                    [0.1, 0.1], [0.9, 0.1], [0.1, 0.9], [0.9, 0.9],\n                    [0.5, 0.1], [0.5, 0.9], [0.1, 0.5], [0.9, 0.5],\n                    [0.3, 0.3], [0.7, 0.3], [0.3, 0.7], [0.7, 0.7]\n                ])\n                candidates = np.vstack([candidates, corner_candidates])\n            \n            # If we have existing circles, add candidates near them (gap filling)\n            if len(centers) > 2:\n                centers_array = np.array(centers)\n                radii_array = np.array(radii)\n                \n                # Sample points around existing circles\n                for j in range(min(5, len(centers))):\n                    angles = np.linspace(0, 2*np.pi, 20)\n                    dist = radii_array[j] * 2.2\n                    gap_candidates = centers_array[j] + dist * np.column_stack([np.cos(angles), np.sin(angles)])\n                    gap_candidates = np.clip(gap_candidates, 0, 1)\n                    candidates = np.vstack([candidates, gap_candidates])\n            \n            for candidate in candidates:\n                x, y = candidate\n                \n                # Maximum radius from boundaries\n                max_r = min(x, y, 1 - x, 1 - y)\n                \n                if max_r <= 0:\n                    continue\n                \n                # Check constraints with existing circles\n                if len(centers) > 0:\n                    centers_array = np.array(centers)\n                    radii_array = np.array(radii)\n                    \n                    # Distance to existing circles\n                    distances = np.sqrt(np.sum((centers_array - candidate)**2, axis=1))\n                    # Maximum radius to avoid overlap\n                    max_r_circles = distances - radii_array\n                    max_r = min(max_r, np.min(max_r_circles))\n                \n                if max_r > best_radius:\n                    best_radius = max_r\n                    best_pos = candidate\n            \n            if best_radius > 0:\n                centers.append(best_pos)\n                radii.append(best_radius)\n        \n        return np.array(centers), np.array(radii)\n    \n    # Try multiple seeds and keep best\n    best_centers = None\n    best_radii = None\n    best_sum = 0\n    \n    seeds = [42, 123, 456, 789, 1337, 2024, 9999]\n    \n    for seed in seeds:\n        centers, radii = greedy_packing(seed)\n        current_sum = np.sum(radii)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    centers = best_centers\n    radii = best_radii\n    \n    # Local refinement: adjust positions slightly\n    def local_search(centers, radii, iterations=100):\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n        best_sum = np.sum(radii)\n        \n        for _ in range(iterations):\n            # Pick a random circle\n            idx = np.random.randint(n)\n            \n            # Try small perturbations\n            for _ in range(20):\n                new_center = centers[idx] + np.random.randn(2) * 0.02\n                new_center = np.clip(new_center, 0, 1)\n                \n                # Calculate max radius at new position\n                max_r = min(new_center[0], new_center[1], 1 - new_center[0], 1 - new_center[1])\n                \n                # Check with other circles\n                for j in range(n):\n                    if j != idx:\n                        dist = np.sqrt(np.sum((centers[j] - new_center)**2))\n                        max_r = min(max_r, dist - radii[j])\n                \n                if max_r > 0:\n                    # Try this configuration\n                    test_centers = centers.copy()\n                    test_radii = radii.copy()\n                    test_centers[idx] = new_center\n                    test_radii[idx] = max_r\n                    \n                    test_sum = np.sum(test_radii)\n                    if test_sum > best_sum:\n                        best_sum = test_sum\n                        best_centers = test_centers.copy()\n                        best_radii = test_radii.copy()\n                        centers = best_centers.copy()\n                        radii = best_radii.copy()\n        \n        return best_centers, best_radii\n    \n    centers, radii = local_search(centers, radii, iterations=150)\n    \n    # Final optimization with scipy\n    def objective(x):\n        n_circles = len(radii)\n        radii_opt = x[n_circles*2:]\n        return -np.sum(radii_opt)\n    \n    def constraint_boundary(x):\n        n_circles = len(radii)\n        centers_opt = x[:n_circles*2].reshape(n_circles, 2)\n        radii_opt = x[n_circles*2:]\n        \n        constraints = []\n        for i in range(n_circles):\n            constraints.extend([\n                centers_opt[i, 0] - radii_opt[i],\n                centers_opt[i, 1] - radii_opt[i],\n                1 - centers_opt[i, 0] - radii_opt[i],\n                1 - centers_opt[i, 1] - radii_opt[i]\n            ])\n        return np.array(constraints)\n    \n    def constraint_overlap(x):\n        n_circles = len(radii)\n        centers_opt = x[:n_circles*2].reshape(n_circles, 2)\n        radii_opt = x[n_circles*2:]\n        \n        constraints = []\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt(np.sum((centers_opt[i] - centers_opt[j])**2))\n                constraints.append(dist - radii_opt[i] - radii_opt[j])\n        return np.array(constraints)\n    \n    x0 = np.concatenate([centers.ravel(), radii])\n    bounds = [(0, 1)] * (n * 2) + [(0, 0.5)] * n\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_boundary},\n        {'type': 'ineq', 'fun': constraint_overlap}\n    ]\n    \n    # Multiple optimization attempts\n    best_result = None\n    best_value = float('inf')\n    \n    for attempt in range(5):\n        try:\n            if attempt > 0:\n                x0_perturbed = x0 + np.random.randn(len(x0)) * 0.005\n                x0_perturbed[:n*2] = np.clip(x0_perturbed[:n*2], 0.01, 0.99)\n                x0_perturbed[n*2:] = np.clip(x0_perturbed[n*2:], 0, 0.4)\n            else:\n                x0_perturbed = x0\n            \n            result = minimize(\n                objective,\n                x0_perturbed,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 1000, 'ftol': 1e-10}\n            )\n            \n            if result.fun < best_value:\n                best_result = result\n                best_value = result.fun\n        except:\n            pass\n    \n    if best_result is not None:\n        centers = best_result.x[:n*2].reshape(n, 2)\n        radii = best_result.x[n*2:]\n    \n    radii = np.maximum(radii, 0)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.603323800525935,
    "target_ratio": 0.9879786719263511,
    "combined_score": 0.9879786719263511,
    "eval_time": 22.950674772262573,
    "error": null
  },
  "prompt": "Enhance this high-scoring algorithm:\n\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    centers = []\n    radii = []\n    \n    # Sequential greedy placement\n    for i in range(n):\n        best_pos = None\n        best_radius = 0\n        \n        # Generate candidate positions\n        n_candidates = 2000\n        candidates = np.random.rand(n_candidates, 2)\n        \n        # Add grid-based candidates for better coverage\n        grid_size = 20\n        x_grid = np.linspace(0, 1, grid_size)\n        y_grid = np.linspace(0, 1, grid_size)\n        xx, yy = np.meshgrid(x_grid, y_grid)\n        grid_candidates = np.column_stack([xx.ravel(), yy.ravel()])\n        candidates = np.vstack([candidates, grid_candidates])\n        \n        for candidate in candidates:\n            x, y = candidate\n            \n            # Maximum radius from boundaries\n            max_r = min(x, y, 1 - x, 1 - y)\n            \n            # Check constraints with existing circles\n            if len(centers) > 0:\n                centers_array = np.array(centers)\n                radii_array = np.array(radii)\n                \n                # Distance to existing circles\n                distances = np.sqrt(np.sum((centers_array - candidate)**2, axis=1))\n                # Maximum radius to avoid overlap\n                max_r_circles = distances - radii_array\n                max_r = min(max_r, np.min(max_r_circles))\n            \n            if max_r > best_radius:\n                best_radius = max_r\n                best_pos = candidate\n        \n        if best_radius > 0:\n            centers.append(best_pos)\n            radii.append(best_radius)\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    \n    # Local optimization to refine the packing\n    def objective(x):\n        # x contains [centers (n*2), radii (n)]\n        n_circles = len(radii)\n        centers_opt = x[:n_circles*2].reshape(n_circles, 2)\n        radii_opt = x[n_circles*2:]\n        \n        # Maximize sum of radii = minimize negative sum\n        return -np.sum(radii_opt)\n    \n    def constraint_boundary(x):\n        n_circles = len(radii)\n        centers_opt = x[:n_circles*2].reshape(n_circles, 2)\n        radii_opt = x[n_circles*2:]\n        \n        # All circles must be inside [0,1]x[0,1]\n        constraints = []\n        for i in range(n_circles):\n            constraints.append(centers_opt[i, 0] - radii_opt[i])  # x - r >= 0\n            constraints.append(centers_opt[i, 1] - radii_opt[i])  # y - r >= 0\n            constraints.append(1 - centers_opt[i, 0] - radii_opt[i])  # 1 - x - r >= 0\n            constraints.append(1 - centers_opt[i, 1] - radii_opt[i])  # 1 - y - r >= 0\n        return np.array(constraints)\n    \n    def constraint_overlap(x):\n        n_circles = len(radii)\n        centers_opt = x[:n_circles*2].reshape(n_circles, 2)\n        radii_opt = x[n_circles*2:]\n        \n        # No overlap between circles\n        constraints = []\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt(np.sum((centers_opt[i] - centers_opt[j])**2))\n                constraints.append(dist - radii_opt[i] - radii_opt[j])  # dist >= r_i + r_j\n        return np.array(constraints)\n    \n    # Initial solution\n    x0 = np.concatenate([centers.ravel(), radii])\n    \n    # Bounds\n    bounds = [(0, 1)] * (n * 2) + [(0, 0.5)] * n\n    \n    # Constraints\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_boundary},\n        {'type': 'ineq', 'fun': constraint_overlap}\n    ]\n    \n    # Optimize with multiple attempts\n    best_result = None\n    best_value = float('inf')\n    \n    for attempt in range(3):\n        try:\n            if attempt > 0:\n                # Add small perturbation for different starting points\n                x0_perturbed = x0 + np.random.randn(len(x0)) * 0.01\n                x0_perturbed[:n*2] = np.clip(x0_perturbed[:n*2], 0.05, 0.95)\n                x0_perturbed[n*2:] = np.clip(x0_perturbed[n*2:], 0, 0.3)\n            else:\n                x0_perturbed = x0\n            \n            result = minimize(\n                objective,\n                x0_perturbed,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 500, 'ftol': 1e-9}\n            )\n            \n            if result.success and result.fun < best_value:\n                best_result = result\n                best_value = result.fun\n        except:\n            pass\n    \n    if best_result is not None and best_result.success:\n        centers = best_result.x[:n*2].reshape(n, 2)\n        radii = best_result.x[n*2:]\n    \n    # Ensure non-negative radii\n    radii = np.maximum(radii, 0)\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nAchieved 2.5941. Improvements:\n1. Increase candidate positions sampling (try 5000+ positions per circle)\n2. Use smarter candidate generation: focus on high-potential regions\n3. Add local search after greedy placement\n4. Apply scipy optimization for final refinement\n5. Try multiple random seeds, keep best result\n\nRequirements:\n- Maintain core sequential/greedy approach\n- Add refinement stages\n- Fast execution\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def greedy_packing(seed):\n        np.random.seed(seed)\n        centers = []\n        radii = []\n        \n        for i in range(n):\n            best_pos = None\n            best_radius = 0\n            \n            # Adaptive candidate generation\n            n_random = 3000\n            n_grid = 30\n            \n            # Random candidates\n            candidates = np.random.rand(n_random, 2)\n            \n            # Dense grid candidates\n            x_grid = np.linspace(0.02, 0.98, n_grid)\n            y_grid = np.linspace(0.02, 0.98, n_grid)\n            xx, yy = np.meshgrid(x_grid, y_grid)\n            grid_candidates = np.column_stack([xx.ravel(), yy.ravel()])\n            candidates = np.vstack([candidates, grid_candidates])\n            \n            # Strategic candidates: focus on corners and edges for first few circles\n            if i < 8:\n                corner_candidates = np.array([\n                    [0.1, 0.1], [0.9, 0.1], [0.1, 0.9], [0.9, 0.9],\n                    [0.5, 0.1], [0.5, 0.9], [0.1, 0.5], [0.9, 0.5],\n                    [0.3, 0.3], [0.7, 0.3], [0.3, 0.7], [0.7, 0.7]\n                ])\n                candidates = np.vstack([candidates, corner_candidates])\n            \n            # If we have existing circles, add candidates near them (gap filling)\n            if len(centers) > 2:\n                centers_array = np.array(centers)\n                radii_array = np.array(radii)\n                \n                # Sample points around existing circles\n                for j in range(min(5, len(centers))):\n                    angles = np.linspace(0, 2*np.pi, 20)\n                    dist = radii_array[j] * 2.2\n                    gap_candidates = centers_array[j] + dist * np.column_stack([np.cos(angles), np.sin(angles)])\n                    gap_candidates = np.clip(gap_candidates, 0, 1)\n                    candidates = np.vstack([candidates, gap_candidates])\n            \n            for candidate in candidates:\n                x, y = candidate\n                \n                # Maximum radius from boundaries\n                max_r = min(x, y, 1 - x, 1 - y)\n                \n                if max_r <= 0:\n                    continue\n                \n                # Check constraints with existing circles\n                if len(centers) > 0:\n                    centers_array = np.array(centers)\n                    radii_array = np.array(radii)\n                    \n                    # Distance to existing circles\n                    distances = np.sqrt(np.sum((centers_array - candidate)**2, axis=1))\n                    # Maximum radius to avoid overlap\n                    max_r_circles = distances - radii_array\n                    max_r = min(max_r, np.min(max_r_circles))\n                \n                if max_r > best_radius:\n                    best_radius = max_r\n                    best_pos = candidate\n            \n            if best_radius > 0:\n                centers.append(best_pos)\n                radii.append(best_radius)\n        \n        return np.array(centers), np.array(radii)\n    \n    # Try multiple seeds and keep best\n    best_centers = None\n    best_radii = None\n    best_sum = 0\n    \n    seeds = [42, 123, 456, 789, 1337, 2024, 9999]\n    \n    for seed in seeds:\n        centers, radii = greedy_packing(seed)\n        current_sum = np.sum(radii)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    centers = best_centers\n    radii = best_radii\n    \n    # Local refinement: adjust positions slightly\n    def local_search(centers, radii, iterations=100):\n        best_centers = centers.copy()\n        best_radii = radii.copy()\n        best_sum = np.sum(radii)\n        \n        for _ in range(iterations):\n            # Pick a random circle\n            idx = np.random.randint(n)\n            \n            # Try small perturbations\n            for _ in range(20):\n                new_center = centers[idx] + np.random.randn(2) * 0.02\n                new_center = np.clip(new_center, 0, 1)\n                \n                # Calculate max radius at new position\n                max_r = min(new_center[0], new_center[1], 1 - new_center[0], 1 - new_center[1])\n                \n                # Check with other circles\n                for j in range(n):\n                    if j != idx:\n                        dist = np.sqrt(np.sum((centers[j] - new_center)**2))\n                        max_r = min(max_r, dist - radii[j])\n                \n                if max_r > 0:\n                    # Try this configuration\n                    test_centers = centers.copy()\n                    test_radii = radii.copy()\n                    test_centers[idx] = new_center\n                    test_radii[idx] = max_r\n                    \n                    test_sum = np.sum(test_radii)\n                    if test_sum > best_sum:\n                        best_sum = test_sum\n                        best_centers = test_centers.copy()\n                        best_radii = test_radii.copy()\n                        centers = best_centers.copy()\n                        radii = best_radii.copy()\n        \n        return best_centers, best_radii\n    \n    centers, radii = local_search(centers, radii, iterations=150)\n    \n    # Final optimization with scipy\n    def objective(x):\n        n_circles = len(radii)\n        radii_opt = x[n_circles*2:]\n        return -np.sum(radii_opt)\n    \n    def constraint_boundary(x):\n        n_circles = len(radii)\n        centers_opt = x[:n_circles*2].reshape(n_circles, 2)\n        radii_opt = x[n_circles*2:]\n        \n        constraints = []\n        for i in range(n_circles):\n            constraints.extend([\n                centers_opt[i, 0] - radii_opt[i],\n                centers_opt[i, 1] - radii_opt[i],\n                1 - centers_opt[i, 0] - radii_opt[i],\n                1 - centers_opt[i, 1] - radii_opt[i]\n            ])\n        return np.array(constraints)\n    \n    def constraint_overlap(x):\n        n_circles = len(radii)\n        centers_opt = x[:n_circles*2].reshape(n_circles, 2)\n        radii_opt = x[n_circles*2:]\n        \n        constraints = []\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt(np.sum((centers_opt[i] - centers_opt[j])**2))\n                constraints.append(dist - radii_opt[i] - radii_opt[j])\n        return np.array(constraints)\n    \n    x0 = np.concatenate([centers.ravel(), radii])\n    bounds = [(0, 1)] * (n * 2) + [(0, 0.5)] * n\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_boundary},\n        {'type': 'ineq', 'fun': constraint_overlap}\n    ]\n    \n    # Multiple optimization attempts\n    best_result = None\n    best_value = float('inf')\n    \n    for attempt in range(5):\n        try:\n            if attempt > 0:\n                x0_perturbed = x0 + np.random.randn(len(x0)) * 0.005\n                x0_perturbed[:n*2] = np.clip(x0_perturbed[:n*2], 0.01, 0.99)\n                x0_perturbed[n*2:] = np.clip(x0_perturbed[n*2:], 0, 0.4)\n            else:\n                x0_perturbed = x0\n            \n            result = minimize(\n                objective,\n                x0_perturbed,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 1000, 'ftol': 1e-10}\n            )\n            \n            if result.fun < best_value:\n                best_result = result\n                best_value = result.fun\n        except:\n            pass\n    \n    if best_result is not None:\n        centers = best_result.x[:n*2].reshape(n, 2)\n        radii = best_result.x[n*2:]\n    \n    radii = np.maximum(radii, 0)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T18:00:18.946193",
  "cost_data": null
}