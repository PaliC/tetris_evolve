{
  "trial_id": "trial_2_4",
  "generation": 2,
  "parent_id": "trial_1_1",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, differential_evolution\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using multi-stage optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def pack_circles_grid(n_circles, x_min, x_max, y_min, y_max):\n        \"\"\"Initial grid-based packing in a region.\"\"\"\n        width = x_max - x_min\n        height = y_max - y_min\n        \n        aspect_ratio = width / height\n        cols = int(np.ceil(np.sqrt(n_circles * aspect_ratio)))\n        rows = int(np.ceil(n_circles / cols))\n        \n        while cols * rows < n_circles:\n            if width / cols > height / rows:\n                cols += 1\n            else:\n                rows += 1\n        \n        cell_width = width / cols\n        cell_height = height / rows\n        radius = min(cell_width, cell_height) / 2.0 * 0.95\n        \n        centers = []\n        radii = []\n        \n        for i in range(n_circles):\n            row = i // cols\n            col = i % cols\n            \n            cx = x_min + (col + 0.5) * cell_width\n            cy = y_min + (row + 0.5) * cell_height\n            \n            cx = np.clip(cx, x_min + radius, x_max - radius)\n            cy = np.clip(cy, y_min + radius, y_max - radius)\n            \n            centers.append([cx, cy])\n            radii.append(radius)\n        \n        return np.array(centers), np.array(radii)\n    \n    def force_directed_optimization(centers, radii, iterations=600):\n        \"\"\"Stage 1: Force-directed layout with momentum.\"\"\"\n        centers = centers.copy()\n        radii = radii.copy()\n        \n        velocities = np.zeros_like(centers)\n        momentum = 0.85\n        \n        for iteration in range(iterations):\n            forces = np.zeros_like(centers)\n            \n            # Repulsion between overlapping circles\n            for i in range(len(centers)):\n                for j in range(i + 1, len(centers)):\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    \n                    if dist < 1e-8:\n                        diff = np.random.randn(2) * 0.01\n                        dist = np.linalg.norm(diff)\n                    \n                    min_dist = radii[i] + radii[j]\n                    \n                    # Stronger repulsion for overlapping circles\n                    if dist < min_dist * 1.15:\n                        overlap = min_dist - dist\n                        force_mag = overlap * 1.2 if dist < min_dist else overlap * 0.3\n                        force_dir = diff / dist\n                        \n                        forces[i] += force_dir * force_mag\n                        forces[j] -= force_dir * force_mag\n            \n            # Boundary forces - stronger push from edges\n            for i in range(len(centers)):\n                r = radii[i]\n                margin = r * 0.02\n                \n                if centers[i, 0] - r < margin:\n                    forces[i, 0] += (margin + r - centers[i, 0]) * 1.0\n                if centers[i, 0] + r > 1 - margin:\n                    forces[i, 0] -= (centers[i, 0] + r - 1 + margin) * 1.0\n                if centers[i, 1] - r < margin:\n                    forces[i, 1] += (margin + r - centers[i, 1]) * 1.0\n                if centers[i, 1] + r > 1 - margin:\n                    forces[i, 1] -= (centers[i, 1] + r - 1 + margin) * 1.0\n            \n            # Update velocities with momentum and damping\n            damping = 0.9 * (1 - iteration / iterations * 0.5)\n            velocities = momentum * velocities + forces * 0.015\n            velocities *= damping\n            \n            # Update positions\n            centers += velocities\n            \n            # Enforce boundaries\n            for i in range(len(centers)):\n                centers[i, 0] = np.clip(centers[i, 0], radii[i], 1 - radii[i])\n                centers[i, 1] = np.clip(centers[i, 1], radii[i], 1 - radii[i])\n        \n        return centers, radii\n    \n    def optimize_radii_fixed_centers(centers):\n        \"\"\"Stage 2: Optimize only radii with fixed centers using aggressive expansion.\"\"\"\n        n = len(centers)\n        \n        def objective(radii):\n            return -np.sum(radii)\n        \n        def constraint_bounds(radii):\n            violations = []\n            for i in range(n):\n                violations.append(centers[i, 0] - radii[i])\n                violations.append(1 - centers[i, 0] - radii[i])\n                violations.append(centers[i, 1] - radii[i])\n                violations.append(1 - centers[i, 1] - radii[i])\n            return np.array(violations)\n        \n        def constraint_no_overlap(radii):\n            violations = []\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    violations.append(dist - radii[i] - radii[j])\n            return np.array(violations)\n        \n        # Aggressive initial radii\n        initial_radii = np.zeros(n)\n        for i in range(n):\n            max_r = min(\n                centers[i, 0],\n                1 - centers[i, 0],\n                centers[i, 1],\n                1 - centers[i, 1]\n            )\n            \n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, dist / 2.0)\n            \n            initial_radii[i] = max(0.001, max_r * 0.98)\n        \n        constraints = [\n            {'type': 'ineq', 'fun': constraint_bounds},\n            {'type': 'ineq', 'fun': constraint_no_overlap}\n        ]\n        \n        bounds = [(0.001, 0.6) for _ in range(n)]\n        \n        result = minimize(\n            objective,\n            initial_radii,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 2000, 'ftol': 1e-10}\n        )\n        \n        return result.x\n    \n    def joint_optimization(centers, radii, max_iter=800):\n        \"\"\"Stage 3: Joint optimization with multiple restarts.\"\"\"\n        n = len(centers)\n        \n        def objective(x):\n            return -np.sum(x[2::3])\n        \n        def constraint_bounds(x):\n            violations = []\n            for i in range(n):\n                cx, cy, r = x[3*i], x[3*i + 1], x[3*i + 2]\n                violations.extend([cx - r, 1 - cx - r, cy - r, 1 - cy - r])\n            return np.array(violations)\n        \n        def constraint_no_overlap(x):\n            violations = []\n            for i in range(n):\n                for j in range(i + 1, n):\n                    cx1, cy1, r1 = x[3*i], x[3*i + 1], x[3*i + 2]\n                    cx2, cy2, r2 = x[3*j], x[3*j + 1], x[3*j + 2]\n                    dist = np.sqrt((cx1 - cx2)**2 + (cy1 - cy2)**2)\n                    violations.append(dist - r1 - r2)\n            return np.array(violations)\n        \n        constraints = [\n            {'type': 'ineq', 'fun': constraint_bounds},\n            {'type': 'ineq', 'fun': constraint_no_overlap}\n        ]\n        \n        bounds = []\n        for i in range(n):\n            bounds.extend([(0, 1), (0, 1), (0.001, 0.6)])\n        \n        best_result = None\n        best_value = float('inf')\n        \n        # Multiple restarts with perturbations\n        for restart in range(3):\n            x0 = np.zeros(3 * n)\n            for i in range(n):\n                if restart == 0:\n                    x0[3*i] = centers[i, 0]\n                    x0[3*i + 1] = centers[i, 1]\n                else:\n                    # Small perturbation\n                    x0[3*i] = np.clip(centers[i, 0] + np.random.randn() * 0.02, radii[i], 1 - radii[i])\n                    x0[3*i + 1] = np.clip(centers[i, 1] + np.random.randn() * 0.02, radii[i], 1 - radii[i])\n                x0[3*i + 2] = radii[i]\n            \n            result = minimize(\n                objective,\n                x0,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': max_iter, 'ftol': 1e-10}\n            )\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_result = result\n        \n        opt_centers = np.zeros((n, 2))\n        opt_radii = np.zeros(n)\n        for i in range(n):\n            opt_centers[i, 0] = best_result.x[3*i]\n            opt_centers[i, 1] = best_result.x[3*i + 1]\n            opt_radii[i] = best_result.x[3*i + 2]\n        \n        return opt_centers, opt_radii\n    \n    def gradient_free_polish(centers, radii):\n        \"\"\"Stage 4: Final polish with Nelder-Mead.\"\"\"\n        n = len(centers)\n        \n        x0 = np.zeros(3 * n)\n        for i in range(n):\n            x0[3*i] = centers[i, 0]\n            x0[3*i + 1] = centers[i, 1]\n            x0[3*i + 2] = radii[i]\n        \n        def objective(x):\n            penalty = 0\n            \n            # Check bounds\n            for i in range(n):\n                cx, cy, r = x[3*i], x[3*i + 1], x[3*i + 2]\n                if cx - r < 0 or cx + r > 1 or cy - r < 0 or cy + r > 1:\n                    penalty += 1000\n                if r < 0.001:\n                    penalty += 1000\n            \n            # Check overlaps\n            for i in range(n):\n                for j in range(i + 1, n):\n                    cx1, cy1, r1 = x[3*i], x[3*i + 1], x[3*i + 2]\n                    cx2, cy2, r2 = x[3*j], x[3*j + 1], x[3*j + 2]\n                    dist = np.sqrt((cx1 - cx2)**2 + (cy1 - cy2)**2)\n                    if dist < r1 + r2:\n                        penalty += 1000 * (r1 + r2 - dist)\n            \n            return -np.sum(x[2::3]) + penalty\n        \n        result = minimize(\n            objective,\n            x0,\n            method='Nelder-Mead',\n            options={'maxiter': 5000, 'xatol': 1e-8, 'fatol': 1e-8}\n        )\n        \n        opt_centers = np.zeros((n, 2))\n        opt_radii = np.zeros(n)\n        for i in range(n):\n            opt_centers[i, 0] = result.x[3*i]\n            opt_centers[i, 1] = result.x[3*i + 1]\n            opt_radii[i] = result.x[3*i + 2]\n        \n        return opt_centers, opt_radii\n    \n    # Try multiple initial configurations\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    strategies = [\n        [(13, 0.0, 0.5, 0.0, 1.0), (13, 0.5, 1.0, 0.0, 1.0)],\n        [(13, 0.0, 1.0, 0.0, 0.5), (13, 0.0, 1.0, 0.5, 1.0)],\n        [(7, 0.0, 0.5, 0.5, 1.0), (7, 0.5, 1.0, 0.5, 1.0), \n         (6, 0.0, 0.5, 0.0, 0.5), (6, 0.5, 1.0, 0.0, 0.5)],\n        [(9, 0.0, 0.6, 0.0, 1.0), (9, 0.4, 1.0, 0.0, 0.6), (8, 0.4, 1.0, 0.4, 1.0)],\n    ]\n    \n    for strategy in strategies:\n        all_centers = []\n        all_radii = []\n        \n        for n_circles, x_min, x_max, y_min, y_max in strategy:\n            centers, radii = pack_circles_grid(n_circles, x_min, x_max, y_min, y_max)\n            all_centers.append(centers)\n            all_radii.append(radii)\n        \n        centers = np.vstack(all_centers)\n        radii = np.concatenate(all_radii)\n        \n        # Stage 1: Force-directed optimization with momentum\n        centers, radii = force_directed_optimization(centers, radii, iterations=600)\n        \n        # Stage 2: Optimize radii with fixed centers\n        radii = optimize_radii_fixed_centers(centers)\n        \n        # Stage 3: Joint optimization with restarts\n        centers, radii = joint_optimization(centers, radii, max_iter=800)\n        \n        # Stage 4: Gradient-free polish\n        centers, radii = gradient_free_polish(centers, radii)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 13.699434041976929,
    "error": "Circles 0 and 1 overlap: distance=0.204582, required=0.204595"
  },
  "prompt": "Improve this force-directed multi-stage optimizer:\n\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using multi-stage optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def pack_circles_grid(n_circles, x_min, x_max, y_min, y_max):\n        \"\"\"Initial grid-based packing in a region.\"\"\"\n        width = x_max - x_min\n        height = y_max - y_min\n        \n        aspect_ratio = width / height\n        cols = int(np.ceil(np.sqrt(n_circles * aspect_ratio)))\n        rows = int(np.ceil(n_circles / cols))\n        \n        while cols * rows < n_circles:\n            if width / cols > height / rows:\n                cols += 1\n            else:\n                rows += 1\n        \n        cell_width = width / cols\n        cell_height = height / rows\n        radius = min(cell_width, cell_height) / 2.0 * 0.92\n        \n        centers = []\n        radii = []\n        \n        for i in range(n_circles):\n            row = i // cols\n            col = i % cols\n            \n            cx = x_min + (col + 0.5) * cell_width\n            cy = y_min + (row + 0.5) * cell_height\n            \n            cx = np.clip(cx, x_min + radius, x_max - radius)\n            cy = np.clip(cy, y_min + radius, y_max - radius)\n            \n            centers.append([cx, cy])\n            radii.append(radius)\n        \n        return np.array(centers), np.array(radii)\n    \n    def force_directed_optimization(centers, radii, iterations=500):\n        \"\"\"Stage 1: Force-directed layout to optimize positions.\"\"\"\n        centers = centers.copy()\n        radii = radii.copy()\n        \n        for iteration in range(iterations):\n            forces = np.zeros_like(centers)\n            \n            # Repulsion between overlapping circles\n            for i in range(len(centers)):\n                for j in range(i + 1, len(centers)):\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    \n                    if dist < 1e-6:\n                        diff = np.random.randn(2) * 0.01\n                        dist = np.linalg.norm(diff)\n                    \n                    min_dist = radii[i] + radii[j]\n                    \n                    if dist < min_dist * 1.1:  # Apply force if too close\n                        overlap = min_dist - dist\n                        force_mag = overlap * 0.5\n                        force_dir = diff / dist\n                        \n                        forces[i] += force_dir * force_mag\n                        forces[j] -= force_dir * force_mag\n            \n            # Boundary forces - push circles away from edges\n            for i in range(len(centers)):\n                r = radii[i]\n                \n                if centers[i, 0] - r < 0:\n                    forces[i, 0] += (r - centers[i, 0]) * 0.5\n                if centers[i, 0] + r > 1:\n                    forces[i, 0] -= (centers[i, 0] + r - 1) * 0.5\n                if centers[i, 1] - r < 0:\n                    forces[i, 1] += (r - centers[i, 1]) * 0.5\n                if centers[i, 1] + r > 1:\n                    forces[i, 1] -= (centers[i, 1] + r - 1) * 0.5\n            \n            # Update positions with damping\n            damping = 0.8 * (1 - iteration / iterations)\n            centers += forces * damping * 0.01\n            \n            # Enforce boundaries\n            for i in range(len(centers)):\n                centers[i, 0] = np.clip(centers[i, 0], radii[i], 1 - radii[i])\n                centers[i, 1] = np.clip(centers[i, 1], radii[i], 1 - radii[i])\n        \n        return centers, radii\n    \n    def optimize_radii_fixed_centers(centers):\n        \"\"\"Stage 2: Optimize only radii with fixed centers.\"\"\"\n        n = len(centers)\n        \n        def objective(radii):\n            \"\"\"Negative sum of radii (to minimize).\"\"\"\n            return -np.sum(radii)\n        \n        def constraint_bounds(radii):\n            \"\"\"All circles must be within bounds.\"\"\"\n            violations = []\n            for i in range(n):\n                violations.append(centers[i, 0] - radii[i])  # left\n                violations.append(1 - centers[i, 0] - radii[i])  # right\n                violations.append(centers[i, 1] - radii[i])  # bottom\n                violations.append(1 - centers[i, 1] - radii[i])  # top\n            return np.array(violations)\n        \n        def constraint_no_overlap(radii):\n            \"\"\"No two circles may overlap.\"\"\"\n            violations = []\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    violations.append(dist - radii[i] - radii[j])\n            return np.array(violations)\n        \n        # Initial radii based on constraints\n        initial_radii = np.zeros(n)\n        for i in range(n):\n            # Maximum radius based on boundaries\n            max_r = min(\n                centers[i, 0],\n                1 - centers[i, 0],\n                centers[i, 1],\n                1 - centers[i, 1]\n            )\n            \n            # Check against other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, dist / 2)\n            \n            initial_radii[i] = max(0.001, max_r * 0.95)\n        \n        constraints = [\n            {'type': 'ineq', 'fun': constraint_bounds},\n            {'type': 'ineq', 'fun': constraint_no_overlap}\n        ]\n        \n        bounds = [(0.001, 0.5) for _ in range(n)]\n        \n        result = minimize(\n            objective,\n            initial_radii,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-9}\n        )\n        \n        return result.x\n    \n    def joint_optimization(centers, radii):\n        \"\"\"Stage 3: Joint optimization of positions and radii.\"\"\"\n        n = len(centers)\n        \n        # Flatten parameters\n        x0 = np.zeros(3 * n)\n        for i in range(n):\n            x0[3*i] = centers[i, 0]\n            x0[3*i + 1] = centers[i, 1]\n            x0[3*i + 2] = radii[i]\n        \n        def objective(x):\n            return -np.sum(x[2::3])\n        \n        def constraint_bounds(x):\n            violations = []\n            for i in range(n):\n                cx, cy, r = x[3*i], x[3*i + 1], x[3*i + 2]\n                violations.extend([cx - r, 1 - cx - r, cy - r, 1 - cy - r])\n            return np.array(violations)\n        \n        def constraint_no_overlap(x):\n            violations = []\n            for i in range(n):\n                for j in range(i + 1, n):\n                    cx1, cy1, r1 = x[3*i], x[3*i + 1], x[3*i + 2]\n                    cx2, cy2, r2 = x[3*j], x[3*j + 1], x[3*j + 2]\n                    dist = np.sqrt((cx1 - cx2)**2 + (cy1 - cy2)**2)\n                    violations.append(dist - r1 - r2)\n            return np.array(violations)\n        \n        constraints = [\n            {'type': 'ineq', 'fun': constraint_bounds},\n            {'type': 'ineq', 'fun': constraint_no_overlap}\n        ]\n        \n        bounds = []\n        for i in range(n):\n            bounds.extend([(0, 1), (0, 1), (0.001, 0.5)])\n        \n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 500, 'ftol': 1e-8}\n        )\n        \n        opt_centers = np.zeros((n, 2))\n        opt_radii = np.zeros(n)\n        for i in range(n):\n            opt_centers[i, 0] = result.x[3*i]\n            opt_centers[i, 1] = result.x[3*i + 1]\n            opt_radii[i] = result.x[3*i + 2]\n        \n        return opt_centers, opt_radii\n    \n    # Try multiple initial configurations\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    strategies = [\n        [(13, 0.0, 0.5, 0.0, 1.0), (13, 0.5, 1.0, 0.0, 1.0)],  # vertical split\n        [(13, 0.0, 1.0, 0.0, 0.5), (13, 0.0, 1.0, 0.5, 1.0)],  # horizontal split\n        [(7, 0.0, 0.5, 0.5, 1.0), (7, 0.5, 1.0, 0.5, 1.0), \n         (6, 0.0, 0.5, 0.0, 0.5), (6, 0.5, 1.0, 0.0, 0.5)],  # quadrants\n    ]\n    \n    for strategy in strategies:\n        all_centers = []\n        all_radii = []\n        \n        for n_circles, x_min, x_max, y_min, y_max in strategy:\n            centers, radii = pack_circles_grid(n_circles, x_min, x_max, y_min, y_max)\n            all_centers.append(centers)\n            all_radii.append(radii)\n        \n        centers = np.vstack(all_centers)\n        radii = np.concatenate(all_radii)\n        \n        # Stage 1: Force-directed optimization\n        centers, radii = force_directed_optimization(centers, radii, iterations=300)\n        \n        # Stage 2: Optimize radii with fixed centers\n        radii = optimize_radii_fixed_centers(centers)\n        \n        # Stage 3: Joint optimization\n        centers, radii = joint_optimization(centers, radii)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nAchieved 2.5828. Enhancements:\n1. Tune force parameters for faster convergence\n2. Add momentum to force updates\n3. Implement better radius expansion strategy\n4. Use scipy with multiple restarts from perturbed states\n5. Add final gradient-free polish (Nelder-Mead)\n\nRequirements:\n- Keep multi-stage structure\n- Better parameter tuning\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using multi-stage optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def pack_circles_grid(n_circles, x_min, x_max, y_min, y_max):\n        \"\"\"Initial grid-based packing in a region.\"\"\"\n        width = x_max - x_min\n        height = y_max - y_min\n        \n        aspect_ratio = width / height\n        cols = int(np.ceil(np.sqrt(n_circles * aspect_ratio)))\n        rows = int(np.ceil(n_circles / cols))\n        \n        while cols * rows < n_circles:\n            if width / cols > height / rows:\n                cols += 1\n            else:\n                rows += 1\n        \n        cell_width = width / cols\n        cell_height = height / rows\n        radius = min(cell_width, cell_height) / 2.0 * 0.95\n        \n        centers = []\n        radii = []\n        \n        for i in range(n_circles):\n            row = i // cols\n            col = i % cols\n            \n            cx = x_min + (col + 0.5) * cell_width\n            cy = y_min + (row + 0.5) * cell_height\n            \n            cx = np.clip(cx, x_min + radius, x_max - radius)\n            cy = np.clip(cy, y_min + radius, y_max - radius)\n            \n            centers.append([cx, cy])\n            radii.append(radius)\n        \n        return np.array(centers), np.array(radii)\n    \n    def force_directed_optimization(centers, radii, iterations=600):\n        \"\"\"Stage 1: Force-directed layout with momentum.\"\"\"\n        centers = centers.copy()\n        radii = radii.copy()\n        \n        velocities = np.zeros_like(centers)\n        momentum = 0.85\n        \n        for iteration in range(iterations):\n            forces = np.zeros_like(centers)\n            \n            # Repulsion between overlapping circles\n            for i in range(len(centers)):\n                for j in range(i + 1, len(centers)):\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    \n                    if dist < 1e-8:\n                        diff = np.random.randn(2) * 0.01\n                        dist = np.linalg.norm(diff)\n                    \n                    min_dist = radii[i] + radii[j]\n                    \n                    # Stronger repulsion for overlapping circles\n                    if dist < min_dist * 1.15:\n                        overlap = min_dist - dist\n                        force_mag = overlap * 1.2 if dist < min_dist else overlap * 0.3\n                        force_dir = diff / dist\n                        \n                        forces[i] += force_dir * force_mag\n                        forces[j] -= force_dir * force_mag\n            \n            # Boundary forces - stronger push from edges\n            for i in range(len(centers)):\n                r = radii[i]\n                margin = r * 0.02\n                \n                if centers[i, 0] - r < margin:\n                    forces[i, 0] += (margin + r - centers[i, 0]) * 1.0\n                if centers[i, 0] + r > 1 - margin:\n                    forces[i, 0] -= (centers[i, 0] + r - 1 + margin) * 1.0\n                if centers[i, 1] - r < margin:\n                    forces[i, 1] += (margin + r - centers[i, 1]) * 1.0\n                if centers[i, 1] + r > 1 - margin:\n                    forces[i, 1] -= (centers[i, 1] + r - 1 + margin) * 1.0\n            \n            # Update velocities with momentum and damping\n            damping = 0.9 * (1 - iteration / iterations * 0.5)\n            velocities = momentum * velocities + forces * 0.015\n            velocities *= damping\n            \n            # Update positions\n            centers += velocities\n            \n            # Enforce boundaries\n            for i in range(len(centers)):\n                centers[i, 0] = np.clip(centers[i, 0], radii[i], 1 - radii[i])\n                centers[i, 1] = np.clip(centers[i, 1], radii[i], 1 - radii[i])\n        \n        return centers, radii\n    \n    def optimize_radii_fixed_centers(centers):\n        \"\"\"Stage 2: Optimize only radii with fixed centers using aggressive expansion.\"\"\"\n        n = len(centers)\n        \n        def objective(radii):\n            return -np.sum(radii)\n        \n        def constraint_bounds(radii):\n            violations = []\n            for i in range(n):\n                violations.append(centers[i, 0] - radii[i])\n                violations.append(1 - centers[i, 0] - radii[i])\n                violations.append(centers[i, 1] - radii[i])\n                violations.append(1 - centers[i, 1] - radii[i])\n            return np.array(violations)\n        \n        def constraint_no_overlap(radii):\n            violations = []\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    violations.append(dist - radii[i] - radii[j])\n            return np.array(violations)\n        \n        # Aggressive initial radii\n        initial_radii = np.zeros(n)\n        for i in range(n):\n            max_r = min(\n                centers[i, 0],\n                1 - centers[i, 0],\n                centers[i, 1],\n                1 - centers[i, 1]\n            )\n            \n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, dist / 2.0)\n            \n            initial_radii[i] = max(0.001, max_r * 0.98)\n        \n        constraints = [\n            {'type': 'ineq', 'fun': constraint_bounds},\n            {'type': 'ineq', 'fun': constraint_no_overlap}\n        ]\n        \n        bounds = [(0.001, 0.6) for _ in range(n)]\n        \n        result = minimize(\n            objective,\n            initial_radii,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 2000, 'ftol': 1e-10}\n        )\n        \n        return result.x\n    \n    def joint_optimization(centers, radii, max_iter=800):\n        \"\"\"Stage 3: Joint optimization with multiple restarts.\"\"\"\n        n = len(centers)\n        \n        def objective(x):\n            return -np.sum(x[2::3])\n        \n        def constraint_bounds(x):\n            violations = []\n            for i in range(n):\n                cx, cy, r = x[3*i], x[3*i + 1], x[3*i + 2]\n                violations.extend([cx - r, 1 - cx - r, cy - r, 1 - cy - r])\n            return np.array(violations)\n        \n        def constraint_no_overlap(x):\n            violations = []\n            for i in range(n):\n                for j in range(i + 1, n):\n                    cx1, cy1, r1 = x[3*i], x[3*i + 1], x[3*i + 2]\n                    cx2, cy2, r2 = x[3*j], x[3*j + 1], x[3*j + 2]\n                    dist = np.sqrt((cx1 - cx2)**2 + (cy1 - cy2)**2)\n                    violations.append(dist - r1 - r2)\n            return np.array(violations)\n        \n        constraints = [\n            {'type': 'ineq', 'fun': constraint_bounds},\n            {'type': 'ineq', 'fun': constraint_no_overlap}\n        ]\n        \n        bounds = []\n        for i in range(n):\n            bounds.extend([(0, 1), (0, 1), (0.001, 0.6)])\n        \n        best_result = None\n        best_value = float('inf')\n        \n        # Multiple restarts with perturbations\n        for restart in range(3):\n            x0 = np.zeros(3 * n)\n            for i in range(n):\n                if restart == 0:\n                    x0[3*i] = centers[i, 0]\n                    x0[3*i + 1] = centers[i, 1]\n                else:\n                    # Small perturbation\n                    x0[3*i] = np.clip(centers[i, 0] + np.random.randn() * 0.02, radii[i], 1 - radii[i])\n                    x0[3*i + 1] = np.clip(centers[i, 1] + np.random.randn() * 0.02, radii[i], 1 - radii[i])\n                x0[3*i + 2] = radii[i]\n            \n            result = minimize(\n                objective,\n                x0,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': max_iter, 'ftol': 1e-10}\n            )\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_result = result\n        \n        opt_centers = np.zeros((n, 2))\n        opt_radii = np.zeros(n)\n        for i in range(n):\n            opt_centers[i, 0] = best_result.x[3*i]\n            opt_centers[i, 1] = best_result.x[3*i + 1]\n            opt_radii[i] = best_result.x[3*i + 2]\n        \n        return opt_centers, opt_radii\n    \n    def gradient_free_polish(centers, radii):\n        \"\"\"Stage 4: Final polish with Nelder-Mead.\"\"\"\n        n = len(centers)\n        \n        x0 = np.zeros(3 * n)\n        for i in range(n):\n            x0[3*i] = centers[i, 0]\n            x0[3*i + 1] = centers[i, 1]\n            x0[3*i + 2] = radii[i]\n        \n        def objective(x):\n            penalty = 0\n            \n            # Check bounds\n            for i in range(n):\n                cx, cy, r = x[3*i], x[3*i + 1], x[3*i + 2]\n                if cx - r < 0 or cx + r > 1 or cy - r < 0 or cy + r > 1:\n                    penalty += 1000\n                if r < 0.001:\n                    penalty += 1000\n            \n            # Check overlaps\n            for i in range(n):\n                for j in range(i + 1, n):\n                    cx1, cy1, r1 = x[3*i], x[3*i + 1], x[3*i + 2]\n                    cx2, cy2, r2 = x[3*j], x[3*j + 1], x[3*j + 2]\n                    dist = np.sqrt((cx1 - cx2)**2 + (cy1 - cy2)**2)\n                    if dist < r1 + r2:\n                        penalty += 1000 * (r1 + r2 - dist)\n            \n            return -np.sum(x[2::3]) + penalty\n        \n        result = minimize(\n            objective,\n            x0,\n            method='Nelder-Mead',\n            options={'maxiter': 5000, 'xatol': 1e-8, 'fatol': 1e-8}\n        )\n        \n        opt_centers = np.zeros((n, 2))\n        opt_radii = np.zeros(n)\n        for i in range(n):\n            opt_centers[i, 0] = result.x[3*i]\n            opt_centers[i, 1] = result.x[3*i + 1]\n            opt_radii[i] = result.x[3*i + 2]\n        \n        return opt_centers, opt_radii\n    \n    # Try multiple initial configurations\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    strategies = [\n        [(13, 0.0, 0.5, 0.0, 1.0), (13, 0.5, 1.0, 0.0, 1.0)],\n        [(13, 0.0, 1.0, 0.0, 0.5), (13, 0.0, 1.0, 0.5, 1.0)],\n        [(7, 0.0, 0.5, 0.5, 1.0), (7, 0.5, 1.0, 0.5, 1.0), \n         (6, 0.0, 0.5, 0.0, 0.5), (6, 0.5, 1.0, 0.0, 0.5)],\n        [(9, 0.0, 0.6, 0.0, 1.0), (9, 0.4, 1.0, 0.0, 0.6), (8, 0.4, 1.0, 0.4, 1.0)],\n    ]\n    \n    for strategy in strategies:\n        all_centers = []\n        all_radii = []\n        \n        for n_circles, x_min, x_max, y_min, y_max in strategy:\n            centers, radii = pack_circles_grid(n_circles, x_min, x_max, y_min, y_max)\n            all_centers.append(centers)\n            all_radii.append(radii)\n        \n        centers = np.vstack(all_centers)\n        radii = np.concatenate(all_radii)\n        \n        # Stage 1: Force-directed optimization with momentum\n        centers, radii = force_directed_optimization(centers, radii, iterations=600)\n        \n        # Stage 2: Optimize radii with fixed centers\n        radii = optimize_radii_fixed_centers(centers)\n        \n        # Stage 3: Joint optimization with restarts\n        centers, radii = joint_optimization(centers, radii, max_iter=800)\n        \n        # Stage 4: Gradient-free polish\n        centers, radii = gradient_free_polish(centers, radii)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T18:00:20.500387",
  "cost_data": null
}