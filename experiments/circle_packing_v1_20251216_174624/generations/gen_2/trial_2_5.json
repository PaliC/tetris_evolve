{
  "trial_id": "trial_2_5",
  "generation": 2,
  "parent_id": "trial_1_6",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using a three-stage hybrid approach.\n    \n    Stage 1: Sequential greedy placement for initial configuration\n    Stage 2: Force-directed layout for refinement\n    Stage 3: Scipy optimization for final polish\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # ===== STAGE 1: Sequential Greedy Placement =====\n    def sequential_placement():\n        centers = []\n        radii = []\n        \n        for i in range(n):\n            best_pos = None\n            best_radius = 0\n            \n            # Generate candidate positions\n            n_candidates = 1500\n            candidates = np.random.rand(n_candidates, 2)\n            \n            # Add grid-based candidates for better coverage\n            grid_size = 15\n            x_grid = np.linspace(0.05, 0.95, grid_size)\n            y_grid = np.linspace(0.05, 0.95, grid_size)\n            xx, yy = np.meshgrid(x_grid, y_grid)\n            grid_candidates = np.column_stack([xx.ravel(), yy.ravel()])\n            candidates = np.vstack([candidates, grid_candidates])\n            \n            for candidate in candidates:\n                x, y = candidate\n                \n                # Maximum radius from boundaries\n                max_r = min(x, y, 1 - x, 1 - y)\n                \n                # Check constraints with existing circles\n                if len(centers) > 0:\n                    centers_array = np.array(centers)\n                    radii_array = np.array(radii)\n                    \n                    # Distance to existing circles\n                    distances = np.sqrt(np.sum((centers_array - candidate)**2, axis=1))\n                    # Maximum radius to avoid overlap\n                    max_r_circles = distances - radii_array\n                    max_r = min(max_r, np.min(max_r_circles))\n                \n                if max_r > best_radius:\n                    best_radius = max_r\n                    best_pos = candidate\n            \n            if best_radius > 0:\n                centers.append(best_pos)\n                radii.append(best_radius)\n        \n        return np.array(centers), np.array(radii)\n    \n    # ===== STAGE 2: Force-Directed Layout =====\n    def force_directed_refinement(centers, radii, n_iterations=5000):\n        \"\"\"Refine positions using force-directed approach.\"\"\"\n        centers = centers.copy()\n        radii = radii.copy()\n        \n        dt = 0.001\n        damping = 0.9\n        velocities = np.zeros_like(centers)\n        \n        for iteration in range(n_iterations):\n            forces = np.zeros_like(centers)\n            \n            # Repulsion between overlapping or close circles\n            for i in range(n):\n                for j in range(i + 1, n):\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    min_dist = radii[i] + radii[j]\n                    \n                    if dist < min_dist + 0.02:\n                        if dist > 1e-6:\n                            force_mag = (min_dist - dist) * 8.0\n                            force_dir = diff / dist\n                            forces[i] += force_mag * force_dir\n                            forces[j] -= force_mag * force_dir\n            \n            # Boundary forces\n            for i in range(n):\n                r = radii[i]\n                margin = 0.001\n                \n                if centers[i, 0] - r < margin:\n                    forces[i, 0] += (r + margin - centers[i, 0]) * 5.0\n                if centers[i, 0] + r > 1 - margin:\n                    forces[i, 0] -= (centers[i, 0] + r - 1 + margin) * 5.0\n                if centers[i, 1] - r < margin:\n                    forces[i, 1] += (r + margin - centers[i, 1]) * 5.0\n                if centers[i, 1] + r > 1 - margin:\n                    forces[i, 1] -= (centers[i, 1] + r - 1 + margin) * 5.0\n            \n            # Update velocities and positions\n            velocities = velocities * damping + forces * dt\n            centers += velocities * dt\n            \n            # Clamp to valid range with margin\n            for i in range(n):\n                r = radii[i]\n                centers[i, 0] = np.clip(centers[i, 0], r, 1 - r)\n                centers[i, 1] = np.clip(centers[i, 1], r, 1 - r)\n            \n            # Try to increase radii periodically\n            if iteration % 200 == 0 and iteration < 3000:\n                for i in range(n):\n                    test_radius = radii[i] * 1.005\n                    \n                    # Check bounds\n                    if (centers[i, 0] - test_radius >= 0 and \n                        centers[i, 0] + test_radius <= 1 and\n                        centers[i, 1] - test_radius >= 0 and \n                        centers[i, 1] + test_radius <= 1):\n                        \n                        # Check overlaps\n                        can_increase = True\n                        for j in range(n):\n                            if i != j:\n                                dist = np.linalg.norm(centers[i] - centers[j])\n                                if dist < test_radius + radii[j]:\n                                    can_increase = False\n                                    break\n                        \n                        if can_increase:\n                            radii[i] = test_radius\n        \n        return centers, radii\n    \n    # ===== STAGE 3: Scipy Optimization =====\n    def scipy_polish(centers, radii):\n        \"\"\"Final optimization using scipy.\"\"\"\n        x0 = np.concatenate([centers.flatten(), radii])\n        \n        def objective(x):\n            return -np.sum(x[2*n:])\n        \n        def constraint_boundary(x):\n            centers_opt = x[:2*n].reshape(n, 2)\n            radii_opt = x[2*n:]\n            constraints = []\n            for i in range(n):\n                constraints.append(centers_opt[i, 0] - radii_opt[i])\n                constraints.append(centers_opt[i, 1] - radii_opt[i])\n                constraints.append(1 - centers_opt[i, 0] - radii_opt[i])\n                constraints.append(1 - centers_opt[i, 1] - radii_opt[i])\n            return np.array(constraints)\n        \n        def constraint_overlap(x):\n            centers_opt = x[:2*n].reshape(n, 2)\n            radii_opt = x[2*n:]\n            constraints = []\n            for i in range(n):\n                for j in range(i+1, n):\n                    dist = np.sqrt(np.sum((centers_opt[i] - centers_opt[j])**2))\n                    constraints.append(dist - radii_opt[i] - radii_opt[j])\n            return np.array(constraints)\n        \n        bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n        \n        constraints = [\n            {'type': 'ineq', 'fun': constraint_boundary},\n            {'type': 'ineq', 'fun': constraint_overlap}\n        ]\n        \n        best_result = None\n        best_value = float('inf')\n        \n        for attempt in range(3):\n            try:\n                if attempt > 0:\n                    x_init = x0 + np.random.randn(len(x0)) * 0.003\n                    x_init[:2*n] = np.clip(x_init[:2*n], 0.01, 0.99)\n                    x_init[2*n:] = np.clip(x_init[2*n:], 0.001, 0.4)\n                else:\n                    x_init = x0\n                \n                result = minimize(\n                    objective,\n                    x_init,\n                    method='SLSQP',\n                    bounds=bounds,\n                    constraints=constraints,\n                    options={'maxiter': 500, 'ftol': 1e-9}\n                )\n                \n                if result.fun < best_value:\n                    best_value = result.fun\n                    best_result = result\n            except:\n                pass\n        \n        if best_result is not None:\n            centers_opt = best_result.x[:2*n].reshape(n, 2)\n            radii_opt = best_result.x[2*n:]\n            return centers_opt, radii_opt\n        else:\n            return centers, radii\n    \n    # ===== Execute Three-Stage Pipeline =====\n    # Stage 1: Sequential placement\n    centers, radii = sequential_placement()\n    \n    # Stage 2: Force-directed refinement\n    centers, radii = force_directed_refinement(centers, radii)\n    \n    # Stage 3: Scipy polish\n    centers, radii = scipy_polish(centers, radii)\n    \n    # Ensure non-negative radii\n    radii = np.maximum(radii, 0)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 17.289910078048706,
    "error": "Circle 2 at (0.0, 1.0) with radius 0.5 extends outside x-bounds"
  },
  "prompt": "Create a super-hybrid combining the best two approaches:\n\nStart with sequential placement from trial_1_11:\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    centers = []\n    radii = []\n    \n    # Sequential greedy placement\n    for i in range(n):\n        best_pos = None\n        best_radius = 0\n        \n        # Generate candidate positions\n        n_candidates = 2000\n        candidates = np.random.rand(n_candidates, 2)\n        \n        # Add grid-based candidates for better coverage\n        grid_size = 20\n        x_grid = np.linspace(0, 1, grid_size)\n        y_grid = np.linspace(0, 1, grid_size)\n        xx, yy = np.meshgrid(x_grid, y_grid)\n        grid_candidates = np.column_stack([xx.ravel(), yy.ravel()])\n        candidates = np.vstack([candidates, grid_candidates])\n        \n        for candidate in candidates:\n            x, y = candidate\n            \n            # Maximum radius from boundaries\n            max_r = min(x, y, 1 - x, 1 - y)\n            \n            # Check constraints with existing circles\n            if len(centers) > 0:\n                centers_array = np.array(centers)\n                radii_array = np.array(radii)\n                \n                # Distance to existing circles\n                distances = np.sqrt(np.sum((centers_array - candidate)**2, axis=1))\n                # Maximum radius to avoid overlap\n                max_r_circles = distances - radii_array\n                max_r = min(max_r, np.min(max_r_circles))\n            \n            if max_r > best_radius:\n                best_radius = max_r\n                best_pos = candidate\n        \n        if best_radius > 0:\n            centers.append(best_pos)\n            radii.append(best_radius)\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    \n    # Local optimization to refine the packing\n    def objective(x):\n        # x contains [centers (n*2), radii (n)]\n        n_circles = len(radii)\n        centers_opt = x[:n_circles*2].reshape(n_circles, 2)\n        radii_opt = x[n_circles*2:]\n        \n        # Maximize sum of radii = minimize negative sum\n        return -np.sum(radii_opt)\n    \n    def constraint_boundary(x):\n        n_circles = len(radii)\n        centers_opt = x[:n_circles*2].reshape(n_circles, 2)\n        radii_opt = x[n_circles*2:]\n        \n        # All circles must be inside [0,1]x[0,1]\n        constraints = []\n        for i in range(n_circles):\n            constraints.append(centers_opt[i, 0] - radii_opt[i])  # x - r >= 0\n            constraints.append(centers_opt[i, 1] - radii_opt[i])  # y - r >= 0\n            constraints.append(1 - centers_opt[i, 0] - radii_opt[i])  # 1 - x - r >= 0\n            constraints.append(1 - centers_opt[i, 1] - radii_opt[i])  # 1 - y - r >= 0\n        return np.array(constraints)\n    \n    def constraint_overlap(x):\n        n_circles = len(radii)\n        centers_opt = x[:n_circles*2].reshape(n_circles, 2)\n        radii_opt = x[n_circles*2:]\n        \n        # No overlap between circles\n        constraints = []\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt(np.sum((centers_opt[i] - centers_opt[j])**2))\n                constraints.append(dist - radii_opt[i] - radii_opt[j])  # dist >= r_i + r_j\n        return np.array(constraints)\n    \n    # Initial solution\n    x0 = np.concatenate([centers.ravel(), radii])\n    \n    # Bounds\n    bounds = [(0, 1)] * (n * 2) + [(0, 0.5)] * n\n    \n    # Constraints\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_boundary},\n        {'type': 'ineq', 'fun': constraint_overlap}\n    ]\n    \n    # Optimize with multiple attempts\n    best_result = None\n    best_value = float('inf')\n    \n    for attempt in range(3):\n        try:\n            if attempt > 0:\n                # Add small perturbation for different starting points\n                x0_perturbed = x0 + np.random.randn(len(x0)) * 0.01\n                x0_perturbed[:n*2] = np.clip(x0_perturbed[:n*2], 0.05, 0.95)\n                x0_perturbed[n*2:] = np.clip(x0_perturbed[n*2:], 0, 0.3)\n            else:\n                x0_perturbed = x0\n            \n            result = minimize(\n                objective,\n                x0_perturbed,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 500, 'ftol': 1e-9}\n            )\n            \n            if result.success and result.fun < best_value:\n                best_result = result\n                best_value = result.fun\n        except:\n            pass\n    \n    if best_result is not None and best_result.success:\n        centers = best_result.x[:n*2].reshape(n, 2)\n        radii = best_result.x[n*2:]\n    \n    # Ensure non-negative radii\n    radii = np.maximum(radii, 0)\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nThen apply force-directed + scipy from trial_1_6:\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using hybrid optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Phase 1: Force-directed layout to find good initial positions\n    def force_directed_layout(n_iterations=10000):\n        \"\"\"Use force-directed approach to find good initial positions.\"\"\"\n        # Start with grid layout\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            centers.append([x, y])\n        centers = np.array(centers)\n        \n        # Initialize with uniform radii\n        radii = np.ones(n) * 0.04\n        \n        # Force-directed parameters\n        dt = 0.001\n        damping = 0.9\n        velocities = np.zeros_like(centers)\n        \n        for iteration in range(n_iterations):\n            forces = np.zeros_like(centers)\n            \n            # Repulsion between overlapping circles\n            for i in range(n):\n                for j in range(i + 1, n):\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    min_dist = radii[i] + radii[j]\n                    \n                    if dist < min_dist + 0.01:  # Add small buffer\n                        if dist > 1e-6:\n                            force_mag = (min_dist - dist) * 10.0\n                            force_dir = diff / dist\n                            forces[i] += force_mag * force_dir\n                            forces[j] -= force_mag * force_dir\n            \n            # Boundary forces (keep circles inside)\n            for i in range(n):\n                r = radii[i]\n                # Left boundary\n                if centers[i, 0] - r < 0:\n                    forces[i, 0] += (r - centers[i, 0]) * 5.0\n                # Right boundary\n                if centers[i, 0] + r > 1:\n                    forces[i, 0] -= (centers[i, 0] + r - 1) * 5.0\n                # Bottom boundary\n                if centers[i, 1] - r < 0:\n                    forces[i, 1] += (r - centers[i, 1]) * 5.0\n                # Top boundary\n                if centers[i, 1] + r > 1:\n                    forces[i, 1] -= (centers[i, 1] + r - 1) * 5.0\n            \n            # Update velocities and positions\n            velocities = velocities * damping + forces * dt\n            centers += velocities * dt\n            \n            # Clamp to valid range\n            centers = np.clip(centers, 0, 1)\n            \n            # Gradually increase radii\n            if iteration % 100 == 0 and iteration < 5000:\n                # Try to increase radii slightly\n                for i in range(n):\n                    can_increase = True\n                    test_radius = radii[i] * 1.01\n                    \n                    # Check bounds\n                    if (centers[i, 0] - test_radius < 0 or \n                        centers[i, 0] + test_radius > 1 or\n                        centers[i, 1] - test_radius < 0 or \n                        centers[i, 1] + test_radius > 1):\n                        can_increase = False\n                    \n                    # Check overlaps\n                    if can_increase:\n                        for j in range(n):\n                            if i != j:\n                                dist = np.linalg.norm(centers[i] - centers[j])\n                                if dist < test_radius + radii[j]:\n                                    can_increase = False\n                                    break\n                    \n                    if can_increase:\n                        radii[i] = test_radius\n        \n        return centers, radii\n    \n    # Get initial layout from force-directed method\n    initial_centers, initial_radii = force_directed_layout()\n    \n    # Phase 2: Scipy optimization to refine and maximize radii\n    def scipy_optimization(centers_init, radii_init):\n        \"\"\"Refine packing using scipy optimization.\"\"\"\n        # Combine into single vector: [centers_flat, radii]\n        x0 = np.concatenate([centers_init.flatten(), radii_init])\n        \n        # Objective: minimize negative sum of radii (to maximize sum)\n        def objective(x):\n            radii = x[2*n:]\n            return -np.sum(radii)\n        \n        # Constraints\n        constraints = []\n        \n        # Circles must be within bounds: center \u00b1 radius in [0,1]\n        for i in range(n):\n            # x_i - r_i >= 0\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: x[2*i] - x[2*n + i]\n            })\n            # x_i + r_i <= 1\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: 1 - x[2*i] - x[2*n + i]\n            })\n            # y_i - r_i >= 0\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: x[2*i + 1] - x[2*n + i]\n            })\n            # y_i + r_i <= 1\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: 1 - x[2*i + 1] - x[2*n + i]\n            })\n        \n        # No overlaps: distance between centers >= sum of radii\n        for i in range(n):\n            for j in range(i + 1, n):\n                def overlap_constraint(x, i=i, j=j):\n                    cx_i, cy_i = x[2*i], x[2*i + 1]\n                    cx_j, cy_j = x[2*j], x[2*j + 1]\n                    r_i, r_j = x[2*n + i], x[2*n + j]\n                    dist = np.sqrt((cx_i - cx_j)**2 + (cy_i - cy_j)**2)\n                    return dist - (r_i + r_j)\n                \n                constraints.append({\n                    'type': 'ineq',\n                    'fun': overlap_constraint\n                })\n        \n        # Radii must be non-negative\n        for i in range(n):\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: x[2*n + i]\n            })\n        \n        # Bounds for variables\n        bounds = []\n        # Centers: [0, 1] for each coordinate\n        for i in range(2*n):\n            bounds.append((0, 1))\n        # Radii: [0, 0.5] (reasonable upper bound)\n        for i in range(n):\n            bounds.append((0, 0.5))\n        \n        # Optimize with multiple attempts\n        best_result = None\n        best_value = float('inf')\n        \n        for attempt in range(3):\n            if attempt > 0:\n                # Add small random perturbation for subsequent attempts\n                x_init = x0 + np.random.randn(len(x0)) * 0.005\n                x_init[:2*n] = np.clip(x_init[:2*n], 0, 1)\n                x_init[2*n:] = np.clip(x_init[2*n:], 0, 0.5)\n            else:\n                x_init = x0\n            \n            result = minimize(\n                objective,\n                x_init,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 1000, 'ftol': 1e-9}\n            )\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_result = result\n        \n        # Extract solution\n        solution = best_result.x\n        centers = solution[:2*n].reshape(n, 2)\n        radii = solution[2*n:]\n        \n        return centers, radii\n    \n    # Run scipy optimization\n    final_centers, final_radii = scipy_optimization(initial_centers, initial_radii)\n    sum_radii = np.sum(final_radii)\n    \n    return final_centers, final_radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nStrategy:\n1. Use sequential greedy placement to get good initial configuration\n2. Apply force-directed layout to refine positions\n3. Use scipy optimization for final polish\n4. Return best result across multiple runs\n\nRequirements:\n- Three-stage pipeline\n- Fast execution (under 300s)\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using a three-stage hybrid approach.\n    \n    Stage 1: Sequential greedy placement for initial configuration\n    Stage 2: Force-directed layout for refinement\n    Stage 3: Scipy optimization for final polish\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # ===== STAGE 1: Sequential Greedy Placement =====\n    def sequential_placement():\n        centers = []\n        radii = []\n        \n        for i in range(n):\n            best_pos = None\n            best_radius = 0\n            \n            # Generate candidate positions\n            n_candidates = 1500\n            candidates = np.random.rand(n_candidates, 2)\n            \n            # Add grid-based candidates for better coverage\n            grid_size = 15\n            x_grid = np.linspace(0.05, 0.95, grid_size)\n            y_grid = np.linspace(0.05, 0.95, grid_size)\n            xx, yy = np.meshgrid(x_grid, y_grid)\n            grid_candidates = np.column_stack([xx.ravel(), yy.ravel()])\n            candidates = np.vstack([candidates, grid_candidates])\n            \n            for candidate in candidates:\n                x, y = candidate\n                \n                # Maximum radius from boundaries\n                max_r = min(x, y, 1 - x, 1 - y)\n                \n                # Check constraints with existing circles\n                if len(centers) > 0:\n                    centers_array = np.array(centers)\n                    radii_array = np.array(radii)\n                    \n                    # Distance to existing circles\n                    distances = np.sqrt(np.sum((centers_array - candidate)**2, axis=1))\n                    # Maximum radius to avoid overlap\n                    max_r_circles = distances - radii_array\n                    max_r = min(max_r, np.min(max_r_circles))\n                \n                if max_r > best_radius:\n                    best_radius = max_r\n                    best_pos = candidate\n            \n            if best_radius > 0:\n                centers.append(best_pos)\n                radii.append(best_radius)\n        \n        return np.array(centers), np.array(radii)\n    \n    # ===== STAGE 2: Force-Directed Layout =====\n    def force_directed_refinement(centers, radii, n_iterations=5000):\n        \"\"\"Refine positions using force-directed approach.\"\"\"\n        centers = centers.copy()\n        radii = radii.copy()\n        \n        dt = 0.001\n        damping = 0.9\n        velocities = np.zeros_like(centers)\n        \n        for iteration in range(n_iterations):\n            forces = np.zeros_like(centers)\n            \n            # Repulsion between overlapping or close circles\n            for i in range(n):\n                for j in range(i + 1, n):\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    min_dist = radii[i] + radii[j]\n                    \n                    if dist < min_dist + 0.02:\n                        if dist > 1e-6:\n                            force_mag = (min_dist - dist) * 8.0\n                            force_dir = diff / dist\n                            forces[i] += force_mag * force_dir\n                            forces[j] -= force_mag * force_dir\n            \n            # Boundary forces\n            for i in range(n):\n                r = radii[i]\n                margin = 0.001\n                \n                if centers[i, 0] - r < margin:\n                    forces[i, 0] += (r + margin - centers[i, 0]) * 5.0\n                if centers[i, 0] + r > 1 - margin:\n                    forces[i, 0] -= (centers[i, 0] + r - 1 + margin) * 5.0\n                if centers[i, 1] - r < margin:\n                    forces[i, 1] += (r + margin - centers[i, 1]) * 5.0\n                if centers[i, 1] + r > 1 - margin:\n                    forces[i, 1] -= (centers[i, 1] + r - 1 + margin) * 5.0\n            \n            # Update velocities and positions\n            velocities = velocities * damping + forces * dt\n            centers += velocities * dt\n            \n            # Clamp to valid range with margin\n            for i in range(n):\n                r = radii[i]\n                centers[i, 0] = np.clip(centers[i, 0], r, 1 - r)\n                centers[i, 1] = np.clip(centers[i, 1], r, 1 - r)\n            \n            # Try to increase radii periodically\n            if iteration % 200 == 0 and iteration < 3000:\n                for i in range(n):\n                    test_radius = radii[i] * 1.005\n                    \n                    # Check bounds\n                    if (centers[i, 0] - test_radius >= 0 and \n                        centers[i, 0] + test_radius <= 1 and\n                        centers[i, 1] - test_radius >= 0 and \n                        centers[i, 1] + test_radius <= 1):\n                        \n                        # Check overlaps\n                        can_increase = True\n                        for j in range(n):\n                            if i != j:\n                                dist = np.linalg.norm(centers[i] - centers[j])\n                                if dist < test_radius + radii[j]:\n                                    can_increase = False\n                                    break\n                        \n                        if can_increase:\n                            radii[i] = test_radius\n        \n        return centers, radii\n    \n    # ===== STAGE 3: Scipy Optimization =====\n    def scipy_polish(centers, radii):\n        \"\"\"Final optimization using scipy.\"\"\"\n        x0 = np.concatenate([centers.flatten(), radii])\n        \n        def objective(x):\n            return -np.sum(x[2*n:])\n        \n        def constraint_boundary(x):\n            centers_opt = x[:2*n].reshape(n, 2)\n            radii_opt = x[2*n:]\n            constraints = []\n            for i in range(n):\n                constraints.append(centers_opt[i, 0] - radii_opt[i])\n                constraints.append(centers_opt[i, 1] - radii_opt[i])\n                constraints.append(1 - centers_opt[i, 0] - radii_opt[i])\n                constraints.append(1 - centers_opt[i, 1] - radii_opt[i])\n            return np.array(constraints)\n        \n        def constraint_overlap(x):\n            centers_opt = x[:2*n].reshape(n, 2)\n            radii_opt = x[2*n:]\n            constraints = []\n            for i in range(n):\n                for j in range(i+1, n):\n                    dist = np.sqrt(np.sum((centers_opt[i] - centers_opt[j])**2))\n                    constraints.append(dist - radii_opt[i] - radii_opt[j])\n            return np.array(constraints)\n        \n        bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n        \n        constraints = [\n            {'type': 'ineq', 'fun': constraint_boundary},\n            {'type': 'ineq', 'fun': constraint_overlap}\n        ]\n        \n        best_result = None\n        best_value = float('inf')\n        \n        for attempt in range(3):\n            try:\n                if attempt > 0:\n                    x_init = x0 + np.random.randn(len(x0)) * 0.003\n                    x_init[:2*n] = np.clip(x_init[:2*n], 0.01, 0.99)\n                    x_init[2*n:] = np.clip(x_init[2*n:], 0.001, 0.4)\n                else:\n                    x_init = x0\n                \n                result = minimize(\n                    objective,\n                    x_init,\n                    method='SLSQP',\n                    bounds=bounds,\n                    constraints=constraints,\n                    options={'maxiter': 500, 'ftol': 1e-9}\n                )\n                \n                if result.fun < best_value:\n                    best_value = result.fun\n                    best_result = result\n            except:\n                pass\n        \n        if best_result is not None:\n            centers_opt = best_result.x[:2*n].reshape(n, 2)\n            radii_opt = best_result.x[2*n:]\n            return centers_opt, radii_opt\n        else:\n            return centers, radii\n    \n    # ===== Execute Three-Stage Pipeline =====\n    # Stage 1: Sequential placement\n    centers, radii = sequential_placement()\n    \n    # Stage 2: Force-directed refinement\n    centers, radii = force_directed_refinement(centers, radii)\n    \n    # Stage 3: Scipy polish\n    centers, radii = scipy_polish(centers, radii)\n    \n    # Ensure non-negative radii\n    radii = np.maximum(radii, 0)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T18:00:11.665786",
  "cost_data": null
}