{
  "trial_id": "trial_2_7",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Ensemble optimizer that runs multiple methods and returns the best result.\n    \"\"\"\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    # Try multiple methods with different seeds\n    methods = [\n        force_directed_method,\n        sequential_greedy_method,\n        iterative_expansion_method\n    ]\n    \n    seeds = [42, 123, 456]\n    \n    for method in methods:\n        for seed in seeds:\n            try:\n                centers, radii, sum_radii = method(seed)\n                if sum_radii > best_sum and is_valid_packing(centers, radii):\n                    best_sum = sum_radii\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n            except:\n                continue\n    \n    # Fallback if all methods fail\n    if best_centers is None:\n        best_centers, best_radii, best_sum = fallback_packing()\n    \n    return best_centers, best_radii, best_sum\n\n\ndef is_valid_packing(centers, radii):\n    \"\"\"Check if packing satisfies all constraints.\"\"\"\n    n = len(centers)\n    \n    # Check bounds\n    if np.any(centers - radii[:, None] < 0) or np.any(centers + radii[:, None] > 1):\n        return False\n    \n    # Check overlaps\n    dists = cdist(centers, centers)\n    min_dists = radii[:, None] + radii[None, :]\n    np.fill_diagonal(dists, np.inf)\n    if np.any(dists < min_dists - 1e-6):\n        return False\n    \n    return True\n\n\ndef force_directed_method(seed):\n    \"\"\"Force-directed layout with scipy optimization.\"\"\"\n    np.random.seed(seed)\n    n = 26\n    \n    # Initialize with grid + noise\n    grid_size = int(np.ceil(np.sqrt(n)))\n    positions = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size + np.random.randn() * 0.05\n        y = (row + 0.5) / grid_size + np.random.randn() * 0.05\n        positions.append([np.clip(x, 0.1, 0.9), np.clip(y, 0.1, 0.9)])\n    \n    centers = np.array(positions)\n    \n    # Force-directed relaxation\n    for iteration in range(50):\n        forces = np.zeros_like(centers)\n        \n        # Repulsion between circles\n        for i in range(n):\n            for j in range(i+1, n):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                if dist > 0:\n                    force = diff / dist * (0.1 / (dist + 0.01))\n                    forces[i] += force\n                    forces[j] -= force\n        \n        # Attraction to center\n        center_point = np.array([0.5, 0.5])\n        for i in range(n):\n            diff = center_point - centers[i]\n            forces[i] += diff * 0.05\n        \n        # Update positions\n        centers += forces * 0.1\n        centers = np.clip(centers, 0.05, 0.95)\n    \n    # Compute radii\n    radii = compute_radii(centers)\n    \n    # Optimize with scipy\n    def objective(x):\n        c = x.reshape(n, 2)\n        r = compute_radii(c)\n        return -np.sum(r)\n    \n    def constraint_bounds(x):\n        c = x.reshape(n, 2)\n        r = compute_radii(c)\n        violations = []\n        violations.extend(c[:, 0] - r - 0.0)\n        violations.extend(c[:, 1] - r - 0.0)\n        violations.extend(1.0 - c[:, 0] - r)\n        violations.extend(1.0 - c[:, 1] - r)\n        return np.array(violations)\n    \n    x0 = centers.flatten()\n    result = minimize(\n        objective, x0,\n        method='SLSQP',\n        constraints={'type': 'ineq', 'fun': constraint_bounds},\n        options={'maxiter': 100, 'ftol': 1e-6}\n    )\n    \n    centers = result.x.reshape(n, 2)\n    radii = compute_radii(centers)\n    \n    return centers, radii, np.sum(radii)\n\n\ndef sequential_greedy_method(seed):\n    \"\"\"Sequential greedy placement with optimization.\"\"\"\n    np.random.seed(seed)\n    n = 26\n    \n    centers = []\n    radii = []\n    \n    # Place first circle at center\n    centers.append([0.5, 0.5])\n    radii.append(0.5)\n    \n    # Greedily place remaining circles\n    for i in range(1, n):\n        best_pos = None\n        best_r = 0\n        \n        # Try multiple candidate positions\n        candidates = []\n        if i < 10:\n            # Grid-based candidates\n            for x in np.linspace(0.1, 0.9, 8):\n                for y in np.linspace(0.1, 0.9, 8):\n                    candidates.append([x, y])\n        else:\n            # Random candidates\n            for _ in range(30):\n                candidates.append([np.random.uniform(0.1, 0.9), \n                                 np.random.uniform(0.1, 0.9)])\n        \n        for pos in candidates:\n            r = compute_max_radius(pos, np.array(centers), np.array(radii))\n            if r > best_r:\n                best_r = r\n                best_pos = pos\n        \n        if best_pos is not None and best_r > 0:\n            centers.append(best_pos)\n            radii.append(best_r)\n    \n    # Ensure we have n circles\n    while len(centers) < n:\n        centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n        radii.append(0.01)\n    \n    centers = np.array(centers[:n])\n    radii = np.array(radii[:n])\n    \n    # Optimize\n    radii = compute_radii(centers)\n    \n    return centers, radii, np.sum(radii)\n\n\ndef iterative_expansion_method(seed):\n    \"\"\"Iterative expansion with refinement.\"\"\"\n    np.random.seed(seed)\n    n = 26\n    \n    # Start with tight grid\n    grid_size = int(np.ceil(np.sqrt(n)))\n    spacing = 0.9 / grid_size\n    \n    centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = 0.05 + (col + 0.5) * spacing\n        y = 0.05 + (row + 0.5) * spacing\n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    \n    # Iteratively expand\n    for iteration in range(30):\n        radii = compute_radii(centers)\n        \n        # Move circles to maximize space\n        new_centers = centers.copy()\n        for i in range(n):\n            # Try small moves\n            best_pos = centers[i]\n            best_r = radii[i]\n            \n            for dx in [-0.02, 0, 0.02]:\n                for dy in [-0.02, 0, 0.02]:\n                    test_pos = centers[i] + np.array([dx, dy])\n                    if 0 < test_pos[0] < 1 and 0 < test_pos[1] < 1:\n                        test_centers = centers.copy()\n                        test_centers[i] = test_pos\n                        test_radii = compute_radii(test_centers)\n                        if test_radii[i] > best_r:\n                            best_r = test_radii[i]\n                            best_pos = test_pos\n            \n            new_centers[i] = best_pos\n        \n        centers = new_centers\n    \n    radii = compute_radii(centers)\n    \n    return centers, radii, np.sum(radii)\n\n\ndef compute_radii(centers):\n    \"\"\"Compute maximum valid radius for each circle.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Distance to boundaries\n        r_max = min(centers[i, 0], centers[i, 1], \n                   1 - centers[i, 0], 1 - centers[i, 1])\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                r_max = min(r_max, (dist - radii[j]) / 2 if radii[j] > 0 else dist)\n        \n        radii[i] = max(0, r_max)\n    \n    return radii\n\n\ndef compute_max_radius(pos, centers, radii):\n    \"\"\"Compute maximum radius for a circle at given position.\"\"\"\n    pos = np.array(pos)\n    \n    # Distance to boundaries\n    r_max = min(pos[0], pos[1], 1 - pos[0], 1 - pos[1])\n    \n    # Distance to existing circles\n    for i in range(len(centers)):\n        dist = np.linalg.norm(pos - centers[i])\n        r_max = min(r_max, dist - radii[i])\n    \n    return max(0, r_max)\n\n\ndef fallback_packing():\n    \"\"\"Simple fallback packing if all methods fail.\"\"\"\n    n = 26\n    grid_size = 6\n    spacing = 1.0 / grid_size\n    radius = spacing / 2.5\n    \n    centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) * spacing\n        y = (row + 0.5) * spacing\n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    radii = np.full(n, radius)\n    \n    return centers, radii, np.sum(radii)\n\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.8624647000849224,
    "target_ratio": 0.7068177229923804,
    "combined_score": 0.7068177229923804,
    "eval_time": 51.345908880233765,
    "error": null
  },
  "prompt": "Create an ensemble optimizer that runs multiple methods and picks the best.\n\nRun these three approaches in parallel:\n1. Force-directed + scipy (like trial_1_6)\n2. Sequential greedy + optimization (like trial_1_11)\n3. Iterative expansion + refinement (like trial_1_13)\n\nFor each approach:\n- Run with optimized parameters\n- Try 3 different random seeds\n- Keep track of best result\n\nReturn the overall best packing found.\n\nRequirements:\n- Run multiple approaches\n- Compare results, return best\n- Ensure fast execution per method\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Ensemble optimizer that runs multiple methods and returns the best result.\n    \"\"\"\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    # Try multiple methods with different seeds\n    methods = [\n        force_directed_method,\n        sequential_greedy_method,\n        iterative_expansion_method\n    ]\n    \n    seeds = [42, 123, 456]\n    \n    for method in methods:\n        for seed in seeds:\n            try:\n                centers, radii, sum_radii = method(seed)\n                if sum_radii > best_sum and is_valid_packing(centers, radii):\n                    best_sum = sum_radii\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n            except:\n                continue\n    \n    # Fallback if all methods fail\n    if best_centers is None:\n        best_centers, best_radii, best_sum = fallback_packing()\n    \n    return best_centers, best_radii, best_sum\n\n\ndef is_valid_packing(centers, radii):\n    \"\"\"Check if packing satisfies all constraints.\"\"\"\n    n = len(centers)\n    \n    # Check bounds\n    if np.any(centers - radii[:, None] < 0) or np.any(centers + radii[:, None] > 1):\n        return False\n    \n    # Check overlaps\n    dists = cdist(centers, centers)\n    min_dists = radii[:, None] + radii[None, :]\n    np.fill_diagonal(dists, np.inf)\n    if np.any(dists < min_dists - 1e-6):\n        return False\n    \n    return True\n\n\ndef force_directed_method(seed):\n    \"\"\"Force-directed layout with scipy optimization.\"\"\"\n    np.random.seed(seed)\n    n = 26\n    \n    # Initialize with grid + noise\n    grid_size = int(np.ceil(np.sqrt(n)))\n    positions = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size + np.random.randn() * 0.05\n        y = (row + 0.5) / grid_size + np.random.randn() * 0.05\n        positions.append([np.clip(x, 0.1, 0.9), np.clip(y, 0.1, 0.9)])\n    \n    centers = np.array(positions)\n    \n    # Force-directed relaxation\n    for iteration in range(50):\n        forces = np.zeros_like(centers)\n        \n        # Repulsion between circles\n        for i in range(n):\n            for j in range(i+1, n):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                if dist > 0:\n                    force = diff / dist * (0.1 / (dist + 0.01))\n                    forces[i] += force\n                    forces[j] -= force\n        \n        # Attraction to center\n        center_point = np.array([0.5, 0.5])\n        for i in range(n):\n            diff = center_point - centers[i]\n            forces[i] += diff * 0.05\n        \n        # Update positions\n        centers += forces * 0.1\n        centers = np.clip(centers, 0.05, 0.95)\n    \n    # Compute radii\n    radii = compute_radii(centers)\n    \n    # Optimize with scipy\n    def objective(x):\n        c = x.reshape(n, 2)\n        r = compute_radii(c)\n        return -np.sum(r)\n    \n    def constraint_bounds(x):\n        c = x.reshape(n, 2)\n        r = compute_radii(c)\n        violations = []\n        violations.extend(c[:, 0] - r - 0.0)\n        violations.extend(c[:, 1] - r - 0.0)\n        violations.extend(1.0 - c[:, 0] - r)\n        violations.extend(1.0 - c[:, 1] - r)\n        return np.array(violations)\n    \n    x0 = centers.flatten()\n    result = minimize(\n        objective, x0,\n        method='SLSQP',\n        constraints={'type': 'ineq', 'fun': constraint_bounds},\n        options={'maxiter': 100, 'ftol': 1e-6}\n    )\n    \n    centers = result.x.reshape(n, 2)\n    radii = compute_radii(centers)\n    \n    return centers, radii, np.sum(radii)\n\n\ndef sequential_greedy_method(seed):\n    \"\"\"Sequential greedy placement with optimization.\"\"\"\n    np.random.seed(seed)\n    n = 26\n    \n    centers = []\n    radii = []\n    \n    # Place first circle at center\n    centers.append([0.5, 0.5])\n    radii.append(0.5)\n    \n    # Greedily place remaining circles\n    for i in range(1, n):\n        best_pos = None\n        best_r = 0\n        \n        # Try multiple candidate positions\n        candidates = []\n        if i < 10:\n            # Grid-based candidates\n            for x in np.linspace(0.1, 0.9, 8):\n                for y in np.linspace(0.1, 0.9, 8):\n                    candidates.append([x, y])\n        else:\n            # Random candidates\n            for _ in range(30):\n                candidates.append([np.random.uniform(0.1, 0.9), \n                                 np.random.uniform(0.1, 0.9)])\n        \n        for pos in candidates:\n            r = compute_max_radius(pos, np.array(centers), np.array(radii))\n            if r > best_r:\n                best_r = r\n                best_pos = pos\n        \n        if best_pos is not None and best_r > 0:\n            centers.append(best_pos)\n            radii.append(best_r)\n    \n    # Ensure we have n circles\n    while len(centers) < n:\n        centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n        radii.append(0.01)\n    \n    centers = np.array(centers[:n])\n    radii = np.array(radii[:n])\n    \n    # Optimize\n    radii = compute_radii(centers)\n    \n    return centers, radii, np.sum(radii)\n\n\ndef iterative_expansion_method(seed):\n    \"\"\"Iterative expansion with refinement.\"\"\"\n    np.random.seed(seed)\n    n = 26\n    \n    # Start with tight grid\n    grid_size = int(np.ceil(np.sqrt(n)))\n    spacing = 0.9 / grid_size\n    \n    centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = 0.05 + (col + 0.5) * spacing\n        y = 0.05 + (row + 0.5) * spacing\n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    \n    # Iteratively expand\n    for iteration in range(30):\n        radii = compute_radii(centers)\n        \n        # Move circles to maximize space\n        new_centers = centers.copy()\n        for i in range(n):\n            # Try small moves\n            best_pos = centers[i]\n            best_r = radii[i]\n            \n            for dx in [-0.02, 0, 0.02]:\n                for dy in [-0.02, 0, 0.02]:\n                    test_pos = centers[i] + np.array([dx, dy])\n                    if 0 < test_pos[0] < 1 and 0 < test_pos[1] < 1:\n                        test_centers = centers.copy()\n                        test_centers[i] = test_pos\n                        test_radii = compute_radii(test_centers)\n                        if test_radii[i] > best_r:\n                            best_r = test_radii[i]\n                            best_pos = test_pos\n            \n            new_centers[i] = best_pos\n        \n        centers = new_centers\n    \n    radii = compute_radii(centers)\n    \n    return centers, radii, np.sum(radii)\n\n\ndef compute_radii(centers):\n    \"\"\"Compute maximum valid radius for each circle.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Distance to boundaries\n        r_max = min(centers[i, 0], centers[i, 1], \n                   1 - centers[i, 0], 1 - centers[i, 1])\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                r_max = min(r_max, (dist - radii[j]) / 2 if radii[j] > 0 else dist)\n        \n        radii[i] = max(0, r_max)\n    \n    return radii\n\n\ndef compute_max_radius(pos, centers, radii):\n    \"\"\"Compute maximum radius for a circle at given position.\"\"\"\n    pos = np.array(pos)\n    \n    # Distance to boundaries\n    r_max = min(pos[0], pos[1], 1 - pos[0], 1 - pos[1])\n    \n    # Distance to existing circles\n    for i in range(len(centers)):\n        dist = np.linalg.norm(pos - centers[i])\n        r_max = min(r_max, dist - radii[i])\n    \n    return max(0, r_max)\n\n\ndef fallback_packing():\n    \"\"\"Simple fallback packing if all methods fail.\"\"\"\n    n = 26\n    grid_size = 6\n    spacing = 1.0 / grid_size\n    radius = spacing / 2.5\n    \n    centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) * spacing\n        y = (row + 0.5) * spacing\n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    radii = np.full(n, radius)\n    \n    return centers, radii, np.sum(radii)\n\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T18:00:55.145278",
  "cost_data": null
}