{
  "trial_id": "trial_2_10",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Start with a 5x6 grid (30 positions, we'll use 26)\n    rows, cols = 5, 6\n    x_coords = np.linspace(0.1, 0.9, cols)\n    y_coords = np.linspace(0.1, 0.9, rows)\n    \n    # Create initial grid positions\n    centers = []\n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) < n:\n                centers.append([x_coords[j], y_coords[i]])\n    centers = np.array(centers[:n])\n    \n    def compute_radii(centers):\n        \"\"\"Compute maximum valid radius for each circle.\"\"\"\n        radii = np.zeros(n)\n        for i in range(n):\n            # Distance to boundaries\n            min_dist = min(centers[i, 0], 1 - centers[i, 0], \n                          centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    if radii[j] > 0:\n                        min_dist = min(min_dist, dist - radii[j])\n                    else:\n                        min_dist = min(min_dist, dist / 2)\n            \n            radii[i] = max(0, min_dist)\n        return radii\n    \n    def compute_radii_iterative(centers, max_iter=10):\n        \"\"\"Iteratively compute radii until convergence.\"\"\"\n        radii = np.zeros(n)\n        for iteration in range(max_iter):\n            old_radii = radii.copy()\n            for i in range(n):\n                # Distance to boundaries\n                min_dist = min(centers[i, 0], 1 - centers[i, 0], \n                              centers[i, 1], 1 - centers[i, 1])\n                \n                # Distance to other circles\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        min_dist = min(min_dist, dist - radii[j])\n                \n                radii[i] = max(0, min_dist)\n            \n            if np.allclose(radii, old_radii, rtol=1e-6):\n                break\n        return radii\n    \n    # Adaptive refinement iterations\n    best_centers = centers.copy()\n    best_radii = compute_radii_iterative(best_centers)\n    best_sum = np.sum(best_radii)\n    \n    n_refinement_iterations = 50\n    n_worst_to_refine = 5\n    \n    for iteration in range(n_refinement_iterations):\n        radii = compute_radii_iterative(centers)\n        \n        # Identify circles with smallest radii\n        worst_indices = np.argsort(radii)[:n_worst_to_refine]\n        \n        # Try to improve each worst circle\n        improved = False\n        for idx in worst_indices:\n            # Local search around current position\n            current_pos = centers[idx].copy()\n            best_local_pos = current_pos.copy()\n            best_local_sum = np.sum(radii)\n            \n            # Try small perturbations\n            step_sizes = [0.02, 0.01, 0.005]\n            for step in step_sizes:\n                for dx in [-step, 0, step]:\n                    for dy in [-step, 0, step]:\n                        if dx == 0 and dy == 0:\n                            continue\n                        \n                        new_pos = current_pos + np.array([dx, dy])\n                        \n                        # Check if position is valid\n                        if (new_pos[0] < 0.05 or new_pos[0] > 0.95 or\n                            new_pos[1] < 0.05 or new_pos[1] > 0.95):\n                            continue\n                        \n                        # Temporarily update position\n                        centers[idx] = new_pos\n                        new_radii = compute_radii_iterative(centers)\n                        new_sum = np.sum(new_radii)\n                        \n                        if new_sum > best_local_sum:\n                            best_local_sum = new_sum\n                            best_local_pos = new_pos.copy()\n                            improved = True\n            \n            # Apply best local improvement\n            centers[idx] = best_local_pos\n        \n        # Recompute radii after all improvements\n        radii = compute_radii_iterative(centers)\n        current_sum = np.sum(radii)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n        \n        if not improved:\n            break\n    \n    # Final optimization with scipy\n    centers = best_centers.copy()\n    \n    def objective(x):\n        \"\"\"Objective: minimize negative sum of radii.\"\"\"\n        centers_temp = x.reshape(n, 2)\n        radii_temp = compute_radii_iterative(centers_temp)\n        return -np.sum(radii_temp)\n    \n    def constraint_boundaries(x):\n        \"\"\"Ensure all centers are well within boundaries.\"\"\"\n        centers_temp = x.reshape(n, 2)\n        radii_temp = compute_radii_iterative(centers_temp)\n        constraints = []\n        for i in range(n):\n            constraints.extend([\n                centers_temp[i, 0] - radii_temp[i],  # left\n                1 - centers_temp[i, 0] - radii_temp[i],  # right\n                centers_temp[i, 1] - radii_temp[i],  # bottom\n                1 - centers_temp[i, 1] - radii_temp[i]  # top\n            ])\n        return np.array(constraints)\n    \n    # Run optimization\n    x0 = centers.flatten()\n    bounds = [(0.05, 0.95) for _ in range(2 * n)]\n    \n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraint_boundaries},\n        options={'maxiter': 200, 'ftol': 1e-8}\n    )\n    \n    if result.success:\n        centers = result.x.reshape(n, 2)\n    \n    # Final radii computation\n    radii = compute_radii_iterative(centers, max_iter=20)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.321499603355333,
    "target_ratio": 0.8810245174024035,
    "combined_score": 0.8810245174024035,
    "eval_time": 48.81070899963379,
    "error": null
  },
  "prompt": "Create an adaptive grid refinement approach.\n\nStrategy:\n1. Start with coarse regular grid (5x6)\n2. Compute uniform radii for grid\n3. Iteratively refine:\n   - Identify circles with smallest radii\n   - Move them to better positions (local search)\n   - Recompute all radii\n   - Accept if total sum improves\n4. Continue until convergence\n5. Final scipy polish\n\nRequirements:\n- Adaptive refinement strategy\n- Focus on improving worst circles\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Start with a 5x6 grid (30 positions, we'll use 26)\n    rows, cols = 5, 6\n    x_coords = np.linspace(0.1, 0.9, cols)\n    y_coords = np.linspace(0.1, 0.9, rows)\n    \n    # Create initial grid positions\n    centers = []\n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) < n:\n                centers.append([x_coords[j], y_coords[i]])\n    centers = np.array(centers[:n])\n    \n    def compute_radii(centers):\n        \"\"\"Compute maximum valid radius for each circle.\"\"\"\n        radii = np.zeros(n)\n        for i in range(n):\n            # Distance to boundaries\n            min_dist = min(centers[i, 0], 1 - centers[i, 0], \n                          centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    if radii[j] > 0:\n                        min_dist = min(min_dist, dist - radii[j])\n                    else:\n                        min_dist = min(min_dist, dist / 2)\n            \n            radii[i] = max(0, min_dist)\n        return radii\n    \n    def compute_radii_iterative(centers, max_iter=10):\n        \"\"\"Iteratively compute radii until convergence.\"\"\"\n        radii = np.zeros(n)\n        for iteration in range(max_iter):\n            old_radii = radii.copy()\n            for i in range(n):\n                # Distance to boundaries\n                min_dist = min(centers[i, 0], 1 - centers[i, 0], \n                              centers[i, 1], 1 - centers[i, 1])\n                \n                # Distance to other circles\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        min_dist = min(min_dist, dist - radii[j])\n                \n                radii[i] = max(0, min_dist)\n            \n            if np.allclose(radii, old_radii, rtol=1e-6):\n                break\n        return radii\n    \n    # Adaptive refinement iterations\n    best_centers = centers.copy()\n    best_radii = compute_radii_iterative(best_centers)\n    best_sum = np.sum(best_radii)\n    \n    n_refinement_iterations = 50\n    n_worst_to_refine = 5\n    \n    for iteration in range(n_refinement_iterations):\n        radii = compute_radii_iterative(centers)\n        \n        # Identify circles with smallest radii\n        worst_indices = np.argsort(radii)[:n_worst_to_refine]\n        \n        # Try to improve each worst circle\n        improved = False\n        for idx in worst_indices:\n            # Local search around current position\n            current_pos = centers[idx].copy()\n            best_local_pos = current_pos.copy()\n            best_local_sum = np.sum(radii)\n            \n            # Try small perturbations\n            step_sizes = [0.02, 0.01, 0.005]\n            for step in step_sizes:\n                for dx in [-step, 0, step]:\n                    for dy in [-step, 0, step]:\n                        if dx == 0 and dy == 0:\n                            continue\n                        \n                        new_pos = current_pos + np.array([dx, dy])\n                        \n                        # Check if position is valid\n                        if (new_pos[0] < 0.05 or new_pos[0] > 0.95 or\n                            new_pos[1] < 0.05 or new_pos[1] > 0.95):\n                            continue\n                        \n                        # Temporarily update position\n                        centers[idx] = new_pos\n                        new_radii = compute_radii_iterative(centers)\n                        new_sum = np.sum(new_radii)\n                        \n                        if new_sum > best_local_sum:\n                            best_local_sum = new_sum\n                            best_local_pos = new_pos.copy()\n                            improved = True\n            \n            # Apply best local improvement\n            centers[idx] = best_local_pos\n        \n        # Recompute radii after all improvements\n        radii = compute_radii_iterative(centers)\n        current_sum = np.sum(radii)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n        \n        if not improved:\n            break\n    \n    # Final optimization with scipy\n    centers = best_centers.copy()\n    \n    def objective(x):\n        \"\"\"Objective: minimize negative sum of radii.\"\"\"\n        centers_temp = x.reshape(n, 2)\n        radii_temp = compute_radii_iterative(centers_temp)\n        return -np.sum(radii_temp)\n    \n    def constraint_boundaries(x):\n        \"\"\"Ensure all centers are well within boundaries.\"\"\"\n        centers_temp = x.reshape(n, 2)\n        radii_temp = compute_radii_iterative(centers_temp)\n        constraints = []\n        for i in range(n):\n            constraints.extend([\n                centers_temp[i, 0] - radii_temp[i],  # left\n                1 - centers_temp[i, 0] - radii_temp[i],  # right\n                centers_temp[i, 1] - radii_temp[i],  # bottom\n                1 - centers_temp[i, 1] - radii_temp[i]  # top\n            ])\n        return np.array(constraints)\n    \n    # Run optimization\n    x0 = centers.flatten()\n    bounds = [(0.05, 0.95) for _ in range(2 * n)]\n    \n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraint_boundaries},\n        options={'maxiter': 200, 'ftol': 1e-8}\n    )\n    \n    if result.success:\n        centers = result.x.reshape(n, 2)\n    \n    # Final radii computation\n    radii = compute_radii_iterative(centers, max_iter=20)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T18:00:42.170942",
  "cost_data": null
}