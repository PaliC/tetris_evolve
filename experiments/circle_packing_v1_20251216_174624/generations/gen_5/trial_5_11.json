{
  "trial_id": "trial_5_11",
  "generation": 5,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses multi-scale optimization with progressive constraint tightening.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_sum = -np.inf\n    best_centers = None\n    best_radii = None\n    \n    # Multi-scale parameters\n    scales = [\n        {'tol': 1e-5, 'maxiter': 5000, 'name': 'coarse'},\n        {'tol': 1e-7, 'maxiter': 8000, 'name': 'medium'},\n        {'tol': 1e-10, 'maxiter': 12000, 'name': 'fine'}\n    ]\n    \n    # Run 12 restarts with 3-scale refinement each\n    for restart in range(12):\n        # Initialize with different strategies\n        if restart == 0:\n            # Grid initialization\n            grid_size = int(np.ceil(np.sqrt(n)))\n            centers = np.array([[i/(grid_size+1), j/(grid_size+1)] \n                               for i in range(1, grid_size+1) \n                               for j in range(1, grid_size+1)])[:n]\n            radii = np.full(n, 0.08)\n        elif restart == 1:\n            # Hexagonal packing approximation\n            centers = []\n            rows = 5\n            for row in range(rows):\n                cols = 6 if row % 2 == 0 else 5\n                offset = 0.0 if row % 2 == 0 else 0.083\n                for col in range(cols):\n                    if len(centers) < n:\n                        centers.append([offset + col * 0.167, 0.15 + row * 0.17])\n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.075)\n        elif restart == 2:\n            # Random with clustering\n            centers = np.random.rand(n, 2) * 0.8 + 0.1\n            radii = np.full(n, 0.06)\n        elif restart == 3:\n            # Border emphasis\n            border_n = n // 3\n            centers = []\n            for i in range(border_n):\n                t = i / border_n\n                if i % 4 == 0:\n                    centers.append([t, 0.1])\n                elif i % 4 == 1:\n                    centers.append([0.9, t])\n                elif i % 4 == 2:\n                    centers.append([t, 0.9])\n                else:\n                    centers.append([0.1, t])\n            centers.extend(np.random.rand(n - border_n, 2) * 0.6 + 0.2)\n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.07)\n        else:\n            # Random variations\n            centers = np.random.rand(n, 2) * 0.85 + 0.075\n            radii = np.random.rand(n) * 0.05 + 0.05\n        \n        # Progressive multi-scale optimization\n        x = np.concatenate([centers.flatten(), radii])\n        \n        for scale_idx, scale in enumerate(scales):\n            tol = scale['tol']\n            maxiter = scale['maxiter']\n            \n            # Objective: maximize sum of radii = minimize negative sum\n            def objective(x):\n                r = x[2*n:]\n                return -np.sum(r)\n            \n            # Constraints with current tolerance\n            def constraint_functions(x):\n                c = x[:2*n].reshape(n, 2)\n                r = x[2*n:]\n                \n                constraints = []\n                \n                # Non-negativity of radii\n                constraints.extend(r - tol)\n                \n                # Circles inside square\n                constraints.extend(c[:, 0] - r - tol)  # left\n                constraints.extend(c[:, 1] - r - tol)  # bottom\n                constraints.extend(1 - tol - c[:, 0] - r)  # right\n                constraints.extend(1 - tol - c[:, 1] - r)  # top\n                \n                # Non-overlapping\n                dists = squareform(pdist(c))\n                for i in range(n):\n                    for j in range(i+1, n):\n                        constraints.append(dists[i, j] - r[i] - r[j] - tol)\n                \n                return np.array(constraints)\n            \n            # Setup constraints\n            constraints = {'type': 'ineq', 'fun': constraint_functions}\n            \n            # Bounds\n            bounds = [(tol, 1-tol)] * (2*n) + [(tol, 0.5)] * n\n            \n            # Optimize\n            options = {\n                'maxiter': maxiter,\n                'ftol': 1e-9 if scale_idx == 2 else 1e-6,\n                'disp': False\n            }\n            \n            result = minimize(\n                objective,\n                x,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options=options\n            )\n            \n            if result.success or scale_idx < 2:\n                x = result.x\n            else:\n                # If fine scale fails, use medium scale result\n                break\n        \n        # Extract final solution\n        centers_final = x[:2*n].reshape(n, 2)\n        radii_final = x[2*n:]\n        sum_radii = np.sum(radii_final)\n        \n        # Validate solution strictly\n        valid = True\n        \n        # Check radii non-negative\n        if np.any(radii_final < -1e-9):\n            valid = False\n        \n        # Check inside square\n        if np.any(centers_final - radii_final.reshape(-1, 1) < -1e-9):\n            valid = False\n        if np.any(centers_final + radii_final.reshape(-1, 1) > 1 + 1e-9):\n            valid = False\n        \n        # Check non-overlapping\n        dists = squareform(pdist(centers_final))\n        for i in range(n):\n            for j in range(i+1, n):\n                if dists[i, j] < radii_final[i] + radii_final[j] - 1e-9:\n                    valid = False\n                    break\n            if not valid:\n                break\n        \n        # Update best if valid and better\n        if valid and sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers_final.copy()\n            best_radii = radii_final.copy()\n    \n    # If no valid solution found, return a simple grid\n    if best_centers is None:\n        grid_size = int(np.ceil(np.sqrt(n)))\n        spacing = 1.0 / (grid_size + 1)\n        centers = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(centers) < n:\n                    centers.append([(i+1)*spacing, (j+1)*spacing])\n        best_centers = np.array(centers)\n        best_radii = np.full(n, spacing * 0.4)\n        best_sum = np.sum(best_radii)\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.6084747745626804,
    "target_ratio": 0.989933500782801,
    "combined_score": 0.989933500782801,
    "eval_time": 8.835200071334839,
    "error": null
  },
  "prompt": "Create multi-scale optimizer: coarse to fine scale.\n\nStrategy:\n1. Scale 1 (coarse): Optimize with loose constraints\n   - Allow small violations (1e-5)\n   - Fast convergence\n   - maxiter=5000\n2. Scale 2 (medium): Tighten constraints\n   - Allow tiny violations (1e-7)\n   - maxiter=8000\n3. Scale 3 (fine): Strict constraints\n   - No violations (1e-10)\n   - maxiter=12000\n4. Run this 3-scale process 12 times\n5. Return best\n\nRequirements:\n- 3-scale progressive refinement\n- 12 restarts\n- Efficient execution\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses multi-scale optimization with progressive constraint tightening.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_sum = -np.inf\n    best_centers = None\n    best_radii = None\n    \n    # Multi-scale parameters\n    scales = [\n        {'tol': 1e-5, 'maxiter': 5000, 'name': 'coarse'},\n        {'tol': 1e-7, 'maxiter': 8000, 'name': 'medium'},\n        {'tol': 1e-10, 'maxiter': 12000, 'name': 'fine'}\n    ]\n    \n    # Run 12 restarts with 3-scale refinement each\n    for restart in range(12):\n        # Initialize with different strategies\n        if restart == 0:\n            # Grid initialization\n            grid_size = int(np.ceil(np.sqrt(n)))\n            centers = np.array([[i/(grid_size+1), j/(grid_size+1)] \n                               for i in range(1, grid_size+1) \n                               for j in range(1, grid_size+1)])[:n]\n            radii = np.full(n, 0.08)\n        elif restart == 1:\n            # Hexagonal packing approximation\n            centers = []\n            rows = 5\n            for row in range(rows):\n                cols = 6 if row % 2 == 0 else 5\n                offset = 0.0 if row % 2 == 0 else 0.083\n                for col in range(cols):\n                    if len(centers) < n:\n                        centers.append([offset + col * 0.167, 0.15 + row * 0.17])\n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.075)\n        elif restart == 2:\n            # Random with clustering\n            centers = np.random.rand(n, 2) * 0.8 + 0.1\n            radii = np.full(n, 0.06)\n        elif restart == 3:\n            # Border emphasis\n            border_n = n // 3\n            centers = []\n            for i in range(border_n):\n                t = i / border_n\n                if i % 4 == 0:\n                    centers.append([t, 0.1])\n                elif i % 4 == 1:\n                    centers.append([0.9, t])\n                elif i % 4 == 2:\n                    centers.append([t, 0.9])\n                else:\n                    centers.append([0.1, t])\n            centers.extend(np.random.rand(n - border_n, 2) * 0.6 + 0.2)\n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.07)\n        else:\n            # Random variations\n            centers = np.random.rand(n, 2) * 0.85 + 0.075\n            radii = np.random.rand(n) * 0.05 + 0.05\n        \n        # Progressive multi-scale optimization\n        x = np.concatenate([centers.flatten(), radii])\n        \n        for scale_idx, scale in enumerate(scales):\n            tol = scale['tol']\n            maxiter = scale['maxiter']\n            \n            # Objective: maximize sum of radii = minimize negative sum\n            def objective(x):\n                r = x[2*n:]\n                return -np.sum(r)\n            \n            # Constraints with current tolerance\n            def constraint_functions(x):\n                c = x[:2*n].reshape(n, 2)\n                r = x[2*n:]\n                \n                constraints = []\n                \n                # Non-negativity of radii\n                constraints.extend(r - tol)\n                \n                # Circles inside square\n                constraints.extend(c[:, 0] - r - tol)  # left\n                constraints.extend(c[:, 1] - r - tol)  # bottom\n                constraints.extend(1 - tol - c[:, 0] - r)  # right\n                constraints.extend(1 - tol - c[:, 1] - r)  # top\n                \n                # Non-overlapping\n                dists = squareform(pdist(c))\n                for i in range(n):\n                    for j in range(i+1, n):\n                        constraints.append(dists[i, j] - r[i] - r[j] - tol)\n                \n                return np.array(constraints)\n            \n            # Setup constraints\n            constraints = {'type': 'ineq', 'fun': constraint_functions}\n            \n            # Bounds\n            bounds = [(tol, 1-tol)] * (2*n) + [(tol, 0.5)] * n\n            \n            # Optimize\n            options = {\n                'maxiter': maxiter,\n                'ftol': 1e-9 if scale_idx == 2 else 1e-6,\n                'disp': False\n            }\n            \n            result = minimize(\n                objective,\n                x,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options=options\n            )\n            \n            if result.success or scale_idx < 2:\n                x = result.x\n            else:\n                # If fine scale fails, use medium scale result\n                break\n        \n        # Extract final solution\n        centers_final = x[:2*n].reshape(n, 2)\n        radii_final = x[2*n:]\n        sum_radii = np.sum(radii_final)\n        \n        # Validate solution strictly\n        valid = True\n        \n        # Check radii non-negative\n        if np.any(radii_final < -1e-9):\n            valid = False\n        \n        # Check inside square\n        if np.any(centers_final - radii_final.reshape(-1, 1) < -1e-9):\n            valid = False\n        if np.any(centers_final + radii_final.reshape(-1, 1) > 1 + 1e-9):\n            valid = False\n        \n        # Check non-overlapping\n        dists = squareform(pdist(centers_final))\n        for i in range(n):\n            for j in range(i+1, n):\n                if dists[i, j] < radii_final[i] + radii_final[j] - 1e-9:\n                    valid = False\n                    break\n            if not valid:\n                break\n        \n        # Update best if valid and better\n        if valid and sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers_final.copy()\n            best_radii = radii_final.copy()\n    \n    # If no valid solution found, return a simple grid\n    if best_centers is None:\n        grid_size = int(np.ceil(np.sqrt(n)))\n        spacing = 1.0 / (grid_size + 1)\n        centers = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(centers) < n:\n                    centers.append([(i+1)*spacing, (j+1)*spacing])\n        best_centers = np.array(centers)\n        best_radii = np.full(n, spacing * 0.4)\n        best_sum = np.sum(best_radii)\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T19:06:15.115183",
  "cost_data": null
}