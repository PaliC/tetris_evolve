{
  "trial_id": "trial_5_9",
  "generation": 5,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def decode_params(x):\n        \"\"\"Decode flat parameter vector into centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def encode_params(centers, radii):\n        \"\"\"Encode centers and radii into flat parameter vector.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def compute_violations(centers, radii):\n        \"\"\"Compute constraint violations.\"\"\"\n        violations = []\n        \n        # Boundary constraints: center \u00b1 radius within [0,1]\n        for i in range(n):\n            violations.append(max(0, radii[i] - centers[i, 0]))  # left\n            violations.append(max(0, radii[i] - (1 - centers[i, 0])))  # right\n            violations.append(max(0, radii[i] - centers[i, 1]))  # bottom\n            violations.append(max(0, radii[i] - (1 - centers[i, 1])))  # top\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                violations.append(max(0, overlap))\n        \n        # Non-negative radii\n        for i in range(n):\n            violations.append(max(0, -radii[i]))\n        \n        return np.array(violations)\n    \n    def objective_with_penalty(x, penalty_coeff):\n        \"\"\"Objective function with penalty for constraint violations.\"\"\"\n        centers, radii = decode_params(x)\n        \n        # Maximize sum of radii = minimize negative sum\n        obj = -np.sum(radii)\n        \n        # Add penalty for violations\n        violations = compute_violations(centers, radii)\n        penalty = penalty_coeff * np.sum(violations**2)\n        \n        return obj + penalty\n    \n    def optimize_with_penalty_method(x0, max_penalty=1e6):\n        \"\"\"Optimize using penalty method with increasing penalty coefficient.\"\"\"\n        x = x0.copy()\n        penalty_coeff = 1.0\n        \n        while penalty_coeff <= max_penalty:\n            result = minimize(\n                lambda x: objective_with_penalty(x, penalty_coeff),\n                x,\n                method='L-BFGS-B',\n                options={'maxiter': 500, 'ftol': 1e-9}\n            )\n            x = result.x\n            penalty_coeff *= 10\n        \n        return x\n    \n    def generate_initial_guess(seed):\n        \"\"\"Generate initial guess with different strategies.\"\"\"\n        np.random.seed(seed)\n        \n        if seed == 0:\n            # Grid-based initialization\n            grid_size = int(np.ceil(np.sqrt(n)))\n            centers = []\n            for i in range(n):\n                row = i // grid_size\n                col = i % grid_size\n                x = (col + 0.5) / grid_size\n                y = (row + 0.5) / grid_size\n                centers.append([x, y])\n            centers = np.array(centers)\n            radii = np.full(n, 0.05)\n        elif seed == 1:\n            # Hexagonal packing approximation\n            centers = []\n            row = 0\n            col = 0\n            dx = 0.12\n            dy = 0.104\n            while len(centers) < n:\n                if row % 2 == 0:\n                    x = col * dx + 0.06\n                else:\n                    x = col * dx + 0.12\n                y = row * dy + 0.06\n                if x <= 0.94 and y <= 0.94:\n                    centers.append([x, y])\n                col += 1\n                if x > 0.94:\n                    col = 0\n                    row += 1\n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.05)\n        else:\n            # Random initialization with some structure\n            k = int(np.sqrt(n)) + 1\n            base_centers = []\n            for i in range(k):\n                for j in range(k):\n                    if len(base_centers) < n:\n                        x = (i + 0.5 + 0.1 * np.random.randn()) / k\n                        y = (j + 0.5 + 0.1 * np.random.randn()) / k\n                        base_centers.append([np.clip(x, 0.1, 0.9), np.clip(y, 0.1, 0.9)])\n            centers = np.array(base_centers[:n])\n            radii = np.full(n, 0.04) + 0.01 * np.random.rand(n)\n        \n        return encode_params(centers, radii)\n    \n    def constrained_refinement(x):\n        \"\"\"Final refinement with explicit constraints.\"\"\"\n        centers, radii = decode_params(x)\n        \n        # Set up bounds\n        bounds = []\n        for i in range(n):\n            bounds.append((0.0, 1.0))  # x\n            bounds.append((0.0, 1.0))  # y\n        for i in range(n):\n            bounds.append((0.0, 0.5))  # radius\n        \n        # Constraints\n        constraints = []\n        \n        # Boundary constraints\n        for i in range(n):\n            # x - r >= 0\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: decode_params(x)[0][i, 0] - decode_params(x)[1][i]\n            })\n            # x + r <= 1\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: 1 - decode_params(x)[0][i, 0] - decode_params(x)[1][i]\n            })\n            # y - r >= 0\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: decode_params(x)[0][i, 1] - decode_params(x)[1][i]\n            })\n            # y + r <= 1\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: 1 - decode_params(x)[0][i, 1] - decode_params(x)[1][i]\n            })\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                constraints.append({\n                    'type': 'ineq',\n                    'fun': lambda x, i=i, j=j: (\n                        np.linalg.norm(decode_params(x)[0][i] - decode_params(x)[0][j]) -\n                        decode_params(x)[1][i] - decode_params(x)[1][j]\n                    )\n                })\n        \n        result = minimize(\n            lambda x: -np.sum(decode_params(x)[1]),\n            x,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-9}\n        )\n        \n        return result.x\n    \n    # Run optimization with multiple restarts\n    best_solutions = []\n    \n    for restart in range(10):\n        x0 = generate_initial_guess(restart)\n        x_opt = optimize_with_penalty_method(x0)\n        \n        centers, radii = decode_params(x_opt)\n        sum_radii = np.sum(radii)\n        \n        best_solutions.append((sum_radii, x_opt))\n    \n    # Sort by sum of radii\n    best_solutions.sort(reverse=True, key=lambda x: x[0])\n    \n    # Refine top 3 solutions with constrained optimization\n    refined_solutions = []\n    for i in range(min(3, len(best_solutions))):\n        try:\n            x_refined = constrained_refinement(best_solutions[i][1])\n            centers, radii = decode_params(x_refined)\n            sum_radii = np.sum(radii)\n            refined_solutions.append((sum_radii, centers, radii))\n        except:\n            # If refinement fails, use original\n            centers, radii = decode_params(best_solutions[i][1])\n            sum_radii = np.sum(radii)\n            refined_solutions.append((sum_radii, centers, radii))\n    \n    # Return best solution\n    refined_solutions.sort(reverse=True, key=lambda x: x[0])\n    sum_radii, centers, radii = refined_solutions[0]\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 300.00816774368286,
    "error": "Timeout after 300s"
  },
  "prompt": "Create optimizer using penalty method for constraints.\n\nStrategy:\n1. Transform constrained problem to unconstrained using penalties\n2. Start with low penalty coefficient\n3. Iteratively:\n   - Optimize unconstrained problem\n   - Increase penalty coefficient\n   - Use previous result as starting point\n4. Run this 10 times with different initializations\n5. Apply final constrained optimization to top 3\n6. Return best\n\nRequirements:\n- Penalty method implementation\n- 10 restarts\n- Efficient execution\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def decode_params(x):\n        \"\"\"Decode flat parameter vector into centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def encode_params(centers, radii):\n        \"\"\"Encode centers and radii into flat parameter vector.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def compute_violations(centers, radii):\n        \"\"\"Compute constraint violations.\"\"\"\n        violations = []\n        \n        # Boundary constraints: center \u00b1 radius within [0,1]\n        for i in range(n):\n            violations.append(max(0, radii[i] - centers[i, 0]))  # left\n            violations.append(max(0, radii[i] - (1 - centers[i, 0])))  # right\n            violations.append(max(0, radii[i] - centers[i, 1]))  # bottom\n            violations.append(max(0, radii[i] - (1 - centers[i, 1])))  # top\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                violations.append(max(0, overlap))\n        \n        # Non-negative radii\n        for i in range(n):\n            violations.append(max(0, -radii[i]))\n        \n        return np.array(violations)\n    \n    def objective_with_penalty(x, penalty_coeff):\n        \"\"\"Objective function with penalty for constraint violations.\"\"\"\n        centers, radii = decode_params(x)\n        \n        # Maximize sum of radii = minimize negative sum\n        obj = -np.sum(radii)\n        \n        # Add penalty for violations\n        violations = compute_violations(centers, radii)\n        penalty = penalty_coeff * np.sum(violations**2)\n        \n        return obj + penalty\n    \n    def optimize_with_penalty_method(x0, max_penalty=1e6):\n        \"\"\"Optimize using penalty method with increasing penalty coefficient.\"\"\"\n        x = x0.copy()\n        penalty_coeff = 1.0\n        \n        while penalty_coeff <= max_penalty:\n            result = minimize(\n                lambda x: objective_with_penalty(x, penalty_coeff),\n                x,\n                method='L-BFGS-B',\n                options={'maxiter': 500, 'ftol': 1e-9}\n            )\n            x = result.x\n            penalty_coeff *= 10\n        \n        return x\n    \n    def generate_initial_guess(seed):\n        \"\"\"Generate initial guess with different strategies.\"\"\"\n        np.random.seed(seed)\n        \n        if seed == 0:\n            # Grid-based initialization\n            grid_size = int(np.ceil(np.sqrt(n)))\n            centers = []\n            for i in range(n):\n                row = i // grid_size\n                col = i % grid_size\n                x = (col + 0.5) / grid_size\n                y = (row + 0.5) / grid_size\n                centers.append([x, y])\n            centers = np.array(centers)\n            radii = np.full(n, 0.05)\n        elif seed == 1:\n            # Hexagonal packing approximation\n            centers = []\n            row = 0\n            col = 0\n            dx = 0.12\n            dy = 0.104\n            while len(centers) < n:\n                if row % 2 == 0:\n                    x = col * dx + 0.06\n                else:\n                    x = col * dx + 0.12\n                y = row * dy + 0.06\n                if x <= 0.94 and y <= 0.94:\n                    centers.append([x, y])\n                col += 1\n                if x > 0.94:\n                    col = 0\n                    row += 1\n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.05)\n        else:\n            # Random initialization with some structure\n            k = int(np.sqrt(n)) + 1\n            base_centers = []\n            for i in range(k):\n                for j in range(k):\n                    if len(base_centers) < n:\n                        x = (i + 0.5 + 0.1 * np.random.randn()) / k\n                        y = (j + 0.5 + 0.1 * np.random.randn()) / k\n                        base_centers.append([np.clip(x, 0.1, 0.9), np.clip(y, 0.1, 0.9)])\n            centers = np.array(base_centers[:n])\n            radii = np.full(n, 0.04) + 0.01 * np.random.rand(n)\n        \n        return encode_params(centers, radii)\n    \n    def constrained_refinement(x):\n        \"\"\"Final refinement with explicit constraints.\"\"\"\n        centers, radii = decode_params(x)\n        \n        # Set up bounds\n        bounds = []\n        for i in range(n):\n            bounds.append((0.0, 1.0))  # x\n            bounds.append((0.0, 1.0))  # y\n        for i in range(n):\n            bounds.append((0.0, 0.5))  # radius\n        \n        # Constraints\n        constraints = []\n        \n        # Boundary constraints\n        for i in range(n):\n            # x - r >= 0\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: decode_params(x)[0][i, 0] - decode_params(x)[1][i]\n            })\n            # x + r <= 1\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: 1 - decode_params(x)[0][i, 0] - decode_params(x)[1][i]\n            })\n            # y - r >= 0\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: decode_params(x)[0][i, 1] - decode_params(x)[1][i]\n            })\n            # y + r <= 1\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: 1 - decode_params(x)[0][i, 1] - decode_params(x)[1][i]\n            })\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                constraints.append({\n                    'type': 'ineq',\n                    'fun': lambda x, i=i, j=j: (\n                        np.linalg.norm(decode_params(x)[0][i] - decode_params(x)[0][j]) -\n                        decode_params(x)[1][i] - decode_params(x)[1][j]\n                    )\n                })\n        \n        result = minimize(\n            lambda x: -np.sum(decode_params(x)[1]),\n            x,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-9}\n        )\n        \n        return result.x\n    \n    # Run optimization with multiple restarts\n    best_solutions = []\n    \n    for restart in range(10):\n        x0 = generate_initial_guess(restart)\n        x_opt = optimize_with_penalty_method(x0)\n        \n        centers, radii = decode_params(x_opt)\n        sum_radii = np.sum(radii)\n        \n        best_solutions.append((sum_radii, x_opt))\n    \n    # Sort by sum of radii\n    best_solutions.sort(reverse=True, key=lambda x: x[0])\n    \n    # Refine top 3 solutions with constrained optimization\n    refined_solutions = []\n    for i in range(min(3, len(best_solutions))):\n        try:\n            x_refined = constrained_refinement(best_solutions[i][1])\n            centers, radii = decode_params(x_refined)\n            sum_radii = np.sum(radii)\n            refined_solutions.append((sum_radii, centers, radii))\n        except:\n            # If refinement fails, use original\n            centers, radii = decode_params(best_solutions[i][1])\n            sum_radii = np.sum(radii)\n            refined_solutions.append((sum_radii, centers, radii))\n    \n    # Return best solution\n    refined_solutions.sort(reverse=True, key=lambda x: x[0])\n    sum_radii, centers, radii = refined_solutions[0]\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T19:11:09.464961",
  "cost_data": null
}