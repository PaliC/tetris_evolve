{
  "trial_id": "trial_5_7",
  "generation": 5,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses adaptive restart optimization that learns from previous runs.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def hexagonal_init():\n        \"\"\"Generate hexagonal packing initialization.\"\"\"\n        centers = []\n        rows = 5\n        cols = 6\n        spacing = 0.18\n        \n        for i in range(rows):\n            for j in range(cols):\n                if len(centers) >= n:\n                    break\n                x = 0.15 + j * spacing\n                y = 0.15 + i * spacing * 0.866\n                if i % 2 == 1:\n                    x += spacing * 0.5\n                centers.append([x, y])\n            if len(centers) >= n:\n                break\n        \n        return np.array(centers[:n])\n    \n    def compute_radii(centers):\n        \"\"\"Compute maximum radii for given centers.\"\"\"\n        radii = np.ones(n) * 0.5\n        \n        for i in range(n):\n            # Distance to boundaries\n            min_r = min(centers[i, 0], 1 - centers[i, 0], \n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    min_r = min(min_r, dist / 2)\n            \n            radii[i] = max(0, min_r)\n        \n        return radii\n    \n    def objective(x):\n        \"\"\"Objective: minimize negative sum of radii.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        return -np.sum(radii)\n    \n    def constraint_boundary(x):\n        \"\"\"Ensure circles stay within unit square.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        \n        violations = []\n        for i in range(n):\n            violations.append(centers[i, 0] - radii[i])\n            violations.append(1 - centers[i, 0] - radii[i])\n            violations.append(centers[i, 1] - radii[i])\n            violations.append(1 - centers[i, 1] - radii[i])\n        \n        return np.array(violations)\n    \n    def constraint_overlap(x):\n        \"\"\"Ensure no circles overlap.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        \n        violations = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                violations.append(dist - radii[i] - radii[j])\n        \n        return np.array(violations)\n    \n    constraints = [\n        {'type': 'ineq', 'fun': constraint_boundary},\n        {'type': 'ineq', 'fun': constraint_overlap}\n    ]\n    \n    bounds = [(0.05, 0.95)] * (2 * n)\n    \n    # Track all runs\n    all_results = []\n    best_result = None\n    best_sum = -np.inf\n    \n    # Run 1: Standard hexagonal initialization\n    centers_init = hexagonal_init()\n    x0 = centers_init.flatten()\n    \n    result = minimize(objective, x0, method='SLSQP', bounds=bounds,\n                     constraints=constraints, options={'maxiter': 500, 'ftol': 1e-8})\n    \n    centers = result.x.reshape(n, 2)\n    radii = compute_radii(centers)\n    sum_radii = np.sum(radii)\n    \n    all_results.append({\n        'centers': centers.copy(),\n        'radii': radii.copy(),\n        'sum': sum_radii\n    })\n    \n    if sum_radii > best_sum:\n        best_sum = sum_radii\n        best_result = all_results[-1]\n    \n    # Runs 2-15: Adaptive restarts\n    for run in range(1, 15):\n        # Sort results by quality\n        sorted_results = sorted(all_results, key=lambda x: x['sum'], reverse=True)\n        \n        # Choose initialization strategy based on run number\n        if run <= 3:\n            # Use best result with small perturbation\n            base_centers = sorted_results[0]['centers'].copy()\n            perturbation = np.random.normal(0, 0.02, (n, 2))\n        elif run <= 7:\n            # Blend top 2 results\n            alpha = np.random.uniform(0.3, 0.7)\n            base_centers = (alpha * sorted_results[0]['centers'] + \n                          (1 - alpha) * sorted_results[1]['centers'])\n            perturbation = np.random.normal(0, 0.03, (n, 2))\n        elif run <= 11:\n            # Use best result with larger perturbation\n            base_centers = sorted_results[0]['centers'].copy()\n            perturbation = np.random.normal(0, 0.04, (n, 2))\n        else:\n            # Try random shuffling of best result\n            base_centers = sorted_results[0]['centers'].copy()\n            indices = np.random.permutation(n)\n            base_centers = base_centers[indices]\n            perturbation = np.random.normal(0, 0.025, (n, 2))\n        \n        # Apply perturbation and clip to bounds\n        centers_init = np.clip(base_centers + perturbation, 0.05, 0.95)\n        x0 = centers_init.flatten()\n        \n        # Optimize\n        result = minimize(objective, x0, method='SLSQP', bounds=bounds,\n                         constraints=constraints, \n                         options={'maxiter': 400, 'ftol': 1e-8})\n        \n        centers = result.x.reshape(n, 2)\n        radii = compute_radii(centers)\n        sum_radii = np.sum(radii)\n        \n        all_results.append({\n            'centers': centers.copy(),\n            'radii': radii.copy(),\n            'sum': sum_radii\n        })\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_result = all_results[-1]\n    \n    # Final polish: take top 3 and apply intensive optimization\n    sorted_results = sorted(all_results, key=lambda x: x['sum'], reverse=True)\n    \n    for i in range(min(3, len(sorted_results))):\n        x0 = sorted_results[i]['centers'].flatten()\n        \n        # More intensive final optimization\n        result = minimize(objective, x0, method='SLSQP', bounds=bounds,\n                         constraints=constraints, \n                         options={'maxiter': 1000, 'ftol': 1e-10})\n        \n        centers = result.x.reshape(n, 2)\n        radii = compute_radii(centers)\n        sum_radii = np.sum(radii)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_result = {\n                'centers': centers.copy(),\n                'radii': radii.copy(),\n                'sum': sum_radii\n            }\n    \n    return best_result['centers'], best_result['radii'], best_result['sum']\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 300.0082001686096,
    "error": "Timeout after 300s"
  },
  "prompt": "Create adaptive restart optimizer that learns from previous runs.\n\nStrategy:\n1. Run 1: Standard hexagonal initialization, optimize\n2. For runs 2-15:\n   - Analyze what made previous best runs successful\n   - Generate new initialization near best previous results\n   - Add small random perturbations\n   - Optimize\n3. Track best result continuously\n4. After 15 runs, take top 3 and apply final polish\n5. Return best\n\nRequirements:\n- 15 adaptive restarts\n- Learn from previous runs\n- Efficient execution\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses adaptive restart optimization that learns from previous runs.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def hexagonal_init():\n        \"\"\"Generate hexagonal packing initialization.\"\"\"\n        centers = []\n        rows = 5\n        cols = 6\n        spacing = 0.18\n        \n        for i in range(rows):\n            for j in range(cols):\n                if len(centers) >= n:\n                    break\n                x = 0.15 + j * spacing\n                y = 0.15 + i * spacing * 0.866\n                if i % 2 == 1:\n                    x += spacing * 0.5\n                centers.append([x, y])\n            if len(centers) >= n:\n                break\n        \n        return np.array(centers[:n])\n    \n    def compute_radii(centers):\n        \"\"\"Compute maximum radii for given centers.\"\"\"\n        radii = np.ones(n) * 0.5\n        \n        for i in range(n):\n            # Distance to boundaries\n            min_r = min(centers[i, 0], 1 - centers[i, 0], \n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    min_r = min(min_r, dist / 2)\n            \n            radii[i] = max(0, min_r)\n        \n        return radii\n    \n    def objective(x):\n        \"\"\"Objective: minimize negative sum of radii.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        return -np.sum(radii)\n    \n    def constraint_boundary(x):\n        \"\"\"Ensure circles stay within unit square.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        \n        violations = []\n        for i in range(n):\n            violations.append(centers[i, 0] - radii[i])\n            violations.append(1 - centers[i, 0] - radii[i])\n            violations.append(centers[i, 1] - radii[i])\n            violations.append(1 - centers[i, 1] - radii[i])\n        \n        return np.array(violations)\n    \n    def constraint_overlap(x):\n        \"\"\"Ensure no circles overlap.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        \n        violations = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                violations.append(dist - radii[i] - radii[j])\n        \n        return np.array(violations)\n    \n    constraints = [\n        {'type': 'ineq', 'fun': constraint_boundary},\n        {'type': 'ineq', 'fun': constraint_overlap}\n    ]\n    \n    bounds = [(0.05, 0.95)] * (2 * n)\n    \n    # Track all runs\n    all_results = []\n    best_result = None\n    best_sum = -np.inf\n    \n    # Run 1: Standard hexagonal initialization\n    centers_init = hexagonal_init()\n    x0 = centers_init.flatten()\n    \n    result = minimize(objective, x0, method='SLSQP', bounds=bounds,\n                     constraints=constraints, options={'maxiter': 500, 'ftol': 1e-8})\n    \n    centers = result.x.reshape(n, 2)\n    radii = compute_radii(centers)\n    sum_radii = np.sum(radii)\n    \n    all_results.append({\n        'centers': centers.copy(),\n        'radii': radii.copy(),\n        'sum': sum_radii\n    })\n    \n    if sum_radii > best_sum:\n        best_sum = sum_radii\n        best_result = all_results[-1]\n    \n    # Runs 2-15: Adaptive restarts\n    for run in range(1, 15):\n        # Sort results by quality\n        sorted_results = sorted(all_results, key=lambda x: x['sum'], reverse=True)\n        \n        # Choose initialization strategy based on run number\n        if run <= 3:\n            # Use best result with small perturbation\n            base_centers = sorted_results[0]['centers'].copy()\n            perturbation = np.random.normal(0, 0.02, (n, 2))\n        elif run <= 7:\n            # Blend top 2 results\n            alpha = np.random.uniform(0.3, 0.7)\n            base_centers = (alpha * sorted_results[0]['centers'] + \n                          (1 - alpha) * sorted_results[1]['centers'])\n            perturbation = np.random.normal(0, 0.03, (n, 2))\n        elif run <= 11:\n            # Use best result with larger perturbation\n            base_centers = sorted_results[0]['centers'].copy()\n            perturbation = np.random.normal(0, 0.04, (n, 2))\n        else:\n            # Try random shuffling of best result\n            base_centers = sorted_results[0]['centers'].copy()\n            indices = np.random.permutation(n)\n            base_centers = base_centers[indices]\n            perturbation = np.random.normal(0, 0.025, (n, 2))\n        \n        # Apply perturbation and clip to bounds\n        centers_init = np.clip(base_centers + perturbation, 0.05, 0.95)\n        x0 = centers_init.flatten()\n        \n        # Optimize\n        result = minimize(objective, x0, method='SLSQP', bounds=bounds,\n                         constraints=constraints, \n                         options={'maxiter': 400, 'ftol': 1e-8})\n        \n        centers = result.x.reshape(n, 2)\n        radii = compute_radii(centers)\n        sum_radii = np.sum(radii)\n        \n        all_results.append({\n            'centers': centers.copy(),\n            'radii': radii.copy(),\n            'sum': sum_radii\n        })\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_result = all_results[-1]\n    \n    # Final polish: take top 3 and apply intensive optimization\n    sorted_results = sorted(all_results, key=lambda x: x['sum'], reverse=True)\n    \n    for i in range(min(3, len(sorted_results))):\n        x0 = sorted_results[i]['centers'].flatten()\n        \n        # More intensive final optimization\n        result = minimize(objective, x0, method='SLSQP', bounds=bounds,\n                         constraints=constraints, \n                         options={'maxiter': 1000, 'ftol': 1e-10})\n        \n        centers = result.x.reshape(n, 2)\n        radii = compute_radii(centers)\n        sum_radii = np.sum(radii)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_result = {\n                'centers': centers.copy(),\n                'radii': radii.copy(),\n                'sum': sum_radii\n            }\n    \n    return best_result['centers'], best_result['radii'], best_result['sum']\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T19:11:04.442502",
  "cost_data": null
}