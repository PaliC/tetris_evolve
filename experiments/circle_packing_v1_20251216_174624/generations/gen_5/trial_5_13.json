{
  "trial_id": "trial_5_13",
  "generation": 5,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses gradient-based optimization with momentum and adaptive learning rate.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Try multiple random initializations\n    for seed in range(10):\n        np.random.seed(seed)\n        centers, radii, sum_radii = optimize_with_momentum(n)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef optimize_with_momentum(n, max_iters=50000):\n    \"\"\"Gradient-based optimization with momentum and adaptive learning rate.\"\"\"\n    \n    # Initialize positions in a grid with small random perturbations\n    grid_size = int(np.ceil(np.sqrt(n)))\n    centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size + np.random.randn() * 0.05\n        y = (row + 0.5) / grid_size + np.random.randn() * 0.05\n        centers.append([x, y])\n    centers = np.array(centers)\n    \n    # Initialize radii - start small\n    radii = np.ones(n) * 0.05\n    \n    # Momentum parameters\n    beta = 0.9\n    velocity_centers = np.zeros_like(centers)\n    velocity_radii = np.zeros_like(radii)\n    \n    # Adaptive learning rate\n    lr = 0.01\n    lr_min = 1e-5\n    lr_max = 0.02\n    prev_obj = -np.inf\n    oscillation_count = 0\n    progress_count = 0\n    \n    for iteration in range(max_iters):\n        # Compute maximum feasible radii given current centers\n        max_radii = compute_max_radii(centers)\n        radii = np.minimum(radii, max_radii)\n        \n        # Compute gradients\n        grad_centers, grad_radii = compute_gradients(centers, radii)\n        \n        # Update velocities with momentum\n        velocity_centers = beta * velocity_centers + (1 - beta) * grad_centers\n        velocity_radii = beta * velocity_radii + (1 - beta) * grad_radii\n        \n        # Update positions\n        centers += lr * velocity_centers\n        radii += lr * velocity_radii\n        \n        # Project onto feasible region\n        centers, radii = project_feasible(centers, radii)\n        \n        # Adaptive learning rate\n        current_obj = np.sum(radii)\n        if iteration % 100 == 0:\n            if current_obj < prev_obj:\n                oscillation_count += 1\n                progress_count = 0\n                lr *= 0.95  # Decrease learning rate\n            else:\n                progress_count += 1\n                oscillation_count = 0\n                if progress_count > 3:\n                    lr = min(lr * 1.05, lr_max)  # Increase learning rate\n            \n            lr = max(lr, lr_min)\n            prev_obj = current_obj\n        \n        # Early stopping if converged\n        if iteration > 1000 and iteration % 1000 == 0:\n            if np.linalg.norm(velocity_centers) < 1e-6 and np.linalg.norm(velocity_radii) < 1e-6:\n                break\n    \n    # Final projection\n    centers, radii = project_feasible(centers, radii)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef compute_max_radii(centers):\n    \"\"\"Compute maximum feasible radius for each circle given centers.\"\"\"\n    n = len(centers)\n    max_radii = np.ones(n)\n    \n    # Distance to boundaries\n    for i in range(n):\n        max_radii[i] = min(\n            centers[i, 0],  # left\n            1 - centers[i, 0],  # right\n            centers[i, 1],  # bottom\n            1 - centers[i, 1]  # top\n        )\n    \n    # Distance to other circles\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            max_radii[i] = min(max_radii[i], dist / 2)\n            max_radii[j] = min(max_radii[j], dist / 2)\n    \n    return np.maximum(max_radii, 0)\n\ndef compute_gradients(centers, radii):\n    \"\"\"Compute gradients of sum of radii w.r.t. centers and radii.\"\"\"\n    n = len(centers)\n    grad_centers = np.zeros_like(centers)\n    grad_radii = np.ones_like(radii)  # Gradient w.r.t. radii is always 1\n    \n    # Gradient from non-overlap constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            diff = centers[i] - centers[j]\n            dist = np.linalg.norm(diff)\n            \n            if dist < radii[i] + radii[j] + 0.01:  # Near violation\n                # Push circles apart\n                if dist > 1e-8:\n                    direction = diff / dist\n                    force = 1.0 / (dist + 1e-6)\n                    grad_centers[i] += force * direction\n                    grad_centers[j] -= force * direction\n    \n    # Gradient from boundary constraints\n    for i in range(n):\n        # Left boundary\n        if centers[i, 0] - radii[i] < 0.01:\n            grad_centers[i, 0] += 1.0\n        # Right boundary\n        if centers[i, 0] + radii[i] > 0.99:\n            grad_centers[i, 0] -= 1.0\n        # Bottom boundary\n        if centers[i, 1] - radii[i] < 0.01:\n            grad_centers[i, 1] += 1.0\n        # Top boundary\n        if centers[i, 1] + radii[i] > 0.99:\n            grad_centers[i, 1] -= 1.0\n    \n    return grad_centers, grad_radii\n\ndef project_feasible(centers, radii):\n    \"\"\"Project centers and radii onto feasible region.\"\"\"\n    n = len(centers)\n    \n    # Clip radii to non-negative\n    radii = np.maximum(radii, 0)\n    \n    # Ensure circles stay within boundaries\n    for i in range(n):\n        # Adjust center if too close to boundary\n        centers[i, 0] = np.clip(centers[i, 0], radii[i], 1 - radii[i])\n        centers[i, 1] = np.clip(centers[i, 1], radii[i], 1 - radii[i])\n        \n        # Recompute max radius after center adjustment\n        max_r = min(\n            centers[i, 0],\n            1 - centers[i, 0],\n            centers[i, 1],\n            1 - centers[i, 1]\n        )\n        radii[i] = min(radii[i], max_r)\n    \n    # Handle overlaps by shrinking radii\n    max_iterations = 10\n    for _ in range(max_iterations):\n        overlaps = False\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j]:\n                    overlaps = True\n                    # Shrink both radii proportionally\n                    shrink_factor = 0.95 * dist / (radii[i] + radii[j])\n                    radii[i] *= shrink_factor\n                    radii[j] *= shrink_factor\n        \n        if not overlaps:\n            break\n    \n    return centers, radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 300.0094542503357,
    "error": "Timeout after 300s"
  },
  "prompt": "Create gradient-based optimizer with momentum and adaptive learning rate.\n\nStrategy:\n1. Compute gradients of objective w.r.t. all variables\n2. Use momentum-based gradient ascent:\n   - velocity = beta * velocity + (1-beta) * gradient\n   - position += learning_rate * velocity\n3. Adaptive learning rate:\n   - Start high (0.01)\n   - Decrease when oscillating\n   - Increase when making progress\n4. Project onto feasible region after each step\n5. Run for 50000 iterations with 10 different seeds\n6. Return best\n\nRequirements:\n- Momentum-based gradients\n- Adaptive learning rate\n- 10 restarts\n- Efficient execution\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses gradient-based optimization with momentum and adaptive learning rate.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Try multiple random initializations\n    for seed in range(10):\n        np.random.seed(seed)\n        centers, radii, sum_radii = optimize_with_momentum(n)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef optimize_with_momentum(n, max_iters=50000):\n    \"\"\"Gradient-based optimization with momentum and adaptive learning rate.\"\"\"\n    \n    # Initialize positions in a grid with small random perturbations\n    grid_size = int(np.ceil(np.sqrt(n)))\n    centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size + np.random.randn() * 0.05\n        y = (row + 0.5) / grid_size + np.random.randn() * 0.05\n        centers.append([x, y])\n    centers = np.array(centers)\n    \n    # Initialize radii - start small\n    radii = np.ones(n) * 0.05\n    \n    # Momentum parameters\n    beta = 0.9\n    velocity_centers = np.zeros_like(centers)\n    velocity_radii = np.zeros_like(radii)\n    \n    # Adaptive learning rate\n    lr = 0.01\n    lr_min = 1e-5\n    lr_max = 0.02\n    prev_obj = -np.inf\n    oscillation_count = 0\n    progress_count = 0\n    \n    for iteration in range(max_iters):\n        # Compute maximum feasible radii given current centers\n        max_radii = compute_max_radii(centers)\n        radii = np.minimum(radii, max_radii)\n        \n        # Compute gradients\n        grad_centers, grad_radii = compute_gradients(centers, radii)\n        \n        # Update velocities with momentum\n        velocity_centers = beta * velocity_centers + (1 - beta) * grad_centers\n        velocity_radii = beta * velocity_radii + (1 - beta) * grad_radii\n        \n        # Update positions\n        centers += lr * velocity_centers\n        radii += lr * velocity_radii\n        \n        # Project onto feasible region\n        centers, radii = project_feasible(centers, radii)\n        \n        # Adaptive learning rate\n        current_obj = np.sum(radii)\n        if iteration % 100 == 0:\n            if current_obj < prev_obj:\n                oscillation_count += 1\n                progress_count = 0\n                lr *= 0.95  # Decrease learning rate\n            else:\n                progress_count += 1\n                oscillation_count = 0\n                if progress_count > 3:\n                    lr = min(lr * 1.05, lr_max)  # Increase learning rate\n            \n            lr = max(lr, lr_min)\n            prev_obj = current_obj\n        \n        # Early stopping if converged\n        if iteration > 1000 and iteration % 1000 == 0:\n            if np.linalg.norm(velocity_centers) < 1e-6 and np.linalg.norm(velocity_radii) < 1e-6:\n                break\n    \n    # Final projection\n    centers, radii = project_feasible(centers, radii)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef compute_max_radii(centers):\n    \"\"\"Compute maximum feasible radius for each circle given centers.\"\"\"\n    n = len(centers)\n    max_radii = np.ones(n)\n    \n    # Distance to boundaries\n    for i in range(n):\n        max_radii[i] = min(\n            centers[i, 0],  # left\n            1 - centers[i, 0],  # right\n            centers[i, 1],  # bottom\n            1 - centers[i, 1]  # top\n        )\n    \n    # Distance to other circles\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            max_radii[i] = min(max_radii[i], dist / 2)\n            max_radii[j] = min(max_radii[j], dist / 2)\n    \n    return np.maximum(max_radii, 0)\n\ndef compute_gradients(centers, radii):\n    \"\"\"Compute gradients of sum of radii w.r.t. centers and radii.\"\"\"\n    n = len(centers)\n    grad_centers = np.zeros_like(centers)\n    grad_radii = np.ones_like(radii)  # Gradient w.r.t. radii is always 1\n    \n    # Gradient from non-overlap constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            diff = centers[i] - centers[j]\n            dist = np.linalg.norm(diff)\n            \n            if dist < radii[i] + radii[j] + 0.01:  # Near violation\n                # Push circles apart\n                if dist > 1e-8:\n                    direction = diff / dist\n                    force = 1.0 / (dist + 1e-6)\n                    grad_centers[i] += force * direction\n                    grad_centers[j] -= force * direction\n    \n    # Gradient from boundary constraints\n    for i in range(n):\n        # Left boundary\n        if centers[i, 0] - radii[i] < 0.01:\n            grad_centers[i, 0] += 1.0\n        # Right boundary\n        if centers[i, 0] + radii[i] > 0.99:\n            grad_centers[i, 0] -= 1.0\n        # Bottom boundary\n        if centers[i, 1] - radii[i] < 0.01:\n            grad_centers[i, 1] += 1.0\n        # Top boundary\n        if centers[i, 1] + radii[i] > 0.99:\n            grad_centers[i, 1] -= 1.0\n    \n    return grad_centers, grad_radii\n\ndef project_feasible(centers, radii):\n    \"\"\"Project centers and radii onto feasible region.\"\"\"\n    n = len(centers)\n    \n    # Clip radii to non-negative\n    radii = np.maximum(radii, 0)\n    \n    # Ensure circles stay within boundaries\n    for i in range(n):\n        # Adjust center if too close to boundary\n        centers[i, 0] = np.clip(centers[i, 0], radii[i], 1 - radii[i])\n        centers[i, 1] = np.clip(centers[i, 1], radii[i], 1 - radii[i])\n        \n        # Recompute max radius after center adjustment\n        max_r = min(\n            centers[i, 0],\n            1 - centers[i, 0],\n            centers[i, 1],\n            1 - centers[i, 1]\n        )\n        radii[i] = min(radii[i], max_r)\n    \n    # Handle overlaps by shrinking radii\n    max_iterations = 10\n    for _ in range(max_iterations):\n        overlaps = False\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j]:\n                    overlaps = True\n                    # Shrink both radii proportionally\n                    shrink_factor = 0.95 * dist / (radii[i] + radii[j])\n                    radii[i] *= shrink_factor\n                    radii[j] *= shrink_factor\n        \n        if not overlaps:\n            break\n    \n    return centers, radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T19:11:07.010821",
  "cost_data": null
}