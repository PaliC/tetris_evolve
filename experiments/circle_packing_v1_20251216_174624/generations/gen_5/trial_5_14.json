{
  "trial_id": "trial_5_14",
  "generation": 5,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses simulated annealing followed by scipy optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def params_to_circles(params):\n        \"\"\"Convert flat parameter array to centers and radii.\"\"\"\n        centers = params[:2*n].reshape(n, 2)\n        radii = params[2*n:]\n        return centers, radii\n    \n    def circles_to_params(centers, radii):\n        \"\"\"Convert centers and radii to flat parameter array.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def objective(params):\n        \"\"\"Negative sum of radii (we minimize).\"\"\"\n        _, radii = params_to_circles(params)\n        return -np.sum(radii)\n    \n    def is_valid(params):\n        \"\"\"Check if configuration satisfies all constraints.\"\"\"\n        centers, radii = params_to_circles(params)\n        \n        # Check if all radii are non-negative\n        if np.any(radii < 0):\n            return False\n        \n        # Check if circles are inside unit square\n        if np.any(centers - radii.reshape(-1, 1) < 0) or np.any(centers + radii.reshape(-1, 1) > 1):\n            return False\n        \n        # Check for overlaps\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-10:\n                    return False\n        \n        return True\n    \n    def constraint_violation(params):\n        \"\"\"Calculate total constraint violation (for penalty).\"\"\"\n        centers, radii = params_to_circles(params)\n        violation = 0.0\n        \n        # Penalty for negative radii\n        violation += np.sum(np.maximum(0, -radii)) * 100\n        \n        # Penalty for circles outside square\n        violation += np.sum(np.maximum(0, -(centers - radii.reshape(-1, 1)))) * 100\n        violation += np.sum(np.maximum(0, centers + radii.reshape(-1, 1) - 1)) * 100\n        \n        # Penalty for overlaps\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    violation += overlap * 100\n        \n        return violation\n    \n    def simulated_annealing(seed, n_iter=10000):\n        \"\"\"Run simulated annealing.\"\"\"\n        np.random.seed(seed)\n        \n        # Initialize with grid layout\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            centers.append([x, y])\n        centers = np.array(centers)\n        \n        # Initial radii - conservative\n        radii = np.full(n, 0.04)\n        params = circles_to_params(centers, radii)\n        \n        # Make sure initial solution is valid\n        while not is_valid(params):\n            radii *= 0.9\n            params = circles_to_params(centers, radii)\n        \n        current_energy = objective(params)\n        best_params = params.copy()\n        best_energy = current_energy\n        \n        T = 1.0\n        \n        for iteration in range(n_iter):\n            # Generate neighbor\n            new_params = params.copy()\n            \n            # Choose what to perturb\n            choice = np.random.rand()\n            if choice < 0.5:\n                # Perturb a random center\n                idx = np.random.randint(n)\n                new_params[2*idx:2*idx+2] += np.random.randn(2) * 0.02 * T\n            else:\n                # Perturb a random radius\n                idx = np.random.randint(n)\n                new_params[2*n + idx] += np.random.randn() * 0.01 * T\n            \n            # Calculate energy with penalty for constraint violations\n            if is_valid(new_params):\n                new_energy = objective(new_params)\n            else:\n                new_energy = objective(new_params) + constraint_violation(new_params)\n            \n            # Accept or reject\n            delta_e = new_energy - current_energy\n            if delta_e < 0 or np.random.rand() < np.exp(-delta_e / T):\n                params = new_params\n                current_energy = new_energy\n                \n                # Update best if valid and better\n                if is_valid(params):\n                    actual_energy = objective(params)\n                    if actual_energy < best_energy:\n                        best_params = params.copy()\n                        best_energy = actual_energy\n            \n            # Cool down\n            T *= 0.99\n        \n        return best_params, best_energy\n    \n    # Run simulated annealing multiple times\n    sa_results = []\n    for seed in range(10):\n        params, energy = simulated_annealing(seed)\n        if is_valid(params):\n            sa_results.append((params, energy))\n    \n    # Sort by energy and take top 5\n    sa_results.sort(key=lambda x: x[1])\n    top_results = sa_results[:min(5, len(sa_results))]\n    \n    # Scipy optimization constraints\n    def constraint_circles_in_square(params):\n        centers, radii = params_to_circles(params)\n        constraints = []\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # x - r >= 0\n            constraints.append(centers[i, 1] - radii[i])  # y - r >= 0\n            constraints.append(1 - centers[i, 0] - radii[i])  # 1 - x - r >= 0\n            constraints.append(1 - centers[i, 1] - radii[i])  # 1 - y - r >= 0\n        return np.array(constraints)\n    \n    def constraint_no_overlap(params):\n        centers, radii = params_to_circles(params)\n        constraints = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - radii[i] - radii[j])  # dist - r_i - r_j >= 0\n        return np.array(constraints)\n    \n    def constraint_radii_positive(params):\n        _, radii = params_to_circles(params)\n        return radii\n    \n    constraints = [\n        {'type': 'ineq', 'fun': constraint_circles_in_square},\n        {'type': 'ineq', 'fun': constraint_no_overlap},\n        {'type': 'ineq', 'fun': constraint_radii_positive}\n    ]\n    \n    # Refine top results with scipy\n    best_solution = None\n    best_sum = -np.inf\n    \n    for params, _ in top_results:\n        result = minimize(\n            objective,\n            params,\n            method='trust-constr',\n            constraints=constraints,\n            options={'maxiter': 15000, 'gtol': 1e-11, 'verbose': 0}\n        )\n        \n        if result.success or is_valid(result.x):\n            centers, radii = params_to_circles(result.x)\n            sum_radii = np.sum(radii)\n            \n            if sum_radii > best_sum and is_valid(result.x):\n                best_sum = sum_radii\n                best_solution = (centers, radii, sum_radii)\n    \n    # If no scipy solution worked, use best SA result\n    if best_solution is None and len(top_results) > 0:\n        params, _ = top_results[0]\n        centers, radii = params_to_circles(params)\n        sum_radii = np.sum(radii)\n        best_solution = (centers, radii, sum_radii)\n    \n    return best_solution\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.5423876339057734,
    "target_ratio": 0.964852991994601,
    "combined_score": 0.964852991994601,
    "eval_time": 157.12833094596863,
    "error": null
  },
  "prompt": "Create simulated annealing with scipy local refinement.\n\nStrategy:\n1. Simulated annealing phase (fast exploration):\n   - Start temperature: 1.0\n   - Cool slowly: T *= 0.99 per iteration\n   - 10000 iterations\n   - Accept worse solutions with probability exp(-\u0394E/T)\n2. Run SA 10 times with different seeds\n3. Take top 5 SA results\n4. Apply scipy trust-constr refinement to each:\n   - maxiter=15000\n   - gtol=1e-11\n5. Return best\n\nRequirements:\n- Simulated annealing + scipy\n- 10 SA runs\n- Efficient execution\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses simulated annealing followed by scipy optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def params_to_circles(params):\n        \"\"\"Convert flat parameter array to centers and radii.\"\"\"\n        centers = params[:2*n].reshape(n, 2)\n        radii = params[2*n:]\n        return centers, radii\n    \n    def circles_to_params(centers, radii):\n        \"\"\"Convert centers and radii to flat parameter array.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def objective(params):\n        \"\"\"Negative sum of radii (we minimize).\"\"\"\n        _, radii = params_to_circles(params)\n        return -np.sum(radii)\n    \n    def is_valid(params):\n        \"\"\"Check if configuration satisfies all constraints.\"\"\"\n        centers, radii = params_to_circles(params)\n        \n        # Check if all radii are non-negative\n        if np.any(radii < 0):\n            return False\n        \n        # Check if circles are inside unit square\n        if np.any(centers - radii.reshape(-1, 1) < 0) or np.any(centers + radii.reshape(-1, 1) > 1):\n            return False\n        \n        # Check for overlaps\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-10:\n                    return False\n        \n        return True\n    \n    def constraint_violation(params):\n        \"\"\"Calculate total constraint violation (for penalty).\"\"\"\n        centers, radii = params_to_circles(params)\n        violation = 0.0\n        \n        # Penalty for negative radii\n        violation += np.sum(np.maximum(0, -radii)) * 100\n        \n        # Penalty for circles outside square\n        violation += np.sum(np.maximum(0, -(centers - radii.reshape(-1, 1)))) * 100\n        violation += np.sum(np.maximum(0, centers + radii.reshape(-1, 1) - 1)) * 100\n        \n        # Penalty for overlaps\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    violation += overlap * 100\n        \n        return violation\n    \n    def simulated_annealing(seed, n_iter=10000):\n        \"\"\"Run simulated annealing.\"\"\"\n        np.random.seed(seed)\n        \n        # Initialize with grid layout\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            centers.append([x, y])\n        centers = np.array(centers)\n        \n        # Initial radii - conservative\n        radii = np.full(n, 0.04)\n        params = circles_to_params(centers, radii)\n        \n        # Make sure initial solution is valid\n        while not is_valid(params):\n            radii *= 0.9\n            params = circles_to_params(centers, radii)\n        \n        current_energy = objective(params)\n        best_params = params.copy()\n        best_energy = current_energy\n        \n        T = 1.0\n        \n        for iteration in range(n_iter):\n            # Generate neighbor\n            new_params = params.copy()\n            \n            # Choose what to perturb\n            choice = np.random.rand()\n            if choice < 0.5:\n                # Perturb a random center\n                idx = np.random.randint(n)\n                new_params[2*idx:2*idx+2] += np.random.randn(2) * 0.02 * T\n            else:\n                # Perturb a random radius\n                idx = np.random.randint(n)\n                new_params[2*n + idx] += np.random.randn() * 0.01 * T\n            \n            # Calculate energy with penalty for constraint violations\n            if is_valid(new_params):\n                new_energy = objective(new_params)\n            else:\n                new_energy = objective(new_params) + constraint_violation(new_params)\n            \n            # Accept or reject\n            delta_e = new_energy - current_energy\n            if delta_e < 0 or np.random.rand() < np.exp(-delta_e / T):\n                params = new_params\n                current_energy = new_energy\n                \n                # Update best if valid and better\n                if is_valid(params):\n                    actual_energy = objective(params)\n                    if actual_energy < best_energy:\n                        best_params = params.copy()\n                        best_energy = actual_energy\n            \n            # Cool down\n            T *= 0.99\n        \n        return best_params, best_energy\n    \n    # Run simulated annealing multiple times\n    sa_results = []\n    for seed in range(10):\n        params, energy = simulated_annealing(seed)\n        if is_valid(params):\n            sa_results.append((params, energy))\n    \n    # Sort by energy and take top 5\n    sa_results.sort(key=lambda x: x[1])\n    top_results = sa_results[:min(5, len(sa_results))]\n    \n    # Scipy optimization constraints\n    def constraint_circles_in_square(params):\n        centers, radii = params_to_circles(params)\n        constraints = []\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # x - r >= 0\n            constraints.append(centers[i, 1] - radii[i])  # y - r >= 0\n            constraints.append(1 - centers[i, 0] - radii[i])  # 1 - x - r >= 0\n            constraints.append(1 - centers[i, 1] - radii[i])  # 1 - y - r >= 0\n        return np.array(constraints)\n    \n    def constraint_no_overlap(params):\n        centers, radii = params_to_circles(params)\n        constraints = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - radii[i] - radii[j])  # dist - r_i - r_j >= 0\n        return np.array(constraints)\n    \n    def constraint_radii_positive(params):\n        _, radii = params_to_circles(params)\n        return radii\n    \n    constraints = [\n        {'type': 'ineq', 'fun': constraint_circles_in_square},\n        {'type': 'ineq', 'fun': constraint_no_overlap},\n        {'type': 'ineq', 'fun': constraint_radii_positive}\n    ]\n    \n    # Refine top results with scipy\n    best_solution = None\n    best_sum = -np.inf\n    \n    for params, _ in top_results:\n        result = minimize(\n            objective,\n            params,\n            method='trust-constr',\n            constraints=constraints,\n            options={'maxiter': 15000, 'gtol': 1e-11, 'verbose': 0}\n        )\n        \n        if result.success or is_valid(result.x):\n            centers, radii = params_to_circles(result.x)\n            sum_radii = np.sum(radii)\n            \n            if sum_radii > best_sum and is_valid(result.x):\n                best_sum = sum_radii\n                best_solution = (centers, radii, sum_radii)\n    \n    # If no scipy solution worked, use best SA result\n    if best_solution is None and len(top_results) > 0:\n        params, _ = top_results[0]\n        centers, radii = params_to_circles(params)\n        sum_radii = np.sum(radii)\n        best_solution = (centers, radii, sum_radii)\n    \n    return best_solution\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T19:08:44.638955",
  "cost_data": null
}