{
  "trial_id": "trial_5_10",
  "generation": 5,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def hexagonal_initialization(n):\n        \"\"\"Create hexagonal grid initialization.\"\"\"\n        # Estimate grid dimensions\n        aspect = 1.0\n        cols = int(np.ceil(np.sqrt(n / aspect)))\n        rows = int(np.ceil(n / cols))\n        \n        centers = []\n        for i in range(rows):\n            for j in range(cols):\n                if len(centers) >= n:\n                    break\n                x = (j + 0.5 * (i % 2)) / cols\n                y = i * np.sqrt(3) / 2 / rows\n                centers.append([x, y])\n            if len(centers) >= n:\n                break\n        \n        centers = np.array(centers[:n])\n        # Normalize to fit in [0.1, 0.9] x [0.1, 0.9]\n        centers = 0.1 + 0.8 * (centers - centers.min(axis=0)) / (centers.max(axis=0) - centers.min(axis=0) + 1e-10)\n        return centers\n    \n    def pack_circles(centers_init):\n        \"\"\"Optimize circle packing given initial centers.\"\"\"\n        x0 = centers_init.flatten()\n        \n        def objective(x):\n            centers = x.reshape(n, 2)\n            # Calculate maximum possible radius for each circle\n            radii = np.full(n, 1.0)\n            \n            # Constrain by square boundaries\n            radii = np.minimum(radii, centers[:, 0])\n            radii = np.minimum(radii, 1 - centers[:, 0])\n            radii = np.minimum(radii, centers[:, 1])\n            radii = np.minimum(radii, 1 - centers[:, 1])\n            \n            # Constrain by other circles\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = dist / 2\n                    radii[i] = min(radii[i], max_r)\n                    radii[j] = min(radii[j], max_r)\n            \n            return -np.sum(radii)\n        \n        def constraint_boundary(x):\n            \"\"\"Ensure circles stay within boundaries.\"\"\"\n            centers = x.reshape(n, 2)\n            radii = np.full(n, 1.0)\n            \n            radii = np.minimum(radii, centers[:, 0])\n            radii = np.minimum(radii, 1 - centers[:, 0])\n            radii = np.minimum(radii, centers[:, 1])\n            radii = np.minimum(radii, 1 - centers[:, 1])\n            \n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = dist / 2\n                    radii[i] = min(radii[i], max_r)\n                    radii[j] = min(radii[j], max_r)\n            \n            constraints = []\n            for i in range(n):\n                constraints.extend([\n                    centers[i, 0] - radii[i],\n                    1 - centers[i, 0] - radii[i],\n                    centers[i, 1] - radii[i],\n                    1 - centers[i, 1] - radii[i]\n                ])\n            return np.array(constraints)\n        \n        def constraint_overlap(x):\n            \"\"\"Ensure circles don't overlap.\"\"\"\n            centers = x.reshape(n, 2)\n            radii = np.full(n, 1.0)\n            \n            radii = np.minimum(radii, centers[:, 0])\n            radii = np.minimum(radii, 1 - centers[:, 0])\n            radii = np.minimum(radii, centers[:, 1])\n            radii = np.minimum(radii, 1 - centers[:, 1])\n            \n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = dist / 2\n                    radii[i] = min(radii[i], max_r)\n                    radii[j] = min(radii[j], max_r)\n            \n            constraints = []\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    constraints.append(dist - radii[i] - radii[j])\n            return np.array(constraints)\n        \n        constraints = [\n            {'type': 'ineq', 'fun': constraint_boundary},\n            {'type': 'ineq', 'fun': constraint_overlap}\n        ]\n        \n        bounds = [(0, 1)] * (2 * n)\n        \n        result = minimize(\n            objective,\n            x0,\n            method='trust-constr',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'gtol': 1e-8, 'xtol': 1e-10}\n        )\n        \n        return result.x.reshape(n, 2), -result.fun\n    \n    def calculate_radii(centers):\n        \"\"\"Calculate radii given centers.\"\"\"\n        radii = np.full(n, 1.0)\n        \n        # Constrain by boundaries\n        radii = np.minimum(radii, centers[:, 0])\n        radii = np.minimum(radii, 1 - centers[:, 0])\n        radii = np.minimum(radii, centers[:, 1])\n        radii = np.minimum(radii, 1 - centers[:, 1])\n        \n        # Constrain by other circles\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_r = dist / 2\n                radii[i] = min(radii[i], max_r)\n                radii[j] = min(radii[j], max_r)\n        \n        return radii\n    \n    # Initialize with hexagonal grid\n    centers_init = hexagonal_initialization(n)\n    \n    # Initial optimization\n    best_centers, best_sum = pack_circles(centers_init)\n    best_radii = calculate_radii(best_centers)\n    \n    # Local search with intelligent perturbations\n    np.random.seed(42)\n    for iteration in range(20):\n        improved = False\n        \n        # Generate 10 perturbations\n        for perturb_idx in range(10):\n            if perturb_idx < 5:\n                # Small random perturbations with varying scales\n                scale = 10 ** (-5 + perturb_idx * 0.4)  # 1e-5 to ~1e-3\n                perturbed = best_centers + np.random.randn(n, 2) * scale\n            else:\n                # Systematic shifts - move each circle in a direction\n                perturbed = best_centers.copy()\n                circle_idx = (perturb_idx - 5) % n\n                direction = np.random.randn(2)\n                direction /= np.linalg.norm(direction)\n                perturbed[circle_idx] += direction * 1e-4\n            \n            # Clip to valid range\n            perturbed = np.clip(perturbed, 0.01, 0.99)\n            \n            # Optimize from perturbed position\n            try:\n                new_centers, new_sum = pack_circles(perturbed)\n                \n                if new_sum > best_sum + 1e-9:\n                    best_centers = new_centers\n                    best_sum = new_sum\n                    best_radii = calculate_radii(best_centers)\n                    improved = True\n            except:\n                continue\n        \n        if not improved:\n            # Try larger perturbations if no improvement\n            scale = 1e-3 * (1 + iteration * 0.1)\n            perturbed = best_centers + np.random.randn(n, 2) * scale\n            perturbed = np.clip(perturbed, 0.01, 0.99)\n            \n            try:\n                new_centers, new_sum = pack_circles(perturbed)\n                if new_sum > best_sum + 1e-9:\n                    best_centers = new_centers\n                    best_sum = new_sum\n                    best_radii = calculate_radii(best_centers)\n            except:\n                pass\n    \n    sum_radii = np.sum(best_radii)\n    return best_centers, best_radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 300.00955080986023,
    "error": "Timeout after 300s"
  },
  "prompt": "Create local search with intelligent perturbation strategy.\n\nStrategy:\n1. Start with excellent initialization (hexagonal)\n2. Optimize with scipy (trust-constr, tight tolerances)\n3. Local search loop (20 iterations):\n   - Generate 10 perturbations of current best:\n     * Small random moves (scale 1e-5 to 1e-3)\n     * Systematic shifts (move each circle slightly)\n   - Optimize each perturbation\n   - Keep best if improved\n4. Return best result\n\nRequirements:\n- Intelligent perturbations\n- 20 local search iterations\n- Efficient execution\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def hexagonal_initialization(n):\n        \"\"\"Create hexagonal grid initialization.\"\"\"\n        # Estimate grid dimensions\n        aspect = 1.0\n        cols = int(np.ceil(np.sqrt(n / aspect)))\n        rows = int(np.ceil(n / cols))\n        \n        centers = []\n        for i in range(rows):\n            for j in range(cols):\n                if len(centers) >= n:\n                    break\n                x = (j + 0.5 * (i % 2)) / cols\n                y = i * np.sqrt(3) / 2 / rows\n                centers.append([x, y])\n            if len(centers) >= n:\n                break\n        \n        centers = np.array(centers[:n])\n        # Normalize to fit in [0.1, 0.9] x [0.1, 0.9]\n        centers = 0.1 + 0.8 * (centers - centers.min(axis=0)) / (centers.max(axis=0) - centers.min(axis=0) + 1e-10)\n        return centers\n    \n    def pack_circles(centers_init):\n        \"\"\"Optimize circle packing given initial centers.\"\"\"\n        x0 = centers_init.flatten()\n        \n        def objective(x):\n            centers = x.reshape(n, 2)\n            # Calculate maximum possible radius for each circle\n            radii = np.full(n, 1.0)\n            \n            # Constrain by square boundaries\n            radii = np.minimum(radii, centers[:, 0])\n            radii = np.minimum(radii, 1 - centers[:, 0])\n            radii = np.minimum(radii, centers[:, 1])\n            radii = np.minimum(radii, 1 - centers[:, 1])\n            \n            # Constrain by other circles\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = dist / 2\n                    radii[i] = min(radii[i], max_r)\n                    radii[j] = min(radii[j], max_r)\n            \n            return -np.sum(radii)\n        \n        def constraint_boundary(x):\n            \"\"\"Ensure circles stay within boundaries.\"\"\"\n            centers = x.reshape(n, 2)\n            radii = np.full(n, 1.0)\n            \n            radii = np.minimum(radii, centers[:, 0])\n            radii = np.minimum(radii, 1 - centers[:, 0])\n            radii = np.minimum(radii, centers[:, 1])\n            radii = np.minimum(radii, 1 - centers[:, 1])\n            \n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = dist / 2\n                    radii[i] = min(radii[i], max_r)\n                    radii[j] = min(radii[j], max_r)\n            \n            constraints = []\n            for i in range(n):\n                constraints.extend([\n                    centers[i, 0] - radii[i],\n                    1 - centers[i, 0] - radii[i],\n                    centers[i, 1] - radii[i],\n                    1 - centers[i, 1] - radii[i]\n                ])\n            return np.array(constraints)\n        \n        def constraint_overlap(x):\n            \"\"\"Ensure circles don't overlap.\"\"\"\n            centers = x.reshape(n, 2)\n            radii = np.full(n, 1.0)\n            \n            radii = np.minimum(radii, centers[:, 0])\n            radii = np.minimum(radii, 1 - centers[:, 0])\n            radii = np.minimum(radii, centers[:, 1])\n            radii = np.minimum(radii, 1 - centers[:, 1])\n            \n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = dist / 2\n                    radii[i] = min(radii[i], max_r)\n                    radii[j] = min(radii[j], max_r)\n            \n            constraints = []\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    constraints.append(dist - radii[i] - radii[j])\n            return np.array(constraints)\n        \n        constraints = [\n            {'type': 'ineq', 'fun': constraint_boundary},\n            {'type': 'ineq', 'fun': constraint_overlap}\n        ]\n        \n        bounds = [(0, 1)] * (2 * n)\n        \n        result = minimize(\n            objective,\n            x0,\n            method='trust-constr',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'gtol': 1e-8, 'xtol': 1e-10}\n        )\n        \n        return result.x.reshape(n, 2), -result.fun\n    \n    def calculate_radii(centers):\n        \"\"\"Calculate radii given centers.\"\"\"\n        radii = np.full(n, 1.0)\n        \n        # Constrain by boundaries\n        radii = np.minimum(radii, centers[:, 0])\n        radii = np.minimum(radii, 1 - centers[:, 0])\n        radii = np.minimum(radii, centers[:, 1])\n        radii = np.minimum(radii, 1 - centers[:, 1])\n        \n        # Constrain by other circles\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_r = dist / 2\n                radii[i] = min(radii[i], max_r)\n                radii[j] = min(radii[j], max_r)\n        \n        return radii\n    \n    # Initialize with hexagonal grid\n    centers_init = hexagonal_initialization(n)\n    \n    # Initial optimization\n    best_centers, best_sum = pack_circles(centers_init)\n    best_radii = calculate_radii(best_centers)\n    \n    # Local search with intelligent perturbations\n    np.random.seed(42)\n    for iteration in range(20):\n        improved = False\n        \n        # Generate 10 perturbations\n        for perturb_idx in range(10):\n            if perturb_idx < 5:\n                # Small random perturbations with varying scales\n                scale = 10 ** (-5 + perturb_idx * 0.4)  # 1e-5 to ~1e-3\n                perturbed = best_centers + np.random.randn(n, 2) * scale\n            else:\n                # Systematic shifts - move each circle in a direction\n                perturbed = best_centers.copy()\n                circle_idx = (perturb_idx - 5) % n\n                direction = np.random.randn(2)\n                direction /= np.linalg.norm(direction)\n                perturbed[circle_idx] += direction * 1e-4\n            \n            # Clip to valid range\n            perturbed = np.clip(perturbed, 0.01, 0.99)\n            \n            # Optimize from perturbed position\n            try:\n                new_centers, new_sum = pack_circles(perturbed)\n                \n                if new_sum > best_sum + 1e-9:\n                    best_centers = new_centers\n                    best_sum = new_sum\n                    best_radii = calculate_radii(best_centers)\n                    improved = True\n            except:\n                continue\n        \n        if not improved:\n            # Try larger perturbations if no improvement\n            scale = 1e-3 * (1 + iteration * 0.1)\n            perturbed = best_centers + np.random.randn(n, 2) * scale\n            perturbed = np.clip(perturbed, 0.01, 0.99)\n            \n            try:\n                new_centers, new_sum = pack_circles(perturbed)\n                if new_sum > best_sum + 1e-9:\n                    best_centers = new_centers\n                    best_sum = new_sum\n                    best_radii = calculate_radii(best_centers)\n            except:\n                pass\n    \n    sum_radii = np.sum(best_radii)\n    return best_centers, best_radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T19:11:07.986000",
  "cost_data": null
}