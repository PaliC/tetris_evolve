{
  "trial_id": "trial_5_1",
  "generation": 5,
  "parent_id": "trial_4_6",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def create_constraints(tolerance):\n        \"\"\"Create constraints with given tolerance.\"\"\"\n        \n        def boundary_constraints(x):\n            \"\"\"All circles must be inside [0,1]x[0,1].\"\"\"\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            \n            constraints = np.zeros(4*n)\n            constraints[0:n] = centers[:, 0] - radii\n            constraints[n:2*n] = 1 - centers[:, 0] - radii\n            constraints[2*n:3*n] = centers[:, 1] - radii\n            constraints[3*n:4*n] = 1 - centers[:, 1] - radii\n            \n            return constraints\n        \n        def non_overlap_constraints(x):\n            \"\"\"No two circles may overlap.\"\"\"\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            \n            dists = squareform(pdist(centers))\n            \n            constraints = []\n            for i in range(n):\n                for j in range(i+1, n):\n                    constraints.append(dists[i, j] - radii[i] - radii[j])\n            \n            return np.array(constraints)\n        \n        def radii_positive(x):\n            \"\"\"All radii must be non-negative.\"\"\"\n            radii = x[2*n:]\n            return radii\n        \n        def all_constraints(x):\n            return np.concatenate([\n                boundary_constraints(x),\n                non_overlap_constraints(x),\n                radii_positive(x)\n            ])\n        \n        n_boundary = 4*n\n        n_overlap = n*(n-1)//2\n        n_radii = n\n        n_total = n_boundary + n_overlap + n_radii\n        \n        return NonlinearConstraint(\n            all_constraints,\n            -tolerance * np.ones(n_total),\n            np.inf * np.ones(n_total)\n        )\n    \n    def initialize_hexagonal(angle_deg=0, scale=1.0):\n        \"\"\"Initialize with hexagonal packing at given angle.\"\"\"\n        angle = np.radians(angle_deg)\n        cos_a, sin_a = np.cos(angle), np.sin(angle)\n        \n        # Hexagonal lattice vectors\n        v1 = np.array([cos_a, sin_a])\n        v2 = np.array([cos_a * np.cos(np.pi/3) - sin_a * np.sin(np.pi/3),\n                       sin_a * np.cos(np.pi/3) + cos_a * np.sin(np.pi/3)])\n        \n        # Determine grid size\n        spacing = 0.18 * scale\n        centers = []\n        \n        for i in range(-2, 8):\n            for j in range(-2, 8):\n                pos = 0.5 + spacing * (i * v1 + j * v2)\n                if 0.05 < pos[0] < 0.95 and 0.05 < pos[1] < 0.95:\n                    centers.append(pos)\n                if len(centers) >= n:\n                    break\n            if len(centers) >= n:\n                break\n        \n        if len(centers) < n:\n            # Fill remaining with grid\n            grid_size = int(np.ceil(np.sqrt(n - len(centers))))\n            for i in range(grid_size):\n                for j in range(grid_size):\n                    if len(centers) >= n:\n                        break\n                    x = 0.1 + 0.8 * i / max(grid_size - 1, 1)\n                    y = 0.1 + 0.8 * j / max(grid_size - 1, 1)\n                    centers.append([x, y])\n                if len(centers) >= n:\n                    break\n        \n        centers = np.array(centers[:n])\n        radii = np.full(n, 0.06 * scale)\n        \n        return np.concatenate([centers.flatten(), radii])\n    \n    def initialize_square_grid(offset=0.0, scale=1.0):\n        \"\"\"Initialize with square grid with optional offset.\"\"\"\n        grid_size = int(np.ceil(np.sqrt(n)))\n        spacing = 1.0 / (grid_size + 1)\n        r_init = spacing / (2.5 * scale)\n        \n        centers = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(centers) >= n:\n                    break\n                x = (i + 1 + offset) * spacing\n                y = (j + 1 + offset) * spacing\n                if 0 < x < 1 and 0 < y < 1:\n                    centers.append([x, y])\n            if len(centers) >= n:\n                break\n        \n        while len(centers) < n:\n            centers.append([0.5, 0.5])\n        \n        centers = np.array(centers[:n])\n        radii = np.full(n, r_init)\n        \n        return np.concatenate([centers.flatten(), radii])\n    \n    def initialize_random_constrained(seed, margin=0.15):\n        \"\"\"Initialize with random positions in constrained region.\"\"\"\n        np.random.seed(seed)\n        centers = np.random.uniform(margin, 1-margin, (n, 2))\n        radii = np.random.uniform(0.03, 0.06, n)\n        return np.concatenate([centers.flatten(), radii])\n    \n    def initialize_concentric(layers=3):\n        \"\"\"Initialize with concentric pattern.\"\"\"\n        centers = []\n        \n        # Center circle\n        centers.append([0.5, 0.5])\n        \n        # Concentric layers\n        for layer in range(1, layers + 1):\n            radius = 0.15 * layer\n            n_circles = max(6 * layer, 1)\n            for i in range(n_circles):\n                if len(centers) >= n:\n                    break\n                angle = 2 * np.pi * i / n_circles\n                x = 0.5 + radius * np.cos(angle)\n                y = 0.5 + radius * np.sin(angle)\n                if 0.1 < x < 0.9 and 0.1 < y < 0.9:\n                    centers.append([x, y])\n            if len(centers) >= n:\n                break\n        \n        while len(centers) < n:\n            centers.append([0.5, 0.5])\n        \n        centers = np.array(centers[:n])\n        radii = np.full(n, 0.05)\n        \n        return np.concatenate([centers.flatten(), radii])\n    \n    def three_phase_optimization(x0):\n        \"\"\"Run three-phase optimization with progressive constraint tightening.\"\"\"\n        \n        # Phase 1: Relaxed constraints\n        tolerance1 = 1e-4\n        constraints1 = create_constraints(tolerance1)\n        \n        result1 = minimize(\n            objective,\n            x0,\n            method='trust-constr',\n            constraints=constraints1,\n            options={'maxiter': 400, 'verbose': 0}\n        )\n        \n        if not result1.success:\n            return None, -np.inf\n        \n        # Phase 2: Medium constraints\n        tolerance2 = 1e-6\n        constraints2 = create_constraints(tolerance2)\n        \n        result2 = minimize(\n            objective,\n            result1.x,\n            method='trust-constr',\n            constraints=constraints2,\n            options={'maxiter': 400, 'verbose': 0}\n        )\n        \n        if not result2.success:\n            return result1.x, -result1.fun\n        \n        # Phase 3: Strict constraints\n        tolerance3 = 1e-10\n        constraints3 = create_constraints(tolerance3)\n        \n        result3 = minimize(\n            objective,\n            result2.x,\n            method='trust-constr',\n            constraints=constraints3,\n            options={'maxiter': 400, 'verbose': 0}\n        )\n        \n        if not result3.success:\n            return result2.x, -result2.fun\n        \n        return result3.x, -result3.fun\n    \n    # Strategy 1: Hexagonal at 0\u00b0\n    x0 = initialize_hexagonal(0, 1.0)\n    x_opt, sum_opt = three_phase_optimization(x0)\n    if x_opt is not None and sum_opt > best_sum:\n        best_sum = sum_opt\n        best_centers = x_opt[:2*n].reshape(n, 2)\n        best_radii = x_opt[2*n:]\n    \n    # Strategy 2: Hexagonal at 15\u00b0\n    x0 = initialize_hexagonal(15, 1.0)\n    x_opt, sum_opt = three_phase_optimization(x0)\n    if x_opt is not None and sum_opt > best_sum:\n        best_sum = sum_opt\n        best_centers = x_opt[:2*n].reshape(n, 2)\n        best_radii = x_opt[2*n:]\n    \n    # Strategy 3: Hexagonal at 30\u00b0\n    x0 = initialize_hexagonal(30, 1.0)\n    x_opt, sum_opt = three_phase_optimization(x0)\n    if x_opt is not None and sum_opt > best_sum:\n        best_sum = sum_opt\n        best_centers = x_opt[:2*n].reshape(n, 2)\n        best_radii = x_opt[2*n:]\n    \n    # Strategy 4: Hexagonal at 45\u00b0 with tighter packing\n    x0 = initialize_hexagonal(45, 0.95)\n    x_opt, sum_opt = three_phase_optimization(x0)\n    if x_opt is not None and sum_opt > best_sum:\n        best_sum = sum_opt\n        best_centers = x_opt[:2*n].reshape(n, 2)\n        best_radii = x_opt[2*n:]\n    \n    # Strategy 5: Square grid no offset\n    x0 = initialize_square_grid(0.0, 1.0)\n    x_opt, sum_opt = three_phase_optimization(x0)\n    if x_opt is not None and sum_opt > best_sum:\n        best_sum = sum_opt\n        best_centers = x_opt[:2*n].reshape(n, 2)\n        best_radii = x_opt[2*n:]\n    \n    # Strategy 6: Square grid with offset\n    x0 = initialize_square_grid(0.25, 1.0)\n    x_opt, sum_opt = three_phase_optimization(x0)\n    if x_opt is not None and sum_opt > best_sum:\n        best_sum = sum_opt\n        best_centers = x_opt[:2*n].reshape(n, 2)\n        best_radii = x_opt[2*n:]\n    \n    # Strategy 7: Concentric pattern\n    x0 = initialize_concentric(3)\n    x_opt, sum_opt = three_phase_optimization(x0)\n    if x_opt is not None and sum_opt > best_sum:\n        best_sum = sum_opt\n        best_centers = x_opt[:2*n].reshape(n, 2)\n        best_radii = x_opt[2*n:]\n    \n    # Strategies 8-10: Random constrained initializations\n    for seed in [42, 123, 999]:\n        x0 = initialize_random_constrained(seed, 0.15)\n        x_opt, sum_opt = three_phase_optimization(x0)\n        if x_opt is not None and sum_opt > best_sum:\n            best_sum = sum_opt\n            best_centers = x_opt[:2*n].reshape(n, 2)\n            best_radii = x_opt[2*n:]\n    \n    # Validate solution\n    if best_centers is None:\n        # Fallback to simple grid\n        grid_size = int(np.ceil(np.sqrt(n)))\n        spacing = 1.0 / (grid_size + 1)\n        r = spacing / 3.0\n        \n        centers = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(centers) >= n:\n                    break\n                x = (i + 1) * spacing\n                y = (j + 1) * spacing\n                centers.append([x, y])\n            if len(centers) >= n:\n                break\n        \n        best_centers = np.array(centers[:n])\n        best_radii = np.full(n, r)\n        best_sum = n * r\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.586208387616139,
    "target_ratio": 0.9814832590573582,
    "combined_score": 0.9814832590573582,
    "eval_time": 67.8446671962738,
    "error": null
  },
  "prompt": "Create enhanced version of trial_4_6 with better initialization:\n\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def create_constraints(tolerance):\n        \"\"\"Create constraints with given tolerance.\"\"\"\n        \n        def boundary_constraints(x):\n            \"\"\"All circles must be inside [0,1]x[0,1].\"\"\"\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            \n            constraints = np.zeros(4*n)\n            # x - r >= 0\n            constraints[0:n] = centers[:, 0] - radii\n            # x + r <= 1\n            constraints[n:2*n] = 1 - centers[:, 0] - radii\n            # y - r >= 0\n            constraints[2*n:3*n] = centers[:, 1] - radii\n            # y + r <= 1\n            constraints[3*n:4*n] = 1 - centers[:, 1] - radii\n            \n            return constraints\n        \n        def non_overlap_constraints(x):\n            \"\"\"No two circles may overlap.\"\"\"\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            \n            # Compute pairwise distances\n            dists = squareform(pdist(centers))\n            \n            # For each pair (i,j), distance >= r_i + r_j\n            constraints = []\n            for i in range(n):\n                for j in range(i+1, n):\n                    constraints.append(dists[i, j] - radii[i] - radii[j])\n            \n            return np.array(constraints)\n        \n        def radii_positive(x):\n            \"\"\"All radii must be non-negative.\"\"\"\n            radii = x[2*n:]\n            return radii\n        \n        # Combine all constraints\n        def all_constraints(x):\n            return np.concatenate([\n                boundary_constraints(x),\n                non_overlap_constraints(x),\n                radii_positive(x)\n            ])\n        \n        n_boundary = 4*n\n        n_overlap = n*(n-1)//2\n        n_radii = n\n        n_total = n_boundary + n_overlap + n_radii\n        \n        return NonlinearConstraint(\n            all_constraints,\n            -tolerance * np.ones(n_total),\n            np.inf * np.ones(n_total)\n        )\n    \n    def initialize_grid():\n        \"\"\"Initialize with a grid pattern.\"\"\"\n        # Try to fit circles in a grid\n        grid_size = int(np.ceil(np.sqrt(n)))\n        spacing = 1.0 / grid_size\n        r_init = spacing / 2.5  # Conservative radius\n        \n        centers = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(centers) >= n:\n                    break\n                x = (i + 0.5) * spacing\n                y = (j + 0.5) * spacing\n                centers.append([x, y])\n            if len(centers) >= n:\n                break\n        \n        centers = np.array(centers[:n])\n        radii = np.full(n, r_init)\n        \n        return np.concatenate([centers.flatten(), radii])\n    \n    def initialize_random(seed):\n        \"\"\"Initialize with random positions.\"\"\"\n        np.random.seed(seed)\n        centers = np.random.uniform(0.2, 0.8, (n, 2))\n        radii = np.random.uniform(0.02, 0.05, n)\n        return np.concatenate([centers.flatten(), radii])\n    \n    def three_phase_optimization(x0, seed):\n        \"\"\"Run three-phase optimization with progressive constraint tightening.\"\"\"\n        \n        # Phase 1: Relaxed constraints\n        tolerance1 = 1e-4\n        constraints1 = create_constraints(tolerance1)\n        \n        result1 = minimize(\n            objective,\n            x0,\n            method='trust-constr',\n            constraints=constraints1,\n            options={'maxiter': 500, 'verbose': 0}\n        )\n        \n        if not result1.success:\n            return None, -np.inf\n        \n        # Phase 2: Medium constraints\n        tolerance2 = 1e-6\n        constraints2 = create_constraints(tolerance2)\n        \n        result2 = minimize(\n            objective,\n            result1.x,\n            method='trust-constr',\n            constraints=constraints2,\n            options={'maxiter': 500, 'verbose': 0}\n        )\n        \n        if not result2.success:\n            return result1.x, -result1.fun\n        \n        # Phase 3: Strict constraints\n        tolerance3 = 1e-10\n        constraints3 = create_constraints(tolerance3)\n        \n        result3 = minimize(\n            objective,\n            result2.x,\n            method='trust-constr',\n            constraints=constraints3,\n            options={'maxiter': 500, 'verbose': 0}\n        )\n        \n        if not result3.success:\n            return result2.x, -result2.fun\n        \n        return result3.x, -result3.fun\n    \n    # Try grid initialization\n    x0_grid = initialize_grid()\n    x_best, sum_best = three_phase_optimization(x0_grid, 0)\n    \n    if x_best is not None and sum_best > best_sum:\n        best_sum = sum_best\n        best_centers = x_best[:2*n].reshape(n, 2)\n        best_radii = x_best[2*n:]\n    \n    # Try multiple random initializations\n    n_trials = 60\n    for seed in range(1, n_trials):\n        x0 = initialize_random(seed)\n        x_opt, sum_opt = three_phase_optimization(x0, seed)\n        \n        if x_opt is not None and sum_opt > best_sum:\n            best_sum = sum_opt\n            best_centers = x_opt[:2*n].reshape(n, 2)\n            best_radii = x_opt[2*n:]\n    \n    # Validate solution\n    if best_centers is None:\n        # Fallback to simple grid\n        grid_size = int(np.ceil(np.sqrt(n)))\n        spacing = 1.0 / grid_size\n        r = spacing / 3.0\n        \n        centers = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(centers) >= n:\n                    break\n                x = (i + 0.5) * spacing\n                y = (j + 0.5) * spacing\n                centers.append([x, y])\n            if len(centers) >= n:\n                break\n        \n        best_centers = np.array(centers[:n])\n        best_radii = np.full(n, r)\n        best_sum = n * r\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nImprovements:\n1. Test multiple initialization strategies (10 different approaches):\n   - Hexagonal grids at different angles (0\u00b0, 15\u00b0, 30\u00b0, 45\u00b0)\n   - Square grids with different spacing\n   - Random but constrained positions\n2. For each initialization, run the 3-phase optimization\n3. Track best result from each\n4. Apply final polish to top 3 results\n5. Return absolute best\n\nRequirements:\n- 10 different initializations\n- 3-phase optimization per init\n- Efficient execution\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def create_constraints(tolerance):\n        \"\"\"Create constraints with given tolerance.\"\"\"\n        \n        def boundary_constraints(x):\n            \"\"\"All circles must be inside [0,1]x[0,1].\"\"\"\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            \n            constraints = np.zeros(4*n)\n            constraints[0:n] = centers[:, 0] - radii\n            constraints[n:2*n] = 1 - centers[:, 0] - radii\n            constraints[2*n:3*n] = centers[:, 1] - radii\n            constraints[3*n:4*n] = 1 - centers[:, 1] - radii\n            \n            return constraints\n        \n        def non_overlap_constraints(x):\n            \"\"\"No two circles may overlap.\"\"\"\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            \n            dists = squareform(pdist(centers))\n            \n            constraints = []\n            for i in range(n):\n                for j in range(i+1, n):\n                    constraints.append(dists[i, j] - radii[i] - radii[j])\n            \n            return np.array(constraints)\n        \n        def radii_positive(x):\n            \"\"\"All radii must be non-negative.\"\"\"\n            radii = x[2*n:]\n            return radii\n        \n        def all_constraints(x):\n            return np.concatenate([\n                boundary_constraints(x),\n                non_overlap_constraints(x),\n                radii_positive(x)\n            ])\n        \n        n_boundary = 4*n\n        n_overlap = n*(n-1)//2\n        n_radii = n\n        n_total = n_boundary + n_overlap + n_radii\n        \n        return NonlinearConstraint(\n            all_constraints,\n            -tolerance * np.ones(n_total),\n            np.inf * np.ones(n_total)\n        )\n    \n    def initialize_hexagonal(angle_deg=0, scale=1.0):\n        \"\"\"Initialize with hexagonal packing at given angle.\"\"\"\n        angle = np.radians(angle_deg)\n        cos_a, sin_a = np.cos(angle), np.sin(angle)\n        \n        # Hexagonal lattice vectors\n        v1 = np.array([cos_a, sin_a])\n        v2 = np.array([cos_a * np.cos(np.pi/3) - sin_a * np.sin(np.pi/3),\n                       sin_a * np.cos(np.pi/3) + cos_a * np.sin(np.pi/3)])\n        \n        # Determine grid size\n        spacing = 0.18 * scale\n        centers = []\n        \n        for i in range(-2, 8):\n            for j in range(-2, 8):\n                pos = 0.5 + spacing * (i * v1 + j * v2)\n                if 0.05 < pos[0] < 0.95 and 0.05 < pos[1] < 0.95:\n                    centers.append(pos)\n                if len(centers) >= n:\n                    break\n            if len(centers) >= n:\n                break\n        \n        if len(centers) < n:\n            # Fill remaining with grid\n            grid_size = int(np.ceil(np.sqrt(n - len(centers))))\n            for i in range(grid_size):\n                for j in range(grid_size):\n                    if len(centers) >= n:\n                        break\n                    x = 0.1 + 0.8 * i / max(grid_size - 1, 1)\n                    y = 0.1 + 0.8 * j / max(grid_size - 1, 1)\n                    centers.append([x, y])\n                if len(centers) >= n:\n                    break\n        \n        centers = np.array(centers[:n])\n        radii = np.full(n, 0.06 * scale)\n        \n        return np.concatenate([centers.flatten(), radii])\n    \n    def initialize_square_grid(offset=0.0, scale=1.0):\n        \"\"\"Initialize with square grid with optional offset.\"\"\"\n        grid_size = int(np.ceil(np.sqrt(n)))\n        spacing = 1.0 / (grid_size + 1)\n        r_init = spacing / (2.5 * scale)\n        \n        centers = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(centers) >= n:\n                    break\n                x = (i + 1 + offset) * spacing\n                y = (j + 1 + offset) * spacing\n                if 0 < x < 1 and 0 < y < 1:\n                    centers.append([x, y])\n            if len(centers) >= n:\n                break\n        \n        while len(centers) < n:\n            centers.append([0.5, 0.5])\n        \n        centers = np.array(centers[:n])\n        radii = np.full(n, r_init)\n        \n        return np.concatenate([centers.flatten(), radii])\n    \n    def initialize_random_constrained(seed, margin=0.15):\n        \"\"\"Initialize with random positions in constrained region.\"\"\"\n        np.random.seed(seed)\n        centers = np.random.uniform(margin, 1-margin, (n, 2))\n        radii = np.random.uniform(0.03, 0.06, n)\n        return np.concatenate([centers.flatten(), radii])\n    \n    def initialize_concentric(layers=3):\n        \"\"\"Initialize with concentric pattern.\"\"\"\n        centers = []\n        \n        # Center circle\n        centers.append([0.5, 0.5])\n        \n        # Concentric layers\n        for layer in range(1, layers + 1):\n            radius = 0.15 * layer\n            n_circles = max(6 * layer, 1)\n            for i in range(n_circles):\n                if len(centers) >= n:\n                    break\n                angle = 2 * np.pi * i / n_circles\n                x = 0.5 + radius * np.cos(angle)\n                y = 0.5 + radius * np.sin(angle)\n                if 0.1 < x < 0.9 and 0.1 < y < 0.9:\n                    centers.append([x, y])\n            if len(centers) >= n:\n                break\n        \n        while len(centers) < n:\n            centers.append([0.5, 0.5])\n        \n        centers = np.array(centers[:n])\n        radii = np.full(n, 0.05)\n        \n        return np.concatenate([centers.flatten(), radii])\n    \n    def three_phase_optimization(x0):\n        \"\"\"Run three-phase optimization with progressive constraint tightening.\"\"\"\n        \n        # Phase 1: Relaxed constraints\n        tolerance1 = 1e-4\n        constraints1 = create_constraints(tolerance1)\n        \n        result1 = minimize(\n            objective,\n            x0,\n            method='trust-constr',\n            constraints=constraints1,\n            options={'maxiter': 400, 'verbose': 0}\n        )\n        \n        if not result1.success:\n            return None, -np.inf\n        \n        # Phase 2: Medium constraints\n        tolerance2 = 1e-6\n        constraints2 = create_constraints(tolerance2)\n        \n        result2 = minimize(\n            objective,\n            result1.x,\n            method='trust-constr',\n            constraints=constraints2,\n            options={'maxiter': 400, 'verbose': 0}\n        )\n        \n        if not result2.success:\n            return result1.x, -result1.fun\n        \n        # Phase 3: Strict constraints\n        tolerance3 = 1e-10\n        constraints3 = create_constraints(tolerance3)\n        \n        result3 = minimize(\n            objective,\n            result2.x,\n            method='trust-constr',\n            constraints=constraints3,\n            options={'maxiter': 400, 'verbose': 0}\n        )\n        \n        if not result3.success:\n            return result2.x, -result2.fun\n        \n        return result3.x, -result3.fun\n    \n    # Strategy 1: Hexagonal at 0\u00b0\n    x0 = initialize_hexagonal(0, 1.0)\n    x_opt, sum_opt = three_phase_optimization(x0)\n    if x_opt is not None and sum_opt > best_sum:\n        best_sum = sum_opt\n        best_centers = x_opt[:2*n].reshape(n, 2)\n        best_radii = x_opt[2*n:]\n    \n    # Strategy 2: Hexagonal at 15\u00b0\n    x0 = initialize_hexagonal(15, 1.0)\n    x_opt, sum_opt = three_phase_optimization(x0)\n    if x_opt is not None and sum_opt > best_sum:\n        best_sum = sum_opt\n        best_centers = x_opt[:2*n].reshape(n, 2)\n        best_radii = x_opt[2*n:]\n    \n    # Strategy 3: Hexagonal at 30\u00b0\n    x0 = initialize_hexagonal(30, 1.0)\n    x_opt, sum_opt = three_phase_optimization(x0)\n    if x_opt is not None and sum_opt > best_sum:\n        best_sum = sum_opt\n        best_centers = x_opt[:2*n].reshape(n, 2)\n        best_radii = x_opt[2*n:]\n    \n    # Strategy 4: Hexagonal at 45\u00b0 with tighter packing\n    x0 = initialize_hexagonal(45, 0.95)\n    x_opt, sum_opt = three_phase_optimization(x0)\n    if x_opt is not None and sum_opt > best_sum:\n        best_sum = sum_opt\n        best_centers = x_opt[:2*n].reshape(n, 2)\n        best_radii = x_opt[2*n:]\n    \n    # Strategy 5: Square grid no offset\n    x0 = initialize_square_grid(0.0, 1.0)\n    x_opt, sum_opt = three_phase_optimization(x0)\n    if x_opt is not None and sum_opt > best_sum:\n        best_sum = sum_opt\n        best_centers = x_opt[:2*n].reshape(n, 2)\n        best_radii = x_opt[2*n:]\n    \n    # Strategy 6: Square grid with offset\n    x0 = initialize_square_grid(0.25, 1.0)\n    x_opt, sum_opt = three_phase_optimization(x0)\n    if x_opt is not None and sum_opt > best_sum:\n        best_sum = sum_opt\n        best_centers = x_opt[:2*n].reshape(n, 2)\n        best_radii = x_opt[2*n:]\n    \n    # Strategy 7: Concentric pattern\n    x0 = initialize_concentric(3)\n    x_opt, sum_opt = three_phase_optimization(x0)\n    if x_opt is not None and sum_opt > best_sum:\n        best_sum = sum_opt\n        best_centers = x_opt[:2*n].reshape(n, 2)\n        best_radii = x_opt[2*n:]\n    \n    # Strategies 8-10: Random constrained initializations\n    for seed in [42, 123, 999]:\n        x0 = initialize_random_constrained(seed, 0.15)\n        x_opt, sum_opt = three_phase_optimization(x0)\n        if x_opt is not None and sum_opt > best_sum:\n            best_sum = sum_opt\n            best_centers = x_opt[:2*n].reshape(n, 2)\n            best_radii = x_opt[2*n:]\n    \n    # Validate solution\n    if best_centers is None:\n        # Fallback to simple grid\n        grid_size = int(np.ceil(np.sqrt(n)))\n        spacing = 1.0 / (grid_size + 1)\n        r = spacing / 3.0\n        \n        centers = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(centers) >= n:\n                    break\n                x = (i + 1) * spacing\n                y = (j + 1) * spacing\n                centers.append([x, y])\n            if len(centers) >= n:\n                break\n        \n        best_centers = np.array(centers[:n])\n        best_radii = np.full(n, r)\n        best_sum = n * r\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T19:07:20.987738",
  "cost_data": null
}