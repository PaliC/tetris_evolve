{
  "trial_id": "trial_7_13",
  "generation": 7,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom dataclasses import dataclass\nfrom typing import Tuple\n\n@dataclass\nclass PackingResult:\n    centers: np.ndarray\n    radii: np.ndarray\n    sum_radii: float\n    valid: bool\n\ndef check_constraints(centers: np.ndarray, radii: np.ndarray) -> bool:\n    \"\"\"Check if packing satisfies all constraints.\"\"\"\n    n = len(radii)\n    \n    # Check boundaries\n    if np.any(centers - radii[:, None] < 0) or np.any(centers + radii[:, None] > 1):\n        return False\n    \n    # Check overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-10:\n                return False\n    \n    return True\n\ndef params_to_packing(params: np.ndarray, n: int) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Convert flat parameter array to centers and radii.\"\"\"\n    centers = params[:2*n].reshape(n, 2)\n    radii = params[2*n:]\n    return centers, radii\n\ndef packing_to_params(centers: np.ndarray, radii: np.ndarray) -> np.ndarray:\n    \"\"\"Convert centers and radii to flat parameter array.\"\"\"\n    return np.concatenate([centers.flatten(), radii])\n\ndef objective(params: np.ndarray, n: int) -> float:\n    \"\"\"Objective function: negative sum of radii.\"\"\"\n    radii = params[2*n:]\n    return -np.sum(radii)\n\ndef constraint_functions(n: int):\n    \"\"\"Generate constraint functions for optimization.\"\"\"\n    constraints = []\n    \n    # Boundary constraints\n    for i in range(n):\n        # x - r >= 0\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda p, i=i: p[2*i] - p[2*n+i]\n        })\n        # x + r <= 1\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda p, i=i: 1 - p[2*i] - p[2*n+i]\n        })\n        # y - r >= 0\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda p, i=i: p[2*i+1] - p[2*n+i]\n        })\n        # y + r <= 1\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda p, i=i: 1 - p[2*i+1] - p[2*n+i]\n        })\n    \n    # Non-overlap constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda p, i=i, j=j: np.sqrt(\n                    (p[2*i] - p[2*j])**2 + (p[2*i+1] - p[2*j+1])**2\n                ) - p[2*n+i] - p[2*n+j]\n            })\n    \n    return constraints\n\ndef simulated_annealing(n: int, iterations: int = 15000, T0: float = 0.1, \n                       alpha: float = 0.995, seed: int = None) -> PackingResult:\n    \"\"\"Run simulated annealing to find a good packing.\"\"\"\n    if seed is not None:\n        np.random.seed(seed)\n    \n    # Initialize with grid-like pattern with perturbation\n    grid_size = int(np.ceil(np.sqrt(n)))\n    centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size + np.random.uniform(-0.05, 0.05)\n        y = (row + 0.5) / grid_size + np.random.uniform(-0.05, 0.05)\n        centers.append([np.clip(x, 0.1, 0.9), np.clip(y, 0.1, 0.9)])\n    centers = np.array(centers)\n    \n    # Initialize radii\n    radii = np.full(n, 0.05)\n    \n    # Adjust radii to be feasible\n    for _ in range(100):\n        valid = True\n        for i in range(n):\n            # Check boundaries\n            max_r = min(centers[i, 0], 1 - centers[i, 0], \n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Check overlaps\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, dist - radii[j])\n            \n            if radii[i] > max_r:\n                radii[i] = max(0.001, max_r * 0.95)\n                valid = False\n        \n        if valid:\n            break\n    \n    current_params = packing_to_params(centers, radii)\n    current_score = -objective(current_params, n)\n    best_params = current_params.copy()\n    best_score = current_score\n    \n    T = T0\n    \n    for iteration in range(iterations):\n        # Generate neighbor\n        new_params = current_params.copy()\n        \n        # Choose what to perturb\n        choice = np.random.rand()\n        \n        if choice < 0.5:  # Move a circle\n            idx = np.random.randint(n)\n            new_params[2*idx:2*idx+2] += np.random.normal(0, 0.02, 2)\n            new_params[2*idx:2*idx+2] = np.clip(new_params[2*idx:2*idx+2], 0, 1)\n        else:  # Adjust radius\n            idx = np.random.randint(n)\n            new_params[2*n+idx] += np.random.normal(0, 0.01)\n            new_params[2*n+idx] = max(0.001, new_params[2*n+idx])\n        \n        # Check feasibility\n        new_centers, new_radii = params_to_packing(new_params, n)\n        if check_constraints(new_centers, new_radii):\n            new_score = -objective(new_params, n)\n            \n            # Accept or reject\n            delta = new_score - current_score\n            if delta > 0 or np.random.rand() < np.exp(delta / T):\n                current_params = new_params\n                current_score = new_score\n                \n                if new_score > best_score:\n                    best_params = new_params.copy()\n                    best_score = new_score\n        \n        T *= alpha\n    \n    centers, radii = params_to_packing(best_params, n)\n    return PackingResult(centers, radii, best_score, check_constraints(centers, radii))\n\ndef scipy_refinement(result: PackingResult, n: int, \n                    gtol: float = 1e-13, xtol: float = 1e-13,\n                    maxiter: int = 30000) -> PackingResult:\n    \"\"\"Refine solution using scipy optimization.\"\"\"\n    if not result.valid:\n        return result\n    \n    params0 = packing_to_params(result.centers, result.radii)\n    \n    # Bounds\n    bounds = []\n    for i in range(n):\n        bounds.append((0, 1))  # x\n        bounds.append((0, 1))  # y\n    for i in range(n):\n        bounds.append((0.001, 0.5))  # r\n    \n    constraints = constraint_functions(n)\n    \n    try:\n        res = minimize(\n            objective,\n            params0,\n            args=(n,),\n            method='trust-constr',\n            constraints=constraints,\n            bounds=bounds,\n            options={'gtol': gtol, 'xtol': xtol, 'maxiter': maxiter, 'verbose': 0}\n        )\n        \n        centers, radii = params_to_packing(res.x, n)\n        sum_radii = np.sum(radii)\n        valid = check_constraints(centers, radii)\n        \n        if valid and sum_radii > result.sum_radii:\n            return PackingResult(centers, radii, sum_radii, True)\n    except:\n        pass\n    \n    return result\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    n = 26\n    \n    # Phase 1: Run 20 simulated annealing instances\n    sa_results = []\n    for i in range(20):\n        result = simulated_annealing(n, iterations=15000, seed=i)\n        if result.valid:\n            sa_results.append(result)\n    \n    # Sort by sum of radii\n    sa_results.sort(key=lambda x: x.sum_radii, reverse=True)\n    \n    # Phase 2: Refine top 10 with scipy\n    refined_results = []\n    for i in range(min(10, len(sa_results))):\n        result = scipy_refinement(sa_results[i], n, gtol=1e-13, xtol=1e-13, maxiter=30000)\n        if result.valid:\n            refined_results.append(result)\n    \n    refined_results.sort(key=lambda x: x.sum_radii, reverse=True)\n    \n    # Phase 3: Ultra-refinement on top 5\n    ultra_refined = []\n    for i in range(min(5, len(refined_results))):\n        # First ultra-refinement\n        result = scipy_refinement(refined_results[i], n, gtol=1e-14, xtol=1e-14, maxiter=50000)\n        # Second ultra-refinement\n        result = scipy_refinement(result, n, gtol=1e-15, xtol=1e-15, maxiter=50000)\n        if result.valid:\n            ultra_refined.append(result)\n    \n    ultra_refined.sort(key=lambda x: x.sum_radii, reverse=True)\n    \n    # Return best result\n    if ultra_refined:\n        best = ultra_refined[0]\n    elif refined_results:\n        best = refined_results[0]\n    elif sa_results:\n        best = sa_results[0]\n    else:\n        # Fallback: simple grid\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            centers.append([x, y])\n        centers = np.array(centers)\n        radii = np.full(n, 0.05)\n        return centers, radii, np.sum(radii)\n    \n    return best.centers, best.radii, best.sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 300.009578704834,
    "error": "Timeout after 300s"
  },
  "prompt": "Create simulated annealing + ultra-refinement:\n\nStrategy:\n1. Simulated annealing (20 runs):\n   - Temperature schedule: T = 0.1 * 0.995^iteration\n   - 15000 iterations each\n   - Accept worse solutions probabilistically\n2. Take top 10 SA results\n3. Apply intensive scipy refinement to each:\n   - trust-constr\n   - gtol=1e-13, xtol=1e-13\n   - maxiter=30000\n4. Apply final micro-refinement to top 5\n5. Return best\n\nRequirements:\n- 20 SA runs\n- Top 10 scipy refinement\n- Ultra-tight tolerances\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom dataclasses import dataclass\nfrom typing import Tuple\n\n@dataclass\nclass PackingResult:\n    centers: np.ndarray\n    radii: np.ndarray\n    sum_radii: float\n    valid: bool\n\ndef check_constraints(centers: np.ndarray, radii: np.ndarray) -> bool:\n    \"\"\"Check if packing satisfies all constraints.\"\"\"\n    n = len(radii)\n    \n    # Check boundaries\n    if np.any(centers - radii[:, None] < 0) or np.any(centers + radii[:, None] > 1):\n        return False\n    \n    # Check overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-10:\n                return False\n    \n    return True\n\ndef params_to_packing(params: np.ndarray, n: int) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Convert flat parameter array to centers and radii.\"\"\"\n    centers = params[:2*n].reshape(n, 2)\n    radii = params[2*n:]\n    return centers, radii\n\ndef packing_to_params(centers: np.ndarray, radii: np.ndarray) -> np.ndarray:\n    \"\"\"Convert centers and radii to flat parameter array.\"\"\"\n    return np.concatenate([centers.flatten(), radii])\n\ndef objective(params: np.ndarray, n: int) -> float:\n    \"\"\"Objective function: negative sum of radii.\"\"\"\n    radii = params[2*n:]\n    return -np.sum(radii)\n\ndef constraint_functions(n: int):\n    \"\"\"Generate constraint functions for optimization.\"\"\"\n    constraints = []\n    \n    # Boundary constraints\n    for i in range(n):\n        # x - r >= 0\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda p, i=i: p[2*i] - p[2*n+i]\n        })\n        # x + r <= 1\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda p, i=i: 1 - p[2*i] - p[2*n+i]\n        })\n        # y - r >= 0\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda p, i=i: p[2*i+1] - p[2*n+i]\n        })\n        # y + r <= 1\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda p, i=i: 1 - p[2*i+1] - p[2*n+i]\n        })\n    \n    # Non-overlap constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda p, i=i, j=j: np.sqrt(\n                    (p[2*i] - p[2*j])**2 + (p[2*i+1] - p[2*j+1])**2\n                ) - p[2*n+i] - p[2*n+j]\n            })\n    \n    return constraints\n\ndef simulated_annealing(n: int, iterations: int = 15000, T0: float = 0.1, \n                       alpha: float = 0.995, seed: int = None) -> PackingResult:\n    \"\"\"Run simulated annealing to find a good packing.\"\"\"\n    if seed is not None:\n        np.random.seed(seed)\n    \n    # Initialize with grid-like pattern with perturbation\n    grid_size = int(np.ceil(np.sqrt(n)))\n    centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size + np.random.uniform(-0.05, 0.05)\n        y = (row + 0.5) / grid_size + np.random.uniform(-0.05, 0.05)\n        centers.append([np.clip(x, 0.1, 0.9), np.clip(y, 0.1, 0.9)])\n    centers = np.array(centers)\n    \n    # Initialize radii\n    radii = np.full(n, 0.05)\n    \n    # Adjust radii to be feasible\n    for _ in range(100):\n        valid = True\n        for i in range(n):\n            # Check boundaries\n            max_r = min(centers[i, 0], 1 - centers[i, 0], \n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Check overlaps\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, dist - radii[j])\n            \n            if radii[i] > max_r:\n                radii[i] = max(0.001, max_r * 0.95)\n                valid = False\n        \n        if valid:\n            break\n    \n    current_params = packing_to_params(centers, radii)\n    current_score = -objective(current_params, n)\n    best_params = current_params.copy()\n    best_score = current_score\n    \n    T = T0\n    \n    for iteration in range(iterations):\n        # Generate neighbor\n        new_params = current_params.copy()\n        \n        # Choose what to perturb\n        choice = np.random.rand()\n        \n        if choice < 0.5:  # Move a circle\n            idx = np.random.randint(n)\n            new_params[2*idx:2*idx+2] += np.random.normal(0, 0.02, 2)\n            new_params[2*idx:2*idx+2] = np.clip(new_params[2*idx:2*idx+2], 0, 1)\n        else:  # Adjust radius\n            idx = np.random.randint(n)\n            new_params[2*n+idx] += np.random.normal(0, 0.01)\n            new_params[2*n+idx] = max(0.001, new_params[2*n+idx])\n        \n        # Check feasibility\n        new_centers, new_radii = params_to_packing(new_params, n)\n        if check_constraints(new_centers, new_radii):\n            new_score = -objective(new_params, n)\n            \n            # Accept or reject\n            delta = new_score - current_score\n            if delta > 0 or np.random.rand() < np.exp(delta / T):\n                current_params = new_params\n                current_score = new_score\n                \n                if new_score > best_score:\n                    best_params = new_params.copy()\n                    best_score = new_score\n        \n        T *= alpha\n    \n    centers, radii = params_to_packing(best_params, n)\n    return PackingResult(centers, radii, best_score, check_constraints(centers, radii))\n\ndef scipy_refinement(result: PackingResult, n: int, \n                    gtol: float = 1e-13, xtol: float = 1e-13,\n                    maxiter: int = 30000) -> PackingResult:\n    \"\"\"Refine solution using scipy optimization.\"\"\"\n    if not result.valid:\n        return result\n    \n    params0 = packing_to_params(result.centers, result.radii)\n    \n    # Bounds\n    bounds = []\n    for i in range(n):\n        bounds.append((0, 1))  # x\n        bounds.append((0, 1))  # y\n    for i in range(n):\n        bounds.append((0.001, 0.5))  # r\n    \n    constraints = constraint_functions(n)\n    \n    try:\n        res = minimize(\n            objective,\n            params0,\n            args=(n,),\n            method='trust-constr',\n            constraints=constraints,\n            bounds=bounds,\n            options={'gtol': gtol, 'xtol': xtol, 'maxiter': maxiter, 'verbose': 0}\n        )\n        \n        centers, radii = params_to_packing(res.x, n)\n        sum_radii = np.sum(radii)\n        valid = check_constraints(centers, radii)\n        \n        if valid and sum_radii > result.sum_radii:\n            return PackingResult(centers, radii, sum_radii, True)\n    except:\n        pass\n    \n    return result\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    n = 26\n    \n    # Phase 1: Run 20 simulated annealing instances\n    sa_results = []\n    for i in range(20):\n        result = simulated_annealing(n, iterations=15000, seed=i)\n        if result.valid:\n            sa_results.append(result)\n    \n    # Sort by sum of radii\n    sa_results.sort(key=lambda x: x.sum_radii, reverse=True)\n    \n    # Phase 2: Refine top 10 with scipy\n    refined_results = []\n    for i in range(min(10, len(sa_results))):\n        result = scipy_refinement(sa_results[i], n, gtol=1e-13, xtol=1e-13, maxiter=30000)\n        if result.valid:\n            refined_results.append(result)\n    \n    refined_results.sort(key=lambda x: x.sum_radii, reverse=True)\n    \n    # Phase 3: Ultra-refinement on top 5\n    ultra_refined = []\n    for i in range(min(5, len(refined_results))):\n        # First ultra-refinement\n        result = scipy_refinement(refined_results[i], n, gtol=1e-14, xtol=1e-14, maxiter=50000)\n        # Second ultra-refinement\n        result = scipy_refinement(result, n, gtol=1e-15, xtol=1e-15, maxiter=50000)\n        if result.valid:\n            ultra_refined.append(result)\n    \n    ultra_refined.sort(key=lambda x: x.sum_radii, reverse=True)\n    \n    # Return best result\n    if ultra_refined:\n        best = ultra_refined[0]\n    elif refined_results:\n        best = refined_results[0]\n    elif sa_results:\n        best = sa_results[0]\n    else:\n        # Fallback: simple grid\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            centers.append([x, y])\n        centers = np.array(centers)\n        radii = np.full(n, 0.05)\n        return centers, radii, np.sum(radii)\n    \n    return best.centers, best.radii, best.sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T19:25:27.269785",
  "cost_data": null
}