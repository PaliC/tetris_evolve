{
  "trial_id": "trial_7_6",
  "generation": 7,
  "parent_id": "trial_6_6",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Mega-ensemble combining top approaches from trial_6_6, trial_6_8, and trial_6_4.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # ==================== SHARED UTILITIES ====================\n    \n    def pack_to_vector(centers, radii):\n        \"\"\"Convert centers and radii to optimization vector.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def vector_to_pack(x):\n        \"\"\"Convert optimization vector to centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Objective: maximize sum of radii (minimize negative sum).\"\"\"\n        _, radii = vector_to_pack(x)\n        return -np.sum(radii)\n    \n    def constraint_function(x):\n        \"\"\"Compute all constraint values.\"\"\"\n        centers, radii = vector_to_pack(x)\n        constraints = []\n        \n        # Boundary constraints\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])\n            constraints.append(1 - centers[i, 0] - radii[i])\n            constraints.append(centers[i, 1] - radii[i])\n            constraints.append(1 - centers[i, 1] - radii[i])\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                             (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Non-negative radii\n        for i in range(n):\n            constraints.append(radii[i])\n        \n        return np.array(constraints)\n    \n    def validate_solution(x, tol=1e-6):\n        \"\"\"Check if solution satisfies all constraints.\"\"\"\n        constraints = constraint_function(x)\n        return np.all(constraints >= -tol)\n    \n    # ==================== INITIALIZATION METHODS ====================\n    \n    def initialize_hexagonal(angle=0, seed=None):\n        \"\"\"Initialize with hexagonal packing pattern (trial_6_6 style).\"\"\"\n        if seed is not None:\n            np.random.seed(seed)\n        \n        rows = 6\n        cols = 5\n        hex_height = np.sqrt(3) / 2\n        estimated_radius = 0.5 / (cols + 0.5)\n        \n        centers = []\n        for row in range(rows):\n            for col in range(cols):\n                x_offset = 0.5 * estimated_radius if row % 2 == 1 else 0\n                x = estimated_radius + col * 2 * estimated_radius + x_offset\n                y = estimated_radius + row * hex_height * 2 * estimated_radius\n                centers.append([x, y])\n        \n        centers = np.array(centers)\n        \n        # Apply rotation\n        if angle != 0:\n            center_point = np.mean(centers, axis=0)\n            cos_a = np.cos(angle)\n            sin_a = np.sin(angle)\n            rotation_matrix = np.array([[cos_a, -sin_a], [sin_a, cos_a]])\n            centers = (centers - center_point) @ rotation_matrix.T + center_point\n        \n        # Scale to fit\n        margin = 0.02\n        centers_min = centers.min(axis=0)\n        centers_max = centers.max(axis=0)\n        centers = (centers - centers_min) / (centers_max - centers_min)\n        centers = centers * (1 - 2 * margin) + margin\n        \n        # Select 26 circles\n        if len(centers) > n:\n            indices = []\n            remaining = list(range(len(centers)))\n            dists_to_center = np.linalg.norm(centers - np.array([0.5, 0.5]), axis=1)\n            first_idx = np.argmin(dists_to_center)\n            indices.append(first_idx)\n            remaining.remove(first_idx)\n            \n            while len(indices) < n:\n                max_min_dist = -1\n                best_idx = -1\n                for idx in remaining:\n                    min_dist = np.min(np.linalg.norm(centers[indices] - centers[idx], axis=1))\n                    if min_dist > max_min_dist:\n                        max_min_dist = min_dist\n                        best_idx = idx\n                indices.append(best_idx)\n                remaining.remove(best_idx)\n            \n            centers = centers[indices]\n        \n        distances = pdist(centers)\n        min_dist = np.min(distances) if len(distances) > 0 else 0.1\n        radii = np.full(n, min_dist / 2.5)\n        \n        for i in range(n):\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = min(radii[i], max_r * 0.95)\n        \n        return pack_to_vector(centers, radii)\n    \n    def initialize_diverse(seed):\n        \"\"\"Create diverse initial configurations (trial_6_4 style).\"\"\"\n        np.random.seed(seed)\n        \n        if seed % 5 == 0:\n            # Hexagonal-inspired\n            rows = 5\n            cols = 6\n            centers = []\n            for i in range(rows):\n                for j in range(cols):\n                    if len(centers) >= n:\n                        break\n                    x = 0.1 + 0.8 * j / (cols - 1)\n                    y = 0.1 + 0.8 * i / (rows - 1)\n                    if i % 2 == 1:\n                        x += 0.4 / cols\n                    centers.append([x, y])\n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.08)\n        elif seed % 5 == 1:\n            # Concentric\n            centers = []\n            for i in range(12):\n                angle = 2 * np.pi * i / 12\n                x = 0.5 + 0.35 * np.cos(angle)\n                y = 0.5 + 0.35 * np.sin(angle)\n                centers.append([x, y])\n            for i in range(8):\n                angle = 2 * np.pi * i / 8\n                x = 0.5 + 0.22 * np.cos(angle)\n                y = 0.5 + 0.22 * np.sin(angle)\n                centers.append([x, y])\n            for i in range(6):\n                angle = 2 * np.pi * i / 6\n                x = 0.5 + 0.1 * np.cos(angle)\n                y = 0.5 + 0.1 * np.sin(angle)\n                centers.append([x, y])\n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.07)\n        else:\n            # Random variations\n            margin = 0.15 + 0.02 * (seed % 4)\n            centers = np.random.uniform(margin, 1-margin, (n, 2))\n            radii = np.full(n, 0.06 + 0.01 * (seed % 3))\n        \n        return pack_to_vector(centers, radii)\n    \n    # ==================== OPTIMIZATION ====================\n    \n    def optimize_standard(x0, max_iter=5000):\n        \"\"\"Standard optimization with tight tolerances.\"\"\"\n        bounds = [(0, 1)] * (2 * n) + [(0.001, 0.5)] * n\n        nlc = NonlinearConstraint(constraint_function, 0, np.inf)\n        \n        result = minimize(\n            objective,\n            x0,\n            method='trust-constr',\n            bounds=bounds,\n            constraints=nlc,\n            options={\n                'maxiter': max_iter,\n                'verbose': 0,\n                'gtol': 1e-12,\n                'xtol': 1e-12,\n            }\n        )\n        \n        return result.x, -result.fun if result.success else -np.inf\n    \n    def ultra_refine(x):\n        \"\"\"Ultra-refinement with tightest tolerances.\"\"\"\n        bounds = [(0, 1)] * (2 * n) + [(0.001, 0.5)] * n\n        nlc = NonlinearConstraint(constraint_function, 0, np.inf)\n        \n        result = minimize(\n            objective,\n            x,\n            method='trust-constr',\n            bounds=bounds,\n            constraints=nlc,\n            options={\n                'maxiter': 8000,\n                'verbose': 0,\n                'gtol': 1e-14,\n                'xtol': 1e-14,\n                'barrier_tol': 1e-14\n            }\n        )\n        \n        return result.x, -result.fun if result.success else -np.inf\n    \n    # ==================== MEGA-ENSEMBLE ====================\n    \n    all_results = []\n    \n    # Phase 1: Run trial_6_6 approach (20 runs)\n    angles = [0, np.pi/8, np.pi/6, np.pi/4, np.pi/3, 3*np.pi/8, np.pi/2, 5*np.pi/8]\n    for i in range(20):\n        angle = angles[i % len(angles)]\n        seed = i\n        \n        x0 = initialize_hexagonal(angle=angle, seed=seed)\n        \n        # Add perturbation for diversity\n        if i % len(angles) > 0:\n            centers_init, radii_init = vector_to_pack(x0)\n            centers_init += np.random.normal(0, 0.02, centers_init.shape)\n            centers_init = np.clip(centers_init, 0.05, 0.95)\n            radii_init *= (1 + np.random.normal(0, 0.05, radii_init.shape))\n            radii_init = np.clip(radii_init, 0.01, 0.1)\n            x0 = pack_to_vector(centers_init, radii_init)\n        \n        x_opt, sum_opt = optimize_standard(x0, max_iter=4000)\n        \n        if validate_solution(x_opt):\n            all_results.append((x_opt, sum_opt))\n    \n    # Phase 2: Run trial_6_8 approach (15 runs)\n    for i in range(15):\n        x0 = initialize_hexagonal(angle=0, seed=20+i)\n        \n        if i > 0:\n            centers_init, radii_init = vector_to_pack(x0)\n            perturbation_scale = 0.01 + 0.02 * (i / 15)\n            centers_init += np.random.normal(0, perturbation_scale, centers_init.shape)\n            centers_init = np.clip(centers_init, 0.05, 0.95)\n            radii_init *= (1 + np.random.normal(0, 0.05 * (i / 15), radii_init.shape))\n            radii_init = np.clip(radii_init, 0.001, 0.15)\n            x0 = pack_to_vector(centers_init, radii_init)\n        \n        x_opt, sum_opt = optimize_standard(x0, max_iter=4000)\n        \n        if validate_solution(x_opt):\n            all_results.append((x_opt, sum_opt))\n    \n    # Phase 3: Run trial_6_4 approach (15 runs)\n    for i in range(15):\n        x0 = initialize_diverse(35+i)\n        x_opt, sum_opt = optimize_standard(x0, max_iter=4000)\n        \n        if validate_solution(x_opt):\n            all_results.append((x_opt, sum_opt))\n    \n    # Sort all results\n    all_results.sort(key=lambda x: x[1], reverse=True)\n    \n    # Phase 4: Ultra-refine top 20 results\n    refined_results = []\n    for i in range(min(20, len(all_results))):\n        x, _ = all_results[i]\n        x_refined, sum_refined = ultra_refine(x)\n        \n        if validate_solution(x_refined, tol=1e-8):\n            refined_results.append((x_refined, sum_refined))\n    \n    # Combine and sort\n    final_results = all_results + refined_results\n    final_results.sort(key=lambda x: x[1], reverse=True)\n    \n    # Return best result\n    if len(final_results) > 0:\n        best_x, best_sum = final_results[0]\n        best_centers, best_radii = vector_to_pack(best_x)\n        return best_centers, best_radii, best_sum\n    \n    # Fallback\n    side = int(np.ceil(np.sqrt(n)))\n    centers = []\n    for i in range(side):\n        for j in range(side):\n            if len(centers) >= n:\n                break\n            x = 0.15 + 0.7 * j / (side - 1)\n            y = 0.15 + 0.7 * i / (side - 1)\n            centers.append([x, y])\n    centers = np.array(centers[:n])\n    radii = np.full(n, 0.06)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.6278253239873695,
    "target_ratio": 0.9972771628035558,
    "combined_score": 0.9972771628035558,
    "eval_time": 227.59005069732666,
    "error": null
  },
  "prompt": "Create mega-ensemble combining all top approaches:\n\nFrom trial_6_6 (2.6276):\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def initialize_hexagonal(angle=0, seed=None):\n        \"\"\"Initialize with hexagonal packing pattern at given rotation angle.\"\"\"\n        if seed is not None:\n            np.random.seed(seed)\n        \n        # For 26 circles, use a 5x6 hexagonal grid (30 positions, take best 26)\n        rows = 6\n        cols = 5\n        \n        # Hexagonal spacing\n        hex_height = np.sqrt(3) / 2\n        \n        # Estimate radius for tight packing\n        estimated_radius = 0.5 / (cols + 0.5)\n        \n        centers = []\n        for row in range(rows):\n            for col in range(cols):\n                x_offset = 0.5 * estimated_radius if row % 2 == 1 else 0\n                x = estimated_radius + col * 2 * estimated_radius + x_offset\n                y = estimated_radius + row * hex_height * 2 * estimated_radius\n                centers.append([x, y])\n        \n        centers = np.array(centers)\n        \n        # Apply rotation around center\n        if angle != 0:\n            center_point = np.mean(centers, axis=0)\n            cos_a = np.cos(angle)\n            sin_a = np.sin(angle)\n            rotation_matrix = np.array([[cos_a, -sin_a], [sin_a, cos_a]])\n            centers = (centers - center_point) @ rotation_matrix.T + center_point\n        \n        # Scale to fit in unit square with margin\n        margin = 0.02\n        centers_min = centers.min(axis=0)\n        centers_max = centers.max(axis=0)\n        centers = (centers - centers_min) / (centers_max - centers_min)\n        centers = centers * (1 - 2 * margin) + margin\n        \n        # Select 26 most evenly distributed circles\n        if len(centers) > n:\n            indices = []\n            remaining = list(range(len(centers)))\n            \n            # Start with center closest to (0.5, 0.5)\n            dists_to_center = np.linalg.norm(centers - np.array([0.5, 0.5]), axis=1)\n            first_idx = np.argmin(dists_to_center)\n            indices.append(first_idx)\n            remaining.remove(first_idx)\n            \n            # Greedily add circles that maximize minimum distance to selected\n            while len(indices) < n:\n                max_min_dist = -1\n                best_idx = -1\n                for idx in remaining:\n                    min_dist = np.min(np.linalg.norm(centers[indices] - centers[idx], axis=1))\n                    if min_dist > max_min_dist:\n                        max_min_dist = min_dist\n                        best_idx = idx\n                indices.append(best_idx)\n                remaining.remove(best_idx)\n            \n            centers = centers[indices]\n        \n        # Initialize radii based on minimum pairwise distance\n        distances = pdist(centers)\n        min_dist = np.min(distances) if len(distances) > 0 else 0.1\n        radii = np.full(n, min_dist / 2.5)\n        \n        # Adjust radii to respect boundaries\n        for i in range(n):\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = min(radii[i], max_r * 0.95)\n        \n        return centers, radii\n    \n    def pack_to_vector(centers, radii):\n        \"\"\"Convert centers and radii to optimization vector.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def vector_to_pack(x):\n        \"\"\"Convert optimization vector to centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Objective: maximize sum of radii (minimize negative sum).\"\"\"\n        _, radii = vector_to_pack(x)\n        return -np.sum(radii)\n    \n    def constraint_no_overlap(x):\n        \"\"\"Constraint: circles must not overlap.\"\"\"\n        centers, radii = vector_to_pack(x)\n        dists = squareform(pdist(centers))\n        np.fill_diagonal(dists, np.inf)\n        \n        # For each pair, distance - sum of radii should be >= 0\n        constraints = []\n        for i in range(n):\n            for j in range(i+1, n):\n                constraints.append(dists[i, j] - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    def constraint_inside_square(x):\n        \"\"\"Constraint: circles must be inside unit square.\"\"\"\n        centers, radii = vector_to_pack(x)\n        constraints = []\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        return np.array(constraints)\n    \n    def verify_solution(centers, radii):\n        \"\"\"Verify that solution satisfies all constraints.\"\"\"\n        # Check inside square\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < -1e-6 or\n                centers[i, 0] + radii[i] > 1 + 1e-6 or\n                centers[i, 1] - radii[i] < -1e-6 or\n                centers[i, 1] + radii[i] > 1 + 1e-6):\n                return False\n        \n        # Check no overlap\n        dists = squareform(pdist(centers))\n        for i in range(n):\n            for j in range(i+1, n):\n                if dists[i, j] < radii[i] + radii[j] - 1e-6:\n                    return False\n        \n        return True\n    \n    def optimize_from_init(centers_init, radii_init, max_iter=20000):\n        \"\"\"Run optimization from given initialization.\"\"\"\n        x0 = pack_to_vector(centers_init, radii_init)\n        \n        # Bounds\n        bounds = []\n        for i in range(n):\n            bounds.append((0.0, 1.0))  # x\n            bounds.append((0.0, 1.0))  # y\n        for i in range(n):\n            bounds.append((0.001, 0.5))  # radius\n        \n        # Constraints with scaling for better conditioning\n        nlc_overlap = NonlinearConstraint(constraint_no_overlap, 0, np.inf)\n        nlc_inside = NonlinearConstraint(constraint_inside_square, 0, np.inf)\n        \n        # Optimize with tight tolerances\n        result = minimize(\n            objective,\n            x0,\n            method='trust-constr',\n            bounds=bounds,\n            constraints=[nlc_overlap, nlc_inside],\n            options={\n                'maxiter': max_iter,\n                'verbose': 0,\n                'gtol': 1e-12,\n                'xtol': 1e-12,\n            }\n        )\n        \n        centers_opt, radii_opt = vector_to_pack(result.x)\n        sum_radii = np.sum(radii_opt)\n        valid = verify_solution(centers_opt, radii_opt)\n        \n        return centers_opt, radii_opt, sum_radii, valid\n    \n    # Phase 1: Run 40 optimizations with smart initialization\n    all_results = []\n    \n    # Test 8 different rotation angles for better coverage\n    angles = [0, np.pi/8, np.pi/6, np.pi/4, np.pi/3, 3*np.pi/8, np.pi/2, 5*np.pi/8]\n    \n    trial = 0\n    for angle_idx, angle in enumerate(angles):\n        for perturbation in range(5):\n            # Initialize with rotation angle\n            centers_init, radii_init = initialize_hexagonal(angle=angle, seed=trial)\n            \n            # Add perturbation for diversity (except first of each angle)\n            if perturbation > 0:\n                centers_init += np.random.normal(0, 0.02, centers_init.shape)\n                centers_init = np.clip(centers_init, 0.05, 0.95)\n                radii_init *= (1 + np.random.normal(0, 0.05, radii_init.shape))\n                radii_init = np.clip(radii_init, 0.01, 0.1)\n            \n            # Optimize\n            centers, radii, sum_radii, valid = optimize_from_init(centers_init, radii_init)\n            \n            if valid:\n                all_results.append({\n                    'centers': centers.copy(),\n                    'radii': radii.copy(),\n                    'sum_radii': sum_radii\n                })\n            \n            trial += 1\n    \n    # Sort by sum of radii\n    all_results.sort(key=lambda x: x['sum_radii'], reverse=True)\n    \n    # Phase 2: Refinement of top 10 results with extended iterations\n    refined_results = []\n    \n    for i in range(min(10, len(all_results))):\n        result = all_results[i]\n        \n        # Apply refinement with extended iterations and tighter tolerances\n        centers_refined, radii_refined, sum_refined, valid = optimize_from_init(\n            result['centers'], \n            result['radii'], \n            max_iter=10000\n        )\n        \n        if valid:\n            refined_results.append({\n                'centers': centers_refined.copy(),\n                'radii': radii_refined.copy(),\n                'sum_radii': sum_refined\n            })\n    \n    # Combine all valid results\n    all_valid_results = all_results + refined_results\n    all_valid_results.sort(key=lambda x: x['sum_radii'], reverse=True)\n    \n    # Return best result\n    if len(all_valid_results) > 0:\n        best = all_valid_results[0]\n        return best['centers'], best['radii'], best['sum_radii']\n    else:\n        # Fallback: return basic initialization if all optimizations failed\n        centers_init, radii_init = initialize_hexagonal(angle=0, seed=0)\n        return centers_init, radii_init, np.sum(radii_init)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nFrom trial_6_8 (2.6243):\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using\n    sequential refinement starting from trial_5_2 base solution.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def create_constraints(tolerance):\n        \"\"\"Create constraints with given tolerance.\"\"\"\n        \n        def boundary_constraints(x):\n            \"\"\"All circles must be inside [0,1]x[0,1].\"\"\"\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            \n            constraints = np.zeros(4*n)\n            constraints[0:n] = centers[:, 0] - radii\n            constraints[n:2*n] = 1 - centers[:, 0] - radii\n            constraints[2*n:3*n] = centers[:, 1] - radii\n            constraints[3*n:4*n] = 1 - centers[:, 1] - radii\n            \n            return constraints\n        \n        def non_overlap_constraints(x):\n            \"\"\"No two circles may overlap.\"\"\"\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            \n            dists = squareform(pdist(centers))\n            \n            constraints = []\n            for i in range(n):\n                for j in range(i+1, n):\n                    constraints.append(dists[i, j] - radii[i] - radii[j])\n            \n            return np.array(constraints)\n        \n        def radii_positive(x):\n            \"\"\"All radii must be non-negative.\"\"\"\n            radii = x[2*n:]\n            return radii\n        \n        def all_constraints(x):\n            return np.concatenate([\n                boundary_constraints(x),\n                non_overlap_constraints(x),\n                radii_positive(x)\n            ])\n        \n        n_boundary = 4*n\n        n_overlap = n*(n-1)//2\n        n_radii = n\n        n_total = n_boundary + n_overlap + n_radii\n        \n        return NonlinearConstraint(\n            all_constraints,\n            -tolerance * np.ones(n_total),\n            np.inf * np.ones(n_total)\n        )\n    \n    def initialize_hexagonal(seed=0):\n        \"\"\"Initialize with hexagonal packing pattern.\"\"\"\n        np.random.seed(seed)\n        rows = 6\n        cols = 5\n        \n        hex_height = np.sqrt(3) / 2\n        estimated_radius = 0.5 / (cols + 0.5)\n        \n        centers = []\n        for row in range(rows):\n            for col in range(cols):\n                x_offset = 0.5 * estimated_radius if row % 2 == 1 else 0\n                x = estimated_radius + col * 2 * estimated_radius + x_offset\n                y = estimated_radius + row * hex_height * 2 * estimated_radius\n                centers.append([x, y])\n        \n        centers = np.array(centers)\n        \n        margin = 0.02\n        centers_min = centers.min(axis=0)\n        centers_max = centers.max(axis=0)\n        centers = (centers - centers_min) / (centers_max - centers_min)\n        centers = centers * (1 - 2 * margin) + margin\n        \n        if len(centers) > n:\n            indices = []\n            remaining = list(range(len(centers)))\n            \n            dists_to_center = np.linalg.norm(centers - np.array([0.5, 0.5]), axis=1)\n            first_idx = np.argmin(dists_to_center)\n            indices.append(first_idx)\n            remaining.remove(first_idx)\n            \n            while len(indices) < n:\n                max_min_dist = -1\n                best_idx = -1\n                for idx in remaining:\n                    min_dist = np.min(np.linalg.norm(centers[indices] - centers[idx], axis=1))\n                    if min_dist > max_min_dist:\n                        max_min_dist = min_dist\n                        best_idx = idx\n                indices.append(best_idx)\n                remaining.remove(best_idx)\n            \n            centers = centers[indices]\n        \n        distances = pdist(centers)\n        min_dist = np.min(distances) if len(distances) > 0 else 0.1\n        radii = np.full(n, min_dist / 2.5)\n        \n        for i in range(n):\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = min(radii[i], max_r * 0.95)\n        \n        return np.concatenate([centers.flatten(), radii])\n    \n    def three_phase_optimization(x0):\n        \"\"\"Run three-phase optimization with progressive constraint tightening.\"\"\"\n        \n        # Phase 1: Relaxed constraints\n        tolerance1 = 1e-4\n        constraints1 = create_constraints(tolerance1)\n        \n        result1 = minimize(\n            objective,\n            x0,\n            method='trust-constr',\n            constraints=constraints1,\n            options={'maxiter': 800, 'verbose': 0}\n        )\n        \n        if not result1.success:\n            return None, -np.inf\n        \n        # Phase 2: Medium constraints\n        tolerance2 = 1e-6\n        constraints2 = create_constraints(tolerance2)\n        \n        result2 = minimize(\n            objective,\n            result1.x,\n            method='trust-constr',\n            constraints=constraints2,\n            options={'maxiter': 800, 'verbose': 0}\n        )\n        \n        if not result2.success:\n            return result1.x, -result1.fun\n        \n        # Phase 3: Strict constraints\n        tolerance3 = 1e-10\n        constraints3 = create_constraints(tolerance3)\n        \n        result3 = minimize(\n            objective,\n            result2.x,\n            method='trust-constr',\n            constraints=constraints3,\n            options={'maxiter': 800, 'verbose': 0}\n        )\n        \n        if not result3.success:\n            return result2.x, -result2.fun\n        \n        return result3.x, -result3.fun\n    \n    def is_valid_packing(x, tol=1e-6):\n        \"\"\"Check if packing satisfies all constraints.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        # Check inside square\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < -tol or\n                centers[i, 0] + radii[i] > 1 + tol or\n                centers[i, 1] - radii[i] < -tol or\n                centers[i, 1] + radii[i] > 1 + tol):\n                return False\n        \n        # Check no overlap\n        dists = squareform(pdist(centers))\n        for i in range(n):\n            for j in range(i+1, n):\n                if dists[i, j] < radii[i] + radii[j] - tol:\n                    return False\n        \n        return True\n    \n    # STEP 1: Get initial best solution from trial_5_2 base algorithm\n    valid_results = []\n    n_restarts = 12\n    \n    for restart in range(n_restarts):\n        x0 = initialize_hexagonal(seed=restart)\n        \n        if restart > 0:\n            perturbation_scale = 0.01 + 0.02 * (restart / n_restarts)\n            centers_pert = x0[:2*n].reshape(n, 2)\n            centers_pert += np.random.normal(0, perturbation_scale, centers_pert.shape)\n            centers_pert = np.clip(centers_pert, 0.05, 0.95)\n            \n            radii_pert = x0[2*n:]\n            radii_pert *= (1 + np.random.normal(0, 0.05 * (restart / n_restarts), radii_pert.shape))\n            radii_pert = np.clip(radii_pert, 0.001, 0.15)\n            \n            x0 = np.concatenate([centers_pert.flatten(), radii_pert])\n        \n        x_opt, sum_opt = three_phase_optimization(x0)\n        \n        if x_opt is not None and is_valid_packing(x_opt):\n            valid_results.append((x_opt, sum_opt))\n    \n    valid_results.sort(key=lambda x: x[1], reverse=True)\n    \n    if len(valid_results) == 0:\n        # Fallback\n        grid_size = int(np.ceil(np.sqrt(n)))\n        spacing = 1.0 / grid_size\n        r = spacing / 3.0\n        \n        centers = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(centers) >= n:\n                    break\n                x = (i + 0.5) * spacing\n                y = (j + 0.5) * spacing\n                centers.append([x, y])\n            if len(centers) >= n:\n                break\n        \n        best_centers = np.array(centers[:n])\n        best_radii = np.full(n, r)\n        best_sum = n * r\n        return best_centers, best_radii, best_sum\n    \n    # Get initial best\n    best_x, best_sum = valid_results[0]\n    \n    # STEP 2: Sequential refinement loop (10 iterations)\n    n_refinement_iterations = 10\n    n_perturbations_per_iter = 20\n    \n    perturbation_scale = 1e-6  # Start with very small perturbations\n    min_perturbation_scale = 1e-9\n    scale_reduction_factor = 0.5\n    \n    for refinement_iter in range(n_refinement_iterations):\n        improved = False\n        \n        # Generate and test perturbations\n        for pert_idx in range(n_perturbations_per_iter):\n            np.random.seed(10000 + refinement_iter * 100 + pert_idx)\n            \n            # Create perturbed solution\n            x_perturbed = best_x.copy()\n            \n            # Perturb centers\n            centers_p = x_perturbed[:2*n].reshape(n, 2)\n            centers_p += np.random.normal(0, perturbation_scale, centers_p.shape)\n            centers_p = np.clip(centers_p, 0.01, 0.99)\n            x_perturbed[:2*n] = centers_p.flatten()\n            \n            # Perturb radii slightly\n            radii_p = x_perturbed[2*n:]\n            radii_p *= (1 + np.random.normal(0, perturbation_scale * 0.1, radii_p.shape))\n            radii_p = np.clip(radii_p, 0.001, 0.2)\n            x_perturbed[2*n:] = radii_p\n            \n            # Optimize with ultra-tight tolerance\n            tolerance = 1e-12\n            constraints = create_constraints(tolerance)\n            \n            result = minimize(\n                objective,\n                x_perturbed,\n                method='trust-constr',\n                constraints=constraints,\n                options={'maxiter': 1500, 'verbose': 0}\n            )\n            \n            # Check if valid and improved\n            if result.success and is_valid_packing(result.x, tol=1e-8):\n                sum_new = -result.fun\n                if sum_new > best_sum + 1e-10:  # Require meaningful improvement\n                    best_x = result.x\n                    best_sum = sum_new\n                    improved = True\n        \n        # If no improvement, reduce perturbation scale\n        if not improved:\n            perturbation_scale *= scale_reduction_factor\n            if perturbation_scale < min_perturbation_scale:\n                perturbation_scale = min_perturbation_scale\n    \n    # Extract final result\n    best_centers = best_x[:2*n].reshape(n, 2)\n    best_radii = best_x[2*n:]\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nFrom trial_6_4 (2.6219):\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom dataclasses import dataclass\n\n@dataclass\nclass PackingResult:\n    centers: np.ndarray\n    radii: np.ndarray\n    sum_radii: float\n    valid: bool\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses adaptive restart strategy with ultra-tight tolerances and refinement.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def create_initial_guess(seed):\n        \"\"\"Create diverse initial configurations\"\"\"\n        np.random.seed(seed)\n        \n        if seed == 0:\n            # Hexagonal-inspired grid\n            rows = 5\n            cols = 6\n            centers = []\n            for i in range(rows):\n                for j in range(cols):\n                    if len(centers) >= n:\n                        break\n                    x = 0.1 + 0.8 * j / (cols - 1)\n                    y = 0.1 + 0.8 * i / (rows - 1)\n                    if i % 2 == 1:\n                        x += 0.4 / cols\n                    centers.append([x, y])\n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.08)\n            \n        elif seed == 1:\n            # Square grid with perturbation\n            side = int(np.ceil(np.sqrt(n)))\n            centers = []\n            for i in range(side):\n                for j in range(side):\n                    if len(centers) >= n:\n                        break\n                    x = 0.15 + 0.7 * j / (side - 1) + np.random.uniform(-0.02, 0.02)\n                    y = 0.15 + 0.7 * i / (side - 1) + np.random.uniform(-0.02, 0.02)\n                    centers.append([x, y])\n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.075)\n            \n        elif seed == 2:\n            # Concentric circles\n            centers = []\n            # Outer ring\n            for i in range(12):\n                angle = 2 * np.pi * i / 12\n                x = 0.5 + 0.35 * np.cos(angle)\n                y = 0.5 + 0.35 * np.sin(angle)\n                centers.append([x, y])\n            # Middle ring\n            for i in range(8):\n                angle = 2 * np.pi * i / 8\n                x = 0.5 + 0.22 * np.cos(angle)\n                y = 0.5 + 0.22 * np.sin(angle)\n                centers.append([x, y])\n            # Inner circles\n            for i in range(6):\n                angle = 2 * np.pi * i / 6\n                x = 0.5 + 0.1 * np.cos(angle)\n                y = 0.5 + 0.1 * np.sin(angle)\n                centers.append([x, y])\n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.07)\n            \n        elif seed == 3:\n            # Random with clustering\n            centers = np.random.uniform(0.2, 0.8, (n, 2))\n            radii = np.full(n, 0.065)\n            \n        elif seed == 4:\n            # Diagonal arrangement\n            centers = []\n            per_diag = n // 2\n            for i in range(per_diag):\n                t = i / (per_diag - 1)\n                centers.append([0.15 + 0.7 * t, 0.15 + 0.7 * t])\n            for i in range(n - per_diag):\n                t = i / (n - per_diag - 1)\n                centers.append([0.15 + 0.7 * t, 0.85 - 0.7 * t])\n            centers = np.array(centers)\n            radii = np.full(n, 0.07)\n            \n        else:\n            # Random variations with different densities\n            margin = 0.15 + 0.02 * (seed % 4)\n            centers = np.random.uniform(margin, 1-margin, (n, 2))\n            radii = np.full(n, 0.06 + 0.01 * (seed % 3))\n        \n        return np.concatenate([centers.flatten(), radii])\n    \n    def unpack_variables(x):\n        \"\"\"Convert flat array to centers and radii\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Maximize sum of radii (minimize negative sum)\"\"\"\n        _, radii = unpack_variables(x)\n        return -np.sum(radii)\n    \n    def constraint_function(x):\n        \"\"\"\n        Compute all constraint values.\n        Returns array where each element should be >= 0.\n        \"\"\"\n        centers, radii = unpack_variables(x)\n        constraints = []\n        \n        # Boundary constraints: center \u00b1 radius within [0,1]\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        \n        # Non-overlap constraints: distance > sum of radii\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                             (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Non-negative radii\n        for i in range(n):\n            constraints.append(radii[i])\n        \n        return np.array(constraints)\n    \n    def optimize_with_tight_tolerances(x0):\n        \"\"\"\n        Optimize with tight tolerances using trust-constr\n        \"\"\"\n        bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n        nlc = NonlinearConstraint(constraint_function, 0, np.inf)\n        \n        result = minimize(\n            objective,\n            x0,\n            method='trust-constr',\n            bounds=bounds,\n            constraints=nlc,\n            options={\n                'maxiter': 25000,\n                'gtol': 1e-12,\n                'xtol': 1e-12,\n                'barrier_tol': 1e-12\n            }\n        )\n        \n        return result\n    \n    def validate_solution(x):\n        \"\"\"Check if solution satisfies all constraints\"\"\"\n        constraints = constraint_function(x)\n        return np.all(constraints >= -1e-6)\n    \n    def ultra_refine(x):\n        \"\"\"Ultra-fine refinement with tightest tolerances\"\"\"\n        bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n        nlc = NonlinearConstraint(constraint_function, 0, np.inf)\n        \n        result = minimize(\n            objective,\n            x,\n            method='trust-constr',\n            bounds=bounds,\n            constraints=nlc,\n            options={\n                'maxiter': 30000,\n                'gtol': 1e-13,\n                'xtol': 1e-13,\n                'barrier_tol': 1e-13\n            }\n        )\n        return result\n    \n    # Adaptive restart strategy with 20 restarts\n    results = []\n    \n    for seed in range(20):\n        x0 = create_initial_guess(seed)\n        result = optimize_with_tight_tolerances(x0)\n        \n        if validate_solution(result.x):\n            centers, radii = unpack_variables(result.x)\n            sum_radii = np.sum(radii)\n            results.append(PackingResult(centers, radii, sum_radii, True))\n    \n    # Sort by sum of radii\n    results.sort(key=lambda r: r.sum_radii, reverse=True)\n    \n    # Ultra-refine top 5 solutions\n    refined_results = []\n    for i in range(min(5, len(results))):\n        x = np.concatenate([results[i].centers.flatten(), results[i].radii])\n        refined = ultra_refine(x)\n        \n        if validate_solution(refined.x):\n            centers, radii = unpack_variables(refined.x)\n            sum_radii = np.sum(radii)\n            refined_results.append(PackingResult(centers, radii, sum_radii, True))\n    \n    # Combine all results and pick best\n    all_results = results + refined_results\n    all_results.sort(key=lambda r: r.sum_radii, reverse=True)\n    \n    if all_results:\n        best = all_results[0]\n        return best.centers, best.radii, best.sum_radii\n    \n    # Fallback: simple grid if all optimizations fail\n    side = int(np.ceil(np.sqrt(n)))\n    centers = []\n    for i in range(side):\n        for j in range(side):\n            if len(centers) >= n:\n                break\n            x = 0.15 + 0.7 * j / (side - 1)\n            y = 0.15 + 0.7 * i / (side - 1)\n            centers.append([x, y])\n    centers = np.array(centers[:n])\n    radii = np.full(n, 0.06)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nMega-ensemble strategy:\n1. Run trial_6_6's approach 20 times\n2. Run trial_6_8's approach 15 times\n3. Run trial_6_4's approach 15 times\n4. Collect all valid results (50 total)\n5. Take top 20 results\n6. Apply ultra-refinement to each:\n   - Sequential perturbation refinement\n   - Ultra-tight tolerances (1e-14)\n7. Return absolute best\n\nRequirements:\n- 50 total runs across 3 methods\n- Top 20 refinement\n- Ultra-tight tolerances\n- Efficient execution (< 300s)\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Mega-ensemble combining top approaches from trial_6_6, trial_6_8, and trial_6_4.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # ==================== SHARED UTILITIES ====================\n    \n    def pack_to_vector(centers, radii):\n        \"\"\"Convert centers and radii to optimization vector.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def vector_to_pack(x):\n        \"\"\"Convert optimization vector to centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Objective: maximize sum of radii (minimize negative sum).\"\"\"\n        _, radii = vector_to_pack(x)\n        return -np.sum(radii)\n    \n    def constraint_function(x):\n        \"\"\"Compute all constraint values.\"\"\"\n        centers, radii = vector_to_pack(x)\n        constraints = []\n        \n        # Boundary constraints\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])\n            constraints.append(1 - centers[i, 0] - radii[i])\n            constraints.append(centers[i, 1] - radii[i])\n            constraints.append(1 - centers[i, 1] - radii[i])\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                             (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Non-negative radii\n        for i in range(n):\n            constraints.append(radii[i])\n        \n        return np.array(constraints)\n    \n    def validate_solution(x, tol=1e-6):\n        \"\"\"Check if solution satisfies all constraints.\"\"\"\n        constraints = constraint_function(x)\n        return np.all(constraints >= -tol)\n    \n    # ==================== INITIALIZATION METHODS ====================\n    \n    def initialize_hexagonal(angle=0, seed=None):\n        \"\"\"Initialize with hexagonal packing pattern (trial_6_6 style).\"\"\"\n        if seed is not None:\n            np.random.seed(seed)\n        \n        rows = 6\n        cols = 5\n        hex_height = np.sqrt(3) / 2\n        estimated_radius = 0.5 / (cols + 0.5)\n        \n        centers = []\n        for row in range(rows):\n            for col in range(cols):\n                x_offset = 0.5 * estimated_radius if row % 2 == 1 else 0\n                x = estimated_radius + col * 2 * estimated_radius + x_offset\n                y = estimated_radius + row * hex_height * 2 * estimated_radius\n                centers.append([x, y])\n        \n        centers = np.array(centers)\n        \n        # Apply rotation\n        if angle != 0:\n            center_point = np.mean(centers, axis=0)\n            cos_a = np.cos(angle)\n            sin_a = np.sin(angle)\n            rotation_matrix = np.array([[cos_a, -sin_a], [sin_a, cos_a]])\n            centers = (centers - center_point) @ rotation_matrix.T + center_point\n        \n        # Scale to fit\n        margin = 0.02\n        centers_min = centers.min(axis=0)\n        centers_max = centers.max(axis=0)\n        centers = (centers - centers_min) / (centers_max - centers_min)\n        centers = centers * (1 - 2 * margin) + margin\n        \n        # Select 26 circles\n        if len(centers) > n:\n            indices = []\n            remaining = list(range(len(centers)))\n            dists_to_center = np.linalg.norm(centers - np.array([0.5, 0.5]), axis=1)\n            first_idx = np.argmin(dists_to_center)\n            indices.append(first_idx)\n            remaining.remove(first_idx)\n            \n            while len(indices) < n:\n                max_min_dist = -1\n                best_idx = -1\n                for idx in remaining:\n                    min_dist = np.min(np.linalg.norm(centers[indices] - centers[idx], axis=1))\n                    if min_dist > max_min_dist:\n                        max_min_dist = min_dist\n                        best_idx = idx\n                indices.append(best_idx)\n                remaining.remove(best_idx)\n            \n            centers = centers[indices]\n        \n        distances = pdist(centers)\n        min_dist = np.min(distances) if len(distances) > 0 else 0.1\n        radii = np.full(n, min_dist / 2.5)\n        \n        for i in range(n):\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = min(radii[i], max_r * 0.95)\n        \n        return pack_to_vector(centers, radii)\n    \n    def initialize_diverse(seed):\n        \"\"\"Create diverse initial configurations (trial_6_4 style).\"\"\"\n        np.random.seed(seed)\n        \n        if seed % 5 == 0:\n            # Hexagonal-inspired\n            rows = 5\n            cols = 6\n            centers = []\n            for i in range(rows):\n                for j in range(cols):\n                    if len(centers) >= n:\n                        break\n                    x = 0.1 + 0.8 * j / (cols - 1)\n                    y = 0.1 + 0.8 * i / (rows - 1)\n                    if i % 2 == 1:\n                        x += 0.4 / cols\n                    centers.append([x, y])\n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.08)\n        elif seed % 5 == 1:\n            # Concentric\n            centers = []\n            for i in range(12):\n                angle = 2 * np.pi * i / 12\n                x = 0.5 + 0.35 * np.cos(angle)\n                y = 0.5 + 0.35 * np.sin(angle)\n                centers.append([x, y])\n            for i in range(8):\n                angle = 2 * np.pi * i / 8\n                x = 0.5 + 0.22 * np.cos(angle)\n                y = 0.5 + 0.22 * np.sin(angle)\n                centers.append([x, y])\n            for i in range(6):\n                angle = 2 * np.pi * i / 6\n                x = 0.5 + 0.1 * np.cos(angle)\n                y = 0.5 + 0.1 * np.sin(angle)\n                centers.append([x, y])\n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.07)\n        else:\n            # Random variations\n            margin = 0.15 + 0.02 * (seed % 4)\n            centers = np.random.uniform(margin, 1-margin, (n, 2))\n            radii = np.full(n, 0.06 + 0.01 * (seed % 3))\n        \n        return pack_to_vector(centers, radii)\n    \n    # ==================== OPTIMIZATION ====================\n    \n    def optimize_standard(x0, max_iter=5000):\n        \"\"\"Standard optimization with tight tolerances.\"\"\"\n        bounds = [(0, 1)] * (2 * n) + [(0.001, 0.5)] * n\n        nlc = NonlinearConstraint(constraint_function, 0, np.inf)\n        \n        result = minimize(\n            objective,\n            x0,\n            method='trust-constr',\n            bounds=bounds,\n            constraints=nlc,\n            options={\n                'maxiter': max_iter,\n                'verbose': 0,\n                'gtol': 1e-12,\n                'xtol': 1e-12,\n            }\n        )\n        \n        return result.x, -result.fun if result.success else -np.inf\n    \n    def ultra_refine(x):\n        \"\"\"Ultra-refinement with tightest tolerances.\"\"\"\n        bounds = [(0, 1)] * (2 * n) + [(0.001, 0.5)] * n\n        nlc = NonlinearConstraint(constraint_function, 0, np.inf)\n        \n        result = minimize(\n            objective,\n            x,\n            method='trust-constr',\n            bounds=bounds,\n            constraints=nlc,\n            options={\n                'maxiter': 8000,\n                'verbose': 0,\n                'gtol': 1e-14,\n                'xtol': 1e-14,\n                'barrier_tol': 1e-14\n            }\n        )\n        \n        return result.x, -result.fun if result.success else -np.inf\n    \n    # ==================== MEGA-ENSEMBLE ====================\n    \n    all_results = []\n    \n    # Phase 1: Run trial_6_6 approach (20 runs)\n    angles = [0, np.pi/8, np.pi/6, np.pi/4, np.pi/3, 3*np.pi/8, np.pi/2, 5*np.pi/8]\n    for i in range(20):\n        angle = angles[i % len(angles)]\n        seed = i\n        \n        x0 = initialize_hexagonal(angle=angle, seed=seed)\n        \n        # Add perturbation for diversity\n        if i % len(angles) > 0:\n            centers_init, radii_init = vector_to_pack(x0)\n            centers_init += np.random.normal(0, 0.02, centers_init.shape)\n            centers_init = np.clip(centers_init, 0.05, 0.95)\n            radii_init *= (1 + np.random.normal(0, 0.05, radii_init.shape))\n            radii_init = np.clip(radii_init, 0.01, 0.1)\n            x0 = pack_to_vector(centers_init, radii_init)\n        \n        x_opt, sum_opt = optimize_standard(x0, max_iter=4000)\n        \n        if validate_solution(x_opt):\n            all_results.append((x_opt, sum_opt))\n    \n    # Phase 2: Run trial_6_8 approach (15 runs)\n    for i in range(15):\n        x0 = initialize_hexagonal(angle=0, seed=20+i)\n        \n        if i > 0:\n            centers_init, radii_init = vector_to_pack(x0)\n            perturbation_scale = 0.01 + 0.02 * (i / 15)\n            centers_init += np.random.normal(0, perturbation_scale, centers_init.shape)\n            centers_init = np.clip(centers_init, 0.05, 0.95)\n            radii_init *= (1 + np.random.normal(0, 0.05 * (i / 15), radii_init.shape))\n            radii_init = np.clip(radii_init, 0.001, 0.15)\n            x0 = pack_to_vector(centers_init, radii_init)\n        \n        x_opt, sum_opt = optimize_standard(x0, max_iter=4000)\n        \n        if validate_solution(x_opt):\n            all_results.append((x_opt, sum_opt))\n    \n    # Phase 3: Run trial_6_4 approach (15 runs)\n    for i in range(15):\n        x0 = initialize_diverse(35+i)\n        x_opt, sum_opt = optimize_standard(x0, max_iter=4000)\n        \n        if validate_solution(x_opt):\n            all_results.append((x_opt, sum_opt))\n    \n    # Sort all results\n    all_results.sort(key=lambda x: x[1], reverse=True)\n    \n    # Phase 4: Ultra-refine top 20 results\n    refined_results = []\n    for i in range(min(20, len(all_results))):\n        x, _ = all_results[i]\n        x_refined, sum_refined = ultra_refine(x)\n        \n        if validate_solution(x_refined, tol=1e-8):\n            refined_results.append((x_refined, sum_refined))\n    \n    # Combine and sort\n    final_results = all_results + refined_results\n    final_results.sort(key=lambda x: x[1], reverse=True)\n    \n    # Return best result\n    if len(final_results) > 0:\n        best_x, best_sum = final_results[0]\n        best_centers, best_radii = vector_to_pack(best_x)\n        return best_centers, best_radii, best_sum\n    \n    # Fallback\n    side = int(np.ceil(np.sqrt(n)))\n    centers = []\n    for i in range(side):\n        for j in range(side):\n            if len(centers) >= n:\n                break\n            x = 0.15 + 0.7 * j / (side - 1)\n            y = 0.15 + 0.7 * i / (side - 1)\n            centers.append([x, y])\n    centers = np.array(centers[:n])\n    radii = np.full(n, 0.06)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T19:24:24.392428",
  "cost_data": null
}