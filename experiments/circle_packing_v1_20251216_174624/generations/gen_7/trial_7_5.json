{
  "trial_id": "trial_7_5",
  "generation": 7,
  "parent_id": "trial_6_4",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom dataclasses import dataclass\n\n@dataclass\nclass PackingResult:\n    centers: np.ndarray\n    radii: np.ndarray\n    sum_radii: float\n    valid: bool\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses 4-phase optimization with ultra-tight tolerances and 30 restarts.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def create_initial_guess(seed):\n        \"\"\"Create diverse initial configurations\"\"\"\n        np.random.seed(seed)\n        \n        if seed == 0:\n            # Hexagonal-inspired grid\n            rows = 5\n            cols = 6\n            centers = []\n            for i in range(rows):\n                for j in range(cols):\n                    if len(centers) >= n:\n                        break\n                    x = 0.1 + 0.8 * j / (cols - 1)\n                    y = 0.1 + 0.8 * i / (rows - 1)\n                    if i % 2 == 1:\n                        x += 0.4 / cols\n                    centers.append([x, y])\n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.08)\n            \n        elif seed == 1:\n            # Square grid with perturbation\n            side = int(np.ceil(np.sqrt(n)))\n            centers = []\n            for i in range(side):\n                for j in range(side):\n                    if len(centers) >= n:\n                        break\n                    x = 0.15 + 0.7 * j / (side - 1) + np.random.uniform(-0.02, 0.02)\n                    y = 0.15 + 0.7 * i / (side - 1) + np.random.uniform(-0.02, 0.02)\n                    centers.append([x, y])\n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.075)\n            \n        elif seed == 2:\n            # Concentric circles\n            centers = []\n            # Outer ring\n            for i in range(12):\n                angle = 2 * np.pi * i / 12\n                x = 0.5 + 0.35 * np.cos(angle)\n                y = 0.5 + 0.35 * np.sin(angle)\n                centers.append([x, y])\n            # Middle ring\n            for i in range(8):\n                angle = 2 * np.pi * i / 8\n                x = 0.5 + 0.22 * np.cos(angle)\n                y = 0.5 + 0.22 * np.sin(angle)\n                centers.append([x, y])\n            # Inner circles\n            for i in range(6):\n                angle = 2 * np.pi * i / 6\n                x = 0.5 + 0.1 * np.cos(angle)\n                y = 0.5 + 0.1 * np.sin(angle)\n                centers.append([x, y])\n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.07)\n            \n        elif seed == 3:\n            # Random with clustering\n            centers = np.random.uniform(0.2, 0.8, (n, 2))\n            radii = np.full(n, 0.065)\n            \n        elif seed == 4:\n            # Diagonal arrangement\n            centers = []\n            per_diag = n // 2\n            for i in range(per_diag):\n                t = i / (per_diag - 1)\n                centers.append([0.15 + 0.7 * t, 0.15 + 0.7 * t])\n            for i in range(n - per_diag):\n                t = i / (n - per_diag - 1)\n                centers.append([0.15 + 0.7 * t, 0.85 - 0.7 * t])\n            centers = np.array(centers)\n            radii = np.full(n, 0.07)\n            \n        elif seed == 5:\n            # Tight hexagonal pack\n            rows = 5\n            cols = 6\n            centers = []\n            spacing = 0.14\n            for i in range(rows):\n                for j in range(cols):\n                    if len(centers) >= n:\n                        break\n                    x = 0.12 + spacing * j\n                    y = 0.12 + spacing * np.sqrt(3)/2 * i\n                    if i % 2 == 1:\n                        x += spacing / 2\n                    centers.append([x, y])\n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.082)\n            \n        elif seed == 6:\n            # Border-focused layout\n            centers = []\n            # Top and bottom edges\n            for i in range(8):\n                x = 0.1 + 0.8 * i / 7\n                centers.append([x, 0.08])\n                if len(centers) < n:\n                    centers.append([x, 0.92])\n            # Left and right edges\n            for i in range(1, 4):\n                y = 0.25 * i + 0.08\n                if len(centers) < n:\n                    centers.append([0.08, y])\n                if len(centers) < n:\n                    centers.append([0.92, y])\n            # Fill center\n            while len(centers) < n:\n                centers.append([0.5 + np.random.uniform(-0.2, 0.2), \n                              0.5 + np.random.uniform(-0.2, 0.2)])\n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.075)\n            \n        else:\n            # Random variations with different densities and patterns\n            margin = 0.15 + 0.02 * (seed % 5)\n            centers = np.random.uniform(margin, 1-margin, (n, 2))\n            radii = np.full(n, 0.06 + 0.01 * (seed % 4))\n        \n        return np.concatenate([centers.flatten(), radii])\n    \n    def unpack_variables(x):\n        \"\"\"Convert flat array to centers and radii\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Maximize sum of radii (minimize negative sum)\"\"\"\n        _, radii = unpack_variables(x)\n        return -np.sum(radii)\n    \n    def constraint_function(x):\n        \"\"\"\n        Compute all constraint values.\n        Returns array where each element should be >= 0.\n        \"\"\"\n        centers, radii = unpack_variables(x)\n        constraints = []\n        \n        # Boundary constraints: center \u00b1 radius within [0,1]\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        \n        # Non-overlap constraints: distance > sum of radii\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                             (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Non-negative radii\n        for i in range(n):\n            constraints.append(radii[i])\n        \n        return np.array(constraints)\n    \n    def optimize_phase1(x0):\n        \"\"\"Phase 1: Initial optimization with tolerance 1e-10\"\"\"\n        bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n        nlc = NonlinearConstraint(constraint_function, 0, np.inf)\n        \n        result = minimize(\n            objective,\n            x0,\n            method='trust-constr',\n            bounds=bounds,\n            constraints=nlc,\n            options={\n                'maxiter': 30000,\n                'gtol': 1e-10,\n                'xtol': 1e-10,\n                'barrier_tol': 1e-10\n            }\n        )\n        return result\n    \n    def optimize_phase2(x):\n        \"\"\"Phase 2: Refinement with tolerance 1e-12\"\"\"\n        bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n        nlc = NonlinearConstraint(constraint_function, 0, np.inf)\n        \n        result = minimize(\n            objective,\n            x,\n            method='trust-constr',\n            bounds=bounds,\n            constraints=nlc,\n            options={\n                'maxiter': 30000,\n                'gtol': 1e-12,\n                'xtol': 1e-12,\n                'barrier_tol': 1e-12\n            }\n        )\n        return result\n    \n    def optimize_phase3(x):\n        \"\"\"Phase 3: Ultra-refinement with tolerance 1e-14\"\"\"\n        bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n        nlc = NonlinearConstraint(constraint_function, 0, np.inf)\n        \n        result = minimize(\n            objective,\n            x,\n            method='trust-constr',\n            bounds=bounds,\n            constraints=nlc,\n            options={\n                'maxiter': 30000,\n                'gtol': 1e-14,\n                'xtol': 1e-14,\n                'barrier_tol': 1e-14\n            }\n        )\n        return result\n    \n    def optimize_phase4(x):\n        \"\"\"Phase 4: Final polish with extreme tolerance\"\"\"\n        bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n        nlc = NonlinearConstraint(constraint_function, 0, np.inf)\n        \n        result = minimize(\n            objective,\n            x,\n            method='trust-constr',\n            bounds=bounds,\n            constraints=nlc,\n            options={\n                'maxiter': 30000,\n                'gtol': 1e-15,\n                'xtol': 1e-15,\n                'barrier_tol': 1e-15\n            }\n        )\n        return result\n    \n    def validate_solution(x):\n        \"\"\"Check if solution satisfies all constraints\"\"\"\n        constraints = constraint_function(x)\n        return np.all(constraints >= -1e-6)\n    \n    # Phase 1: 30 restarts with initial optimization\n    results = []\n    \n    for seed in range(30):\n        x0 = create_initial_guess(seed)\n        result = optimize_phase1(x0)\n        \n        if validate_solution(result.x):\n            centers, radii = unpack_variables(result.x)\n            sum_radii = np.sum(radii)\n            results.append(PackingResult(centers, radii, sum_radii, True))\n    \n    # Sort by sum of radii\n    results.sort(key=lambda r: r.sum_radii, reverse=True)\n    \n    # Phase 2: Refine top 10 solutions\n    phase2_results = []\n    for i in range(min(10, len(results))):\n        x = np.concatenate([results[i].centers.flatten(), results[i].radii])\n        refined = optimize_phase2(x)\n        \n        if validate_solution(refined.x):\n            centers, radii = unpack_variables(refined.x)\n            sum_radii = np.sum(radii)\n            phase2_results.append(PackingResult(centers, radii, sum_radii, True))\n    \n    # Phase 3: Ultra-refine top 10\n    phase3_results = []\n    for i in range(min(10, len(phase2_results))):\n        x = np.concatenate([phase2_results[i].centers.flatten(), phase2_results[i].radii])\n        refined = optimize_phase3(x)\n        \n        if validate_solution(refined.x):\n            centers, radii = unpack_variables(refined.x)\n            sum_radii = np.sum(radii)\n            phase3_results.append(PackingResult(centers, radii, sum_radii, True))\n    \n    # Phase 4: Final polish on top 10\n    phase4_results = []\n    for i in range(min(10, len(phase3_results))):\n        x = np.concatenate([phase3_results[i].centers.flatten(), phase3_results[i].radii])\n        polished = optimize_phase4(x)\n        \n        if validate_solution(polished.x):\n            centers, radii = unpack_variables(polished.x)\n            sum_radii = np.sum(radii)\n            phase4_results.append(PackingResult(centers, radii, sum_radii, True))\n    \n    # Combine all results and pick best\n    all_results = results + phase2_results + phase3_results + phase4_results\n    all_results.sort(key=lambda r: r.sum_radii, reverse=True)\n    \n    if all_results:\n        best = all_results[0]\n        return best.centers, best.radii, best.sum_radii\n    \n    # Fallback: simple grid if all optimizations fail\n    side = int(np.ceil(np.sqrt(n)))\n    centers = []\n    for i in range(side):\n        for j in range(side):\n            if len(centers) >= n:\n                break\n            x = 0.15 + 0.7 * j / (side - 1)\n            y = 0.15 + 0.7 * i / (side - 1)\n            centers.append([x, y])\n    centers = np.array(centers[:n])\n    radii = np.full(n, 0.06)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.6218513674223467,
    "target_ratio": 0.9950100066118963,
    "combined_score": 0.9950100066118963,
    "eval_time": 200.5019817352295,
    "error": null
  },
  "prompt": "Optimize trial_6_4 with tighter integration:\n\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom dataclasses import dataclass\n\n@dataclass\nclass PackingResult:\n    centers: np.ndarray\n    radii: np.ndarray\n    sum_radii: float\n    valid: bool\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses adaptive restart strategy with ultra-tight tolerances and refinement.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def create_initial_guess(seed):\n        \"\"\"Create diverse initial configurations\"\"\"\n        np.random.seed(seed)\n        \n        if seed == 0:\n            # Hexagonal-inspired grid\n            rows = 5\n            cols = 6\n            centers = []\n            for i in range(rows):\n                for j in range(cols):\n                    if len(centers) >= n:\n                        break\n                    x = 0.1 + 0.8 * j / (cols - 1)\n                    y = 0.1 + 0.8 * i / (rows - 1)\n                    if i % 2 == 1:\n                        x += 0.4 / cols\n                    centers.append([x, y])\n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.08)\n            \n        elif seed == 1:\n            # Square grid with perturbation\n            side = int(np.ceil(np.sqrt(n)))\n            centers = []\n            for i in range(side):\n                for j in range(side):\n                    if len(centers) >= n:\n                        break\n                    x = 0.15 + 0.7 * j / (side - 1) + np.random.uniform(-0.02, 0.02)\n                    y = 0.15 + 0.7 * i / (side - 1) + np.random.uniform(-0.02, 0.02)\n                    centers.append([x, y])\n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.075)\n            \n        elif seed == 2:\n            # Concentric circles\n            centers = []\n            # Outer ring\n            for i in range(12):\n                angle = 2 * np.pi * i / 12\n                x = 0.5 + 0.35 * np.cos(angle)\n                y = 0.5 + 0.35 * np.sin(angle)\n                centers.append([x, y])\n            # Middle ring\n            for i in range(8):\n                angle = 2 * np.pi * i / 8\n                x = 0.5 + 0.22 * np.cos(angle)\n                y = 0.5 + 0.22 * np.sin(angle)\n                centers.append([x, y])\n            # Inner circles\n            for i in range(6):\n                angle = 2 * np.pi * i / 6\n                x = 0.5 + 0.1 * np.cos(angle)\n                y = 0.5 + 0.1 * np.sin(angle)\n                centers.append([x, y])\n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.07)\n            \n        elif seed == 3:\n            # Random with clustering\n            centers = np.random.uniform(0.2, 0.8, (n, 2))\n            radii = np.full(n, 0.065)\n            \n        elif seed == 4:\n            # Diagonal arrangement\n            centers = []\n            per_diag = n // 2\n            for i in range(per_diag):\n                t = i / (per_diag - 1)\n                centers.append([0.15 + 0.7 * t, 0.15 + 0.7 * t])\n            for i in range(n - per_diag):\n                t = i / (n - per_diag - 1)\n                centers.append([0.15 + 0.7 * t, 0.85 - 0.7 * t])\n            centers = np.array(centers)\n            radii = np.full(n, 0.07)\n            \n        else:\n            # Random variations with different densities\n            margin = 0.15 + 0.02 * (seed % 4)\n            centers = np.random.uniform(margin, 1-margin, (n, 2))\n            radii = np.full(n, 0.06 + 0.01 * (seed % 3))\n        \n        return np.concatenate([centers.flatten(), radii])\n    \n    def unpack_variables(x):\n        \"\"\"Convert flat array to centers and radii\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Maximize sum of radii (minimize negative sum)\"\"\"\n        _, radii = unpack_variables(x)\n        return -np.sum(radii)\n    \n    def constraint_function(x):\n        \"\"\"\n        Compute all constraint values.\n        Returns array where each element should be >= 0.\n        \"\"\"\n        centers, radii = unpack_variables(x)\n        constraints = []\n        \n        # Boundary constraints: center \u00b1 radius within [0,1]\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        \n        # Non-overlap constraints: distance > sum of radii\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                             (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Non-negative radii\n        for i in range(n):\n            constraints.append(radii[i])\n        \n        return np.array(constraints)\n    \n    def optimize_with_tight_tolerances(x0):\n        \"\"\"\n        Optimize with tight tolerances using trust-constr\n        \"\"\"\n        bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n        nlc = NonlinearConstraint(constraint_function, 0, np.inf)\n        \n        result = minimize(\n            objective,\n            x0,\n            method='trust-constr',\n            bounds=bounds,\n            constraints=nlc,\n            options={\n                'maxiter': 25000,\n                'gtol': 1e-12,\n                'xtol': 1e-12,\n                'barrier_tol': 1e-12\n            }\n        )\n        \n        return result\n    \n    def validate_solution(x):\n        \"\"\"Check if solution satisfies all constraints\"\"\"\n        constraints = constraint_function(x)\n        return np.all(constraints >= -1e-6)\n    \n    def ultra_refine(x):\n        \"\"\"Ultra-fine refinement with tightest tolerances\"\"\"\n        bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n        nlc = NonlinearConstraint(constraint_function, 0, np.inf)\n        \n        result = minimize(\n            objective,\n            x,\n            method='trust-constr',\n            bounds=bounds,\n            constraints=nlc,\n            options={\n                'maxiter': 30000,\n                'gtol': 1e-13,\n                'xtol': 1e-13,\n                'barrier_tol': 1e-13\n            }\n        )\n        return result\n    \n    # Adaptive restart strategy with 20 restarts\n    results = []\n    \n    for seed in range(20):\n        x0 = create_initial_guess(seed)\n        result = optimize_with_tight_tolerances(x0)\n        \n        if validate_solution(result.x):\n            centers, radii = unpack_variables(result.x)\n            sum_radii = np.sum(radii)\n            results.append(PackingResult(centers, radii, sum_radii, True))\n    \n    # Sort by sum of radii\n    results.sort(key=lambda r: r.sum_radii, reverse=True)\n    \n    # Ultra-refine top 5 solutions\n    refined_results = []\n    for i in range(min(5, len(results))):\n        x = np.concatenate([results[i].centers.flatten(), results[i].radii])\n        refined = ultra_refine(x)\n        \n        if validate_solution(refined.x):\n            centers, radii = unpack_variables(refined.x)\n            sum_radii = np.sum(radii)\n            refined_results.append(PackingResult(centers, radii, sum_radii, True))\n    \n    # Combine all results and pick best\n    all_results = results + refined_results\n    all_results.sort(key=lambda r: r.sum_radii, reverse=True)\n    \n    if all_results:\n        best = all_results[0]\n        return best.centers, best.radii, best.sum_radii\n    \n    # Fallback: simple grid if all optimizations fail\n    side = int(np.ceil(np.sqrt(n)))\n    centers = []\n    for i in range(side):\n        for j in range(side):\n            if len(centers) >= n:\n                break\n            x = 0.15 + 0.7 * j / (side - 1)\n            y = 0.15 + 0.7 * i / (side - 1)\n            centers.append([x, y])\n    centers = np.array(centers[:n])\n    radii = np.full(n, 0.06)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nAchieved 2.6219. Improvements:\n1. Increase restarts to 30 (from 20)\n2. Tighter tolerances throughout:\n   - Phase 1: 1e-10\n   - Phase 2: 1e-12\n   - Phase 3: 1e-14\n3. Add 4th ultra-refinement phase\n4. maxiter=30000 per phase\n5. Take top 10 results and apply final polish\n6. Return best\n\nRequirements:\n- 30 restarts\n- 4-phase optimization\n- Ultra-tight tolerances\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom dataclasses import dataclass\n\n@dataclass\nclass PackingResult:\n    centers: np.ndarray\n    radii: np.ndarray\n    sum_radii: float\n    valid: bool\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses 4-phase optimization with ultra-tight tolerances and 30 restarts.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def create_initial_guess(seed):\n        \"\"\"Create diverse initial configurations\"\"\"\n        np.random.seed(seed)\n        \n        if seed == 0:\n            # Hexagonal-inspired grid\n            rows = 5\n            cols = 6\n            centers = []\n            for i in range(rows):\n                for j in range(cols):\n                    if len(centers) >= n:\n                        break\n                    x = 0.1 + 0.8 * j / (cols - 1)\n                    y = 0.1 + 0.8 * i / (rows - 1)\n                    if i % 2 == 1:\n                        x += 0.4 / cols\n                    centers.append([x, y])\n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.08)\n            \n        elif seed == 1:\n            # Square grid with perturbation\n            side = int(np.ceil(np.sqrt(n)))\n            centers = []\n            for i in range(side):\n                for j in range(side):\n                    if len(centers) >= n:\n                        break\n                    x = 0.15 + 0.7 * j / (side - 1) + np.random.uniform(-0.02, 0.02)\n                    y = 0.15 + 0.7 * i / (side - 1) + np.random.uniform(-0.02, 0.02)\n                    centers.append([x, y])\n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.075)\n            \n        elif seed == 2:\n            # Concentric circles\n            centers = []\n            # Outer ring\n            for i in range(12):\n                angle = 2 * np.pi * i / 12\n                x = 0.5 + 0.35 * np.cos(angle)\n                y = 0.5 + 0.35 * np.sin(angle)\n                centers.append([x, y])\n            # Middle ring\n            for i in range(8):\n                angle = 2 * np.pi * i / 8\n                x = 0.5 + 0.22 * np.cos(angle)\n                y = 0.5 + 0.22 * np.sin(angle)\n                centers.append([x, y])\n            # Inner circles\n            for i in range(6):\n                angle = 2 * np.pi * i / 6\n                x = 0.5 + 0.1 * np.cos(angle)\n                y = 0.5 + 0.1 * np.sin(angle)\n                centers.append([x, y])\n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.07)\n            \n        elif seed == 3:\n            # Random with clustering\n            centers = np.random.uniform(0.2, 0.8, (n, 2))\n            radii = np.full(n, 0.065)\n            \n        elif seed == 4:\n            # Diagonal arrangement\n            centers = []\n            per_diag = n // 2\n            for i in range(per_diag):\n                t = i / (per_diag - 1)\n                centers.append([0.15 + 0.7 * t, 0.15 + 0.7 * t])\n            for i in range(n - per_diag):\n                t = i / (n - per_diag - 1)\n                centers.append([0.15 + 0.7 * t, 0.85 - 0.7 * t])\n            centers = np.array(centers)\n            radii = np.full(n, 0.07)\n            \n        elif seed == 5:\n            # Tight hexagonal pack\n            rows = 5\n            cols = 6\n            centers = []\n            spacing = 0.14\n            for i in range(rows):\n                for j in range(cols):\n                    if len(centers) >= n:\n                        break\n                    x = 0.12 + spacing * j\n                    y = 0.12 + spacing * np.sqrt(3)/2 * i\n                    if i % 2 == 1:\n                        x += spacing / 2\n                    centers.append([x, y])\n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.082)\n            \n        elif seed == 6:\n            # Border-focused layout\n            centers = []\n            # Top and bottom edges\n            for i in range(8):\n                x = 0.1 + 0.8 * i / 7\n                centers.append([x, 0.08])\n                if len(centers) < n:\n                    centers.append([x, 0.92])\n            # Left and right edges\n            for i in range(1, 4):\n                y = 0.25 * i + 0.08\n                if len(centers) < n:\n                    centers.append([0.08, y])\n                if len(centers) < n:\n                    centers.append([0.92, y])\n            # Fill center\n            while len(centers) < n:\n                centers.append([0.5 + np.random.uniform(-0.2, 0.2), \n                              0.5 + np.random.uniform(-0.2, 0.2)])\n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.075)\n            \n        else:\n            # Random variations with different densities and patterns\n            margin = 0.15 + 0.02 * (seed % 5)\n            centers = np.random.uniform(margin, 1-margin, (n, 2))\n            radii = np.full(n, 0.06 + 0.01 * (seed % 4))\n        \n        return np.concatenate([centers.flatten(), radii])\n    \n    def unpack_variables(x):\n        \"\"\"Convert flat array to centers and radii\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Maximize sum of radii (minimize negative sum)\"\"\"\n        _, radii = unpack_variables(x)\n        return -np.sum(radii)\n    \n    def constraint_function(x):\n        \"\"\"\n        Compute all constraint values.\n        Returns array where each element should be >= 0.\n        \"\"\"\n        centers, radii = unpack_variables(x)\n        constraints = []\n        \n        # Boundary constraints: center \u00b1 radius within [0,1]\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        \n        # Non-overlap constraints: distance > sum of radii\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                             (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Non-negative radii\n        for i in range(n):\n            constraints.append(radii[i])\n        \n        return np.array(constraints)\n    \n    def optimize_phase1(x0):\n        \"\"\"Phase 1: Initial optimization with tolerance 1e-10\"\"\"\n        bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n        nlc = NonlinearConstraint(constraint_function, 0, np.inf)\n        \n        result = minimize(\n            objective,\n            x0,\n            method='trust-constr',\n            bounds=bounds,\n            constraints=nlc,\n            options={\n                'maxiter': 30000,\n                'gtol': 1e-10,\n                'xtol': 1e-10,\n                'barrier_tol': 1e-10\n            }\n        )\n        return result\n    \n    def optimize_phase2(x):\n        \"\"\"Phase 2: Refinement with tolerance 1e-12\"\"\"\n        bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n        nlc = NonlinearConstraint(constraint_function, 0, np.inf)\n        \n        result = minimize(\n            objective,\n            x,\n            method='trust-constr',\n            bounds=bounds,\n            constraints=nlc,\n            options={\n                'maxiter': 30000,\n                'gtol': 1e-12,\n                'xtol': 1e-12,\n                'barrier_tol': 1e-12\n            }\n        )\n        return result\n    \n    def optimize_phase3(x):\n        \"\"\"Phase 3: Ultra-refinement with tolerance 1e-14\"\"\"\n        bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n        nlc = NonlinearConstraint(constraint_function, 0, np.inf)\n        \n        result = minimize(\n            objective,\n            x,\n            method='trust-constr',\n            bounds=bounds,\n            constraints=nlc,\n            options={\n                'maxiter': 30000,\n                'gtol': 1e-14,\n                'xtol': 1e-14,\n                'barrier_tol': 1e-14\n            }\n        )\n        return result\n    \n    def optimize_phase4(x):\n        \"\"\"Phase 4: Final polish with extreme tolerance\"\"\"\n        bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n        nlc = NonlinearConstraint(constraint_function, 0, np.inf)\n        \n        result = minimize(\n            objective,\n            x,\n            method='trust-constr',\n            bounds=bounds,\n            constraints=nlc,\n            options={\n                'maxiter': 30000,\n                'gtol': 1e-15,\n                'xtol': 1e-15,\n                'barrier_tol': 1e-15\n            }\n        )\n        return result\n    \n    def validate_solution(x):\n        \"\"\"Check if solution satisfies all constraints\"\"\"\n        constraints = constraint_function(x)\n        return np.all(constraints >= -1e-6)\n    \n    # Phase 1: 30 restarts with initial optimization\n    results = []\n    \n    for seed in range(30):\n        x0 = create_initial_guess(seed)\n        result = optimize_phase1(x0)\n        \n        if validate_solution(result.x):\n            centers, radii = unpack_variables(result.x)\n            sum_radii = np.sum(radii)\n            results.append(PackingResult(centers, radii, sum_radii, True))\n    \n    # Sort by sum of radii\n    results.sort(key=lambda r: r.sum_radii, reverse=True)\n    \n    # Phase 2: Refine top 10 solutions\n    phase2_results = []\n    for i in range(min(10, len(results))):\n        x = np.concatenate([results[i].centers.flatten(), results[i].radii])\n        refined = optimize_phase2(x)\n        \n        if validate_solution(refined.x):\n            centers, radii = unpack_variables(refined.x)\n            sum_radii = np.sum(radii)\n            phase2_results.append(PackingResult(centers, radii, sum_radii, True))\n    \n    # Phase 3: Ultra-refine top 10\n    phase3_results = []\n    for i in range(min(10, len(phase2_results))):\n        x = np.concatenate([phase2_results[i].centers.flatten(), phase2_results[i].radii])\n        refined = optimize_phase3(x)\n        \n        if validate_solution(refined.x):\n            centers, radii = unpack_variables(refined.x)\n            sum_radii = np.sum(radii)\n            phase3_results.append(PackingResult(centers, radii, sum_radii, True))\n    \n    # Phase 4: Final polish on top 10\n    phase4_results = []\n    for i in range(min(10, len(phase3_results))):\n        x = np.concatenate([phase3_results[i].centers.flatten(), phase3_results[i].radii])\n        polished = optimize_phase4(x)\n        \n        if validate_solution(polished.x):\n            centers, radii = unpack_variables(polished.x)\n            sum_radii = np.sum(radii)\n            phase4_results.append(PackingResult(centers, radii, sum_radii, True))\n    \n    # Combine all results and pick best\n    all_results = results + phase2_results + phase3_results + phase4_results\n    all_results.sort(key=lambda r: r.sum_radii, reverse=True)\n    \n    if all_results:\n        best = all_results[0]\n        return best.centers, best.radii, best.sum_radii\n    \n    # Fallback: simple grid if all optimizations fail\n    side = int(np.ceil(np.sqrt(n)))\n    centers = []\n    for i in range(side):\n        for j in range(side):\n            if len(centers) >= n:\n                break\n            x = 0.15 + 0.7 * j / (side - 1)\n            y = 0.15 + 0.7 * i / (side - 1)\n            centers.append([x, y])\n    centers = np.array(centers[:n])\n    radii = np.full(n, 0.06)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T19:23:47.817530",
  "cost_data": null
}