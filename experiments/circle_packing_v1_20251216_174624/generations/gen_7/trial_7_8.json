{
  "trial_id": "trial_7_8",
  "generation": 7,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom dataclasses import dataclass\nfrom typing import Tuple, List\nimport warnings\nwarnings.filterwarnings('ignore')\n\n@dataclass\nclass PackingResult:\n    centers: np.ndarray\n    radii: np.ndarray\n    sum_radii: float\n    valid: bool\n\ndef check_constraints(centers: np.ndarray, radii: np.ndarray) -> bool:\n    \"\"\"Check if packing satisfies all constraints.\"\"\"\n    n = len(radii)\n    \n    # Check if circles are inside unit square\n    if np.any(centers - radii[:, np.newaxis] < -1e-10):\n        return False\n    if np.any(centers + radii[:, np.newaxis] > 1 + 1e-10):\n        return False\n    \n    # Check non-overlapping\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-10:\n                return False\n    \n    return True\n\ndef create_initial_guess(n: int, seed: int) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Create initial guess with hexagonal-like packing.\"\"\"\n    np.random.seed(seed)\n    \n    # Try hexagonal packing with perturbation\n    rows = int(np.sqrt(n * 2 / np.sqrt(3))) + 1\n    cols = int(np.ceil(n / rows)) + 1\n    \n    centers = []\n    for row in range(rows):\n        for col in range(cols):\n            if len(centers) >= n:\n                break\n            x = (col + 0.5 * (row % 2)) / cols\n            y = row * np.sqrt(3) / 2 / rows\n            # Add small random perturbation\n            x += np.random.uniform(-0.02, 0.02)\n            y += np.random.uniform(-0.02, 0.02)\n            centers.append([x, y])\n        if len(centers) >= n:\n            break\n    \n    centers = np.array(centers[:n])\n    \n    # Normalize to [0.1, 0.9] range\n    centers = 0.1 + 0.8 * (centers - centers.min()) / (centers.max() - centers.min() + 1e-10)\n    \n    # Compute initial radii\n    radii = np.zeros(n)\n    for i in range(n):\n        # Distance to boundaries\n        r_max = min(centers[i, 0], centers[i, 1], \n                   1 - centers[i, 0], 1 - centers[i, 1])\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                r_max = min(r_max, dist / 2)\n        \n        radii[i] = max(0.01, r_max * 0.9)\n    \n    return centers, radii\n\ndef optimize_packing(centers_init: np.ndarray, radii_init: np.ndarray, \n                    gtol: float, maxiter: int) -> PackingResult:\n    \"\"\"Optimize circle packing with given tolerance.\"\"\"\n    n = len(radii_init)\n    \n    # Pack parameters: [centers_flat, radii]\n    x0 = np.concatenate([centers_init.flatten(), radii_init])\n    \n    def objective(x):\n        radii = x[2*n:]\n        return -np.sum(radii)  # Maximize sum of radii\n    \n    def constraint_inside_square(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        violations = []\n        # x - r >= 0\n        violations.append(centers[:, 0] - radii)\n        # y - r >= 0\n        violations.append(centers[:, 1] - radii)\n        # x + r <= 1\n        violations.append(1 - centers[:, 0] - radii)\n        # y + r <= 1\n        violations.append(1 - centers[:, 1] - radii)\n        \n        return np.concatenate(violations)\n    \n    def constraint_non_overlapping(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        violations = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                violations.append(dist - radii[i] - radii[j])\n        \n        return np.array(violations)\n    \n    constraints = [\n        {'type': 'ineq', 'fun': constraint_inside_square},\n        {'type': 'ineq', 'fun': constraint_non_overlapping},\n        {'type': 'ineq', 'fun': lambda x: x[2*n:]}  # radii >= 0\n    ]\n    \n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n    \n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': maxiter, 'ftol': 1e-15, 'disp': False}\n    )\n    \n    centers = result.x[:2*n].reshape(n, 2)\n    radii = result.x[2*n:]\n    sum_radii = np.sum(radii)\n    valid = check_constraints(centers, radii)\n    \n    return PackingResult(centers, radii, sum_radii, valid)\n\ndef multi_resolution_optimize(n: int = 26) -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Multi-resolution optimization cascade.\"\"\"\n    \n    # Resolution 1: Coarse (30 runs)\n    print(\"Resolution 1: Coarse optimization (30 runs)...\")\n    coarse_results = []\n    for seed in range(30):\n        centers_init, radii_init = create_initial_guess(n, seed)\n        result = optimize_packing(centers_init, radii_init, gtol=1e-9, maxiter=10000)\n        if result.valid:\n            coarse_results.append(result)\n    \n    if not coarse_results:\n        # Fallback\n        centers_init, radii_init = create_initial_guess(n, 0)\n        result = optimize_packing(centers_init, radii_init, gtol=1e-9, maxiter=10000)\n        return result.centers, result.radii, result.sum_radii\n    \n    # Sort and select top 15\n    coarse_results.sort(key=lambda x: x.sum_radii, reverse=True)\n    top_coarse = coarse_results[:15]\n    \n    # Resolution 2: Medium (top 15)\n    print(\"Resolution 2: Medium optimization (15 runs)...\")\n    medium_results = []\n    for result in top_coarse:\n        refined = optimize_packing(result.centers, result.radii, gtol=1e-11, maxiter=20000)\n        if refined.valid:\n            medium_results.append(refined)\n    \n    if not medium_results:\n        best = top_coarse[0]\n        return best.centers, best.radii, best.sum_radii\n    \n    # Sort and select top 10\n    medium_results.sort(key=lambda x: x.sum_radii, reverse=True)\n    top_medium = medium_results[:10]\n    \n    # Resolution 3: Fine (top 10)\n    print(\"Resolution 3: Fine optimization (10 runs)...\")\n    fine_results = []\n    for result in top_medium:\n        refined = optimize_packing(result.centers, result.radii, gtol=1e-13, maxiter=30000)\n        if refined.valid:\n            fine_results.append(refined)\n    \n    if not fine_results:\n        best = top_medium[0]\n        return best.centers, best.radii, best.sum_radii\n    \n    # Sort and select top 5\n    fine_results.sort(key=lambda x: x.sum_radii, reverse=True)\n    top_fine = fine_results[:5]\n    \n    # Resolution 4: Ultra-fine (top 5)\n    print(\"Resolution 4: Ultra-fine optimization (5 runs)...\")\n    ultra_results = []\n    for result in top_fine:\n        refined = optimize_packing(result.centers, result.radii, gtol=1e-14, maxiter=40000)\n        if refined.valid:\n            ultra_results.append(refined)\n    \n    if not ultra_results:\n        best = top_fine[0]\n        return best.centers, best.radii, best.sum_radii\n    \n    # Return best result\n    ultra_results.sort(key=lambda x: x.sum_radii, reverse=True)\n    best = ultra_results[0]\n    \n    print(f\"Best sum of radii: {best.sum_radii:.6f}\")\n    return best.centers, best.radii, best.sum_radii\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    centers, radii, sum_radii = multi_resolution_optimize(n=26)\n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.57766213473864,
    "target_ratio": 0.9782398993315522,
    "combined_score": 0.9782398993315522,
    "eval_time": 64.31900191307068,
    "error": null
  },
  "prompt": "Create multi-resolution optimizer:\n\nStrategy:\n1. Coarse resolution (fast, 30 runs):\n   - Use trial_6_6's approach with gtol=1e-9\n   - maxiter=10000\n2. Medium resolution (top 15 from coarse):\n   - Refine with gtol=1e-11\n   - maxiter=20000\n3. Fine resolution (top 10 from medium):\n   - Ultra-refine with gtol=1e-13\n   - maxiter=30000\n4. Ultra-fine (top 5 from fine):\n   - Hyper-refine with gtol=1e-14\n   - maxiter=40000\n5. Return best\n\nRequirements:\n- 4-resolution cascade\n- Progressive refinement\n- Efficient execution\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom dataclasses import dataclass\nfrom typing import Tuple, List\nimport warnings\nwarnings.filterwarnings('ignore')\n\n@dataclass\nclass PackingResult:\n    centers: np.ndarray\n    radii: np.ndarray\n    sum_radii: float\n    valid: bool\n\ndef check_constraints(centers: np.ndarray, radii: np.ndarray) -> bool:\n    \"\"\"Check if packing satisfies all constraints.\"\"\"\n    n = len(radii)\n    \n    # Check if circles are inside unit square\n    if np.any(centers - radii[:, np.newaxis] < -1e-10):\n        return False\n    if np.any(centers + radii[:, np.newaxis] > 1 + 1e-10):\n        return False\n    \n    # Check non-overlapping\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-10:\n                return False\n    \n    return True\n\ndef create_initial_guess(n: int, seed: int) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Create initial guess with hexagonal-like packing.\"\"\"\n    np.random.seed(seed)\n    \n    # Try hexagonal packing with perturbation\n    rows = int(np.sqrt(n * 2 / np.sqrt(3))) + 1\n    cols = int(np.ceil(n / rows)) + 1\n    \n    centers = []\n    for row in range(rows):\n        for col in range(cols):\n            if len(centers) >= n:\n                break\n            x = (col + 0.5 * (row % 2)) / cols\n            y = row * np.sqrt(3) / 2 / rows\n            # Add small random perturbation\n            x += np.random.uniform(-0.02, 0.02)\n            y += np.random.uniform(-0.02, 0.02)\n            centers.append([x, y])\n        if len(centers) >= n:\n            break\n    \n    centers = np.array(centers[:n])\n    \n    # Normalize to [0.1, 0.9] range\n    centers = 0.1 + 0.8 * (centers - centers.min()) / (centers.max() - centers.min() + 1e-10)\n    \n    # Compute initial radii\n    radii = np.zeros(n)\n    for i in range(n):\n        # Distance to boundaries\n        r_max = min(centers[i, 0], centers[i, 1], \n                   1 - centers[i, 0], 1 - centers[i, 1])\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                r_max = min(r_max, dist / 2)\n        \n        radii[i] = max(0.01, r_max * 0.9)\n    \n    return centers, radii\n\ndef optimize_packing(centers_init: np.ndarray, radii_init: np.ndarray, \n                    gtol: float, maxiter: int) -> PackingResult:\n    \"\"\"Optimize circle packing with given tolerance.\"\"\"\n    n = len(radii_init)\n    \n    # Pack parameters: [centers_flat, radii]\n    x0 = np.concatenate([centers_init.flatten(), radii_init])\n    \n    def objective(x):\n        radii = x[2*n:]\n        return -np.sum(radii)  # Maximize sum of radii\n    \n    def constraint_inside_square(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        violations = []\n        # x - r >= 0\n        violations.append(centers[:, 0] - radii)\n        # y - r >= 0\n        violations.append(centers[:, 1] - radii)\n        # x + r <= 1\n        violations.append(1 - centers[:, 0] - radii)\n        # y + r <= 1\n        violations.append(1 - centers[:, 1] - radii)\n        \n        return np.concatenate(violations)\n    \n    def constraint_non_overlapping(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        violations = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                violations.append(dist - radii[i] - radii[j])\n        \n        return np.array(violations)\n    \n    constraints = [\n        {'type': 'ineq', 'fun': constraint_inside_square},\n        {'type': 'ineq', 'fun': constraint_non_overlapping},\n        {'type': 'ineq', 'fun': lambda x: x[2*n:]}  # radii >= 0\n    ]\n    \n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n    \n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': maxiter, 'ftol': 1e-15, 'disp': False}\n    )\n    \n    centers = result.x[:2*n].reshape(n, 2)\n    radii = result.x[2*n:]\n    sum_radii = np.sum(radii)\n    valid = check_constraints(centers, radii)\n    \n    return PackingResult(centers, radii, sum_radii, valid)\n\ndef multi_resolution_optimize(n: int = 26) -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Multi-resolution optimization cascade.\"\"\"\n    \n    # Resolution 1: Coarse (30 runs)\n    print(\"Resolution 1: Coarse optimization (30 runs)...\")\n    coarse_results = []\n    for seed in range(30):\n        centers_init, radii_init = create_initial_guess(n, seed)\n        result = optimize_packing(centers_init, radii_init, gtol=1e-9, maxiter=10000)\n        if result.valid:\n            coarse_results.append(result)\n    \n    if not coarse_results:\n        # Fallback\n        centers_init, radii_init = create_initial_guess(n, 0)\n        result = optimize_packing(centers_init, radii_init, gtol=1e-9, maxiter=10000)\n        return result.centers, result.radii, result.sum_radii\n    \n    # Sort and select top 15\n    coarse_results.sort(key=lambda x: x.sum_radii, reverse=True)\n    top_coarse = coarse_results[:15]\n    \n    # Resolution 2: Medium (top 15)\n    print(\"Resolution 2: Medium optimization (15 runs)...\")\n    medium_results = []\n    for result in top_coarse:\n        refined = optimize_packing(result.centers, result.radii, gtol=1e-11, maxiter=20000)\n        if refined.valid:\n            medium_results.append(refined)\n    \n    if not medium_results:\n        best = top_coarse[0]\n        return best.centers, best.radii, best.sum_radii\n    \n    # Sort and select top 10\n    medium_results.sort(key=lambda x: x.sum_radii, reverse=True)\n    top_medium = medium_results[:10]\n    \n    # Resolution 3: Fine (top 10)\n    print(\"Resolution 3: Fine optimization (10 runs)...\")\n    fine_results = []\n    for result in top_medium:\n        refined = optimize_packing(result.centers, result.radii, gtol=1e-13, maxiter=30000)\n        if refined.valid:\n            fine_results.append(refined)\n    \n    if not fine_results:\n        best = top_medium[0]\n        return best.centers, best.radii, best.sum_radii\n    \n    # Sort and select top 5\n    fine_results.sort(key=lambda x: x.sum_radii, reverse=True)\n    top_fine = fine_results[:5]\n    \n    # Resolution 4: Ultra-fine (top 5)\n    print(\"Resolution 4: Ultra-fine optimization (5 runs)...\")\n    ultra_results = []\n    for result in top_fine:\n        refined = optimize_packing(result.centers, result.radii, gtol=1e-14, maxiter=40000)\n        if refined.valid:\n            ultra_results.append(refined)\n    \n    if not ultra_results:\n        best = top_fine[0]\n        return best.centers, best.radii, best.sum_radii\n    \n    # Return best result\n    ultra_results.sort(key=lambda x: x.sum_radii, reverse=True)\n    best = ultra_results[0]\n    \n    print(f\"Best sum of radii: {best.sum_radii:.6f}\")\n    return best.centers, best.radii, best.sum_radii\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    centers, radii, sum_radii = multi_resolution_optimize(n=26)\n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T19:21:28.007092",
  "cost_data": null
}