{
  "trial_id": "trial_7_9",
  "generation": 7,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses constraint-adaptive optimization with dynamic penalty adjustment.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def best_initialization():\n        \"\"\"Start with trial_6_6's best known configuration.\"\"\"\n        centers = np.array([\n            [0.10, 0.10], [0.30, 0.10], [0.50, 0.10], [0.70, 0.10], [0.90, 0.10],\n            [0.10, 0.30], [0.30, 0.30], [0.50, 0.30], [0.70, 0.30], [0.90, 0.30],\n            [0.10, 0.50], [0.30, 0.50], [0.50, 0.50], [0.70, 0.50], [0.90, 0.50],\n            [0.10, 0.70], [0.30, 0.70], [0.50, 0.70], [0.70, 0.70], [0.90, 0.70],\n            [0.10, 0.90], [0.30, 0.90], [0.50, 0.90], [0.70, 0.90], [0.90, 0.90],\n            [0.50, 0.50]\n        ])\n        radii = np.full(n, 0.08)\n        return centers, radii\n    \n    def compute_max_radii(centers):\n        \"\"\"Compute maximum possible radii given centers.\"\"\"\n        radii = np.zeros(n)\n        for i in range(n):\n            # Boundary constraints\n            max_r = min(centers[i, 0], 1 - centers[i, 0], \n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Non-overlap constraints\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, dist / 2)\n            \n            radii[i] = max(0, max_r)\n        return radii\n    \n    def adaptive_objective(x, penalty_weights):\n        \"\"\"Objective with adaptive constraint penalties.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = compute_max_radii(centers)\n        \n        # Primary objective: maximize sum of radii\n        obj = -np.sum(radii)\n        \n        # Adaptive boundary penalties\n        boundary_violations = np.maximum(0, radii[:, None] - np.minimum(\n            np.column_stack([centers[:, 0], 1 - centers[:, 0],\n                           centers[:, 1], 1 - centers[:, 1]]),\n            axis=1\n        ))\n        boundary_penalty = penalty_weights['boundary'] * np.sum(boundary_violations**2)\n        \n        # Adaptive overlap penalties\n        distances = cdist(centers, centers)\n        np.fill_diagonal(distances, np.inf)\n        radii_sum = radii[:, None] + radii[None, :]\n        overlap_violations = np.maximum(0, radii_sum - distances)\n        overlap_penalty = penalty_weights['overlap'] * np.sum(overlap_violations**2)\n        \n        # Adaptive spacing penalty (encourage better distribution)\n        min_distances = np.min(distances, axis=1)\n        spacing_penalty = penalty_weights['spacing'] * np.sum(1.0 / (min_distances + 1e-6))\n        \n        return obj + boundary_penalty + overlap_penalty + spacing_penalty\n    \n    def update_penalty_weights(centers, radii, weights, iteration):\n        \"\"\"Dynamically adjust penalty weights based on violations.\"\"\"\n        # Check boundary violations\n        boundary_slack = np.minimum(\n            np.column_stack([centers[:, 0] - radii, 1 - centers[:, 0] - radii,\n                           centers[:, 1] - radii, 1 - centers[:, 1] - radii]),\n            axis=1\n        )\n        boundary_violation = np.sum(np.maximum(0, -boundary_slack))\n        \n        # Check overlap violations\n        distances = cdist(centers, centers)\n        np.fill_diagonal(distances, np.inf)\n        radii_sum = radii[:, None] + radii[None, :]\n        overlap_violation = np.sum(np.maximum(0, radii_sum - distances))\n        \n        # Adaptive weight update\n        new_weights = weights.copy()\n        \n        if boundary_violation > 1e-6:\n            new_weights['boundary'] *= 1.5\n        else:\n            new_weights['boundary'] *= 0.95\n            \n        if overlap_violation > 1e-6:\n            new_weights['overlap'] *= 1.5\n        else:\n            new_weights['overlap'] *= 0.95\n        \n        # Adjust spacing weight based on progress\n        if iteration > 50:\n            new_weights['spacing'] *= 0.9\n        \n        return new_weights\n    \n    def optimize_with_adaptive_constraints(seed, strategy):\n        \"\"\"Run optimization with adaptive constraint handling.\"\"\"\n        np.random.seed(seed)\n        \n        # Initialize\n        centers, radii = best_initialization()\n        \n        # Add small perturbation based on strategy\n        if strategy == 'perturb_light':\n            centers += np.random.randn(n, 2) * 0.01\n        elif strategy == 'perturb_medium':\n            centers += np.random.randn(n, 2) * 0.02\n        elif strategy == 'perturb_heavy':\n            centers += np.random.randn(n, 2) * 0.03\n        elif strategy == 'grid_shift':\n            shift = np.random.rand(2) * 0.05\n            centers += shift\n        \n        centers = np.clip(centers, 0.05, 0.95)\n        \n        # Initial penalty weights\n        penalty_weights = {\n            'boundary': 1000.0,\n            'overlap': 1000.0,\n            'spacing': 10.0\n        }\n        \n        x0 = centers.flatten()\n        \n        # Multi-stage optimization with adaptive penalties\n        for stage in range(3):\n            for iteration in range(20):\n                result = minimize(\n                    lambda x: adaptive_objective(x, penalty_weights),\n                    x0,\n                    method='L-BFGS-B',\n                    bounds=[(0.01, 0.99)] * (2 * n),\n                    options={'maxiter': 50, 'ftol': 1e-9}\n                )\n                \n                x0 = result.x\n                centers_temp = x0.reshape(n, 2)\n                radii_temp = compute_max_radii(centers_temp)\n                \n                # Update penalties based on violations\n                penalty_weights = update_penalty_weights(\n                    centers_temp, radii_temp, penalty_weights, iteration\n                )\n            \n            # Increase penalty weights for next stage\n            penalty_weights['boundary'] *= 2\n            penalty_weights['overlap'] *= 2\n        \n        centers = x0.reshape(n, 2)\n        radii = compute_max_radii(centers)\n        \n        return centers, radii, np.sum(radii)\n    \n    # Run 40 optimizations with different strategies\n    strategies = ['perturb_light', 'perturb_medium', 'perturb_heavy', 'grid_shift', 'base']\n    results = []\n    \n    for i in range(40):\n        strategy = strategies[i % len(strategies)]\n        centers, radii, sum_r = optimize_with_adaptive_constraints(i, strategy)\n        results.append((centers, radii, sum_r))\n    \n    # Sort and take top 10\n    results.sort(key=lambda x: x[2], reverse=True)\n    top_results = results[:10]\n    \n    # Ultra-refinement on top results\n    best_centers, best_radii, best_sum = top_results[0]\n    \n    for centers, radii, _ in top_results:\n        # Final refinement with very high penalties\n        penalty_weights = {\n            'boundary': 10000.0,\n            'overlap': 10000.0,\n            'spacing': 1.0\n        }\n        \n        x0 = centers.flatten()\n        \n        for _ in range(5):\n            result = minimize(\n                lambda x: adaptive_objective(x, penalty_weights),\n                x0,\n                method='L-BFGS-B',\n                bounds=[(0.01, 0.99)] * (2 * n),\n                options={'maxiter': 200, 'ftol': 1e-12}\n            )\n            x0 = result.x\n        \n        centers_final = x0.reshape(n, 2)\n        radii_final = compute_max_radii(centers_final)\n        sum_final = np.sum(radii_final)\n        \n        if sum_final > best_sum:\n            best_centers = centers_final\n            best_radii = radii_final\n            best_sum = sum_final\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 0.2546510696411133,
    "error": "TypeError: minimum() takes from 2 to 3 positional arguments but 1 were given"
  },
  "prompt": "Create constraint-adaptive optimizer:\n\nStrategy:\n1. Start with trial_6_6's best initialization\n2. Adaptive constraint handling:\n   - Monitor constraint violations\n   - Dynamically adjust penalty weights\n   - Focus on most violated constraints\n3. Run 40 times with different adaptive strategies\n4. Take top 10 results\n5. Apply final ultra-refinement\n6. Return best\n\nRequirements:\n- Adaptive constraint handling\n- 40 runs\n- Dynamic penalty adjustment\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses constraint-adaptive optimization with dynamic penalty adjustment.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def best_initialization():\n        \"\"\"Start with trial_6_6's best known configuration.\"\"\"\n        centers = np.array([\n            [0.10, 0.10], [0.30, 0.10], [0.50, 0.10], [0.70, 0.10], [0.90, 0.10],\n            [0.10, 0.30], [0.30, 0.30], [0.50, 0.30], [0.70, 0.30], [0.90, 0.30],\n            [0.10, 0.50], [0.30, 0.50], [0.50, 0.50], [0.70, 0.50], [0.90, 0.50],\n            [0.10, 0.70], [0.30, 0.70], [0.50, 0.70], [0.70, 0.70], [0.90, 0.70],\n            [0.10, 0.90], [0.30, 0.90], [0.50, 0.90], [0.70, 0.90], [0.90, 0.90],\n            [0.50, 0.50]\n        ])\n        radii = np.full(n, 0.08)\n        return centers, radii\n    \n    def compute_max_radii(centers):\n        \"\"\"Compute maximum possible radii given centers.\"\"\"\n        radii = np.zeros(n)\n        for i in range(n):\n            # Boundary constraints\n            max_r = min(centers[i, 0], 1 - centers[i, 0], \n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Non-overlap constraints\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, dist / 2)\n            \n            radii[i] = max(0, max_r)\n        return radii\n    \n    def adaptive_objective(x, penalty_weights):\n        \"\"\"Objective with adaptive constraint penalties.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = compute_max_radii(centers)\n        \n        # Primary objective: maximize sum of radii\n        obj = -np.sum(radii)\n        \n        # Adaptive boundary penalties\n        boundary_violations = np.maximum(0, radii[:, None] - np.minimum(\n            np.column_stack([centers[:, 0], 1 - centers[:, 0],\n                           centers[:, 1], 1 - centers[:, 1]]),\n            axis=1\n        ))\n        boundary_penalty = penalty_weights['boundary'] * np.sum(boundary_violations**2)\n        \n        # Adaptive overlap penalties\n        distances = cdist(centers, centers)\n        np.fill_diagonal(distances, np.inf)\n        radii_sum = radii[:, None] + radii[None, :]\n        overlap_violations = np.maximum(0, radii_sum - distances)\n        overlap_penalty = penalty_weights['overlap'] * np.sum(overlap_violations**2)\n        \n        # Adaptive spacing penalty (encourage better distribution)\n        min_distances = np.min(distances, axis=1)\n        spacing_penalty = penalty_weights['spacing'] * np.sum(1.0 / (min_distances + 1e-6))\n        \n        return obj + boundary_penalty + overlap_penalty + spacing_penalty\n    \n    def update_penalty_weights(centers, radii, weights, iteration):\n        \"\"\"Dynamically adjust penalty weights based on violations.\"\"\"\n        # Check boundary violations\n        boundary_slack = np.minimum(\n            np.column_stack([centers[:, 0] - radii, 1 - centers[:, 0] - radii,\n                           centers[:, 1] - radii, 1 - centers[:, 1] - radii]),\n            axis=1\n        )\n        boundary_violation = np.sum(np.maximum(0, -boundary_slack))\n        \n        # Check overlap violations\n        distances = cdist(centers, centers)\n        np.fill_diagonal(distances, np.inf)\n        radii_sum = radii[:, None] + radii[None, :]\n        overlap_violation = np.sum(np.maximum(0, radii_sum - distances))\n        \n        # Adaptive weight update\n        new_weights = weights.copy()\n        \n        if boundary_violation > 1e-6:\n            new_weights['boundary'] *= 1.5\n        else:\n            new_weights['boundary'] *= 0.95\n            \n        if overlap_violation > 1e-6:\n            new_weights['overlap'] *= 1.5\n        else:\n            new_weights['overlap'] *= 0.95\n        \n        # Adjust spacing weight based on progress\n        if iteration > 50:\n            new_weights['spacing'] *= 0.9\n        \n        return new_weights\n    \n    def optimize_with_adaptive_constraints(seed, strategy):\n        \"\"\"Run optimization with adaptive constraint handling.\"\"\"\n        np.random.seed(seed)\n        \n        # Initialize\n        centers, radii = best_initialization()\n        \n        # Add small perturbation based on strategy\n        if strategy == 'perturb_light':\n            centers += np.random.randn(n, 2) * 0.01\n        elif strategy == 'perturb_medium':\n            centers += np.random.randn(n, 2) * 0.02\n        elif strategy == 'perturb_heavy':\n            centers += np.random.randn(n, 2) * 0.03\n        elif strategy == 'grid_shift':\n            shift = np.random.rand(2) * 0.05\n            centers += shift\n        \n        centers = np.clip(centers, 0.05, 0.95)\n        \n        # Initial penalty weights\n        penalty_weights = {\n            'boundary': 1000.0,\n            'overlap': 1000.0,\n            'spacing': 10.0\n        }\n        \n        x0 = centers.flatten()\n        \n        # Multi-stage optimization with adaptive penalties\n        for stage in range(3):\n            for iteration in range(20):\n                result = minimize(\n                    lambda x: adaptive_objective(x, penalty_weights),\n                    x0,\n                    method='L-BFGS-B',\n                    bounds=[(0.01, 0.99)] * (2 * n),\n                    options={'maxiter': 50, 'ftol': 1e-9}\n                )\n                \n                x0 = result.x\n                centers_temp = x0.reshape(n, 2)\n                radii_temp = compute_max_radii(centers_temp)\n                \n                # Update penalties based on violations\n                penalty_weights = update_penalty_weights(\n                    centers_temp, radii_temp, penalty_weights, iteration\n                )\n            \n            # Increase penalty weights for next stage\n            penalty_weights['boundary'] *= 2\n            penalty_weights['overlap'] *= 2\n        \n        centers = x0.reshape(n, 2)\n        radii = compute_max_radii(centers)\n        \n        return centers, radii, np.sum(radii)\n    \n    # Run 40 optimizations with different strategies\n    strategies = ['perturb_light', 'perturb_medium', 'perturb_heavy', 'grid_shift', 'base']\n    results = []\n    \n    for i in range(40):\n        strategy = strategies[i % len(strategies)]\n        centers, radii, sum_r = optimize_with_adaptive_constraints(i, strategy)\n        results.append((centers, radii, sum_r))\n    \n    # Sort and take top 10\n    results.sort(key=lambda x: x[2], reverse=True)\n    top_results = results[:10]\n    \n    # Ultra-refinement on top results\n    best_centers, best_radii, best_sum = top_results[0]\n    \n    for centers, radii, _ in top_results:\n        # Final refinement with very high penalties\n        penalty_weights = {\n            'boundary': 10000.0,\n            'overlap': 10000.0,\n            'spacing': 1.0\n        }\n        \n        x0 = centers.flatten()\n        \n        for _ in range(5):\n            result = minimize(\n                lambda x: adaptive_objective(x, penalty_weights),\n                x0,\n                method='L-BFGS-B',\n                bounds=[(0.01, 0.99)] * (2 * n),\n                options={'maxiter': 200, 'ftol': 1e-12}\n            )\n            x0 = result.x\n        \n        centers_final = x0.reshape(n, 2)\n        radii_final = compute_max_radii(centers_final)\n        sum_final = np.sum(radii_final)\n        \n        if sum_final > best_sum:\n            best_centers = centers_final\n            best_radii = radii_final\n            best_sum = sum_final\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T19:20:24.065621",
  "cost_data": null
}