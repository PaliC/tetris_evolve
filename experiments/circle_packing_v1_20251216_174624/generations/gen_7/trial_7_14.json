{
  "trial_id": "trial_7_14",
  "generation": 7,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses 4-level hierarchical optimization with progressive refinement.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def decode_solution(x):\n        \"\"\"Decode flat array into centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        _, radii = decode_solution(x)\n        return -np.sum(radii)\n    \n    def constraints_penalty(x, penalty_weight=1e6):\n        \"\"\"Compute constraint violations with penalty.\"\"\"\n        centers, radii = decode_solution(x)\n        penalty = 0.0\n        \n        # Boundary constraints\n        for i in range(n):\n            penalty += max(0, radii[i] - centers[i, 0]) ** 2\n            penalty += max(0, radii[i] - centers[i, 1]) ** 2\n            penalty += max(0, centers[i, 0] + radii[i] - 1.0) ** 2\n            penalty += max(0, centers[i, 1] + radii[i] - 1.0) ** 2\n            penalty += max(0, -radii[i]) ** 2\n        \n        # Non-overlap constraints\n        dists = squareform(pdist(centers))\n        for i in range(n):\n            for j in range(i+1, n):\n                overlap = (radii[i] + radii[j]) - dists[i, j]\n                if overlap > 0:\n                    penalty += overlap ** 2\n        \n        return penalty * penalty_weight\n    \n    def objective_with_penalty(x, penalty_weight=1e6):\n        \"\"\"Objective function with penalty for constraint violations.\"\"\"\n        return objective(x) + constraints_penalty(x, penalty_weight)\n    \n    def generate_initial_solution(seed=None):\n        \"\"\"Generate diverse initial solutions.\"\"\"\n        if seed is not None:\n            np.random.seed(seed)\n        \n        # Use different grid patterns for diversity\n        patterns = ['grid', 'hex', 'random', 'circular']\n        pattern = patterns[seed % len(patterns)] if seed is not None else 'grid'\n        \n        if pattern == 'grid':\n            grid_size = int(np.ceil(np.sqrt(n)))\n            spacing = 1.0 / (grid_size + 1)\n            centers = []\n            for i in range(grid_size):\n                for j in range(grid_size):\n                    if len(centers) < n:\n                        centers.append([spacing * (i + 1), spacing * (j + 1)])\n            centers = np.array(centers)\n        \n        elif pattern == 'hex':\n            rows = int(np.ceil(np.sqrt(n * 2 / np.sqrt(3))))\n            spacing = 1.0 / (rows + 1)\n            centers = []\n            for i in range(rows):\n                cols = int(np.ceil(n / rows))\n                offset = (i % 2) * spacing / 2\n                for j in range(cols):\n                    if len(centers) < n:\n                        x = spacing * (j + 1) + offset\n                        y = spacing * (i + 1) * np.sqrt(3) / 2\n                        if x <= 1.0 and y <= 1.0:\n                            centers.append([x, y])\n            centers = np.array(centers[:n])\n        \n        elif pattern == 'circular':\n            centers = []\n            for i in range(n):\n                angle = 2 * np.pi * i / n\n                r = 0.3 + 0.1 * np.random.rand()\n                centers.append([0.5 + r * np.cos(angle), 0.5 + r * np.sin(angle)])\n            centers = np.array(centers)\n        \n        else:  # random\n            centers = 0.2 + 0.6 * np.random.rand(n, 2)\n        \n        # Clip to safe region\n        centers = np.clip(centers, 0.1, 0.9)\n        \n        # Initialize radii\n        radii = np.full(n, 0.05)\n        \n        return np.concatenate([centers.flatten(), radii])\n    \n    def optimize_solution(x0, maxiter, gtol):\n        \"\"\"Optimize a single solution.\"\"\"\n        bounds = [(0.0, 1.0)] * (2 * n) + [(0.0, 0.5)] * n\n        \n        result = minimize(\n            objective_with_penalty,\n            x0,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': maxiter, 'gtol': gtol, 'ftol': 1e-15}\n        )\n        \n        return result.x, -result.fun\n    \n    print(\"Level 1: Global search (50 runs)...\")\n    level1_solutions = []\n    for i in range(50):\n        x0 = generate_initial_solution(seed=i)\n        x_opt, sum_radii = optimize_solution(x0, maxiter=5000, gtol=1e-8)\n        level1_solutions.append((x_opt, sum_radii))\n    \n    # Sort and select top 20\n    level1_solutions.sort(key=lambda x: x[1], reverse=True)\n    top20 = level1_solutions[:20]\n    \n    print(f\"Level 1 best: {top20[0][1]:.6f}\")\n    \n    print(\"Level 2: Regional refinement (top 20)...\")\n    level2_solutions = []\n    for x0, _ in top20:\n        x_opt, sum_radii = optimize_solution(x0, maxiter=15000, gtol=1e-11)\n        level2_solutions.append((x_opt, sum_radii))\n    \n    # Sort and select top 10\n    level2_solutions.sort(key=lambda x: x[1], reverse=True)\n    top10 = level2_solutions[:10]\n    \n    print(f\"Level 2 best: {top10[0][1]:.6f}\")\n    \n    print(\"Level 3: Local polish (top 10)...\")\n    level3_solutions = []\n    for x0, _ in top10:\n        x_opt, sum_radii = optimize_solution(x0, maxiter=25000, gtol=1e-13)\n        level3_solutions.append((x_opt, sum_radii))\n    \n    # Sort and select top 5\n    level3_solutions.sort(key=lambda x: x[1], reverse=True)\n    top5 = level3_solutions[:5]\n    \n    print(f\"Level 3 best: {top5[0][1]:.6f}\")\n    \n    print(\"Level 4: Ultra-refinement (top 5)...\")\n    level4_solutions = []\n    for x0, _ in top5:\n        x_opt, sum_radii = optimize_solution(x0, maxiter=35000, gtol=1e-14)\n        level4_solutions.append((x_opt, sum_radii))\n    \n    # Sort and select absolute best\n    level4_solutions.sort(key=lambda x: x[1], reverse=True)\n    best_x, best_sum = level4_solutions[0]\n    \n    print(f\"Level 4 best: {best_sum:.6f}\")\n    \n    # Decode final solution\n    centers, radii = decode_solution(best_x)\n    \n    return centers, radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.8419821790459738,
    "target_ratio": 0.6990444702261761,
    "combined_score": 0.6990444702261761,
    "eval_time": 87.12185287475586,
    "error": null
  },
  "prompt": "Create hierarchical optimization:\n\nStrategy:\n1. Level 1 - Global search (50 runs):\n   - Quick optimization (maxiter=5000, gtol=1e-8)\n   - Diverse initializations\n2. Level 2 - Regional refinement (top 20):\n   - Medium optimization (maxiter=15000, gtol=1e-11)\n3. Level 3 - Local polish (top 10):\n   - Intensive optimization (maxiter=25000, gtol=1e-13)\n4. Level 4 - Ultra-refinement (top 5):\n   - Maximum precision (maxiter=35000, gtol=1e-14)\n5. Return absolute best\n\nRequirements:\n- 4-level hierarchy\n- Progressive refinement\n- Efficient execution\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses 4-level hierarchical optimization with progressive refinement.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def decode_solution(x):\n        \"\"\"Decode flat array into centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        _, radii = decode_solution(x)\n        return -np.sum(radii)\n    \n    def constraints_penalty(x, penalty_weight=1e6):\n        \"\"\"Compute constraint violations with penalty.\"\"\"\n        centers, radii = decode_solution(x)\n        penalty = 0.0\n        \n        # Boundary constraints\n        for i in range(n):\n            penalty += max(0, radii[i] - centers[i, 0]) ** 2\n            penalty += max(0, radii[i] - centers[i, 1]) ** 2\n            penalty += max(0, centers[i, 0] + radii[i] - 1.0) ** 2\n            penalty += max(0, centers[i, 1] + radii[i] - 1.0) ** 2\n            penalty += max(0, -radii[i]) ** 2\n        \n        # Non-overlap constraints\n        dists = squareform(pdist(centers))\n        for i in range(n):\n            for j in range(i+1, n):\n                overlap = (radii[i] + radii[j]) - dists[i, j]\n                if overlap > 0:\n                    penalty += overlap ** 2\n        \n        return penalty * penalty_weight\n    \n    def objective_with_penalty(x, penalty_weight=1e6):\n        \"\"\"Objective function with penalty for constraint violations.\"\"\"\n        return objective(x) + constraints_penalty(x, penalty_weight)\n    \n    def generate_initial_solution(seed=None):\n        \"\"\"Generate diverse initial solutions.\"\"\"\n        if seed is not None:\n            np.random.seed(seed)\n        \n        # Use different grid patterns for diversity\n        patterns = ['grid', 'hex', 'random', 'circular']\n        pattern = patterns[seed % len(patterns)] if seed is not None else 'grid'\n        \n        if pattern == 'grid':\n            grid_size = int(np.ceil(np.sqrt(n)))\n            spacing = 1.0 / (grid_size + 1)\n            centers = []\n            for i in range(grid_size):\n                for j in range(grid_size):\n                    if len(centers) < n:\n                        centers.append([spacing * (i + 1), spacing * (j + 1)])\n            centers = np.array(centers)\n        \n        elif pattern == 'hex':\n            rows = int(np.ceil(np.sqrt(n * 2 / np.sqrt(3))))\n            spacing = 1.0 / (rows + 1)\n            centers = []\n            for i in range(rows):\n                cols = int(np.ceil(n / rows))\n                offset = (i % 2) * spacing / 2\n                for j in range(cols):\n                    if len(centers) < n:\n                        x = spacing * (j + 1) + offset\n                        y = spacing * (i + 1) * np.sqrt(3) / 2\n                        if x <= 1.0 and y <= 1.0:\n                            centers.append([x, y])\n            centers = np.array(centers[:n])\n        \n        elif pattern == 'circular':\n            centers = []\n            for i in range(n):\n                angle = 2 * np.pi * i / n\n                r = 0.3 + 0.1 * np.random.rand()\n                centers.append([0.5 + r * np.cos(angle), 0.5 + r * np.sin(angle)])\n            centers = np.array(centers)\n        \n        else:  # random\n            centers = 0.2 + 0.6 * np.random.rand(n, 2)\n        \n        # Clip to safe region\n        centers = np.clip(centers, 0.1, 0.9)\n        \n        # Initialize radii\n        radii = np.full(n, 0.05)\n        \n        return np.concatenate([centers.flatten(), radii])\n    \n    def optimize_solution(x0, maxiter, gtol):\n        \"\"\"Optimize a single solution.\"\"\"\n        bounds = [(0.0, 1.0)] * (2 * n) + [(0.0, 0.5)] * n\n        \n        result = minimize(\n            objective_with_penalty,\n            x0,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': maxiter, 'gtol': gtol, 'ftol': 1e-15}\n        )\n        \n        return result.x, -result.fun\n    \n    print(\"Level 1: Global search (50 runs)...\")\n    level1_solutions = []\n    for i in range(50):\n        x0 = generate_initial_solution(seed=i)\n        x_opt, sum_radii = optimize_solution(x0, maxiter=5000, gtol=1e-8)\n        level1_solutions.append((x_opt, sum_radii))\n    \n    # Sort and select top 20\n    level1_solutions.sort(key=lambda x: x[1], reverse=True)\n    top20 = level1_solutions[:20]\n    \n    print(f\"Level 1 best: {top20[0][1]:.6f}\")\n    \n    print(\"Level 2: Regional refinement (top 20)...\")\n    level2_solutions = []\n    for x0, _ in top20:\n        x_opt, sum_radii = optimize_solution(x0, maxiter=15000, gtol=1e-11)\n        level2_solutions.append((x_opt, sum_radii))\n    \n    # Sort and select top 10\n    level2_solutions.sort(key=lambda x: x[1], reverse=True)\n    top10 = level2_solutions[:10]\n    \n    print(f\"Level 2 best: {top10[0][1]:.6f}\")\n    \n    print(\"Level 3: Local polish (top 10)...\")\n    level3_solutions = []\n    for x0, _ in top10:\n        x_opt, sum_radii = optimize_solution(x0, maxiter=25000, gtol=1e-13)\n        level3_solutions.append((x_opt, sum_radii))\n    \n    # Sort and select top 5\n    level3_solutions.sort(key=lambda x: x[1], reverse=True)\n    top5 = level3_solutions[:5]\n    \n    print(f\"Level 3 best: {top5[0][1]:.6f}\")\n    \n    print(\"Level 4: Ultra-refinement (top 5)...\")\n    level4_solutions = []\n    for x0, _ in top5:\n        x_opt, sum_radii = optimize_solution(x0, maxiter=35000, gtol=1e-14)\n        level4_solutions.append((x_opt, sum_radii))\n    \n    # Sort and select absolute best\n    level4_solutions.sort(key=lambda x: x[1], reverse=True)\n    best_x, best_sum = level4_solutions[0]\n    \n    print(f\"Level 4 best: {best_sum:.6f}\")\n    \n    # Decode final solution\n    centers, radii = decode_solution(best_x)\n    \n    return centers, radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T19:21:46.052208",
  "cost_data": null
}