{
  "trial_id": "trial_0_12",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom typing import Tuple, List\nimport heapq\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using Apollonian gasket approach.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n_circles = 26\n    centers = []\n    radii = []\n    \n    # Start with 3 large circles arranged in a triangle pattern\n    # Place them to maximize size while staying in unit square\n    r1 = 0.185\n    centers.append(np.array([0.185, 0.185]))\n    radii.append(r1)\n    \n    centers.append(np.array([0.815, 0.185]))\n    radii.append(r1)\n    \n    centers.append(np.array([0.5, 0.815]))\n    radii.append(r1)\n    \n    # Priority queue: (negative_radius, gap_info)\n    # gap_info contains indices of circles forming the gap\n    gaps = []\n    \n    def is_valid_circle(center, radius):\n        \"\"\"Check if circle is valid (inside square and no overlap)\"\"\"\n        x, y = center\n        if x - radius < 0 or x + radius > 1 or y - radius < 0 or y + radius > 1:\n            return False\n        \n        for i, (c, r) in enumerate(zip(centers, radii)):\n            dist = np.linalg.norm(center - c)\n            if dist < radius + r - 1e-9:  # Small tolerance\n                return False\n        return True\n    \n    def find_tangent_circle(c1, r1, c2, r2, c3, r3):\n        \"\"\"\n        Find circle tangent to three given circles using Descartes Circle Theorem.\n        Returns the center and radius of the inscribed circle.\n        \"\"\"\n        # Convert to curvatures (k = 1/r)\n        k1 = 1.0 / r1 if r1 > 0 else 0\n        k2 = 1.0 / r2 if r2 > 0 else 0\n        k3 = 1.0 / r3 if r3 > 0 else 0\n        \n        # Descartes Circle Theorem for curvature\n        k4_sum = k1 + k2 + k3\n        k4_prod = k1*k2 + k2*k3 + k3*k1\n        \n        # Two solutions: k4 = k_sum \u00b1 2*sqrt(k_prod)\n        discriminant = k4_prod\n        if discriminant < 0:\n            return None, None\n        \n        k4_inner = k4_sum + 2 * np.sqrt(discriminant)\n        \n        if k4_inner <= 0:\n            return None, None\n        \n        r4 = 1.0 / k4_inner\n        \n        # Find center using complex number representation\n        z1 = c1[0] + 1j * c1[1]\n        z2 = c2[0] + 1j * c2[1]\n        z3 = c3[0] + 1j * c3[1]\n        \n        zk1 = z1 * k1\n        zk2 = z2 * k2\n        zk3 = z3 * k3\n        \n        zk_sum = zk1 + zk2 + zk3\n        zk_prod = zk1*zk2 + zk2*zk3 + zk3*zk1\n        \n        discriminant_z = zk_prod\n        if discriminant_z.real < 0 and abs(discriminant_z.imag) < 1e-10:\n            discriminant_z = abs(discriminant_z.real)\n        \n        z4 = (zk_sum + 2 * np.sqrt(discriminant_z)) / k4_inner\n        \n        center = np.array([z4.real, z4.imag])\n        \n        return center, r4\n    \n    def add_gap(i1, i2, i3):\n        \"\"\"Try to add a gap formed by three circles to the priority queue\"\"\"\n        c1, r1 = centers[i1], radii[i1]\n        c2, r2 = centers[i2], radii[i2]\n        c3, r3 = centers[i3], radii[i3]\n        \n        center, radius = find_tangent_circle(c1, r1, c2, r2, c3, r3)\n        \n        if center is not None and radius is not None and radius > 1e-6:\n            if is_valid_circle(center, radius):\n                heapq.heappush(gaps, (-radius, (i1, i2, i3), center, radius))\n    \n    # Initialize gaps between the first 3 circles\n    add_gap(0, 1, 2)\n    \n    # Also add gaps with boundary circles (represented as large radius circles)\n    # Add boundary-aware gaps for corners and edges\n    \n    # Fill remaining circles greedily\n    while len(centers) < n_circles and gaps:\n        neg_r, (i1, i2, i3), center, radius = heapq.heappop(gaps)\n        \n        # Verify the circle is still valid\n        if not is_valid_circle(center, radius):\n            continue\n        \n        # Add the circle\n        centers.append(center)\n        radii.append(radius)\n        new_idx = len(centers) - 1\n        \n        # Add new gaps formed with this circle\n        add_gap(new_idx, i1, i2)\n        add_gap(new_idx, i2, i3)\n        add_gap(new_idx, i3, i1)\n    \n    # If we don't have enough circles, add smaller circles in remaining spaces\n    while len(centers) < n_circles:\n        # Try to find the largest circle that fits\n        best_center = None\n        best_radius = 0\n        \n        # Grid search for remaining space\n        for x in np.linspace(0.05, 0.95, 20):\n            for y in np.linspace(0.05, 0.95, 20):\n                # Binary search for maximum radius at this position\n                r_min, r_max = 0, 0.5\n                for _ in range(20):\n                    r_test = (r_min + r_max) / 2\n                    if is_valid_circle(np.array([x, y]), r_test):\n                        r_min = r_test\n                    else:\n                        r_max = r_test\n                \n                if r_min > best_radius:\n                    best_radius = r_min\n                    best_center = np.array([x, y])\n        \n        if best_radius > 1e-6:\n            centers.append(best_center)\n            radii.append(best_radius)\n        else:\n            # Add a minimal circle if we can't find space\n            centers.append(np.array([0.5, 0.5]))\n            radii.append(1e-6)\n    \n    centers = np.array(centers[:n_circles])\n    radii = np.array(radii[:n_circles])\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 0.6897286228431274,
    "target_ratio": 0.2617565931093463,
    "combined_score": 0.2617565931093463,
    "eval_time": 0.08296394348144531,
    "error": null
  },
  "prompt": "Write a circle packing using Apollonian gasket approach for 26 circles.\n\nStart with a few large circles and recursively fill gaps with smaller circles:\n- Place 3-4 large circles first\n- Find gaps between circles\n- Fill gaps with circles tangent to surrounding circles\n- Continue until 26 circles placed\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Use Descartes Circle Theorem for tangent circles\n- Prioritize larger circles (greedy gap filling)\n- Use numpy\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom typing import Tuple, List\nimport heapq\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using Apollonian gasket approach.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n_circles = 26\n    centers = []\n    radii = []\n    \n    # Start with 3 large circles arranged in a triangle pattern\n    # Place them to maximize size while staying in unit square\n    r1 = 0.185\n    centers.append(np.array([0.185, 0.185]))\n    radii.append(r1)\n    \n    centers.append(np.array([0.815, 0.185]))\n    radii.append(r1)\n    \n    centers.append(np.array([0.5, 0.815]))\n    radii.append(r1)\n    \n    # Priority queue: (negative_radius, gap_info)\n    # gap_info contains indices of circles forming the gap\n    gaps = []\n    \n    def is_valid_circle(center, radius):\n        \"\"\"Check if circle is valid (inside square and no overlap)\"\"\"\n        x, y = center\n        if x - radius < 0 or x + radius > 1 or y - radius < 0 or y + radius > 1:\n            return False\n        \n        for i, (c, r) in enumerate(zip(centers, radii)):\n            dist = np.linalg.norm(center - c)\n            if dist < radius + r - 1e-9:  # Small tolerance\n                return False\n        return True\n    \n    def find_tangent_circle(c1, r1, c2, r2, c3, r3):\n        \"\"\"\n        Find circle tangent to three given circles using Descartes Circle Theorem.\n        Returns the center and radius of the inscribed circle.\n        \"\"\"\n        # Convert to curvatures (k = 1/r)\n        k1 = 1.0 / r1 if r1 > 0 else 0\n        k2 = 1.0 / r2 if r2 > 0 else 0\n        k3 = 1.0 / r3 if r3 > 0 else 0\n        \n        # Descartes Circle Theorem for curvature\n        k4_sum = k1 + k2 + k3\n        k4_prod = k1*k2 + k2*k3 + k3*k1\n        \n        # Two solutions: k4 = k_sum \u00b1 2*sqrt(k_prod)\n        discriminant = k4_prod\n        if discriminant < 0:\n            return None, None\n        \n        k4_inner = k4_sum + 2 * np.sqrt(discriminant)\n        \n        if k4_inner <= 0:\n            return None, None\n        \n        r4 = 1.0 / k4_inner\n        \n        # Find center using complex number representation\n        z1 = c1[0] + 1j * c1[1]\n        z2 = c2[0] + 1j * c2[1]\n        z3 = c3[0] + 1j * c3[1]\n        \n        zk1 = z1 * k1\n        zk2 = z2 * k2\n        zk3 = z3 * k3\n        \n        zk_sum = zk1 + zk2 + zk3\n        zk_prod = zk1*zk2 + zk2*zk3 + zk3*zk1\n        \n        discriminant_z = zk_prod\n        if discriminant_z.real < 0 and abs(discriminant_z.imag) < 1e-10:\n            discriminant_z = abs(discriminant_z.real)\n        \n        z4 = (zk_sum + 2 * np.sqrt(discriminant_z)) / k4_inner\n        \n        center = np.array([z4.real, z4.imag])\n        \n        return center, r4\n    \n    def add_gap(i1, i2, i3):\n        \"\"\"Try to add a gap formed by three circles to the priority queue\"\"\"\n        c1, r1 = centers[i1], radii[i1]\n        c2, r2 = centers[i2], radii[i2]\n        c3, r3 = centers[i3], radii[i3]\n        \n        center, radius = find_tangent_circle(c1, r1, c2, r2, c3, r3)\n        \n        if center is not None and radius is not None and radius > 1e-6:\n            if is_valid_circle(center, radius):\n                heapq.heappush(gaps, (-radius, (i1, i2, i3), center, radius))\n    \n    # Initialize gaps between the first 3 circles\n    add_gap(0, 1, 2)\n    \n    # Also add gaps with boundary circles (represented as large radius circles)\n    # Add boundary-aware gaps for corners and edges\n    \n    # Fill remaining circles greedily\n    while len(centers) < n_circles and gaps:\n        neg_r, (i1, i2, i3), center, radius = heapq.heappop(gaps)\n        \n        # Verify the circle is still valid\n        if not is_valid_circle(center, radius):\n            continue\n        \n        # Add the circle\n        centers.append(center)\n        radii.append(radius)\n        new_idx = len(centers) - 1\n        \n        # Add new gaps formed with this circle\n        add_gap(new_idx, i1, i2)\n        add_gap(new_idx, i2, i3)\n        add_gap(new_idx, i3, i1)\n    \n    # If we don't have enough circles, add smaller circles in remaining spaces\n    while len(centers) < n_circles:\n        # Try to find the largest circle that fits\n        best_center = None\n        best_radius = 0\n        \n        # Grid search for remaining space\n        for x in np.linspace(0.05, 0.95, 20):\n            for y in np.linspace(0.05, 0.95, 20):\n                # Binary search for maximum radius at this position\n                r_min, r_max = 0, 0.5\n                for _ in range(20):\n                    r_test = (r_min + r_max) / 2\n                    if is_valid_circle(np.array([x, y]), r_test):\n                        r_min = r_test\n                    else:\n                        r_max = r_test\n                \n                if r_min > best_radius:\n                    best_radius = r_min\n                    best_center = np.array([x, y])\n        \n        if best_radius > 1e-6:\n            centers.append(best_center)\n            radii.append(best_radius)\n        else:\n            # Add a minimal circle if we can't find space\n            centers.append(np.array([0.5, 0.5]))\n            radii.append(1e-6)\n    \n    centers = np.array(centers[:n_circles])\n    radii = np.array(radii[:n_circles])\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T17:47:43.010963",
  "cost_data": null
}