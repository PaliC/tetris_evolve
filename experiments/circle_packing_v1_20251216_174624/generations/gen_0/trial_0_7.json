{
  "trial_id": "trial_0_7",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom typing import Tuple\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using genetic algorithm.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    np.random.seed(42)\n    \n    n_circles = 26\n    pop_size = 50\n    n_generations = 100\n    tournament_size = 5\n    mutation_rate = 0.2\n    mutation_strength = 0.05\n    elite_size = 2\n    \n    def create_individual():\n        \"\"\"Create a random individual (genome).\"\"\"\n        # Start with smaller radii to avoid initial constraint violations\n        centers = np.random.uniform(0.1, 0.9, (n_circles, 2))\n        radii = np.random.uniform(0.02, 0.08, n_circles)\n        return np.concatenate([centers.flatten(), radii])\n    \n    def decode_genome(genome):\n        \"\"\"Decode genome into centers and radii.\"\"\"\n        centers = genome[:2*n_circles].reshape(n_circles, 2)\n        radii = genome[2*n_circles:]\n        return centers, radii\n    \n    def check_constraints(centers, radii):\n        \"\"\"Check if all constraints are satisfied.\"\"\"\n        # Check if circles are inside unit square\n        for i in range(n_circles):\n            if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n                centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n                return False\n            if radii[i] < 0:\n                return False\n        \n        # Check for overlaps\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-6:\n                    return False\n        \n        return True\n    \n    def fitness(genome):\n        \"\"\"Calculate fitness of an individual.\"\"\"\n        centers, radii = decode_genome(genome)\n        \n        # Base fitness is sum of radii\n        sum_radii = np.sum(radii)\n        \n        # Heavy penalty for constraint violations\n        penalty = 0.0\n        \n        # Penalize circles outside unit square\n        for i in range(n_circles):\n            if centers[i, 0] - radii[i] < 0:\n                penalty += (0 - (centers[i, 0] - radii[i])) * 10\n            if centers[i, 0] + radii[i] > 1:\n                penalty += (centers[i, 0] + radii[i] - 1) * 10\n            if centers[i, 1] - radii[i] < 0:\n                penalty += (0 - (centers[i, 1] - radii[i])) * 10\n            if centers[i, 1] + radii[i] > 1:\n                penalty += (centers[i, 1] + radii[i] - 1) * 10\n            if radii[i] < 0:\n                penalty += abs(radii[i]) * 10\n        \n        # Penalize overlaps\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    penalty += overlap * 20\n        \n        return sum_radii - penalty\n    \n    def tournament_selection(population, fitnesses):\n        \"\"\"Select individual using tournament selection.\"\"\"\n        indices = np.random.choice(len(population), tournament_size, replace=False)\n        best_idx = indices[np.argmax(fitnesses[indices])]\n        return population[best_idx].copy()\n    \n    def crossover(parent1, parent2):\n        \"\"\"Blend crossover between two parents.\"\"\"\n        alpha = np.random.uniform(0.3, 0.7)\n        child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def mutate(individual):\n        \"\"\"Mutate an individual.\"\"\"\n        if np.random.random() < mutation_rate:\n            mutation = np.random.normal(0, mutation_strength, len(individual))\n            individual = individual + mutation\n            \n            # Ensure radii stay positive and reasonable\n            centers, radii = decode_genome(individual)\n            radii = np.clip(radii, 0.01, 0.15)\n            centers = np.clip(centers, 0.05, 0.95)\n            individual = np.concatenate([centers.flatten(), radii])\n        \n        return individual\n    \n    # Initialize population\n    population = [create_individual() for _ in range(pop_size)]\n    \n    best_genome = None\n    best_fitness = -float('inf')\n    \n    # Evolution loop\n    for generation in range(n_generations):\n        # Evaluate fitness\n        fitnesses = np.array([fitness(ind) for ind in population])\n        \n        # Track best individual\n        gen_best_idx = np.argmax(fitnesses)\n        if fitnesses[gen_best_idx] > best_fitness:\n            best_fitness = fitnesses[gen_best_idx]\n            best_genome = population[gen_best_idx].copy()\n        \n        # Create next generation\n        new_population = []\n        \n        # Elitism: keep best individuals\n        elite_indices = np.argsort(fitnesses)[-elite_size:]\n        for idx in elite_indices:\n            new_population.append(population[idx].copy())\n        \n        # Generate rest of population\n        while len(new_population) < pop_size:\n            parent1 = tournament_selection(population, fitnesses)\n            parent2 = tournament_selection(population, fitnesses)\n            \n            child = crossover(parent1, parent2)\n            child = mutate(child)\n            \n            new_population.append(child)\n        \n        population = new_population\n    \n    # Final evaluation to get best solution\n    fitnesses = np.array([fitness(ind) for ind in population])\n    best_idx = np.argmax(fitnesses)\n    if fitnesses[best_idx] > best_fitness:\n        best_genome = population[best_idx]\n    \n    # Decode best genome\n    centers, radii = decode_genome(best_genome)\n    \n    # Post-processing: try to increase radii while maintaining constraints\n    for iteration in range(50):\n        improved = False\n        for i in range(n_circles):\n            # Try to increase radius\n            original_radius = radii[i]\n            max_radius = min(\n                centers[i, 0],\n                1 - centers[i, 0],\n                centers[i, 1],\n                1 - centers[i, 1]\n            )\n            \n            # Check distance to other circles\n            for j in range(n_circles):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_radius = min(max_radius, dist - radii[j])\n            \n            if max_radius > radii[i] + 1e-6:\n                radii[i] = max_radius - 1e-6\n                improved = True\n        \n        if not improved:\n            break\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 2.489804744720459,
    "error": "Circles 4 and 12 overlap: distance=0.072655, required=0.093913"
  },
  "prompt": "Write a circle packing using a genetic algorithm for 26 circles in [0,1]x[0,1].\n\nEvolve population of packings:\n- Genome: concatenated (x, y, r) for all 26 circles\n- Fitness: sum of radii (penalize invalid packings)\n- Selection: tournament or roulette\n- Crossover: blend parent genomes\n- Mutation: perturb positions/radii\n- Run for multiple generations\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Population size ~50, run ~100 generations\n- Ensure constraints in fitness evaluation\n- Use numpy\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom typing import Tuple\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using genetic algorithm.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    np.random.seed(42)\n    \n    n_circles = 26\n    pop_size = 50\n    n_generations = 100\n    tournament_size = 5\n    mutation_rate = 0.2\n    mutation_strength = 0.05\n    elite_size = 2\n    \n    def create_individual():\n        \"\"\"Create a random individual (genome).\"\"\"\n        # Start with smaller radii to avoid initial constraint violations\n        centers = np.random.uniform(0.1, 0.9, (n_circles, 2))\n        radii = np.random.uniform(0.02, 0.08, n_circles)\n        return np.concatenate([centers.flatten(), radii])\n    \n    def decode_genome(genome):\n        \"\"\"Decode genome into centers and radii.\"\"\"\n        centers = genome[:2*n_circles].reshape(n_circles, 2)\n        radii = genome[2*n_circles:]\n        return centers, radii\n    \n    def check_constraints(centers, radii):\n        \"\"\"Check if all constraints are satisfied.\"\"\"\n        # Check if circles are inside unit square\n        for i in range(n_circles):\n            if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n                centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n                return False\n            if radii[i] < 0:\n                return False\n        \n        # Check for overlaps\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-6:\n                    return False\n        \n        return True\n    \n    def fitness(genome):\n        \"\"\"Calculate fitness of an individual.\"\"\"\n        centers, radii = decode_genome(genome)\n        \n        # Base fitness is sum of radii\n        sum_radii = np.sum(radii)\n        \n        # Heavy penalty for constraint violations\n        penalty = 0.0\n        \n        # Penalize circles outside unit square\n        for i in range(n_circles):\n            if centers[i, 0] - radii[i] < 0:\n                penalty += (0 - (centers[i, 0] - radii[i])) * 10\n            if centers[i, 0] + radii[i] > 1:\n                penalty += (centers[i, 0] + radii[i] - 1) * 10\n            if centers[i, 1] - radii[i] < 0:\n                penalty += (0 - (centers[i, 1] - radii[i])) * 10\n            if centers[i, 1] + radii[i] > 1:\n                penalty += (centers[i, 1] + radii[i] - 1) * 10\n            if radii[i] < 0:\n                penalty += abs(radii[i]) * 10\n        \n        # Penalize overlaps\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    penalty += overlap * 20\n        \n        return sum_radii - penalty\n    \n    def tournament_selection(population, fitnesses):\n        \"\"\"Select individual using tournament selection.\"\"\"\n        indices = np.random.choice(len(population), tournament_size, replace=False)\n        best_idx = indices[np.argmax(fitnesses[indices])]\n        return population[best_idx].copy()\n    \n    def crossover(parent1, parent2):\n        \"\"\"Blend crossover between two parents.\"\"\"\n        alpha = np.random.uniform(0.3, 0.7)\n        child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def mutate(individual):\n        \"\"\"Mutate an individual.\"\"\"\n        if np.random.random() < mutation_rate:\n            mutation = np.random.normal(0, mutation_strength, len(individual))\n            individual = individual + mutation\n            \n            # Ensure radii stay positive and reasonable\n            centers, radii = decode_genome(individual)\n            radii = np.clip(radii, 0.01, 0.15)\n            centers = np.clip(centers, 0.05, 0.95)\n            individual = np.concatenate([centers.flatten(), radii])\n        \n        return individual\n    \n    # Initialize population\n    population = [create_individual() for _ in range(pop_size)]\n    \n    best_genome = None\n    best_fitness = -float('inf')\n    \n    # Evolution loop\n    for generation in range(n_generations):\n        # Evaluate fitness\n        fitnesses = np.array([fitness(ind) for ind in population])\n        \n        # Track best individual\n        gen_best_idx = np.argmax(fitnesses)\n        if fitnesses[gen_best_idx] > best_fitness:\n            best_fitness = fitnesses[gen_best_idx]\n            best_genome = population[gen_best_idx].copy()\n        \n        # Create next generation\n        new_population = []\n        \n        # Elitism: keep best individuals\n        elite_indices = np.argsort(fitnesses)[-elite_size:]\n        for idx in elite_indices:\n            new_population.append(population[idx].copy())\n        \n        # Generate rest of population\n        while len(new_population) < pop_size:\n            parent1 = tournament_selection(population, fitnesses)\n            parent2 = tournament_selection(population, fitnesses)\n            \n            child = crossover(parent1, parent2)\n            child = mutate(child)\n            \n            new_population.append(child)\n        \n        population = new_population\n    \n    # Final evaluation to get best solution\n    fitnesses = np.array([fitness(ind) for ind in population])\n    best_idx = np.argmax(fitnesses)\n    if fitnesses[best_idx] > best_fitness:\n        best_genome = population[best_idx]\n    \n    # Decode best genome\n    centers, radii = decode_genome(best_genome)\n    \n    # Post-processing: try to increase radii while maintaining constraints\n    for iteration in range(50):\n        improved = False\n        for i in range(n_circles):\n            # Try to increase radius\n            original_radius = radii[i]\n            max_radius = min(\n                centers[i, 0],\n                1 - centers[i, 0],\n                centers[i, 1],\n                1 - centers[i, 1]\n            )\n            \n            # Check distance to other circles\n            for j in range(n_circles):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_radius = min(max_radius, dist - radii[j])\n            \n            if max_radius > radii[i] + 1e-6:\n                radii[i] = max_radius - 1e-6\n                improved = True\n        \n        if not improved:\n            break\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T17:47:42.645956",
  "cost_data": null
}