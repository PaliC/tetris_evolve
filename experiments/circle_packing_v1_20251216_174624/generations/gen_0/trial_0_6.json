{
  "trial_id": "trial_0_6",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    centers = []\n    radii = []\n    \n    # Grid resolution for searching positions\n    grid_res = 30\n    \n    for i in range(n):\n        best_radius = 0\n        best_center = None\n        \n        # Generate candidate positions on a grid\n        x_candidates = np.linspace(0, 1, grid_res)\n        y_candidates = np.linspace(0, 1, grid_res)\n        \n        for x in x_candidates:\n            for y in y_candidates:\n                center = np.array([x, y])\n                \n                # Binary search for maximum radius at this position\n                max_radius = find_max_radius(center, centers, radii)\n                \n                if max_radius > best_radius:\n                    best_radius = max_radius\n                    best_center = center\n        \n        # Add the best circle found\n        if best_center is not None and best_radius > 0:\n            centers.append(best_center)\n            radii.append(best_radius)\n        else:\n            # Fallback: place a tiny circle at a random valid position\n            centers.append(np.array([0.5, 0.5]))\n            radii.append(1e-6)\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef find_max_radius(center, existing_centers, existing_radii):\n    \"\"\"\n    Find maximum radius for a circle at given center using binary search.\n    \n    Args:\n        center: np.array of shape (2,) - proposed center\n        existing_centers: list of np.array - centers of existing circles\n        existing_radii: list of float - radii of existing circles\n    \n    Returns:\n        float: maximum feasible radius\n    \"\"\"\n    x, y = center\n    \n    # Maximum radius constrained by square boundaries\n    max_r_boundary = min(x, y, 1 - x, 1 - y)\n    \n    if max_r_boundary <= 0:\n        return 0\n    \n    # Maximum radius constrained by existing circles\n    max_r_circles = float('inf')\n    for i, existing_center in enumerate(existing_centers):\n        dist = np.linalg.norm(center - existing_center)\n        max_r_circles = min(max_r_circles, dist - existing_radii[i])\n    \n    # Overall maximum possible radius\n    max_r = min(max_r_boundary, max_r_circles)\n    \n    if max_r <= 0:\n        return 0\n    \n    # Binary search for maximum feasible radius\n    low, high = 0, max_r\n    epsilon = 1e-9\n    \n    for _ in range(50):  # Binary search iterations\n        mid = (low + high) / 2\n        \n        if is_feasible(center, mid, existing_centers, existing_radii):\n            low = mid\n        else:\n            high = mid\n        \n        if high - low < epsilon:\n            break\n    \n    return low\n\n\ndef is_feasible(center, radius, existing_centers, existing_radii):\n    \"\"\"\n    Check if a circle at given center with given radius is feasible.\n    \n    Args:\n        center: np.array of shape (2,) - circle center\n        radius: float - circle radius\n        existing_centers: list of np.array - centers of existing circles\n        existing_radii: list of float - radii of existing circles\n    \n    Returns:\n        bool: True if feasible, False otherwise\n    \"\"\"\n    x, y = center\n    \n    # Check boundary constraints\n    if x - radius < 0 or x + radius > 1 or y - radius < 0 or y + radius > 1:\n        return False\n    \n    # Check overlap with existing circles\n    for i, existing_center in enumerate(existing_centers):\n        dist = np.linalg.norm(center - existing_center)\n        if dist < radius + existing_radii[i] - 1e-9:  # Small tolerance\n            return False\n    \n    return True\n\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.4225046311373133,
    "target_ratio": 0.539849954890821,
    "combined_score": 0.539849954890821,
    "eval_time": 0.8187670707702637,
    "error": null
  },
  "prompt": "Write a sequential circle packing with radius maximization for 26 circles.\n\nStrategy: Place circles sequentially, but for each new circle, maximize its radius\ngiven the already-placed circles. Use binary search to find maximum feasible radius.\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- For each circle, try multiple positions (grid search)\n- For each position, binary search for maximum radius\n- Check constraints: no overlap with existing circles, within bounds\n- Use numpy\n- No plotting or printing",
  "response": "```python\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    centers = []\n    radii = []\n    \n    # Grid resolution for searching positions\n    grid_res = 30\n    \n    for i in range(n):\n        best_radius = 0\n        best_center = None\n        \n        # Generate candidate positions on a grid\n        x_candidates = np.linspace(0, 1, grid_res)\n        y_candidates = np.linspace(0, 1, grid_res)\n        \n        for x in x_candidates:\n            for y in y_candidates:\n                center = np.array([x, y])\n                \n                # Binary search for maximum radius at this position\n                max_radius = find_max_radius(center, centers, radii)\n                \n                if max_radius > best_radius:\n                    best_radius = max_radius\n                    best_center = center\n        \n        # Add the best circle found\n        if best_center is not None and best_radius > 0:\n            centers.append(best_center)\n            radii.append(best_radius)\n        else:\n            # Fallback: place a tiny circle at a random valid position\n            centers.append(np.array([0.5, 0.5]))\n            radii.append(1e-6)\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef find_max_radius(center, existing_centers, existing_radii):\n    \"\"\"\n    Find maximum radius for a circle at given center using binary search.\n    \n    Args:\n        center: np.array of shape (2,) - proposed center\n        existing_centers: list of np.array - centers of existing circles\n        existing_radii: list of float - radii of existing circles\n    \n    Returns:\n        float: maximum feasible radius\n    \"\"\"\n    x, y = center\n    \n    # Maximum radius constrained by square boundaries\n    max_r_boundary = min(x, y, 1 - x, 1 - y)\n    \n    if max_r_boundary <= 0:\n        return 0\n    \n    # Maximum radius constrained by existing circles\n    max_r_circles = float('inf')\n    for i, existing_center in enumerate(existing_centers):\n        dist = np.linalg.norm(center - existing_center)\n        max_r_circles = min(max_r_circles, dist - existing_radii[i])\n    \n    # Overall maximum possible radius\n    max_r = min(max_r_boundary, max_r_circles)\n    \n    if max_r <= 0:\n        return 0\n    \n    # Binary search for maximum feasible radius\n    low, high = 0, max_r\n    epsilon = 1e-9\n    \n    for _ in range(50):  # Binary search iterations\n        mid = (low + high) / 2\n        \n        if is_feasible(center, mid, existing_centers, existing_radii):\n            low = mid\n        else:\n            high = mid\n        \n        if high - low < epsilon:\n            break\n    \n    return low\n\n\ndef is_feasible(center, radius, existing_centers, existing_radii):\n    \"\"\"\n    Check if a circle at given center with given radius is feasible.\n    \n    Args:\n        center: np.array of shape (2,) - circle center\n        radius: float - circle radius\n        existing_centers: list of np.array - centers of existing circles\n        existing_radii: list of float - radii of existing circles\n    \n    Returns:\n        bool: True if feasible, False otherwise\n    \"\"\"\n    x, y = center\n    \n    # Check boundary constraints\n    if x - radius < 0 or x + radius > 1 or y - radius < 0 or y + radius > 1:\n        return False\n    \n    # Check overlap with existing circles\n    for i, existing_center in enumerate(existing_centers):\n        dist = np.linalg.norm(center - existing_center)\n        if dist < radius + existing_radii[i] - 1e-9:  # Small tolerance\n            return False\n    \n    return True\n\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T17:47:30.401095",
  "cost_data": null
}