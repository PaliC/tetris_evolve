{
  "trial_id": "trial_0_14",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.spatial import Voronoi\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using Voronoi tessellation.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # Initialize seeds in a grid pattern with some randomness\n    grid_size = int(np.ceil(np.sqrt(n)))\n    seeds = []\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if len(seeds) < n:\n                x = (i + 0.5) / grid_size + np.random.uniform(-0.05, 0.05)\n                y = (j + 0.5) / grid_size + np.random.uniform(-0.05, 0.05)\n                seeds.append([np.clip(x, 0.1, 0.9), np.clip(y, 0.1, 0.9)])\n    seeds = np.array(seeds[:n])\n    \n    def compute_voronoi_radii(points):\n        \"\"\"Compute maximum safe radius for each Voronoi cell.\"\"\"\n        # Add mirror points to handle boundaries\n        mirror_points = []\n        for p in points:\n            mirror_points.append(p)\n            # Mirror across boundaries\n            mirror_points.append([p[0], -p[1]])  # bottom\n            mirror_points.append([p[0], 2 - p[1]])  # top\n            mirror_points.append([-p[0], p[1]])  # left\n            mirror_points.append([2 - p[0], p[1]])  # right\n            # Corners\n            mirror_points.append([-p[0], -p[1]])\n            mirror_points.append([2 - p[0], -p[1]])\n            mirror_points.append([-p[0], 2 - p[1]])\n            mirror_points.append([2 - p[0], 2 - p[1]])\n        \n        mirror_points = np.array(mirror_points)\n        vor = Voronoi(mirror_points)\n        \n        radii = np.zeros(n)\n        centers = np.zeros((n, 2))\n        \n        for i in range(n):\n            point = points[i]\n            \n            # Find the Voronoi region for this point\n            region_index = vor.point_region[i]\n            vertex_indices = vor.regions[region_index]\n            \n            if -1 in vertex_indices or len(vertex_indices) == 0:\n                # Unbounded region, use conservative radius\n                radii[i] = 0.05\n                centers[i] = point\n                continue\n            \n            vertices = vor.vertices[vertex_indices]\n            \n            # Compute centroid of Voronoi cell\n            centroid = np.mean(vertices, axis=0)\n            \n            # Clip centroid to unit square\n            centroid = np.clip(centroid, 0, 1)\n            centers[i] = centroid\n            \n            # Compute maximum radius as minimum distance to:\n            # 1. Voronoi cell boundaries (other points)\n            # 2. Unit square boundaries\n            \n            # Distance to boundaries\n            dist_to_boundaries = min(\n                centroid[0],  # left\n                1 - centroid[0],  # right\n                centroid[1],  # bottom\n                1 - centroid[1]  # top\n            )\n            \n            # Distance to other points\n            distances_to_others = np.linalg.norm(points - centroid, axis=1)\n            distances_to_others[i] = np.inf  # Ignore self\n            dist_to_nearest = np.min(distances_to_others) / 2.0\n            \n            # Distance to Voronoi vertices (cell boundary)\n            dist_to_vertices = np.min(np.linalg.norm(vertices - centroid, axis=1))\n            \n            radii[i] = min(dist_to_boundaries, dist_to_nearest, dist_to_vertices) * 0.95\n        \n        return centers, radii\n    \n    # Lloyd's algorithm iterations to optimize Voronoi tessellation\n    best_seeds = seeds.copy()\n    best_sum = 0\n    \n    for iteration in range(50):\n        centers, radii = compute_voronoi_radii(seeds)\n        current_sum = np.sum(radii)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_seeds = seeds.copy()\n        \n        # Move seeds toward centroids (Lloyd's algorithm)\n        alpha = 0.5 * (1 - iteration / 50)  # Decay learning rate\n        seeds = seeds * (1 - alpha) + centers * alpha\n        \n        # Keep seeds within bounds with margin\n        seeds = np.clip(seeds, 0.05, 0.95)\n    \n    # Refine with optimization\n    def objective(flat_points):\n        points = flat_points.reshape(n, 2)\n        points = np.clip(points, 0.05, 0.95)\n        centers, radii = compute_voronoi_radii(points)\n        return -np.sum(radii)  # Negative because we minimize\n    \n    # Try optimization from best configuration\n    result = minimize(\n        objective,\n        best_seeds.flatten(),\n        method='L-BFGS-B',\n        bounds=[(0.05, 0.95)] * (2 * n),\n        options={'maxiter': 100}\n    )\n    \n    if result.success:\n        optimized_seeds = result.x.reshape(n, 2)\n        centers, radii = compute_voronoi_radii(optimized_seeds)\n        optimized_sum = np.sum(radii)\n        \n        if optimized_sum > best_sum:\n            best_seeds = optimized_seeds\n            best_sum = optimized_sum\n    \n    # Final computation with best seeds\n    centers, radii = compute_voronoi_radii(best_seeds)\n    \n    # Final validation and adjustment\n    for i in range(n):\n        # Ensure within bounds\n        max_r = min(\n            centers[i, 0],\n            1 - centers[i, 0],\n            centers[i, 1],\n            1 - centers[i, 1]\n        )\n        radii[i] = min(radii[i], max_r)\n        \n        # Ensure no overlap with others\n        for j in range(i):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j]:\n                # Shrink both radii proportionally\n                scale = 0.98 * dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n    \n    sum_radii = float(np.sum(radii))\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 0.55632712446887,
    "target_ratio": 0.21112983850811007,
    "combined_score": 0.21112983850811007,
    "eval_time": 1.312727928161621,
    "error": null
  },
  "prompt": "Write a circle packing using optimal transport / Voronoi approach for 26 circles.\n\nUse Voronoi tessellation to allocate space:\n- Generate 26 seed points\n- Compute Voronoi cells\n- Place circle at centroid of each cell\n- Set radius based on cell size (inscribed circle)\n- Optimize seed positions to maximize radii\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Use scipy.spatial.Voronoi\n- Iterate: update seeds based on cell properties\n- Compute maximum safe radius for each cell\n- Use numpy\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.spatial import Voronoi\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using Voronoi tessellation.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # Initialize seeds in a grid pattern with some randomness\n    grid_size = int(np.ceil(np.sqrt(n)))\n    seeds = []\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if len(seeds) < n:\n                x = (i + 0.5) / grid_size + np.random.uniform(-0.05, 0.05)\n                y = (j + 0.5) / grid_size + np.random.uniform(-0.05, 0.05)\n                seeds.append([np.clip(x, 0.1, 0.9), np.clip(y, 0.1, 0.9)])\n    seeds = np.array(seeds[:n])\n    \n    def compute_voronoi_radii(points):\n        \"\"\"Compute maximum safe radius for each Voronoi cell.\"\"\"\n        # Add mirror points to handle boundaries\n        mirror_points = []\n        for p in points:\n            mirror_points.append(p)\n            # Mirror across boundaries\n            mirror_points.append([p[0], -p[1]])  # bottom\n            mirror_points.append([p[0], 2 - p[1]])  # top\n            mirror_points.append([-p[0], p[1]])  # left\n            mirror_points.append([2 - p[0], p[1]])  # right\n            # Corners\n            mirror_points.append([-p[0], -p[1]])\n            mirror_points.append([2 - p[0], -p[1]])\n            mirror_points.append([-p[0], 2 - p[1]])\n            mirror_points.append([2 - p[0], 2 - p[1]])\n        \n        mirror_points = np.array(mirror_points)\n        vor = Voronoi(mirror_points)\n        \n        radii = np.zeros(n)\n        centers = np.zeros((n, 2))\n        \n        for i in range(n):\n            point = points[i]\n            \n            # Find the Voronoi region for this point\n            region_index = vor.point_region[i]\n            vertex_indices = vor.regions[region_index]\n            \n            if -1 in vertex_indices or len(vertex_indices) == 0:\n                # Unbounded region, use conservative radius\n                radii[i] = 0.05\n                centers[i] = point\n                continue\n            \n            vertices = vor.vertices[vertex_indices]\n            \n            # Compute centroid of Voronoi cell\n            centroid = np.mean(vertices, axis=0)\n            \n            # Clip centroid to unit square\n            centroid = np.clip(centroid, 0, 1)\n            centers[i] = centroid\n            \n            # Compute maximum radius as minimum distance to:\n            # 1. Voronoi cell boundaries (other points)\n            # 2. Unit square boundaries\n            \n            # Distance to boundaries\n            dist_to_boundaries = min(\n                centroid[0],  # left\n                1 - centroid[0],  # right\n                centroid[1],  # bottom\n                1 - centroid[1]  # top\n            )\n            \n            # Distance to other points\n            distances_to_others = np.linalg.norm(points - centroid, axis=1)\n            distances_to_others[i] = np.inf  # Ignore self\n            dist_to_nearest = np.min(distances_to_others) / 2.0\n            \n            # Distance to Voronoi vertices (cell boundary)\n            dist_to_vertices = np.min(np.linalg.norm(vertices - centroid, axis=1))\n            \n            radii[i] = min(dist_to_boundaries, dist_to_nearest, dist_to_vertices) * 0.95\n        \n        return centers, radii\n    \n    # Lloyd's algorithm iterations to optimize Voronoi tessellation\n    best_seeds = seeds.copy()\n    best_sum = 0\n    \n    for iteration in range(50):\n        centers, radii = compute_voronoi_radii(seeds)\n        current_sum = np.sum(radii)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_seeds = seeds.copy()\n        \n        # Move seeds toward centroids (Lloyd's algorithm)\n        alpha = 0.5 * (1 - iteration / 50)  # Decay learning rate\n        seeds = seeds * (1 - alpha) + centers * alpha\n        \n        # Keep seeds within bounds with margin\n        seeds = np.clip(seeds, 0.05, 0.95)\n    \n    # Refine with optimization\n    def objective(flat_points):\n        points = flat_points.reshape(n, 2)\n        points = np.clip(points, 0.05, 0.95)\n        centers, radii = compute_voronoi_radii(points)\n        return -np.sum(radii)  # Negative because we minimize\n    \n    # Try optimization from best configuration\n    result = minimize(\n        objective,\n        best_seeds.flatten(),\n        method='L-BFGS-B',\n        bounds=[(0.05, 0.95)] * (2 * n),\n        options={'maxiter': 100}\n    )\n    \n    if result.success:\n        optimized_seeds = result.x.reshape(n, 2)\n        centers, radii = compute_voronoi_radii(optimized_seeds)\n        optimized_sum = np.sum(radii)\n        \n        if optimized_sum > best_sum:\n            best_seeds = optimized_seeds\n            best_sum = optimized_sum\n    \n    # Final computation with best seeds\n    centers, radii = compute_voronoi_radii(best_seeds)\n    \n    # Final validation and adjustment\n    for i in range(n):\n        # Ensure within bounds\n        max_r = min(\n            centers[i, 0],\n            1 - centers[i, 0],\n            centers[i, 1],\n            1 - centers[i, 1]\n        )\n        radii[i] = min(radii[i], max_r)\n        \n        # Ensure no overlap with others\n        for j in range(i):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j]:\n                # Shrink both radii proportionally\n                scale = 0.98 * dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n    \n    sum_radii = float(np.sum(radii))\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T17:47:43.345356",
  "cost_data": null
}