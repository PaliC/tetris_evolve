{
  "trial_id": "trial_0_0",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using hexagonal lattice.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Hexagonal lattice arrangement\n    # We'll use a pattern that fits well in a square\n    # For 26 circles, we can try different row configurations\n    \n    # Try a 5-5-5-5-6 pattern (5 rows with varying circles)\n    # or 4-5-5-5-4-3 pattern\n    # Let's use: 6-5-5-5-5 = 26 circles\n    \n    rows = [6, 5, 5, 5, 5]\n    \n    # Calculate optimal radius based on hexagonal packing\n    # For hexagonal packing, horizontal spacing = 2*r\n    # Vertical spacing = sqrt(3)*r\n    \n    # Estimate initial radius\n    max_cols = max(rows)\n    num_rows = len(rows)\n    \n    # Calculate radius that fits horizontally\n    r_horizontal = 1.0 / (2 * max_cols)\n    \n    # Calculate radius that fits vertically\n    r_vertical = 1.0 / (2 + (num_rows - 1) * np.sqrt(3))\n    \n    # Use the smaller to ensure fit\n    r_initial = min(r_horizontal, r_vertical) * 0.95  # 0.95 for safety margin\n    \n    # Generate hexagonal lattice centers\n    centers = []\n    \n    for row_idx, num_circles in enumerate(rows):\n        y = r_initial + row_idx * np.sqrt(3) * r_initial\n        \n        # Offset for hexagonal packing (alternate rows)\n        x_offset = r_initial if row_idx % 2 == 1 else 0\n        \n        # Center the row\n        row_width = (num_circles - 1) * 2 * r_initial\n        x_start = (1.0 - row_width) / 2 + x_offset\n        \n        for i in range(num_circles):\n            x = x_start + i * 2 * r_initial\n            centers.append([x, y])\n    \n    centers = np.array(centers)\n    \n    # Optimize radius to maximize sum while maintaining constraints\n    def objective(r):\n        return -n * r  # Negative because we minimize\n    \n    def constraint_within_bounds(r):\n        # All circles must be within [0, 1] x [0, 1]\n        min_vals = np.min(centers - r, axis=0)\n        max_vals = np.max(centers + r, axis=0)\n        return np.min([min_vals[0], min_vals[1], \n                      1.0 - max_vals[0], 1.0 - max_vals[1]])\n    \n    def constraint_no_overlap(r):\n        # Minimum distance between any two circles minus 2*r should be >= 0\n        min_dist = float('inf')\n        for i in range(len(centers)):\n            for j in range(i + 1, len(centers)):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = min(min_dist, dist)\n        return min_dist - 2 * r\n    \n    # Optimize radius\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_within_bounds},\n        {'type': 'ineq', 'fun': constraint_no_overlap}\n    ]\n    \n    result = minimize(\n        objective,\n        x0=r_initial,\n        method='SLSQP',\n        bounds=[(0, 0.5)],\n        constraints=constraints,\n        options={'maxiter': 100}\n    )\n    \n    optimal_r = result.x[0]\n    \n    # Create uniform radii\n    radii = np.full(n, optimal_r)\n    \n    # Fine-tune: try to increase radii slightly for circles with more room\n    # Calculate distance to boundary for each circle\n    for i in range(n):\n        x, y = centers[i]\n        \n        # Distance to boundaries\n        dist_to_boundary = min(x - optimal_r, y - optimal_r, \n                              1.0 - x - optimal_r, 1.0 - y - optimal_r)\n        \n        # Distance to nearest neighbor\n        min_neighbor_dist = float('inf')\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_neighbor_dist = min(min_neighbor_dist, dist)\n        \n        # Available space\n        available = min(dist_to_boundary, (min_neighbor_dist - optimal_r) / 2)\n        \n        # Increase radius conservatively\n        if available > 0:\n            radii[i] = optimal_r + available * 0.5\n    \n    # Verify and adjust if needed\n    # Check boundaries\n    for i in range(n):\n        x, y = centers[i]\n        r = radii[i]\n        if x - r < 0:\n            radii[i] = x\n        if y - r < 0:\n            radii[i] = min(radii[i], y)\n        if x + r > 1:\n            radii[i] = min(radii[i], 1 - x)\n        if y + r > 1:\n            radii[i] = min(radii[i], 1 - y)\n    \n    # Check overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j]:\n                # Shrink both proportionally\n                shrink_factor = dist / (radii[i] + radii[j]) * 0.99\n                radii[i] *= shrink_factor\n                radii[j] *= shrink_factor\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.8326672379058098,
    "target_ratio": 0.6955093881995483,
    "combined_score": 0.6955093881995483,
    "eval_time": 0.23197293281555176,
    "error": null
  },
  "prompt": "Write a hexagonal lattice circle packing algorithm for 26 circles in a unit square [0,1]x[0,1].\n\nUse a hexagonal close-packing pattern, which is theoretically optimal for infinite plane packing.\nArrange circles in a hexagonal grid and adjust radii to maximize the sum while staying within bounds.\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- centers: np.array shape (26, 2) with x,y in [0,1]\n- radii: np.array shape (26,) all non-negative\n- No overlaps between circles\n- All circles entirely within [0,1]x[0,1]\n- No plotting or printing\n\nUse numpy for calculations.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using hexagonal lattice.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Hexagonal lattice arrangement\n    # We'll use a pattern that fits well in a square\n    # For 26 circles, we can try different row configurations\n    \n    # Try a 5-5-5-5-6 pattern (5 rows with varying circles)\n    # or 4-5-5-5-4-3 pattern\n    # Let's use: 6-5-5-5-5 = 26 circles\n    \n    rows = [6, 5, 5, 5, 5]\n    \n    # Calculate optimal radius based on hexagonal packing\n    # For hexagonal packing, horizontal spacing = 2*r\n    # Vertical spacing = sqrt(3)*r\n    \n    # Estimate initial radius\n    max_cols = max(rows)\n    num_rows = len(rows)\n    \n    # Calculate radius that fits horizontally\n    r_horizontal = 1.0 / (2 * max_cols)\n    \n    # Calculate radius that fits vertically\n    r_vertical = 1.0 / (2 + (num_rows - 1) * np.sqrt(3))\n    \n    # Use the smaller to ensure fit\n    r_initial = min(r_horizontal, r_vertical) * 0.95  # 0.95 for safety margin\n    \n    # Generate hexagonal lattice centers\n    centers = []\n    \n    for row_idx, num_circles in enumerate(rows):\n        y = r_initial + row_idx * np.sqrt(3) * r_initial\n        \n        # Offset for hexagonal packing (alternate rows)\n        x_offset = r_initial if row_idx % 2 == 1 else 0\n        \n        # Center the row\n        row_width = (num_circles - 1) * 2 * r_initial\n        x_start = (1.0 - row_width) / 2 + x_offset\n        \n        for i in range(num_circles):\n            x = x_start + i * 2 * r_initial\n            centers.append([x, y])\n    \n    centers = np.array(centers)\n    \n    # Optimize radius to maximize sum while maintaining constraints\n    def objective(r):\n        return -n * r  # Negative because we minimize\n    \n    def constraint_within_bounds(r):\n        # All circles must be within [0, 1] x [0, 1]\n        min_vals = np.min(centers - r, axis=0)\n        max_vals = np.max(centers + r, axis=0)\n        return np.min([min_vals[0], min_vals[1], \n                      1.0 - max_vals[0], 1.0 - max_vals[1]])\n    \n    def constraint_no_overlap(r):\n        # Minimum distance between any two circles minus 2*r should be >= 0\n        min_dist = float('inf')\n        for i in range(len(centers)):\n            for j in range(i + 1, len(centers)):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = min(min_dist, dist)\n        return min_dist - 2 * r\n    \n    # Optimize radius\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_within_bounds},\n        {'type': 'ineq', 'fun': constraint_no_overlap}\n    ]\n    \n    result = minimize(\n        objective,\n        x0=r_initial,\n        method='SLSQP',\n        bounds=[(0, 0.5)],\n        constraints=constraints,\n        options={'maxiter': 100}\n    )\n    \n    optimal_r = result.x[0]\n    \n    # Create uniform radii\n    radii = np.full(n, optimal_r)\n    \n    # Fine-tune: try to increase radii slightly for circles with more room\n    # Calculate distance to boundary for each circle\n    for i in range(n):\n        x, y = centers[i]\n        \n        # Distance to boundaries\n        dist_to_boundary = min(x - optimal_r, y - optimal_r, \n                              1.0 - x - optimal_r, 1.0 - y - optimal_r)\n        \n        # Distance to nearest neighbor\n        min_neighbor_dist = float('inf')\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_neighbor_dist = min(min_neighbor_dist, dist)\n        \n        # Available space\n        available = min(dist_to_boundary, (min_neighbor_dist - optimal_r) / 2)\n        \n        # Increase radius conservatively\n        if available > 0:\n            radii[i] = optimal_r + available * 0.5\n    \n    # Verify and adjust if needed\n    # Check boundaries\n    for i in range(n):\n        x, y = centers[i]\n        r = radii[i]\n        if x - r < 0:\n            radii[i] = x\n        if y - r < 0:\n            radii[i] = min(radii[i], y)\n        if x + r > 1:\n            radii[i] = min(radii[i], 1 - x)\n        if y + r > 1:\n            radii[i] = min(radii[i], 1 - y)\n    \n    # Check overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j]:\n                # Shrink both proportionally\n                shrink_factor = dist / (radii[i] + radii[j]) * 0.99\n                radii[i] *= shrink_factor\n                radii[j] *= shrink_factor\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T17:47:42.017244",
  "cost_data": null
}