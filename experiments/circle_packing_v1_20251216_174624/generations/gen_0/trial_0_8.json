{
  "trial_id": "trial_0_8",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom typing import List, Tuple, Optional\n\nclass QuadTreeNode:\n    \"\"\"A node in the quadtree structure.\"\"\"\n    \n    def __init__(self, x_min: float, x_max: float, y_min: float, y_max: float, depth: int = 0):\n        self.x_min = x_min\n        self.x_max = x_max\n        self.y_min = y_min\n        self.y_max = y_max\n        self.depth = depth\n        self.center_x = (x_min + x_max) / 2\n        self.center_y = (y_min + y_max) / 2\n        self.width = x_max - x_min\n        self.height = y_max - y_min\n        self.children: Optional[List['QuadTreeNode']] = None\n        self.is_occupied = False\n        \n    def subdivide(self):\n        \"\"\"Subdivide this node into 4 children.\"\"\"\n        if self.children is not None:\n            return\n        \n        mid_x = self.center_x\n        mid_y = self.center_y\n        new_depth = self.depth + 1\n        \n        self.children = [\n            QuadTreeNode(self.x_min, mid_x, self.y_min, mid_y, new_depth),  # Bottom-left\n            QuadTreeNode(mid_x, self.x_max, self.y_min, mid_y, new_depth),  # Bottom-right\n            QuadTreeNode(self.x_min, mid_x, mid_y, self.y_max, new_depth),  # Top-left\n            QuadTreeNode(mid_x, self.x_max, mid_y, self.y_max, new_depth),  # Top-right\n        ]\n    \n    def get_max_radius(self, existing_circles: List[Tuple[float, float, float]]) -> float:\n        \"\"\"\n        Calculate maximum radius for a circle at this node's center.\n        \n        Args:\n            existing_circles: List of (x, y, r) tuples for existing circles\n            \n        Returns:\n            Maximum safe radius\n        \"\"\"\n        # Distance to boundaries\n        dist_to_left = self.center_x - self.x_min\n        dist_to_right = self.x_max - self.center_x\n        dist_to_bottom = self.center_y - self.y_min\n        dist_to_top = self.y_max - self.center_y\n        \n        max_r = min(dist_to_left, dist_to_right, dist_to_bottom, dist_to_top)\n        \n        # Distance to existing circles\n        for cx, cy, cr in existing_circles:\n            dist = np.sqrt((self.center_x - cx)**2 + (self.center_y - cy)**2)\n            max_r = min(max_r, dist - cr)\n        \n        return max(0.0, max_r)\n\nclass QuadTreePacker:\n    \"\"\"Circle packer using quadtree space partitioning.\"\"\"\n    \n    def __init__(self, n_circles: int, max_depth: int = 6):\n        self.n_circles = n_circles\n        self.max_depth = max_depth\n        self.root = QuadTreeNode(0.0, 1.0, 0.0, 1.0)\n        self.circles: List[Tuple[float, float, float]] = []\n        \n    def get_all_nodes(self, node: QuadTreeNode) -> List[QuadTreeNode]:\n        \"\"\"Get all leaf nodes in the tree.\"\"\"\n        if node.children is None:\n            return [node]\n        \n        all_nodes = []\n        for child in node.children:\n            all_nodes.extend(self.get_all_nodes(child))\n        return all_nodes\n    \n    def find_best_placement(self) -> Optional[Tuple[QuadTreeNode, float]]:\n        \"\"\"\n        Find the best node to place the next circle.\n        \n        Returns:\n            Tuple of (best_node, max_radius) or None if no valid placement\n        \"\"\"\n        leaf_nodes = self.get_all_nodes(self.root)\n        \n        best_node = None\n        best_radius = 0.0\n        \n        for node in leaf_nodes:\n            if node.is_occupied:\n                continue\n                \n            max_r = node.get_max_radius(self.circles)\n            \n            if max_r > best_radius:\n                best_radius = max_r\n                best_node = node\n        \n        if best_node is None or best_radius <= 0:\n            return None\n            \n        return best_node, best_radius\n    \n    def subdivide_tree(self, target_depth: int):\n        \"\"\"Subdivide tree to target depth.\"\"\"\n        def subdivide_recursive(node: QuadTreeNode):\n            if node.depth < target_depth:\n                node.subdivide()\n                if node.children:\n                    for child in node.children:\n                        subdivide_recursive(child)\n        \n        subdivide_recursive(self.root)\n    \n    def pack_circles(self) -> Tuple[np.ndarray, np.ndarray, float]:\n        \"\"\"\n        Pack circles using quadtree strategy.\n        \n        Returns:\n            centers: np.array of shape (n_circles, 2)\n            radii: np.array of shape (n_circles,)\n            sum_radii: float\n        \"\"\"\n        # Start with initial subdivision\n        self.subdivide_tree(3)\n        \n        centers_list = []\n        radii_list = []\n        \n        for i in range(self.n_circles):\n            # Find best placement\n            result = self.find_best_placement()\n            \n            if result is None:\n                # Try subdividing further\n                leaf_nodes = self.get_all_nodes(self.root)\n                unoccupied = [n for n in leaf_nodes if not n.is_occupied]\n                \n                if unoccupied and unoccupied[0].depth < self.max_depth:\n                    # Subdivide largest unoccupied nodes\n                    for node in sorted(unoccupied, key=lambda n: -n.width * n.height)[:4]:\n                        if node.depth < self.max_depth:\n                            node.subdivide()\n                    \n                    result = self.find_best_placement()\n            \n            if result is None:\n                # No valid placement found, use smaller fallback\n                # Place at a grid position with minimal radius\n                grid_size = int(np.ceil(np.sqrt(self.n_circles)))\n                idx = len(self.circles)\n                row = idx // grid_size\n                col = idx % grid_size\n                spacing = 1.0 / grid_size\n                cx = (col + 0.5) * spacing\n                cy = (row + 0.5) * spacing\n                \n                # Find safe radius\n                r = spacing / 2.5\n                for ex_cx, ex_cy, ex_r in self.circles:\n                    dist = np.sqrt((cx - ex_cx)**2 + (cy - ex_cy)**2)\n                    r = min(r, max(0.0, (dist - ex_r) * 0.95))\n                \n                # Ensure within bounds\n                r = min(r, cx, 1.0 - cx, cy, 1.0 - cy)\n                r = max(0.0, r)\n                \n                centers_list.append([cx, cy])\n                radii_list.append(r)\n                self.circles.append((cx, cy, r))\n            else:\n                best_node, best_radius = result\n                \n                # Place circle at this node\n                cx, cy = best_node.center_x, best_node.center_y\n                r = best_radius * 0.98  # Slight safety margin\n                \n                centers_list.append([cx, cy])\n                radii_list.append(r)\n                self.circles.append((cx, cy, r))\n                best_node.is_occupied = True\n        \n        centers = np.array(centers_list)\n        radii = np.array(radii_list)\n        sum_radii = np.sum(radii)\n        \n        return centers, radii, sum_radii\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    packer = QuadTreePacker(n_circles=26, max_depth=7)\n    centers, radii, sum_radii = packer.pack_circles()\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.5925,
    "target_ratio": 0.6043643263757116,
    "combined_score": 0.6043643263757116,
    "eval_time": 0.08292770385742188,
    "error": null
  },
  "prompt": "Write a circle packing using quadtree space partitioning for 26 circles.\n\nUse quadtree to intelligently partition space and place circles:\n- Build quadtree of the unit square\n- Place circles in quadrants with most available space\n- Recursively subdivide and pack\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Implement simple quadtree structure\n- Pack circles from largest to smallest available space\n- Compute maximum safe radius for each placement\n- Use numpy\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\nclass QuadTreeNode:\n    \"\"\"A node in the quadtree structure.\"\"\"\n    \n    def __init__(self, x_min: float, x_max: float, y_min: float, y_max: float, depth: int = 0):\n        self.x_min = x_min\n        self.x_max = x_max\n        self.y_min = y_min\n        self.y_max = y_max\n        self.depth = depth\n        self.center_x = (x_min + x_max) / 2\n        self.center_y = (y_min + y_max) / 2\n        self.width = x_max - x_min\n        self.height = y_max - y_min\n        self.children: Optional[List['QuadTreeNode']] = None\n        self.is_occupied = False\n        \n    def subdivide(self):\n        \"\"\"Subdivide this node into 4 children.\"\"\"\n        if self.children is not None:\n            return\n        \n        mid_x = self.center_x\n        mid_y = self.center_y\n        new_depth = self.depth + 1\n        \n        self.children = [\n            QuadTreeNode(self.x_min, mid_x, self.y_min, mid_y, new_depth),  # Bottom-left\n            QuadTreeNode(mid_x, self.x_max, self.y_min, mid_y, new_depth),  # Bottom-right\n            QuadTreeNode(self.x_min, mid_x, mid_y, self.y_max, new_depth),  # Top-left\n            QuadTreeNode(mid_x, self.x_max, mid_y, self.y_max, new_depth),  # Top-right\n        ]\n    \n    def get_max_radius(self, existing_circles: List[Tuple[float, float, float]]) -> float:\n        \"\"\"\n        Calculate maximum radius for a circle at this node's center.\n        \n        Args:\n            existing_circles: List of (x, y, r) tuples for existing circles\n            \n        Returns:\n            Maximum safe radius\n        \"\"\"\n        # Distance to boundaries\n        dist_to_left = self.center_x - self.x_min\n        dist_to_right = self.x_max - self.center_x\n        dist_to_bottom = self.center_y - self.y_min\n        dist_to_top = self.y_max - self.center_y\n        \n        max_r = min(dist_to_left, dist_to_right, dist_to_bottom, dist_to_top)\n        \n        # Distance to existing circles\n        for cx, cy, cr in existing_circles:\n            dist = np.sqrt((self.center_x - cx)**2 + (self.center_y - cy)**2)\n            max_r = min(max_r, dist - cr)\n        \n        return max(0.0, max_r)\n\nclass QuadTreePacker:\n    \"\"\"Circle packer using quadtree space partitioning.\"\"\"\n    \n    def __init__(self, n_circles: int, max_depth: int = 6):\n        self.n_circles = n_circles\n        self.max_depth = max_depth\n        self.root = QuadTreeNode(0.0, 1.0, 0.0, 1.0)\n        self.circles: List[Tuple[float, float, float]] = []\n        \n    def get_all_nodes(self, node: QuadTreeNode) -> List[QuadTreeNode]:\n        \"\"\"Get all leaf nodes in the tree.\"\"\"\n        if node.children is None:\n            return [node]\n        \n        all_nodes = []\n        for child in node.children:\n            all_nodes.extend(self.get_all_nodes(child))\n        return all_nodes\n    \n    def find_best_placement(self) -> Optional[Tuple[QuadTreeNode, float]]:\n        \"\"\"\n        Find the best node to place the next circle.\n        \n        Returns:\n            Tuple of (best_node, max_radius) or None if no valid placement\n        \"\"\"\n        leaf_nodes = self.get_all_nodes(self.root)\n        \n        best_node = None\n        best_radius = 0.0\n        \n        for node in leaf_nodes:\n            if node.is_occupied:\n                continue\n                \n            max_r = node.get_max_radius(self.circles)\n            \n            if max_r > best_radius:\n                best_radius = max_r\n                best_node = node\n        \n        if best_node is None or best_radius <= 0:\n            return None\n            \n        return best_node, best_radius\n    \n    def subdivide_tree(self, target_depth: int):\n        \"\"\"Subdivide tree to target depth.\"\"\"\n        def subdivide_recursive(node: QuadTreeNode):\n            if node.depth < target_depth:\n                node.subdivide()\n                if node.children:\n                    for child in node.children:\n                        subdivide_recursive(child)\n        \n        subdivide_recursive(self.root)\n    \n    def pack_circles(self) -> Tuple[np.ndarray, np.ndarray, float]:\n        \"\"\"\n        Pack circles using quadtree strategy.\n        \n        Returns:\n            centers: np.array of shape (n_circles, 2)\n            radii: np.array of shape (n_circles,)\n            sum_radii: float\n        \"\"\"\n        # Start with initial subdivision\n        self.subdivide_tree(3)\n        \n        centers_list = []\n        radii_list = []\n        \n        for i in range(self.n_circles):\n            # Find best placement\n            result = self.find_best_placement()\n            \n            if result is None:\n                # Try subdividing further\n                leaf_nodes = self.get_all_nodes(self.root)\n                unoccupied = [n for n in leaf_nodes if not n.is_occupied]\n                \n                if unoccupied and unoccupied[0].depth < self.max_depth:\n                    # Subdivide largest unoccupied nodes\n                    for node in sorted(unoccupied, key=lambda n: -n.width * n.height)[:4]:\n                        if node.depth < self.max_depth:\n                            node.subdivide()\n                    \n                    result = self.find_best_placement()\n            \n            if result is None:\n                # No valid placement found, use smaller fallback\n                # Place at a grid position with minimal radius\n                grid_size = int(np.ceil(np.sqrt(self.n_circles)))\n                idx = len(self.circles)\n                row = idx // grid_size\n                col = idx % grid_size\n                spacing = 1.0 / grid_size\n                cx = (col + 0.5) * spacing\n                cy = (row + 0.5) * spacing\n                \n                # Find safe radius\n                r = spacing / 2.5\n                for ex_cx, ex_cy, ex_r in self.circles:\n                    dist = np.sqrt((cx - ex_cx)**2 + (cy - ex_cy)**2)\n                    r = min(r, max(0.0, (dist - ex_r) * 0.95))\n                \n                # Ensure within bounds\n                r = min(r, cx, 1.0 - cx, cy, 1.0 - cy)\n                r = max(0.0, r)\n                \n                centers_list.append([cx, cy])\n                radii_list.append(r)\n                self.circles.append((cx, cy, r))\n            else:\n                best_node, best_radius = result\n                \n                # Place circle at this node\n                cx, cy = best_node.center_x, best_node.center_y\n                r = best_radius * 0.98  # Slight safety margin\n                \n                centers_list.append([cx, cy])\n                radii_list.append(r)\n                self.circles.append((cx, cy, r))\n                best_node.is_occupied = True\n        \n        centers = np.array(centers_list)\n        radii = np.array(radii_list)\n        sum_radii = np.sum(radii)\n        \n        return centers, radii, sum_radii\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    packer = QuadTreePacker(n_circles=26, max_depth=7)\n    centers, radii, sum_radii = packer.pack_circles()\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T17:47:42.807647",
  "cost_data": null
}