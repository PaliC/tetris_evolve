{
  "trial_id": "trial_0_4",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using simulated annealing.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # Initialize with a grid layout\n    grid_size = int(np.ceil(np.sqrt(n)))\n    initial_radius = 0.5 / grid_size\n    \n    centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    radii = np.full(n, initial_radius)\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if configuration satisfies all constraints.\"\"\"\n        # Check if circles are inside unit square\n        if np.any(centers - radii[:, np.newaxis] < 0) or np.any(centers + radii[:, np.newaxis] > 1):\n            return False\n        \n        # Check for overlaps\n        distances = cdist(centers, centers)\n        np.fill_diagonal(distances, np.inf)\n        min_allowed_distances = radii[:, np.newaxis] + radii[np.newaxis, :]\n        \n        if np.any(distances < min_allowed_distances - 1e-9):\n            return False\n        \n        return True\n    \n    def compute_max_radii(centers):\n        \"\"\"Compute maximum possible radii for given centers.\"\"\"\n        radii = np.zeros(n)\n        \n        for i in range(n):\n            # Distance to boundaries\n            max_r = min(centers[i, 0], 1 - centers[i, 0], \n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, dist - radii[j])\n            \n            radii[i] = max(0, max_r)\n        \n        return radii\n    \n    def energy(centers, radii):\n        \"\"\"Energy function - negative sum of radii (we want to maximize).\"\"\"\n        if not is_valid(centers, radii):\n            return 1e10\n        return -np.sum(radii)\n    \n    # Simulated annealing parameters\n    initial_temp = 0.1\n    final_temp = 1e-6\n    cooling_rate = 0.9995\n    iterations = 50000\n    \n    current_centers = centers.copy()\n    current_radii = radii.copy()\n    current_energy = energy(current_centers, current_radii)\n    \n    best_centers = current_centers.copy()\n    best_radii = current_radii.copy()\n    best_energy = current_energy\n    \n    temperature = initial_temp\n    \n    for iteration in range(iterations):\n        # Create perturbation\n        new_centers = current_centers.copy()\n        new_radii = current_radii.copy()\n        \n        # Choose perturbation type\n        perturbation_type = np.random.rand()\n        \n        if perturbation_type < 0.4:\n            # Perturb one circle's position\n            idx = np.random.randint(n)\n            step_size = temperature * 0.5\n            new_centers[idx] += np.random.randn(2) * step_size\n            new_centers[idx] = np.clip(new_centers[idx], 0, 1)\n            \n        elif perturbation_type < 0.7:\n            # Perturb multiple circles' positions\n            num_perturb = np.random.randint(1, min(5, n))\n            indices = np.random.choice(n, num_perturb, replace=False)\n            step_size = temperature * 0.3\n            new_centers[indices] += np.random.randn(num_perturb, 2) * step_size\n            new_centers = np.clip(new_centers, 0, 1)\n            \n        else:\n            # Swap two circles\n            idx1, idx2 = np.random.choice(n, 2, replace=False)\n            new_centers[[idx1, idx2]] = new_centers[[idx2, idx1]]\n        \n        # Recompute optimal radii for new configuration\n        new_radii = compute_max_radii(new_centers)\n        \n        # Iteratively improve radii\n        for _ in range(3):\n            for i in range(n):\n                max_r = min(new_centers[i, 0], 1 - new_centers[i, 0],\n                           new_centers[i, 1], 1 - new_centers[i, 1])\n                \n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(new_centers[i] - new_centers[j])\n                        max_r = min(max_r, dist - new_radii[j])\n                \n                new_radii[i] = max(0, max_r)\n        \n        new_energy = energy(new_centers, new_radii)\n        \n        # Accept or reject\n        delta_energy = new_energy - current_energy\n        \n        if delta_energy < 0 or np.random.rand() < np.exp(-delta_energy / temperature):\n            current_centers = new_centers\n            current_radii = new_radii\n            current_energy = new_energy\n            \n            if current_energy < best_energy:\n                best_centers = current_centers.copy()\n                best_radii = current_radii.copy()\n                best_energy = current_energy\n        \n        # Cool down\n        temperature *= cooling_rate\n        temperature = max(temperature, final_temp)\n    \n    # Final refinement: optimize radii one more time\n    for _ in range(10):\n        for i in range(n):\n            max_r = min(best_centers[i, 0], 1 - best_centers[i, 0],\n                       best_centers[i, 1], 1 - best_centers[i, 1])\n            \n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(best_centers[i] - best_centers[j])\n                    max_r = min(max_r, dist - best_radii[j])\n            \n            best_radii[i] = max(0, max_r)\n    \n    sum_radii = np.sum(best_radii)\n    \n    return best_centers, best_radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.207713607639031,
    "target_ratio": 0.8378419763335982,
    "combined_score": 0.8378419763335982,
    "eval_time": 170.32636499404907,
    "error": null
  },
  "prompt": "Write a simulated annealing circle packing for 26 circles in [0,1]x[0,1].\n\nUse simulated annealing to optimize circle positions and radii:\n- Start with random/grid initialization\n- Randomly perturb positions and radii\n- Accept improvements always, accept worse solutions with probability exp(-\u0394E/T)\n- Decrease temperature over iterations\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Run for at least 10000 iterations\n- Ensure all constraints maintained\n- Use numpy.random for perturbations\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using simulated annealing.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # Initialize with a grid layout\n    grid_size = int(np.ceil(np.sqrt(n)))\n    initial_radius = 0.5 / grid_size\n    \n    centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    radii = np.full(n, initial_radius)\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if configuration satisfies all constraints.\"\"\"\n        # Check if circles are inside unit square\n        if np.any(centers - radii[:, np.newaxis] < 0) or np.any(centers + radii[:, np.newaxis] > 1):\n            return False\n        \n        # Check for overlaps\n        distances = cdist(centers, centers)\n        np.fill_diagonal(distances, np.inf)\n        min_allowed_distances = radii[:, np.newaxis] + radii[np.newaxis, :]\n        \n        if np.any(distances < min_allowed_distances - 1e-9):\n            return False\n        \n        return True\n    \n    def compute_max_radii(centers):\n        \"\"\"Compute maximum possible radii for given centers.\"\"\"\n        radii = np.zeros(n)\n        \n        for i in range(n):\n            # Distance to boundaries\n            max_r = min(centers[i, 0], 1 - centers[i, 0], \n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, dist - radii[j])\n            \n            radii[i] = max(0, max_r)\n        \n        return radii\n    \n    def energy(centers, radii):\n        \"\"\"Energy function - negative sum of radii (we want to maximize).\"\"\"\n        if not is_valid(centers, radii):\n            return 1e10\n        return -np.sum(radii)\n    \n    # Simulated annealing parameters\n    initial_temp = 0.1\n    final_temp = 1e-6\n    cooling_rate = 0.9995\n    iterations = 50000\n    \n    current_centers = centers.copy()\n    current_radii = radii.copy()\n    current_energy = energy(current_centers, current_radii)\n    \n    best_centers = current_centers.copy()\n    best_radii = current_radii.copy()\n    best_energy = current_energy\n    \n    temperature = initial_temp\n    \n    for iteration in range(iterations):\n        # Create perturbation\n        new_centers = current_centers.copy()\n        new_radii = current_radii.copy()\n        \n        # Choose perturbation type\n        perturbation_type = np.random.rand()\n        \n        if perturbation_type < 0.4:\n            # Perturb one circle's position\n            idx = np.random.randint(n)\n            step_size = temperature * 0.5\n            new_centers[idx] += np.random.randn(2) * step_size\n            new_centers[idx] = np.clip(new_centers[idx], 0, 1)\n            \n        elif perturbation_type < 0.7:\n            # Perturb multiple circles' positions\n            num_perturb = np.random.randint(1, min(5, n))\n            indices = np.random.choice(n, num_perturb, replace=False)\n            step_size = temperature * 0.3\n            new_centers[indices] += np.random.randn(num_perturb, 2) * step_size\n            new_centers = np.clip(new_centers, 0, 1)\n            \n        else:\n            # Swap two circles\n            idx1, idx2 = np.random.choice(n, 2, replace=False)\n            new_centers[[idx1, idx2]] = new_centers[[idx2, idx1]]\n        \n        # Recompute optimal radii for new configuration\n        new_radii = compute_max_radii(new_centers)\n        \n        # Iteratively improve radii\n        for _ in range(3):\n            for i in range(n):\n                max_r = min(new_centers[i, 0], 1 - new_centers[i, 0],\n                           new_centers[i, 1], 1 - new_centers[i, 1])\n                \n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(new_centers[i] - new_centers[j])\n                        max_r = min(max_r, dist - new_radii[j])\n                \n                new_radii[i] = max(0, max_r)\n        \n        new_energy = energy(new_centers, new_radii)\n        \n        # Accept or reject\n        delta_energy = new_energy - current_energy\n        \n        if delta_energy < 0 or np.random.rand() < np.exp(-delta_energy / temperature):\n            current_centers = new_centers\n            current_radii = new_radii\n            current_energy = new_energy\n            \n            if current_energy < best_energy:\n                best_centers = current_centers.copy()\n                best_radii = current_radii.copy()\n                best_energy = current_energy\n        \n        # Cool down\n        temperature *= cooling_rate\n        temperature = max(temperature, final_temp)\n    \n    # Final refinement: optimize radii one more time\n    for _ in range(10):\n        for i in range(n):\n            max_r = min(best_centers[i, 0], 1 - best_centers[i, 0],\n                       best_centers[i, 1], 1 - best_centers[i, 1])\n            \n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(best_centers[i] - best_centers[j])\n                    max_r = min(max_r, dist - best_radii[j])\n            \n            best_radii[i] = max(0, max_r)\n    \n    sum_radii = np.sum(best_radii)\n    \n    return best_centers, best_radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T17:50:28.913552",
  "cost_data": null
}