{
  "trial_id": "trial_6_14",
  "generation": 6,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using barrier method.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_solution = None\n    best_sum = -np.inf\n    \n    # Try 15 different random initializations\n    for seed in range(15):\n        np.random.seed(seed)\n        \n        # Initialize with random positions and small radii\n        centers_init = np.random.uniform(0.1, 0.9, (n, 2))\n        radii_init = np.full(n, 0.05)\n        x_init = np.concatenate([centers_init.flatten(), radii_init])\n        \n        # Progressive barrier reduction\n        barrier_params = [1.0, 0.1, 0.01, 0.001, 0.0001, 1e-5, 1e-6, 1e-7]\n        x_current = x_init.copy()\n        \n        for mu in barrier_params:\n            result = optimize_with_barrier(x_current, n, mu)\n            if result.success:\n                x_current = result.x\n            else:\n                # If optimization fails, try to continue with current solution\n                pass\n        \n        # Extract final solution\n        centers = x_current[:2*n].reshape(n, 2)\n        radii = x_current[2*n:]\n        \n        # Check if solution is valid\n        if is_valid_packing(centers, radii):\n            current_sum = np.sum(radii)\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_solution = (centers.copy(), radii.copy())\n    \n    # Apply final constrained optimization to top solutions\n    top_solutions = []\n    \n    # Collect valid solutions from multiple runs\n    for seed in range(15):\n        np.random.seed(seed)\n        centers_init = np.random.uniform(0.1, 0.9, (n, 2))\n        radii_init = np.full(n, 0.05)\n        x_init = np.concatenate([centers_init.flatten(), radii_init])\n        \n        barrier_params = [1.0, 0.1, 0.01, 0.001, 0.0001]\n        x_current = x_init.copy()\n        \n        for mu in barrier_params:\n            result = optimize_with_barrier(x_current, n, mu)\n            if result.success:\n                x_current = result.x\n        \n        centers = x_current[:2*n].reshape(n, 2)\n        radii = x_current[2*n:]\n        \n        if is_valid_packing(centers, radii):\n            top_solutions.append((centers.copy(), radii.copy(), np.sum(radii)))\n    \n    # Sort and take top 5\n    top_solutions.sort(key=lambda x: x[2], reverse=True)\n    top_solutions = top_solutions[:5]\n    \n    # Apply final optimization to top 5\n    for centers, radii, _ in top_solutions:\n        x_init = np.concatenate([centers.flatten(), radii])\n        \n        # Final constrained optimization\n        result = final_optimization(x_init, n)\n        \n        if result.success:\n            centers_final = result.x[:2*n].reshape(n, 2)\n            radii_final = result.x[2*n:]\n            \n            if is_valid_packing(centers_final, radii_final):\n                current_sum = np.sum(radii_final)\n                if current_sum > best_sum:\n                    best_sum = current_sum\n                    best_solution = (centers_final.copy(), radii_final.copy())\n    \n    if best_solution is None:\n        # Fallback: simple grid arrangement\n        centers, radii = create_fallback_packing(n)\n        best_solution = (centers, radii)\n        best_sum = np.sum(radii)\n    \n    centers, radii = best_solution\n    return centers, radii, best_sum\n\n\ndef optimize_with_barrier(x0, n, mu):\n    \"\"\"Optimize with barrier method for given barrier parameter mu.\"\"\"\n    \n    def barrier_objective(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        # Objective: maximize sum of radii = minimize negative sum\n        obj = -np.sum(radii)\n        \n        # Barrier terms\n        barrier = 0.0\n        \n        # Barrier for radii > 0\n        for i in range(n):\n            if radii[i] <= 1e-10:\n                return 1e10\n            barrier -= mu * np.log(radii[i])\n        \n        # Barrier for centers - radii >= 0 (left boundary)\n        for i in range(n):\n            val = centers[i, 0] - radii[i]\n            if val <= 1e-10:\n                return 1e10\n            barrier -= mu * np.log(val)\n        \n        # Barrier for centers + radii <= 1 (right boundary)\n        for i in range(n):\n            val = 1.0 - centers[i, 0] - radii[i]\n            if val <= 1e-10:\n                return 1e10\n            barrier -= mu * np.log(val)\n        \n        # Barrier for centers - radii >= 0 (bottom boundary)\n        for i in range(n):\n            val = centers[i, 1] - radii[i]\n            if val <= 1e-10:\n                return 1e10\n            barrier -= mu * np.log(val)\n        \n        # Barrier for centers + radii <= 1 (top boundary)\n        for i in range(n):\n            val = 1.0 - centers[i, 1] - radii[i]\n            if val <= 1e-10:\n                return 1e10\n            barrier -= mu * np.log(val)\n        \n        # Barrier for non-overlapping circles\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                val = dist - radii[i] - radii[j]\n                if val <= 1e-10:\n                    return 1e10\n                barrier -= mu * np.log(val)\n        \n        return obj + barrier\n    \n    result = minimize(barrier_objective, x0, method='BFGS', \n                     options={'maxiter': 500, 'gtol': 1e-5})\n    \n    return result\n\n\ndef final_optimization(x0, n):\n    \"\"\"Final constrained optimization.\"\"\"\n    \n    def objective(x):\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def constraints_func(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        constraints = []\n        \n        # Radii > 0\n        constraints.extend(radii)\n        \n        # Centers within bounds\n        constraints.extend(centers[:, 0] - radii)\n        constraints.extend(1.0 - centers[:, 0] - radii)\n        constraints.extend(centers[:, 1] - radii)\n        constraints.extend(1.0 - centers[:, 1] - radii)\n        \n        # Non-overlapping\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        return np.array(constraints)\n    \n    constraints = {'type': 'ineq', 'fun': constraints_func}\n    \n    result = minimize(objective, x0, method='SLSQP', constraints=constraints,\n                     options={'maxiter': 300})\n    \n    return result\n\n\ndef is_valid_packing(centers, radii):\n    \"\"\"Check if packing satisfies all constraints.\"\"\"\n    n = len(radii)\n    tol = 1e-6\n    \n    # Check radii are positive\n    if np.any(radii < -tol):\n        return False\n    \n    # Check circles are within bounds\n    for i in range(n):\n        if centers[i, 0] - radii[i] < -tol or centers[i, 0] + radii[i] > 1 + tol:\n            return False\n        if centers[i, 1] - radii[i] < -tol or centers[i, 1] + radii[i] > 1 + tol:\n            return False\n    \n    # Check non-overlapping\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                          (centers[i, 1] - centers[j, 1])**2)\n            if dist < radii[i] + radii[j] - tol:\n                return False\n    \n    return True\n\n\ndef create_fallback_packing(n):\n    \"\"\"Create a simple valid packing as fallback.\"\"\"\n    # Create a grid arrangement\n    grid_size = int(np.ceil(np.sqrt(n)))\n    spacing = 1.0 / grid_size\n    radius = spacing / 2.5  # Safe radius to avoid overlaps\n    \n    centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) * spacing\n        y = (row + 0.5) * spacing\n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    radii = np.full(n, radius)\n    \n    return centers, radii\n\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.7333333333333334,
    "target_ratio": 0.6578115117014548,
    "combined_score": 0.6578115117014548,
    "eval_time": 2.9537532329559326,
    "error": null
  },
  "prompt": "Create barrier method optimizer with progressive barrier reduction:\n\nStrategy:\n1. Transform to barrier problem (log barriers for constraints)\n2. Start with large barrier parameter (1.0)\n3. Iterative barrier reduction:\n   - Optimize with current barrier\n   - Reduce barrier by factor of 10\n   - Use previous solution as starting point\n   - Repeat 8 times (barrier from 1.0 to 1e-7)\n4. Run this 15 times with different seeds\n5. Apply final constrained optimization to top 5\n6. Return best\n\nRequirements:\n- Barrier method implementation\n- 8-stage barrier reduction\n- 15 restarts\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using barrier method.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_solution = None\n    best_sum = -np.inf\n    \n    # Try 15 different random initializations\n    for seed in range(15):\n        np.random.seed(seed)\n        \n        # Initialize with random positions and small radii\n        centers_init = np.random.uniform(0.1, 0.9, (n, 2))\n        radii_init = np.full(n, 0.05)\n        x_init = np.concatenate([centers_init.flatten(), radii_init])\n        \n        # Progressive barrier reduction\n        barrier_params = [1.0, 0.1, 0.01, 0.001, 0.0001, 1e-5, 1e-6, 1e-7]\n        x_current = x_init.copy()\n        \n        for mu in barrier_params:\n            result = optimize_with_barrier(x_current, n, mu)\n            if result.success:\n                x_current = result.x\n            else:\n                # If optimization fails, try to continue with current solution\n                pass\n        \n        # Extract final solution\n        centers = x_current[:2*n].reshape(n, 2)\n        radii = x_current[2*n:]\n        \n        # Check if solution is valid\n        if is_valid_packing(centers, radii):\n            current_sum = np.sum(radii)\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_solution = (centers.copy(), radii.copy())\n    \n    # Apply final constrained optimization to top solutions\n    top_solutions = []\n    \n    # Collect valid solutions from multiple runs\n    for seed in range(15):\n        np.random.seed(seed)\n        centers_init = np.random.uniform(0.1, 0.9, (n, 2))\n        radii_init = np.full(n, 0.05)\n        x_init = np.concatenate([centers_init.flatten(), radii_init])\n        \n        barrier_params = [1.0, 0.1, 0.01, 0.001, 0.0001]\n        x_current = x_init.copy()\n        \n        for mu in barrier_params:\n            result = optimize_with_barrier(x_current, n, mu)\n            if result.success:\n                x_current = result.x\n        \n        centers = x_current[:2*n].reshape(n, 2)\n        radii = x_current[2*n:]\n        \n        if is_valid_packing(centers, radii):\n            top_solutions.append((centers.copy(), radii.copy(), np.sum(radii)))\n    \n    # Sort and take top 5\n    top_solutions.sort(key=lambda x: x[2], reverse=True)\n    top_solutions = top_solutions[:5]\n    \n    # Apply final optimization to top 5\n    for centers, radii, _ in top_solutions:\n        x_init = np.concatenate([centers.flatten(), radii])\n        \n        # Final constrained optimization\n        result = final_optimization(x_init, n)\n        \n        if result.success:\n            centers_final = result.x[:2*n].reshape(n, 2)\n            radii_final = result.x[2*n:]\n            \n            if is_valid_packing(centers_final, radii_final):\n                current_sum = np.sum(radii_final)\n                if current_sum > best_sum:\n                    best_sum = current_sum\n                    best_solution = (centers_final.copy(), radii_final.copy())\n    \n    if best_solution is None:\n        # Fallback: simple grid arrangement\n        centers, radii = create_fallback_packing(n)\n        best_solution = (centers, radii)\n        best_sum = np.sum(radii)\n    \n    centers, radii = best_solution\n    return centers, radii, best_sum\n\n\ndef optimize_with_barrier(x0, n, mu):\n    \"\"\"Optimize with barrier method for given barrier parameter mu.\"\"\"\n    \n    def barrier_objective(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        # Objective: maximize sum of radii = minimize negative sum\n        obj = -np.sum(radii)\n        \n        # Barrier terms\n        barrier = 0.0\n        \n        # Barrier for radii > 0\n        for i in range(n):\n            if radii[i] <= 1e-10:\n                return 1e10\n            barrier -= mu * np.log(radii[i])\n        \n        # Barrier for centers - radii >= 0 (left boundary)\n        for i in range(n):\n            val = centers[i, 0] - radii[i]\n            if val <= 1e-10:\n                return 1e10\n            barrier -= mu * np.log(val)\n        \n        # Barrier for centers + radii <= 1 (right boundary)\n        for i in range(n):\n            val = 1.0 - centers[i, 0] - radii[i]\n            if val <= 1e-10:\n                return 1e10\n            barrier -= mu * np.log(val)\n        \n        # Barrier for centers - radii >= 0 (bottom boundary)\n        for i in range(n):\n            val = centers[i, 1] - radii[i]\n            if val <= 1e-10:\n                return 1e10\n            barrier -= mu * np.log(val)\n        \n        # Barrier for centers + radii <= 1 (top boundary)\n        for i in range(n):\n            val = 1.0 - centers[i, 1] - radii[i]\n            if val <= 1e-10:\n                return 1e10\n            barrier -= mu * np.log(val)\n        \n        # Barrier for non-overlapping circles\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                val = dist - radii[i] - radii[j]\n                if val <= 1e-10:\n                    return 1e10\n                barrier -= mu * np.log(val)\n        \n        return obj + barrier\n    \n    result = minimize(barrier_objective, x0, method='BFGS', \n                     options={'maxiter': 500, 'gtol': 1e-5})\n    \n    return result\n\n\ndef final_optimization(x0, n):\n    \"\"\"Final constrained optimization.\"\"\"\n    \n    def objective(x):\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def constraints_func(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        constraints = []\n        \n        # Radii > 0\n        constraints.extend(radii)\n        \n        # Centers within bounds\n        constraints.extend(centers[:, 0] - radii)\n        constraints.extend(1.0 - centers[:, 0] - radii)\n        constraints.extend(centers[:, 1] - radii)\n        constraints.extend(1.0 - centers[:, 1] - radii)\n        \n        # Non-overlapping\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        return np.array(constraints)\n    \n    constraints = {'type': 'ineq', 'fun': constraints_func}\n    \n    result = minimize(objective, x0, method='SLSQP', constraints=constraints,\n                     options={'maxiter': 300})\n    \n    return result\n\n\ndef is_valid_packing(centers, radii):\n    \"\"\"Check if packing satisfies all constraints.\"\"\"\n    n = len(radii)\n    tol = 1e-6\n    \n    # Check radii are positive\n    if np.any(radii < -tol):\n        return False\n    \n    # Check circles are within bounds\n    for i in range(n):\n        if centers[i, 0] - radii[i] < -tol or centers[i, 0] + radii[i] > 1 + tol:\n            return False\n        if centers[i, 1] - radii[i] < -tol or centers[i, 1] + radii[i] > 1 + tol:\n            return False\n    \n    # Check non-overlapping\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                          (centers[i, 1] - centers[j, 1])**2)\n            if dist < radii[i] + radii[j] - tol:\n                return False\n    \n    return True\n\n\ndef create_fallback_packing(n):\n    \"\"\"Create a simple valid packing as fallback.\"\"\"\n    # Create a grid arrangement\n    grid_size = int(np.ceil(np.sqrt(n)))\n    spacing = 1.0 / grid_size\n    radius = spacing / 2.5  # Safe radius to avoid overlaps\n    \n    centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) * spacing\n        y = (row + 0.5) * spacing\n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    radii = np.full(n, radius)\n    \n    return centers, radii\n\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T19:13:13.384912",
  "cost_data": null
}