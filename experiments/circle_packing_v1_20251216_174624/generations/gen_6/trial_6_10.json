{
  "trial_id": "trial_6_10",
  "generation": 6,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Run multiple restarts with different seeds\n    for seed in range(20):\n        np.random.seed(seed)\n        centers, radii, sum_radii = optimize_with_active_constraints(n, seed)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef initialize_hexagonal(n, seed=0):\n    \"\"\"Initialize circles in hexagonal pattern with perturbation.\"\"\"\n    np.random.seed(seed)\n    \n    # Estimate grid size\n    cols = int(np.ceil(np.sqrt(n * 1.15)))\n    rows = int(np.ceil(n / cols))\n    \n    centers = []\n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) >= n:\n                break\n            # Hexagonal offset\n            x = (j + 0.5 * (i % 2)) / cols\n            y = i / rows * 0.866  # sqrt(3)/2 for hex spacing\n            \n            # Add small random perturbation\n            x += np.random.uniform(-0.02, 0.02)\n            y += np.random.uniform(-0.02, 0.02)\n            \n            # Keep in bounds\n            x = np.clip(x, 0.05, 0.95)\n            y = np.clip(y, 0.05, 0.95)\n            \n            centers.append([x, y])\n    \n    return np.array(centers[:n])\n\ndef compute_radii(centers):\n    \"\"\"Compute maximum radii for given centers.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Distance to boundaries\n        r_max = min(centers[i, 0], 1 - centers[i, 0], \n                   centers[i, 1], 1 - centers[i, 1])\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                r_max = min(r_max, dist / 2)\n        \n        radii[i] = max(0, r_max)\n    \n    return radii\n\ndef identify_active_constraints(centers, radii, tolerance=0.01):\n    \"\"\"Identify which circles are near constraints.\"\"\"\n    n = len(centers)\n    active = {\n        'boundary': [],\n        'overlap': []\n    }\n    \n    for i in range(n):\n        # Check boundary constraints\n        dist_to_boundaries = [\n            centers[i, 0] - radii[i],  # left\n            1 - centers[i, 0] - radii[i],  # right\n            centers[i, 1] - radii[i],  # bottom\n            1 - centers[i, 1] - radii[i]  # top\n        ]\n        \n        if any(d < tolerance for d in dist_to_boundaries):\n            active['boundary'].append(i)\n        \n        # Check overlap constraints\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist - (radii[i] + radii[j]) < tolerance:\n                active['overlap'].append((i, j))\n    \n    return active\n\ndef objective_with_penalty(x, n, phase_weight):\n    \"\"\"Objective with adaptive penalty based on phase.\"\"\"\n    centers = x.reshape(n, 2)\n    radii = compute_radii(centers)\n    \n    # Base objective: maximize sum of radii\n    obj = -np.sum(radii)\n    \n    # Penalty for constraint violations\n    penalty = 0\n    \n    # Boundary violations\n    for i in range(n):\n        violations = [\n            max(0, radii[i] - centers[i, 0]),\n            max(0, radii[i] - (1 - centers[i, 0])),\n            max(0, radii[i] - centers[i, 1]),\n            max(0, radii[i] - (1 - centers[i, 1]))\n        ]\n        penalty += sum(v**2 for v in violations)\n    \n    # Overlap violations\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            overlap = max(0, radii[i] + radii[j] - dist)\n            penalty += overlap**2\n    \n    return obj + phase_weight * penalty\n\ndef optimize_phase(centers, n, phase_weight, max_iter=200):\n    \"\"\"Optimize with specific phase weight.\"\"\"\n    x0 = centers.flatten()\n    \n    # Bounds to keep centers in [0.02, 0.98]\n    bounds = [(0.02, 0.98)] * (2 * n)\n    \n    result = minimize(\n        lambda x: objective_with_penalty(x, n, phase_weight),\n        x0,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': max_iter, 'ftol': 1e-9}\n    )\n    \n    return result.x.reshape(n, 2)\n\ndef optimize_with_active_constraints(n, seed):\n    \"\"\"Main optimization with progressive tightening.\"\"\"\n    # Phase 1: Initialize\n    centers = initialize_hexagonal(n, seed)\n    \n    # Phase 2: Loose optimization (identify active constraints)\n    centers = optimize_phase(centers, n, phase_weight=100, max_iter=150)\n    radii = compute_radii(centers)\n    active = identify_active_constraints(centers, radii, tolerance=0.02)\n    \n    # Phase 3: Medium optimization (adjust positions)\n    centers = optimize_phase(centers, n, phase_weight=500, max_iter=200)\n    radii = compute_radii(centers)\n    \n    # Phase 4: Tight optimization (final refinement)\n    centers = optimize_phase(centers, n, phase_weight=2000, max_iter=250)\n    radii = compute_radii(centers)\n    \n    # Phase 5: Very tight final pass\n    centers = optimize_phase(centers, n, phase_weight=5000, max_iter=200)\n    radii = compute_radii(centers)\n    \n    # Final adjustment: push away from boundaries if needed\n    for i in range(n):\n        margin = 0.001\n        if centers[i, 0] - radii[i] < margin:\n            centers[i, 0] = radii[i] + margin\n        if 1 - centers[i, 0] - radii[i] < margin:\n            centers[i, 0] = 1 - radii[i] - margin\n        if centers[i, 1] - radii[i] < margin:\n            centers[i, 1] = radii[i] + margin\n        if 1 - centers[i, 1] - radii[i] < margin:\n            centers[i, 1] = 1 - radii[i] - margin\n        \n        # Ensure within bounds\n        centers[i, 0] = np.clip(centers[i, 0], 0.02, 0.98)\n        centers[i, 1] = np.clip(centers[i, 1], 0.02, 0.98)\n    \n    # Recompute final radii\n    radii = compute_radii(centers)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 300.00816583633423,
    "error": "Timeout after 300s"
  },
  "prompt": "Create constraint-aware optimizer with active set management:\n\nStrategy:\n1. Start with good initialization (hexagonal)\n2. Identify which constraints are active (near boundary)\n3. Focus optimization on moving away from constraint boundaries\n4. Progressive tightening with constraint monitoring:\n   - Phase 1: Loose, identify active constraints\n   - Phase 2: Medium, adjust positions\n   - Phase 3: Tight, final refinement\n5. Run 20 times with different seeds\n6. Return best\n\nRequirements:\n- Active constraint management\n- 20 restarts\n- Progressive tightening\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Run multiple restarts with different seeds\n    for seed in range(20):\n        np.random.seed(seed)\n        centers, radii, sum_radii = optimize_with_active_constraints(n, seed)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef initialize_hexagonal(n, seed=0):\n    \"\"\"Initialize circles in hexagonal pattern with perturbation.\"\"\"\n    np.random.seed(seed)\n    \n    # Estimate grid size\n    cols = int(np.ceil(np.sqrt(n * 1.15)))\n    rows = int(np.ceil(n / cols))\n    \n    centers = []\n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) >= n:\n                break\n            # Hexagonal offset\n            x = (j + 0.5 * (i % 2)) / cols\n            y = i / rows * 0.866  # sqrt(3)/2 for hex spacing\n            \n            # Add small random perturbation\n            x += np.random.uniform(-0.02, 0.02)\n            y += np.random.uniform(-0.02, 0.02)\n            \n            # Keep in bounds\n            x = np.clip(x, 0.05, 0.95)\n            y = np.clip(y, 0.05, 0.95)\n            \n            centers.append([x, y])\n    \n    return np.array(centers[:n])\n\ndef compute_radii(centers):\n    \"\"\"Compute maximum radii for given centers.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Distance to boundaries\n        r_max = min(centers[i, 0], 1 - centers[i, 0], \n                   centers[i, 1], 1 - centers[i, 1])\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                r_max = min(r_max, dist / 2)\n        \n        radii[i] = max(0, r_max)\n    \n    return radii\n\ndef identify_active_constraints(centers, radii, tolerance=0.01):\n    \"\"\"Identify which circles are near constraints.\"\"\"\n    n = len(centers)\n    active = {\n        'boundary': [],\n        'overlap': []\n    }\n    \n    for i in range(n):\n        # Check boundary constraints\n        dist_to_boundaries = [\n            centers[i, 0] - radii[i],  # left\n            1 - centers[i, 0] - radii[i],  # right\n            centers[i, 1] - radii[i],  # bottom\n            1 - centers[i, 1] - radii[i]  # top\n        ]\n        \n        if any(d < tolerance for d in dist_to_boundaries):\n            active['boundary'].append(i)\n        \n        # Check overlap constraints\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist - (radii[i] + radii[j]) < tolerance:\n                active['overlap'].append((i, j))\n    \n    return active\n\ndef objective_with_penalty(x, n, phase_weight):\n    \"\"\"Objective with adaptive penalty based on phase.\"\"\"\n    centers = x.reshape(n, 2)\n    radii = compute_radii(centers)\n    \n    # Base objective: maximize sum of radii\n    obj = -np.sum(radii)\n    \n    # Penalty for constraint violations\n    penalty = 0\n    \n    # Boundary violations\n    for i in range(n):\n        violations = [\n            max(0, radii[i] - centers[i, 0]),\n            max(0, radii[i] - (1 - centers[i, 0])),\n            max(0, radii[i] - centers[i, 1]),\n            max(0, radii[i] - (1 - centers[i, 1]))\n        ]\n        penalty += sum(v**2 for v in violations)\n    \n    # Overlap violations\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            overlap = max(0, radii[i] + radii[j] - dist)\n            penalty += overlap**2\n    \n    return obj + phase_weight * penalty\n\ndef optimize_phase(centers, n, phase_weight, max_iter=200):\n    \"\"\"Optimize with specific phase weight.\"\"\"\n    x0 = centers.flatten()\n    \n    # Bounds to keep centers in [0.02, 0.98]\n    bounds = [(0.02, 0.98)] * (2 * n)\n    \n    result = minimize(\n        lambda x: objective_with_penalty(x, n, phase_weight),\n        x0,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': max_iter, 'ftol': 1e-9}\n    )\n    \n    return result.x.reshape(n, 2)\n\ndef optimize_with_active_constraints(n, seed):\n    \"\"\"Main optimization with progressive tightening.\"\"\"\n    # Phase 1: Initialize\n    centers = initialize_hexagonal(n, seed)\n    \n    # Phase 2: Loose optimization (identify active constraints)\n    centers = optimize_phase(centers, n, phase_weight=100, max_iter=150)\n    radii = compute_radii(centers)\n    active = identify_active_constraints(centers, radii, tolerance=0.02)\n    \n    # Phase 3: Medium optimization (adjust positions)\n    centers = optimize_phase(centers, n, phase_weight=500, max_iter=200)\n    radii = compute_radii(centers)\n    \n    # Phase 4: Tight optimization (final refinement)\n    centers = optimize_phase(centers, n, phase_weight=2000, max_iter=250)\n    radii = compute_radii(centers)\n    \n    # Phase 5: Very tight final pass\n    centers = optimize_phase(centers, n, phase_weight=5000, max_iter=200)\n    radii = compute_radii(centers)\n    \n    # Final adjustment: push away from boundaries if needed\n    for i in range(n):\n        margin = 0.001\n        if centers[i, 0] - radii[i] < margin:\n            centers[i, 0] = radii[i] + margin\n        if 1 - centers[i, 0] - radii[i] < margin:\n            centers[i, 0] = 1 - radii[i] - margin\n        if centers[i, 1] - radii[i] < margin:\n            centers[i, 1] = radii[i] + margin\n        if 1 - centers[i, 1] - radii[i] < margin:\n            centers[i, 1] = 1 - radii[i] - margin\n        \n        # Ensure within bounds\n        centers[i, 0] = np.clip(centers[i, 0], 0.02, 0.98)\n        centers[i, 1] = np.clip(centers[i, 1], 0.02, 0.98)\n    \n    # Recompute final radii\n    radii = compute_radii(centers)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T19:18:06.031491",
  "cost_data": null
}