{
  "trial_id": "trial_6_2",
  "generation": 6,
  "parent_id": "trial_5_2",
  "code": "",
  "metrics": {},
  "prompt": "Create ensemble of trial_5_2 with varied parameters:\n\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def create_constraints(tolerance):\n        \"\"\"Create constraints with given tolerance.\"\"\"\n        \n        def boundary_constraints(x):\n            \"\"\"All circles must be inside [0,1]x[0,1].\"\"\"\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            \n            constraints = np.zeros(4*n)\n            constraints[0:n] = centers[:, 0] - radii\n            constraints[n:2*n] = 1 - centers[:, 0] - radii\n            constraints[2*n:3*n] = centers[:, 1] - radii\n            constraints[3*n:4*n] = 1 - centers[:, 1] - radii\n            \n            return constraints\n        \n        def non_overlap_constraints(x):\n            \"\"\"No two circles may overlap.\"\"\"\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            \n            dists = squareform(pdist(centers))\n            \n            constraints = []\n            for i in range(n):\n                for j in range(i+1, n):\n                    constraints.append(dists[i, j] - radii[i] - radii[j])\n            \n            return np.array(constraints)\n        \n        def radii_positive(x):\n            \"\"\"All radii must be non-negative.\"\"\"\n            radii = x[2*n:]\n            return radii\n        \n        def all_constraints(x):\n            return np.concatenate([\n                boundary_constraints(x),\n                non_overlap_constraints(x),\n                radii_positive(x)\n            ])\n        \n        n_boundary = 4*n\n        n_overlap = n*(n-1)//2\n        n_radii = n\n        n_total = n_boundary + n_overlap + n_radii\n        \n        return NonlinearConstraint(\n            all_constraints,\n            -tolerance * np.ones(n_total),\n            np.inf * np.ones(n_total)\n        )\n    \n    def initialize_hexagonal(seed=0):\n        \"\"\"Initialize with hexagonal packing pattern.\"\"\"\n        np.random.seed(seed)\n        rows = 6\n        cols = 5\n        \n        hex_height = np.sqrt(3) / 2\n        estimated_radius = 0.5 / (cols + 0.5)\n        \n        centers = []\n        for row in range(rows):\n            for col in range(cols):\n                x_offset = 0.5 * estimated_radius if row % 2 == 1 else 0\n                x = estimated_radius + col * 2 * estimated_radius + x_offset\n                y = estimated_radius + row * hex_height * 2 * estimated_radius\n                centers.append([x, y])\n        \n        centers = np.array(centers)\n        \n        margin = 0.02\n        centers_min = centers.min(axis=0)\n        centers_max = centers.max(axis=0)\n        centers = (centers - centers_min) / (centers_max - centers_min)\n        centers = centers * (1 - 2 * margin) + margin\n        \n        if len(centers) > n:\n            indices = []\n            remaining = list(range(len(centers)))\n            \n            dists_to_center = np.linalg.norm(centers - np.array([0.5, 0.5]), axis=1)\n            first_idx = np.argmin(dists_to_center)\n            indices.append(first_idx)\n            remaining.remove(first_idx)\n            \n            while len(indices) < n:\n                max_min_dist = -1\n                best_idx = -1\n                for idx in remaining:\n                    min_dist = np.min(np.linalg.norm(centers[indices] - centers[idx], axis=1))\n                    if min_dist > max_min_dist:\n                        max_min_dist = min_dist\n                        best_idx = idx\n                indices.append(best_idx)\n                remaining.remove(best_idx)\n            \n            centers = centers[indices]\n        \n        distances = pdist(centers)\n        min_dist = np.min(distances) if len(distances) > 0 else 0.1\n        radii = np.full(n, min_dist / 2.5)\n        \n        for i in range(n):\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = min(radii[i], max_r * 0.95)\n        \n        return np.concatenate([centers.flatten(), radii])\n    \n    def three_phase_optimization(x0):\n        \"\"\"Run three-phase optimization with progressive constraint tightening.\"\"\"\n        \n        # Phase 1: Relaxed constraints\n        tolerance1 = 1e-4\n        constraints1 = create_constraints(tolerance1)\n        \n        result1 = minimize(\n            objective,\n            x0,\n            method='trust-constr',\n            constraints=constraints1,\n            options={'maxiter': 800, 'verbose': 0}\n        )\n        \n        if not result1.success:\n            return None, -np.inf\n        \n        # Phase 2: Medium constraints\n        tolerance2 = 1e-6\n        constraints2 = create_constraints(tolerance2)\n        \n        result2 = minimize(\n            objective,\n            result1.x,\n            method='trust-constr',\n            constraints=constraints2,\n            options={'maxiter': 800, 'verbose': 0}\n        )\n        \n        if not result2.success:\n            return result1.x, -result1.fun\n        \n        # Phase 3: Strict constraints\n        tolerance3 = 1e-10\n        constraints3 = create_constraints(tolerance3)\n        \n        result3 = minimize(\n            objective,\n            result2.x,\n            method='trust-constr',\n            constraints=constraints3,\n            options={'maxiter': 800, 'verbose': 0}\n        )\n        \n        if not result3.success:\n            return result2.x, -result2.fun\n        \n        return result3.x, -result3.fun\n    \n    def is_valid_packing(x, tol=1e-6):\n        \"\"\"Check if packing satisfies all constraints.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        # Check inside square\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < -tol or\n                centers[i, 0] + radii[i] > 1 + tol or\n                centers[i, 1] - radii[i] < -tol or\n                centers[i, 1] + radii[i] > 1 + tol):\n                return False\n        \n        # Check no overlap\n        dists = squareform(pdist(centers))\n        for i in range(n):\n            for j in range(i+1, n):\n                if dists[i, j] < radii[i] + radii[j] - tol:\n                    return False\n        \n        return True\n    \n    # Store all valid results\n    valid_results = []\n    \n    # Run 12 restarts with different seeds\n    n_restarts = 12\n    \n    for restart in range(n_restarts):\n        # Initialize with hexagonal pattern and seed-based perturbation\n        x0 = initialize_hexagonal(seed=restart)\n        \n        # Add perturbation for diversity (except first run)\n        if restart > 0:\n            perturbation_scale = 0.01 + 0.02 * (restart / n_restarts)\n            centers_pert = x0[:2*n].reshape(n, 2)\n            centers_pert += np.random.normal(0, perturbation_scale, centers_pert.shape)\n            centers_pert = np.clip(centers_pert, 0.05, 0.95)\n            \n            radii_pert = x0[2*n:]\n            radii_pert *= (1 + np.random.normal(0, 0.05 * (restart / n_restarts), radii_pert.shape))\n            radii_pert = np.clip(radii_pert, 0.001, 0.15)\n            \n            x0 = np.concatenate([centers_pert.flatten(), radii_pert])\n        \n        # Run 3-phase optimization\n        x_opt, sum_opt = three_phase_optimization(x0)\n        \n        # Store if valid\n        if x_opt is not None and is_valid_packing(x_opt):\n            valid_results.append((x_opt, sum_opt))\n    \n    # Sort by sum of radii (descending)\n    valid_results.sort(key=lambda x: x[1], reverse=True)\n    \n    # Take top 5 for micro-refinement\n    top_k = min(5, len(valid_results))\n    \n    best_sum = -np.inf\n    best_x = None\n    \n    for i in range(top_k):\n        x_base, sum_base = valid_results[i]\n        \n        # Try micro-refinement with small perturbations\n        for micro_seed in range(3):\n            np.random.seed(1000 + i * 10 + micro_seed)\n            \n            # Small perturbation\n            x_perturbed = x_base.copy()\n            centers_p = x_perturbed[:2*n].reshape(n, 2)\n            centers_p += np.random.normal(0, 0.005, centers_p.shape)\n            centers_p = np.clip(centers_p, 0.01, 0.99)\n            x_perturbed[:2*n] = centers_p.flatten()\n            \n            # Re-optimize with strict constraints\n            tolerance = 1e-10\n            constraints = create_constraints(tolerance)\n            \n            result_micro = minimize(\n                objective,\n                x_perturbed,\n                method='trust-constr',\n                constraints=constraints,\n                options={'maxiter': 1000, 'verbose': 0}\n            )\n            \n            if result_micro.success and is_valid_packing(result_micro.x):\n                sum_micro = -result_micro.fun\n                if sum_micro > best_sum:\n                    best_sum = sum_micro\n                    best_x = result_micro.x\n        \n        # Also try the base solution\n        if sum_base > best_sum:\n            best_sum = sum_base\n            best_x = x_base\n    \n    # Fallback if no valid solution found\n    if best_x is None:\n        grid_size = int(np.ceil(np.sqrt(n)))\n        spacing = 1.0 / grid_size\n        r = spacing / 3.0\n        \n        centers = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(centers) >= n:\n                    break\n                x = (i + 0.5) * spacing\n                y = (j + 0.5) * spacing\n                centers.append([x, y])\n            if len(centers) >= n:\n                break\n        \n        best_centers = np.array(centers[:n])\n        best_radii = np.full(n, r)\n        best_sum = n * r\n    else:\n        best_centers = best_x[:2*n].reshape(n, 2)\n        best_radii = best_x[2*n:]\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nEnsemble strategy:\n1. Run trial_5_2's algorithm 20 times with varied settings:\n   - Vary tolerance levels (1e-9 to 1e-13)\n   - Vary maxiter (15000 to 30000)\n   - Vary number of phases (3 to 5)\n   - Different random seeds\n2. Track all valid results\n3. Take top 10 results\n4. Apply micro-refinement to each:\n   - Small perturbations (1e-8)\n   - Re-optimize with ultra-tight tolerances\n5. Return absolute best\n\nRequirements:\n- 20 varied runs\n- Parameter exploration\n- Efficient execution\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using ensemble approach.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def create_constraints(tolerance):\n        \"\"\"Create constraints with given tolerance.\"\"\"\n        \n        def boundary_constraints(x):\n            \"\"\"All circles must be inside [0,1]x[0,1].\"\"\"\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            \n            constraints = np.zeros(4*n)\n            constraints[0:n] = centers[:, 0] - radii\n            constraints[n:2*n] = 1 - centers[:, 0] - radii\n            constraints[2*n:3*n] = centers[:, 1] - radii\n            constraints[3*n:4*n] = 1 - centers[:, 1] - radii\n            \n            return constraints\n        \n        def non_overlap_constraints(x):\n            \"\"\"No two circles may overlap.\"\"\"\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            \n            dists = squareform(pdist(centers))\n            \n            constraints = []\n            for i in range(n):\n                for j in range(i+1, n):\n                    constraints.append(dists[i, j] - radii[i] - radii[j])\n            \n            return np.array(constraints)\n        \n        def radii_positive(x):\n            \"\"\"All radii must be non-negative.\"\"\"\n            radii = x[2*n:]\n            return radii\n        \n        def all_constraints(x):\n            return np.concatenate([\n                boundary_constraints(x),\n                non_overlap_constraints(x),\n                radii_positive(x)\n            ])\n        \n        n_boundary = 4*n\n        n_overlap = n*(n-1)//2\n        n_radii = n\n        n_total = n_boundary + n_overlap + n_radii\n        \n        return NonlinearConstraint(\n            all_constraints,\n            -tolerance * np.ones(n_total),\n            np.inf * np.ones(n_total)\n        )\n    \n    def initialize_hexagonal(seed=0):\n        \"\"\"Initialize with hexagonal packing pattern.\"\"\"\n        np.random.seed(seed)\n        rows = 6\n        cols = 5\n        \n        hex_height = np.sqrt(3) / 2\n        estimated_radius = 0.5 / (cols + 0.5)\n        \n        centers = []\n        for row in range(rows):\n            for col in range(cols):\n                x_offset = 0.5 * estimated_radius if row % 2 == 1 else 0\n                x = estimated_radius + col * 2 * estimated_radius + x_offset\n                y = estimated_radius + row * hex_height * 2 * estimated_radius\n                centers.append([x, y])\n        \n        centers = np.array(centers)\n        \n        margin = 0.02\n        centers_min = centers.min(axis=0)\n        centers_max = centers.max(axis=0)\n        centers = (centers - centers_min) / (centers_max - centers_min)\n        centers = centers * (1 - 2 * margin) + margin\n        \n        if len(centers) > n:\n            indices = []\n            remaining = list(range(len(centers)))\n            \n            dists_to_center = np.linalg.norm(centers - np.array([0.5, 0.5]), axis=1)\n            first_idx = np.argmin(dists_to_center)\n            indices.append(first_idx)\n            remaining.remove(first_idx)\n            \n            while len(indices) < n:\n                max_min_dist = -1\n                best_idx = -1\n                for idx in remaining:\n                    min_dist = np.min(np.linalg.norm(centers[indices] - centers[idx], axis=1))\n                    if min_dist > max_min_dist:\n                        max_min_dist = min_dist\n                        best_idx = idx\n                indices.append(best_idx)\n                remaining.remove(best_idx)\n            \n            centers = centers[indices]\n        \n        distances = pdist(centers)\n        min_dist = np.min(distances) if len(distances) > 0 else 0.1\n        radii = np.full(n, min_dist / 2.5)\n        \n        for i in range(n):\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = min(radii[i], max_r * 0.95)\n        \n        return np.concatenate([centers.flatten(), radii])\n    \n    def multi_phase_optimization(x0, tolerances, max_iters):\n        \"\"\"Run multi-phase optimization with progressive constraint tightening.\"\"\"\n        x_current = x0.copy()\n        \n        for tol, max_iter in zip(tolerances, max_iters):\n            constraints = create_constraints(tol)\n            \n            result = minimize(\n                objective,\n                x_current,\n                method='trust-constr',\n                constraints=constraints,\n                options={'maxiter': max_iter, 'verbose': 0}\n            )\n            \n            if not result.success:\n                return x_current, -objective(x_current)\n            \n            x_current = result.x\n        \n        return x_current, -objective(x_current)\n    \n    def is_valid_packing(x, tol=1e-6):\n        \"\"\"Check if packing satisfies all constraints.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        # Check inside square\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < -tol or\n                centers[i, 0] + radii[i] > 1 + tol or\n                centers[i, 1] - radii[i] < -tol or\n                centers[i, 1] + radii[i] > 1 + tol):\n                return False\n        \n        # Check no overlap\n        dists = squareform(pdist(centers))\n        for i in range(n):\n            for j in range(i+1, n):\n                if dists[i, j] < radii[i] + radii[j] - tol:\n                    return False\n        \n        # Check positive radii\n        if np.any(radii < -tol):\n            return False\n        \n        return True\n    \n    # Ensemble parameters: 20 different configurations\n    ensemble_configs = [\n        # Config 0-4: Varying tolerances with 3 phases\n        {'tolerances': [1e-4, 1e-7, 1e-10], 'max_iters': [800, 800, 800], 'seed': 0, 'perturb': 0.0},\n        {'tolerances': [1e-4, 1e-7, 1e-11], 'max_iters': [800, 800, 1000], 'seed': 1, 'perturb': 0.005},\n        {'tolerances': [1e-4, 1e-8, 1e-12], 'max_iters': [800, 1000, 1000], 'seed': 2, 'perturb': 0.01},\n        {'tolerances': [1e-4, 1e-6, 1e-9], 'max_iters': [1000, 1000, 1000], 'seed': 3, 'perturb': 0.015},\n        {'tolerances': [1e-4, 1e-8, 1e-13], 'max_iters': [800, 800, 1200], 'seed': 4, 'perturb': 0.02},\n        \n        # Config 5-9: 4-phase optimization\n        {'tolerances': [1e-4, 1e-6, 1e-9, 1e-11], 'max_iters': [600, 600, 800, 800], 'seed': 5, 'perturb': 0.0},\n        {'tolerances': [1e-4, 1e-7, 1e-10, 1e-12], 'max_iters': [600, 600, 800, 1000], 'seed': 6, 'perturb': 0.008},\n        {'tolerances': [1e-3, 1e-6, 1e-9, 1e-11], 'max_iters': [800, 800, 800, 800], 'seed': 7, 'perturb': 0.012},\n        {'tolerances': [1e-4, 1e-7, 1e-10, 1e-13], 'max_iters': [700, 700, 800, 1000], 'seed': 8, 'perturb': 0.018},\n        {'tolerances': [1e-4, 1e-6, 1e-8, 1e-10], 'max_iters': [800, 800, 800, 1000], 'seed': 9, 'perturb': 0.025},\n        \n        # Config 10-14: 5-phase optimization\n        {'tolerances': [1e-4, 1e-6, 1e-8, 1e-10, 1e-12], 'max_iters': [500, 500, 600, 700, 800], 'seed': 10, 'perturb': 0.0},\n        {'tolerances': [1e-3, 1e-5, 1e-7, 1e-9, 1e-11], 'max_iters': [600, 600, 600, 700, 800], 'seed': 11, 'perturb': 0.01},\n        {'tolerances': [1e-4, 1e-6, 1e-8, 1e-11, 1e-13], 'max_iters': [500, 600, 700, 800, 900], 'seed': 12, 'perturb': 0.015},\n        {'tolerances': [1e-4, 1e-7, 1e-9, 1e-11, 1e-12], 'max_iters': [600, 600, 700, 700, 800], 'seed': 13, 'perturb': 0.02},\n        {'tolerances': [1e-3, 1e-6, 1e-9, 1e-11, 1e-13], 'max_iters': [700, 700, 700, 800, 1000], 'seed': 14, 'perturb': 0.005},\n        \n        # Config 15-19: High iteration variants\n        {'tolerances': [1e-4, 1e-8, 1e-11], 'max_iters': [1200, 1200, 1500], 'seed': 15, 'perturb': 0.0},\n        {'tolerances': [1e-4, 1e-7, 1e-10], 'max_iters': [1000, 1200, 1500], 'seed': 16, 'perturb': 0.01},\n        {'tolerances': [1e-4, 1e-6, 1e-9, 1e-12], 'max_iters': [1000, 1000, 1200, 1200], 'seed': 17, 'perturb': 0.005},\n        {'tolerances': [1e-4, 1e-7, 1e-10, 1e-13], 'max_iters': [800, 1000, 1200, 1500], 'seed': 18, 'perturb': 0.015},\n        {'tolerances': [1e-3, 1e-6, 1e-9, 1e-12], 'max_iters': [1000, 1000, 1200, 1500], 'seed': 19, 'perturb': 0.02},\n    ]\n    \n    # Store all valid results\n    valid_results = []\n    \n    # Run ensemble\n    for config in ensemble_configs:\n        # Initialize\n        x0 = initialize_hexagonal(seed=config['seed'])\n        \n        # Add perturbation if specified\n        if config['perturb'] > 0:\n            np.random.seed(config['seed'] + 100)\n            centers_pert = x0[:2*n].reshape(n, 2)\n            centers_pert += np.random.normal(0, config['perturb'], centers_pert.shape)\n            centers_pert = np.clip(centers_pert, 0.05, 0.95)\n            \n            radii_pert = x0[2*n:]\n            radii_pert *= (1 + np.random.normal(0, 0.05, radii_pert.shape))\n            radii_pert = np.clip(radii_pert, 0.001, 0.15)\n            \n            x0 = np.concatenate([centers_pert.flatten(), radii_pert])\n        \n        # Run optimization\n        x_opt, sum_opt = multi_phase_optimization(\n            x0, \n            config['tolerances'], \n            config['max_iters']\n        )\n        \n        # Store if valid\n        if is_valid_packing(x_opt):\n            valid_results.append((x_opt, sum_opt))\n    \n    # Sort by sum of radii (descending)\n    valid_results.sort(key=lambda x: x[1], reverse=True)\n    \n    # Take top 10 for micro-refinement\n    top_k = min(10, len(valid_results))\n    \n    best_sum = -np.inf\n    best_x = None\n    \n    for i in range(top_k):\n        x_base, sum_base = valid_results[i]\n        \n        # Try micro-refinement with ultra-small perturbations\n        for micro_seed in range(3):\n            np.random.seed(2000 + i * 10 + micro_seed)\n            \n            # Ultra-small perturbation\n            x_perturbed = x_base.copy()\n            centers_p = x_perturbed[:2*n].reshape(n, 2)\n            centers_p += np.random.normal(0, 1e-8, centers_p.shape)\n            centers_p = np.clip(centers_p, 0.001, 0.999)\n            x_perturbed[:2*n] = centers_p.flatten()\n            \n            # Re-optimize with ultra-strict constraints\n            tolerance = 1e-13\n            constraints = create_constraints(tolerance)\n            \n            result_micro = minimize(\n                objective,\n                x_perturbed,\n                method='trust-constr',\n                constraints=constraints,\n                options={'maxiter': 1500, 'verbose': 0}\n            )\n            \n            if result_micro.success and is_valid_packing(result_micro.x):\n                sum_micro = -result_micro.fun\n                if sum_micro > best_sum:\n                    best_sum = sum_micro\n                    best_x = result_micro.x\n        \n        # Also consider the base solution\n        if sum_base > best_sum:\n            best_sum = sum_base\n            best",
  "reasoning": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using ensemble approach.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def create_constraints(tolerance):\n        \"\"\"Create constraints with given tolerance.\"\"\"\n        \n        def boundary_constraints(x):\n            \"\"\"All circles must be inside [0,1]x[0,1].\"\"\"\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            \n            constraints = np.zeros(4*n)\n            constraints[0:n] = centers[:, 0] - radii\n            constraints[n:2*n] = 1 - centers[:, 0] - radii\n            constraints[2*n:3*n] = centers[:, 1] - radii\n            constraints[3*n:4*n] = 1 - centers[:, 1] - radii\n            \n            return constraints\n        \n        def non_overlap_constraints(x):\n            \"\"\"No two circles may overlap.\"\"\"\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            \n            dists = squareform(pdist(centers))\n            \n            constraints = []\n            for i in range(n):\n                for j in range(i+1, n):\n                    constraints.append(dists[i, j] - radii[i] - radii[j])\n            \n            return np.array(constraints)\n        \n        def radii_positive(x):\n            \"\"\"All radii must be non-negative.\"\"\"\n            radii = x[2*n:]\n            return radii\n        \n        def all_constraints(x):\n            return np.concatenate([\n                boundary_constraints(x),\n                non_overlap_constraints(x),\n                radii_positive(x)\n            ])\n        \n        n_boundary = 4*n\n        n_overlap = n*(n-1)//2\n        n_radii = n\n        n_total = n_boundary + n_overlap + n_radii\n        \n        return NonlinearConstraint(\n            all_constraints,\n            -tolerance * np.ones(n_total),\n            np.inf * np.ones(n_total)\n        )\n    \n    def initialize_hexagonal(seed=0):\n        \"\"\"Initialize with hexagonal packing pattern.\"\"\"\n        np.random.seed(seed)\n        rows = 6\n        cols = 5\n        \n        hex_height = np.sqrt(3) / 2\n        estimated_radius = 0.5 / (cols + 0.5)\n        \n        centers = []\n        for row in range(rows):\n            for col in range(cols):\n                x_offset = 0.5 * estimated_radius if row % 2 == 1 else 0\n                x = estimated_radius + col * 2 * estimated_radius + x_offset\n                y = estimated_radius + row * hex_height * 2 * estimated_radius\n                centers.append([x, y])\n        \n        centers = np.array(centers)\n        \n        margin = 0.02\n        centers_min = centers.min(axis=0)\n        centers_max = centers.max(axis=0)\n        centers = (centers - centers_min) / (centers_max - centers_min)\n        centers = centers * (1 - 2 * margin) + margin\n        \n        if len(centers) > n:\n            indices = []\n            remaining = list(range(len(centers)))\n            \n            dists_to_center = np.linalg.norm(centers - np.array([0.5, 0.5]), axis=1)\n            first_idx = np.argmin(dists_to_center)\n            indices.append(first_idx)\n            remaining.remove(first_idx)\n            \n            while len(indices) < n:\n                max_min_dist = -1\n                best_idx = -1\n                for idx in remaining:\n                    min_dist = np.min(np.linalg.norm(centers[indices] - centers[idx], axis=1))\n                    if min_dist > max_min_dist:\n                        max_min_dist = min_dist\n                        best_idx = idx\n                indices.append(best_idx)\n                remaining.remove(best_idx)\n            \n            centers = centers[indices]\n        \n        distances = pdist(centers)\n        min_dist = np.min(distances) if len(distances) > 0 else 0.1\n        radii = np.full(n, min_dist / 2.5)\n        \n        for i in range(n):\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = min(radii[i], max_r * 0.95)\n        \n        return np.concatenate([centers.flatten(), radii])\n    \n    def multi_phase_optimization(x0, tolerances, max_iters):\n        \"\"\"Run multi-phase optimization with progressive constraint tightening.\"\"\"\n        x_current = x0.copy()\n        \n        for tol, max_iter in zip(tolerances, max_iters):\n            constraints = create_constraints(tol)\n            \n            result = minimize(\n                objective,\n                x_current,\n                method='trust-constr',\n                constraints=constraints,\n                options={'maxiter': max_iter, 'verbose': 0}\n            )\n            \n            if not result.success:\n                return x_current, -objective(x_current)\n            \n            x_current = result.x\n        \n        return x_current, -objective(x_current)\n    \n    def is_valid_packing(x, tol=1e-6):\n        \"\"\"Check if packing satisfies all constraints.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        # Check inside square\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < -tol or\n                centers[i, 0] + radii[i] > 1 + tol or\n                centers[i, 1] - radii[i] < -tol or\n                centers[i, 1] + radii[i] > 1 + tol):\n                return False\n        \n        # Check no overlap\n        dists = squareform(pdist(centers))\n        for i in range(n):\n            for j in range(i+1, n):\n                if dists[i, j] < radii[i] + radii[j] - tol:\n                    return False\n        \n        # Check positive radii\n        if np.any(radii < -tol):\n            return False\n        \n        return True\n    \n    # Ensemble parameters: 20 different configurations\n    ensemble_configs = [\n        # Config 0-4: Varying tolerances with 3 phases\n        {'tolerances': [1e-4, 1e-7, 1e-10], 'max_iters': [800, 800, 800], 'seed': 0, 'perturb': 0.0},\n        {'tolerances': [1e-4, 1e-7, 1e-11], 'max_iters': [800, 800, 1000], 'seed': 1, 'perturb': 0.005},\n        {'tolerances': [1e-4, 1e-8, 1e-12], 'max_iters': [800, 1000, 1000], 'seed': 2, 'perturb': 0.01},\n        {'tolerances': [1e-4, 1e-6, 1e-9], 'max_iters': [1000, 1000, 1000], 'seed': 3, 'perturb': 0.015},\n        {'tolerances': [1e-4, 1e-8, 1e-13], 'max_iters': [800, 800, 1200], 'seed': 4, 'perturb': 0.02},\n        \n        # Config 5-9: 4-phase optimization\n        {'tolerances': [1e-4, 1e-6, 1e-9, 1e-11], 'max_iters': [600, 600, 800, 800], 'seed': 5, 'perturb': 0.0},\n        {'tolerances': [1e-4, 1e-7, 1e-10, 1e-12], 'max_iters': [600, 600, 800, 1000], 'seed': 6, 'perturb': 0.008},\n        {'tolerances': [1e-3, 1e-6, 1e-9, 1e-11], 'max_iters': [800, 800, 800, 800], 'seed': 7, 'perturb': 0.012},\n        {'tolerances': [1e-4, 1e-7, 1e-10, 1e-13], 'max_iters': [700, 700, 800, 1000], 'seed': 8, 'perturb': 0.018},\n        {'tolerances': [1e-4, 1e-6, 1e-8, 1e-10], 'max_iters': [800, 800, 800, 1000], 'seed': 9, 'perturb': 0.025},\n        \n        # Config 10-14: 5-phase optimization\n        {'tolerances': [1e-4, 1e-6, 1e-8, 1e-10, 1e-12], 'max_iters': [500, 500, 600, 700, 800], 'seed': 10, 'perturb': 0.0},\n        {'tolerances': [1e-3, 1e-5, 1e-7, 1e-9, 1e-11], 'max_iters': [600, 600, 600, 700, 800], 'seed': 11, 'perturb': 0.01},\n        {'tolerances': [1e-4, 1e-6, 1e-8, 1e-11, 1e-13], 'max_iters': [500, 600, 700, 800, 900], 'seed': 12, 'perturb': 0.015},\n        {'tolerances': [1e-4, 1e-7, 1e-9, 1e-11, 1e-12], 'max_iters': [600, 600, 700, 700, 800], 'seed': 13, 'perturb': 0.02},\n        {'tolerances': [1e-3, 1e-6, 1e-9, 1e-11, 1e-13], 'max_iters': [700, 700, 700, 800, 1000], 'seed': 14, 'perturb': 0.005},\n        \n        # Config 15-19: High iteration variants\n        {'tolerances': [1e-4, 1e-8, 1e-11], 'max_iters': [1200, 1200, 1500], 'seed': 15, 'perturb': 0.0},\n        {'tolerances': [1e-4, 1e-7, 1e-10], 'max_iters': [1000, 1200, 1500], 'seed': 16, 'perturb': 0.01},\n        {'tolerances': [1e-4, 1e-6, 1e-9, 1e-12], 'max_iters': [1000, 1000, 1200, 1200], 'seed': 17, 'perturb': 0.005},\n        {'tolerances': [1e-4, 1e-7, 1e-10, 1e-13], 'max_iters': [800, 1000, 1200, 1500], 'seed': 18, 'perturb': 0.015},\n        {'tolerances': [1e-3, 1e-6, 1e-9, 1e-12], 'max_iters': [1000, 1000, 1200, 1500], 'seed': 19, 'perturb': 0.02},\n    ]\n    \n    # Store all valid results\n    valid_results = []\n    \n    # Run ensemble\n    for config in ensemble_configs:\n        # Initialize\n        x0 = initialize_hexagonal(seed=config['seed'])\n        \n        # Add perturbation if specified\n        if config['perturb'] > 0:\n            np.random.seed(config['seed'] + 100)\n            centers_pert = x0[:2*n].reshape(n, 2)\n            centers_pert += np.random.normal(0, config['perturb'], centers_pert.shape)\n            centers_pert = np.clip(centers_pert, 0.05, 0.95)\n            \n            radii_pert = x0[2*n:]\n            radii_pert *= (1 + np.random.normal(0, 0.05, radii_pert.shape))\n            radii_pert = np.clip(radii_pert, 0.001, 0.15)\n            \n            x0 = np.concatenate([centers_pert.flatten(), radii_pert])\n        \n        # Run optimization\n        x_opt, sum_opt = multi_phase_optimization(\n            x0, \n            config['tolerances'], \n            config['max_iters']\n        )\n        \n        # Store if valid\n        if is_valid_packing(x_opt):\n            valid_results.append((x_opt, sum_opt))\n    \n    # Sort by sum of radii (descending)\n    valid_results.sort(key=lambda x: x[1], reverse=True)\n    \n    # Take top 10 for micro-refinement\n    top_k = min(10, len(valid_results))\n    \n    best_sum = -np.inf\n    best_x = None\n    \n    for i in range(top_k):\n        x_base, sum_base = valid_results[i]\n        \n        # Try micro-refinement with ultra-small perturbations\n        for micro_seed in range(3):\n            np.random.seed(2000 + i * 10 + micro_seed)\n            \n            # Ultra-small perturbation\n            x_perturbed = x_base.copy()\n            centers_p = x_perturbed[:2*n].reshape(n, 2)\n            centers_p += np.random.normal(0, 1e-8, centers_p.shape)\n            centers_p = np.clip(centers_p, 0.001, 0.999)\n            x_perturbed[:2*n] = centers_p.flatten()\n            \n            # Re-optimize with ultra-strict constraints\n            tolerance = 1e-13\n            constraints = create_constraints(tolerance)\n            \n            result_micro = minimize(\n                objective,\n                x_perturbed,\n                method='trust-constr',\n                constraints=constraints,\n                options={'maxiter': 1500, 'verbose': 0}\n            )\n            \n            if result_micro.success and is_valid_packing(result_micro.x):\n                sum_micro = -result_micro.fun\n                if sum_micro > best_sum:\n                    best_sum = sum_micro\n                    best_x = result_micro.x\n        \n        # Also consider the base solution\n        if sum_base > best_sum:\n            best_sum = sum_base\n            best",
  "timestamp": "2025-12-16T19:13:19.649125",
  "cost_data": null
}