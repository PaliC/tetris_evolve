{
  "trial_id": "trial_6_11",
  "generation": 6,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses hybrid initialization with multiple patterns and two-stage optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def generate_hexagonal_init(angle=0, scale=1.0, offset_x=0, offset_y=0):\n        \"\"\"Generate hexagonal pattern initialization.\"\"\"\n        centers = []\n        radii = []\n        \n        # Hexagonal packing parameters\n        rows = 5\n        cols = 6\n        \n        # Base spacing\n        dx = 0.18 * scale\n        dy = 0.16 * scale\n        \n        for i in range(rows):\n            for j in range(cols):\n                if len(centers) >= n:\n                    break\n                \n                # Hexagonal offset\n                x_offset = (dx / 2) if i % 2 == 1 else 0\n                x = 0.1 + j * dx + x_offset + offset_x\n                y = 0.1 + i * dy + offset_y\n                \n                # Rotate around center\n                cx, cy = 0.5, 0.5\n                x_rot = cx + (x - cx) * np.cos(angle) - (y - cy) * np.sin(angle)\n                y_rot = cy + (x - cx) * np.sin(angle) + (y - cy) * np.cos(angle)\n                \n                # Clamp to valid range\n                x_rot = np.clip(x_rot, 0.08, 0.92)\n                y_rot = np.clip(y_rot, 0.08, 0.92)\n                \n                centers.append([x_rot, y_rot])\n                radii.append(0.07 * scale)\n            \n            if len(centers) >= n:\n                break\n        \n        # Fill remaining if needed\n        while len(centers) < n:\n            centers.append([0.5 + 0.1 * np.random.randn(), 0.5 + 0.1 * np.random.randn()])\n            radii.append(0.05)\n        \n        return np.array(centers[:n]), np.array(radii[:n])\n    \n    def generate_square_grid_init(rows=5, cols=6, margin=0.1):\n        \"\"\"Generate square grid initialization.\"\"\"\n        centers = []\n        radii = []\n        \n        dx = (1 - 2 * margin) / (cols - 1) if cols > 1 else 0\n        dy = (1 - 2 * margin) / (rows - 1) if rows > 1 else 0\n        \n        for i in range(rows):\n            for j in range(cols):\n                if len(centers) >= n:\n                    break\n                x = margin + j * dx\n                y = margin + i * dy\n                centers.append([x, y])\n                radii.append(0.07)\n            if len(centers) >= n:\n                break\n        \n        while len(centers) < n:\n            centers.append([0.5, 0.5])\n            radii.append(0.05)\n        \n        return np.array(centers[:n]), np.array(radii[:n])\n    \n    def generate_concentric_init(n_rings=4):\n        \"\"\"Generate concentric circles initialization.\"\"\"\n        centers = []\n        radii = []\n        \n        circles_per_ring = [1, 8, 10, 7]\n        ring_radii = [0.0, 0.25, 0.4, 0.55]\n        \n        for ring_idx, (n_circles, ring_r) in enumerate(zip(circles_per_ring, ring_radii)):\n            for i in range(n_circles):\n                if len(centers) >= n:\n                    break\n                angle = 2 * np.pi * i / n_circles\n                x = 0.5 + ring_r * np.cos(angle)\n                y = 0.5 + ring_r * np.sin(angle)\n                centers.append([x, y])\n                radii.append(0.06)\n            if len(centers) >= n:\n                break\n        \n        while len(centers) < n:\n            centers.append([0.5, 0.5])\n            radii.append(0.05)\n        \n        return np.array(centers[:n]), np.array(radii[:n])\n    \n    def generate_random_constrained_init():\n        \"\"\"Generate random but constrained initialization.\"\"\"\n        centers = []\n        radii = []\n        \n        margin = 0.1\n        for _ in range(n):\n            x = margin + (1 - 2 * margin) * np.random.rand()\n            y = margin + (1 - 2 * margin) * np.random.rand()\n            centers.append([x, y])\n            radii.append(0.05 + 0.03 * np.random.rand())\n        \n        return np.array(centers), np.array(radii)\n    \n    def pack_to_vector(centers, radii):\n        \"\"\"Convert centers and radii to optimization vector.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def vector_to_pack(x, n):\n        \"\"\"Convert optimization vector to centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x, n):\n        \"\"\"Objective: minimize negative sum of radii.\"\"\"\n        _, radii = vector_to_pack(x, n)\n        return -np.sum(radii)\n    \n    def constraint_function(x, n):\n        \"\"\"Compute all constraints.\"\"\"\n        centers, radii = vector_to_pack(x, n)\n        constraints = []\n        \n        # Boundary constraints\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        return np.array(constraints)\n    \n    # Generate 25 initializations\n    initializations = []\n    \n    # 10 hexagonal at different angles/scales\n    for i in range(10):\n        angle = i * np.pi / 10\n        scale = 0.9 + 0.2 * (i / 10)\n        offset_x = -0.05 + 0.1 * (i / 10)\n        offset_y = -0.05 + 0.1 * ((10 - i) / 10)\n        centers, radii = generate_hexagonal_init(angle, scale, offset_x, offset_y)\n        initializations.append(pack_to_vector(centers, radii))\n    \n    # 5 square grids\n    grid_configs = [(5, 6), (6, 5), (4, 7), (7, 4), (5, 6)]\n    margins = [0.08, 0.1, 0.12, 0.09, 0.11]\n    for config, margin in zip(grid_configs, margins):\n        centers, radii = generate_square_grid_init(config[0], config[1], margin)\n        initializations.append(pack_to_vector(centers, radii))\n    \n    # 5 concentric circles\n    for i in range(5):\n        centers, radii = generate_concentric_init()\n        # Add small random perturbation\n        centers += 0.02 * np.random.randn(*centers.shape)\n        centers = np.clip(centers, 0.1, 0.9)\n        initializations.append(pack_to_vector(centers, radii))\n    \n    # 5 random but constrained\n    for _ in range(5):\n        centers, radii = generate_random_constrained_init()\n        initializations.append(pack_to_vector(centers, radii))\n    \n    # Stage 1: Quick optimization with SLSQP\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n    constraint = NonlinearConstraint(\n        lambda x: constraint_function(x, n),\n        0, np.inf\n    )\n    \n    stage1_results = []\n    \n    for idx, x0 in enumerate(initializations):\n        try:\n            result = minimize(\n                lambda x: objective(x, n),\n                x0,\n                method='SLSQP',\n                bounds=bounds,\n                constraints={'type': 'ineq', 'fun': lambda x: constraint_function(x, n)},\n                options={'maxiter': 5000, 'ftol': 1e-8}\n            )\n            \n            if result.success or result.fun < 0:\n                # Check if solution is valid\n                c_vals = constraint_function(result.x, n)\n                if np.all(c_vals >= -1e-6):\n                    stage1_results.append((result.fun, result.x))\n        except:\n            pass\n    \n    # Sort by objective value (lower is better since we minimize -sum)\n    stage1_results.sort(key=lambda x: x[0])\n    \n    # Take top 10\n    top_initializations = [x for _, x in stage1_results[:10]]\n    \n    # If we have fewer than 10, add some original initializations\n    if len(top_initializations) < 10:\n        for x0 in initializations:\n            if len(top_initializations) >= 10:\n                break\n            if not any(np.allclose(x0, x) for _, x in stage1_results):\n                top_initializations.append(x0)\n    \n    # Stage 2: Intensive optimization with trust-constr\n    best_result = None\n    best_score = float('inf')\n    \n    for x0 in top_initializations:\n        try:\n            result = minimize(\n                lambda x: objective(x, n),\n                x0,\n                method='trust-constr',\n                bounds=bounds,\n                constraints=constraint,\n                options={\n                    'maxiter': 25000,\n                    'gtol': 1e-12,\n                    'xtol': 1e-12,\n                    'verbose': 0\n                }\n            )\n            \n            # Verify constraints\n            c_vals = constraint_function(result.x, n)\n            if np.all(c_vals >= -1e-6) and result.fun < best_score:\n                best_score = result.fun\n                best_result = result.x\n        except:\n            pass\n    \n    # If no valid solution found, use best from stage 1\n    if best_result is None and len(stage1_results) > 0:\n        best_result = stage1_results[0][1]\n    \n    # Extract final solution\n    centers, radii = vector_to_pack(best_result, n)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.6099128698878893,
    "target_ratio": 0.9904792675096354,
    "combined_score": 0.9904792675096354,
    "eval_time": 65.53458499908447,
    "error": null
  },
  "prompt": "Create optimizer with hybrid initialization combining multiple patterns:\n\nStrategy:\n1. Generate 25 different initializations:\n   - 10 hexagonal at different angles/scales\n   - 5 square grids\n   - 5 concentric circles\n   - 5 random but constrained\n2. For each initialization:\n   - Quick optimization (SLSQP, maxiter=5000)\n   - Rank by score\n3. Take top 10 initializations\n4. Apply intensive optimization to each:\n   - trust-constr\n   - maxiter=25000\n   - gtol=1e-12, xtol=1e-12\n5. Return best\n\nRequirements:\n- 25 diverse initializations\n- Two-stage optimization\n- Efficient execution\n- No plotting or printing",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses hybrid initialization with multiple patterns and two-stage optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def generate_hexagonal_init(angle=0, scale=1.0, offset_x=0, offset_y=0):\n        \"\"\"Generate hexagonal pattern initialization.\"\"\"\n        centers = []\n        radii = []\n        \n        # Hexagonal packing parameters\n        rows = 5\n        cols = 6\n        \n        # Base spacing\n        dx = 0.18 * scale\n        dy = 0.16 * scale\n        \n        for i in range(rows):\n            for j in range(cols):\n                if len(centers) >= n:\n                    break\n                \n                # Hexagonal offset\n                x_offset = (dx / 2) if i % 2 == 1 else 0\n                x = 0.1 + j * dx + x_offset + offset_x\n                y = 0.1 + i * dy + offset_y\n                \n                # Rotate around center\n                cx, cy = 0.5, 0.5\n                x_rot = cx + (x - cx) * np.cos(angle) - (y - cy) * np.sin(angle)\n                y_rot = cy + (x - cx) * np.sin(angle) + (y - cy) * np.cos(angle)\n                \n                # Clamp to valid range\n                x_rot = np.clip(x_rot, 0.08, 0.92)\n                y_rot = np.clip(y_rot, 0.08, 0.92)\n                \n                centers.append([x_rot, y_rot])\n                radii.append(0.07 * scale)\n            \n            if len(centers) >= n:\n                break\n        \n        # Fill remaining if needed\n        while len(centers) < n:\n            centers.append([0.5 + 0.1 * np.random.randn(), 0.5 + 0.1 * np.random.randn()])\n            radii.append(0.05)\n        \n        return np.array(centers[:n]), np.array(radii[:n])\n    \n    def generate_square_grid_init(rows=5, cols=6, margin=0.1):\n        \"\"\"Generate square grid initialization.\"\"\"\n        centers = []\n        radii = []\n        \n        dx = (1 - 2 * margin) / (cols - 1) if cols > 1 else 0\n        dy = (1 - 2 * margin) / (rows - 1) if rows > 1 else 0\n        \n        for i in range(rows):\n            for j in range(cols):\n                if len(centers) >= n:\n                    break\n                x = margin + j * dx\n                y = margin + i * dy\n                centers.append([x, y])\n                radii.append(0.07)\n            if len(centers) >= n:\n                break\n        \n        while len(centers) < n:\n            centers.append([0.5, 0.5])\n            radii.append(0.05)\n        \n        return np.array(centers[:n]), np.array(radii[:n])\n    \n    def generate_concentric_init(n_rings=4):\n        \"\"\"Generate concentric circles initialization.\"\"\"\n        centers = []\n        radii = []\n        \n        circles_per_ring = [1, 8, 10, 7]\n        ring_radii = [0.0, 0.25, 0.4, 0.55]\n        \n        for ring_idx, (n_circles, ring_r) in enumerate(zip(circles_per_ring, ring_radii)):\n            for i in range(n_circles):\n                if len(centers) >= n:\n                    break\n                angle = 2 * np.pi * i / n_circles\n                x = 0.5 + ring_r * np.cos(angle)\n                y = 0.5 + ring_r * np.sin(angle)\n                centers.append([x, y])\n                radii.append(0.06)\n            if len(centers) >= n:\n                break\n        \n        while len(centers) < n:\n            centers.append([0.5, 0.5])\n            radii.append(0.05)\n        \n        return np.array(centers[:n]), np.array(radii[:n])\n    \n    def generate_random_constrained_init():\n        \"\"\"Generate random but constrained initialization.\"\"\"\n        centers = []\n        radii = []\n        \n        margin = 0.1\n        for _ in range(n):\n            x = margin + (1 - 2 * margin) * np.random.rand()\n            y = margin + (1 - 2 * margin) * np.random.rand()\n            centers.append([x, y])\n            radii.append(0.05 + 0.03 * np.random.rand())\n        \n        return np.array(centers), np.array(radii)\n    \n    def pack_to_vector(centers, radii):\n        \"\"\"Convert centers and radii to optimization vector.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def vector_to_pack(x, n):\n        \"\"\"Convert optimization vector to centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x, n):\n        \"\"\"Objective: minimize negative sum of radii.\"\"\"\n        _, radii = vector_to_pack(x, n)\n        return -np.sum(radii)\n    \n    def constraint_function(x, n):\n        \"\"\"Compute all constraints.\"\"\"\n        centers, radii = vector_to_pack(x, n)\n        constraints = []\n        \n        # Boundary constraints\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        return np.array(constraints)\n    \n    # Generate 25 initializations\n    initializations = []\n    \n    # 10 hexagonal at different angles/scales\n    for i in range(10):\n        angle = i * np.pi / 10\n        scale = 0.9 + 0.2 * (i / 10)\n        offset_x = -0.05 + 0.1 * (i / 10)\n        offset_y = -0.05 + 0.1 * ((10 - i) / 10)\n        centers, radii = generate_hexagonal_init(angle, scale, offset_x, offset_y)\n        initializations.append(pack_to_vector(centers, radii))\n    \n    # 5 square grids\n    grid_configs = [(5, 6), (6, 5), (4, 7), (7, 4), (5, 6)]\n    margins = [0.08, 0.1, 0.12, 0.09, 0.11]\n    for config, margin in zip(grid_configs, margins):\n        centers, radii = generate_square_grid_init(config[0], config[1], margin)\n        initializations.append(pack_to_vector(centers, radii))\n    \n    # 5 concentric circles\n    for i in range(5):\n        centers, radii = generate_concentric_init()\n        # Add small random perturbation\n        centers += 0.02 * np.random.randn(*centers.shape)\n        centers = np.clip(centers, 0.1, 0.9)\n        initializations.append(pack_to_vector(centers, radii))\n    \n    # 5 random but constrained\n    for _ in range(5):\n        centers, radii = generate_random_constrained_init()\n        initializations.append(pack_to_vector(centers, radii))\n    \n    # Stage 1: Quick optimization with SLSQP\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n    constraint = NonlinearConstraint(\n        lambda x: constraint_function(x, n),\n        0, np.inf\n    )\n    \n    stage1_results = []\n    \n    for idx, x0 in enumerate(initializations):\n        try:\n            result = minimize(\n                lambda x: objective(x, n),\n                x0,\n                method='SLSQP',\n                bounds=bounds,\n                constraints={'type': 'ineq', 'fun': lambda x: constraint_function(x, n)},\n                options={'maxiter': 5000, 'ftol': 1e-8}\n            )\n            \n            if result.success or result.fun < 0:\n                # Check if solution is valid\n                c_vals = constraint_function(result.x, n)\n                if np.all(c_vals >= -1e-6):\n                    stage1_results.append((result.fun, result.x))\n        except:\n            pass\n    \n    # Sort by objective value (lower is better since we minimize -sum)\n    stage1_results.sort(key=lambda x: x[0])\n    \n    # Take top 10\n    top_initializations = [x for _, x in stage1_results[:10]]\n    \n    # If we have fewer than 10, add some original initializations\n    if len(top_initializations) < 10:\n        for x0 in initializations:\n            if len(top_initializations) >= 10:\n                break\n            if not any(np.allclose(x0, x) for _, x in stage1_results):\n                top_initializations.append(x0)\n    \n    # Stage 2: Intensive optimization with trust-constr\n    best_result = None\n    best_score = float('inf')\n    \n    for x0 in top_initializations:\n        try:\n            result = minimize(\n                lambda x: objective(x, n),\n                x0,\n                method='trust-constr',\n                bounds=bounds,\n                constraints=constraint,\n                options={\n                    'maxiter': 25000,\n                    'gtol': 1e-12,\n                    'xtol': 1e-12,\n                    'verbose': 0\n                }\n            )\n            \n            # Verify constraints\n            c_vals = constraint_function(result.x, n)\n            if np.all(c_vals >= -1e-6) and result.fun < best_score:\n                best_score = result.fun\n                best_result = result.x\n        except:\n            pass\n    \n    # If no valid solution found, use best from stage 1\n    if best_result is None and len(stage1_results) > 0:\n        best_result = stage1_results[0][1]\n    \n    # Extract final solution\n    centers, radii = vector_to_pack(best_result, n)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-16T19:14:20.219843",
  "cost_data": null
}