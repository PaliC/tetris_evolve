{
  "trial_id": "trial_1_11",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    np.random.seed(42)\n    n = 26\n    \n    # PHASE 1: Position Optimization with fixed equal radii\n    def position_objective(positions):\n        \"\"\"Maximize minimum pairwise distance (minimize negative)\"\"\"\n        positions = positions.reshape(n, 2)\n        dists = pdist(positions)\n        return -np.min(dists)  # Negative because we minimize\n    \n    def position_constraints(positions):\n        \"\"\"Ensure positions are in [0,1]^2\"\"\"\n        positions = positions.reshape(n, 2)\n        constraints = []\n        # Stay inside unit square\n        constraints.extend(positions[:, 0])  # x >= 0\n        constraints.extend(1 - positions[:, 0])  # x <= 1\n        constraints.extend(positions[:, 1])  # y >= 0\n        constraints.extend(1 - positions[:, 1])  # y <= 1\n        return np.array(constraints)\n    \n    # Initialize with grid + perturbation\n    grid_size = int(np.ceil(np.sqrt(n)))\n    initial_positions = []\n    for i in range(n):\n        x = (i % grid_size + 0.5) / grid_size\n        y = (i // grid_size + 0.5) / grid_size\n        initial_positions.append([x, y])\n    initial_positions = np.array(initial_positions[:n])\n    \n    # Add small random perturbation\n    initial_positions += np.random.randn(n, 2) * 0.02\n    initial_positions = np.clip(initial_positions, 0.05, 0.95)\n    \n    # Optimize positions\n    result = minimize(\n        position_objective,\n        initial_positions.flatten(),\n        method='SLSQP',\n        constraints={'type': 'ineq', 'fun': position_constraints},\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n    \n    optimized_positions = result.x.reshape(n, 2)\n    \n    # PHASE 2: Radius Optimization via Linear Programming\n    dist_matrix = squareform(pdist(optimized_positions))\n    \n    # LP: maximize sum of radii\n    # Variables: r_0, r_1, ..., r_{n-1}\n    c = -np.ones(n)  # Negative because linprog minimizes\n    \n    # Inequality constraints: r_i + r_j <= dist(i,j)\n    A_ub = []\n    b_ub = []\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            constraint = np.zeros(n)\n            constraint[i] = 1\n            constraint[j] = 1\n            A_ub.append(constraint)\n            b_ub.append(dist_matrix[i, j])\n    \n    # Boundary constraints: r_i <= distance to boundary\n    for i in range(n):\n        x, y = optimized_positions[i]\n        max_r = min(x, 1-x, y, 1-y)\n        constraint = np.zeros(n)\n        constraint[i] = 1\n        A_ub.append(constraint)\n        b_ub.append(max_r)\n    \n    A_ub = np.array(A_ub)\n    b_ub = np.array(b_ub)\n    \n    # Bounds: r_i >= 0\n    bounds = [(0, None) for _ in range(n)]\n    \n    lp_result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n    \n    if lp_result.success:\n        radii = lp_result.x\n    else:\n        # Fallback: equal radii\n        min_dist = np.min(dist_matrix[dist_matrix > 0])\n        radii = np.ones(n) * min_dist / 2.5\n    \n    # PHASE 3: Joint refinement with SLSQP\n    def joint_objective(x):\n        \"\"\"Minimize negative sum of radii\"\"\"\n        positions = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def joint_constraints(x):\n        positions = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        constraints = []\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(positions[i] - positions[j])\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Boundary constraints\n        for i in range(n):\n            constraints.append(positions[i, 0] - radii[i])  # left\n            constraints.append(1 - positions[i, 0] - radii[i])  # right\n            constraints.append(positions[i, 1] - radii[i])  # bottom\n            constraints.append(1 - positions[i, 1] - radii[i])  # top\n        \n        # Radii non-negative\n        constraints.extend(radii)\n        \n        return np.array(constraints)\n    \n    # Initial guess for joint optimization\n    x0 = np.concatenate([optimized_positions.flatten(), radii])\n    \n    joint_result = minimize(\n        joint_objective,\n        x0,\n        method='SLSQP',\n        constraints={'type': 'ineq', 'fun': joint_constraints},\n        options={'maxiter': 500, 'ftol': 1e-9}\n    )\n    \n    if joint_result.success:\n        final_positions = joint_result.x[:2*n].reshape(n, 2)\n        final_radii = joint_result.x[2*n:]\n    else:\n        final_positions = optimized_positions\n        final_radii = radii\n    \n    sum_radii = np.sum(final_radii)\n    \n    return final_positions, final_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.6064434572839277,
    "eval_time": 0.6594648361206055,
    "error": null
  },
  "prompt": "Pack 26 circles in unit square. Use a TWO-PHASE approach:\n\nPHASE 1 - Position Optimization (fixed equal radii):\n- Set all radii to r=0.1 (approximately optimal average)\n- Optimize only positions to maximize minimum pairwise distance\n- This spreads circles evenly\n\nPHASE 2 - Radius Optimization (fixed positions):\n- Given optimized positions, solve LP for optimal radii:\n  max sum(r_i)\n  s.t. r_i + r_j <= dist(i,j) for all pairs\n  s.t. r_i <= min(x_i, 1-x_i, y_i, 1-y_i) for all i\n\nPHASE 3 - Joint refinement with SLSQP\n\nReturn valid (centers, radii, sum_radii). Target > 2.60.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    np.random.seed(42)\n    n = 26\n    \n    # PHASE 1: Position Optimization with fixed equal radii\n    def position_objective(positions):\n        \"\"\"Maximize minimum pairwise distance (minimize negative)\"\"\"\n        positions = positions.reshape(n, 2)\n        dists = pdist(positions)\n        return -np.min(dists)  # Negative because we minimize\n    \n    def position_constraints(positions):\n        \"\"\"Ensure positions are in [0,1]^2\"\"\"\n        positions = positions.reshape(n, 2)\n        constraints = []\n        # Stay inside unit square\n        constraints.extend(positions[:, 0])  # x >= 0\n        constraints.extend(1 - positions[:, 0])  # x <= 1\n        constraints.extend(positions[:, 1])  # y >= 0\n        constraints.extend(1 - positions[:, 1])  # y <= 1\n        return np.array(constraints)\n    \n    # Initialize with grid + perturbation\n    grid_size = int(np.ceil(np.sqrt(n)))\n    initial_positions = []\n    for i in range(n):\n        x = (i % grid_size + 0.5) / grid_size\n        y = (i // grid_size + 0.5) / grid_size\n        initial_positions.append([x, y])\n    initial_positions = np.array(initial_positions[:n])\n    \n    # Add small random perturbation\n    initial_positions += np.random.randn(n, 2) * 0.02\n    initial_positions = np.clip(initial_positions, 0.05, 0.95)\n    \n    # Optimize positions\n    result = minimize(\n        position_objective,\n        initial_positions.flatten(),\n        method='SLSQP',\n        constraints={'type': 'ineq', 'fun': position_constraints},\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n    \n    optimized_positions = result.x.reshape(n, 2)\n    \n    # PHASE 2: Radius Optimization via Linear Programming\n    dist_matrix = squareform(pdist(optimized_positions))\n    \n    # LP: maximize sum of radii\n    # Variables: r_0, r_1, ..., r_{n-1}\n    c = -np.ones(n)  # Negative because linprog minimizes\n    \n    # Inequality constraints: r_i + r_j <= dist(i,j)\n    A_ub = []\n    b_ub = []\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            constraint = np.zeros(n)\n            constraint[i] = 1\n            constraint[j] = 1\n            A_ub.append(constraint)\n            b_ub.append(dist_matrix[i, j])\n    \n    # Boundary constraints: r_i <= distance to boundary\n    for i in range(n):\n        x, y = optimized_positions[i]\n        max_r = min(x, 1-x, y, 1-y)\n        constraint = np.zeros(n)\n        constraint[i] = 1\n        A_ub.append(constraint)\n        b_ub.append(max_r)\n    \n    A_ub = np.array(A_ub)\n    b_ub = np.array(b_ub)\n    \n    # Bounds: r_i >= 0\n    bounds = [(0, None) for _ in range(n)]\n    \n    lp_result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n    \n    if lp_result.success:\n        radii = lp_result.x\n    else:\n        # Fallback: equal radii\n        min_dist = np.min(dist_matrix[dist_matrix > 0])\n        radii = np.ones(n) * min_dist / 2.5\n    \n    # PHASE 3: Joint refinement with SLSQP\n    def joint_objective(x):\n        \"\"\"Minimize negative sum of radii\"\"\"\n        positions = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def joint_constraints(x):\n        positions = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        constraints = []\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(positions[i] - positions[j])\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Boundary constraints\n        for i in range(n):\n            constraints.append(positions[i, 0] - radii[i])  # left\n            constraints.append(1 - positions[i, 0] - radii[i])  # right\n            constraints.append(positions[i, 1] - radii[i])  # bottom\n            constraints.append(1 - positions[i, 1] - radii[i])  # top\n        \n        # Radii non-negative\n        constraints.extend(radii)\n        \n        return np.array(constraints)\n    \n    # Initial guess for joint optimization\n    x0 = np.concatenate([optimized_positions.flatten(), radii])\n    \n    joint_result = minimize(\n        joint_objective,\n        x0,\n        method='SLSQP',\n        constraints={'type': 'ineq', 'fun': joint_constraints},\n        options={'maxiter': 500, 'ftol': 1e-9}\n    )\n    \n    if joint_result.success:\n        final_positions = joint_result.x[:2*n].reshape(n, 2)\n        final_radii = joint_result.x[2*n:]\n    else:\n        final_positions = optimized_positions\n        final_radii = radii\n    \n    sum_radii = np.sum(final_radii)\n    \n    return final_positions, final_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-30T19:40:43.724555",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.5
  }
}