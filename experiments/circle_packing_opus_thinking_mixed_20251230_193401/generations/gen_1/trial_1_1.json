{
  "trial_id": "trial_1_1",
  "generation": 1,
  "parent_id": "trial_0_2",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Hybrid approach: Hexagonal lattice initialization + multiple restarts with perturbations.\n    Combines structured initialization with exploration through restarts.\n    \"\"\"\n    n = 26\n    \n    def create_hex_lattice():\n        \"\"\"Create initial hexagonal lattice configuration.\"\"\"\n        centers = []\n        rows = 5\n        cols = 6\n        dx = 1.0 / (cols - 0.5)\n        dy = np.sqrt(3)/2 * dx\n        \n        for r in range(rows):\n            for c in range(cols):\n                if len(centers) >= n:\n                    break\n                x = (c + 0.5 * (r % 2)) * dx\n                y = r * dy\n                centers.append([x, y])\n        \n        centers = np.array(centers[:n])\n        # Scale and center to fit [0, 1]\n        centers -= centers.min(axis=0)\n        centers /= centers.max(axis=0)\n        # Shrink slightly to avoid boundary issues\n        centers = 0.1 + 0.8 * centers\n        return centers\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def create_constraints():\n        \"\"\"Create constraint list for optimization.\"\"\"\n        constraints = []\n        \n        # Boundary constraints\n        for i in range(n):\n            # x - r >= 0\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: x[2*i] - x[2*n + i]\n            })\n            # 1 - x - r >= 0\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: 1 - x[2*i] - x[2*n + i]\n            })\n            # y - r >= 0\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: x[2*i + 1] - x[2*n + i]\n            })\n            # 1 - y - r >= 0\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: 1 - x[2*i + 1] - x[2*n + i]\n            })\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                def non_overlap(x, i=i, j=j):\n                    xi, yi = x[2*i], x[2*i + 1]\n                    xj, yj = x[2*j], x[2*j + 1]\n                    ri, rj = x[2*n + i], x[2*n + j]\n                    dist_sq = (xi - xj)**2 + (yi - yj)**2\n                    return dist_sq - (ri + rj)**2\n                \n                constraints.append({\n                    'type': 'ineq',\n                    'fun': non_overlap\n                })\n        \n        return constraints\n    \n    # Bounds\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n    constraints = create_constraints()\n    \n    # Track best solution\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Strategy 1: Hexagonal lattice with varying initial radii\n    hex_centers = create_hex_lattice()\n    \n    for trial in range(12):\n        if trial == 0:\n            # Pure hexagonal lattice\n            init_centers = hex_centers.copy()\n            init_radii = np.full(n, 0.095)\n        elif trial < 6:\n            # Hex lattice with small perturbations\n            np.random.seed(trial)\n            init_centers = hex_centers + np.random.randn(n, 2) * 0.02\n            init_centers = np.clip(init_centers, 0.05, 0.95)\n            init_radii = np.random.rand(n) * 0.04 + 0.08\n        else:\n            # More random starts with hex-inspired structure\n            np.random.seed(trial * 10)\n            # Create a perturbed grid\n            grid_size = int(np.ceil(np.sqrt(n)))\n            init_centers = []\n            for i in range(n):\n                row = i // grid_size\n                col = i % grid_size\n                x = (col + 0.5 + np.random.randn() * 0.1) / grid_size\n                y = (row + 0.5 + np.random.randn() * 0.1) / grid_size\n                init_centers.append([x, y])\n            init_centers = np.array(init_centers)\n            init_centers = np.clip(init_centers, 0.05, 0.95)\n            init_radii = np.random.rand(n) * 0.05 + 0.07\n        \n        x0 = np.concatenate([init_centers.flatten(), init_radii])\n        \n        # Optimize with adaptive parameters\n        max_iter = 3000 if trial < 3 else 2000\n        \n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': max_iter, 'ftol': 1e-9, 'disp': False}\n        )\n        \n        if result.success or result.status == 0:\n            solution = result.x\n            radii_trial = solution[2*n:]\n            sum_trial = np.sum(radii_trial)\n            \n            if sum_trial > best_sum:\n                best_sum = sum_trial\n                best_centers = solution[:2*n].reshape(n, 2)\n                best_radii = radii_trial\n    \n    # Additional refinement: take best solution and perturb slightly\n    if best_centers is not None:\n        for refine in range(3):\n            np.random.seed(100 + refine)\n            perturb_centers = best_centers + np.random.randn(n, 2) * 0.005\n            perturb_centers = np.clip(perturb_centers, 0.01, 0.99)\n            perturb_radii = best_radii * (1 + np.random.randn(n) * 0.02)\n            perturb_radii = np.clip(perturb_radii, 0.001, 0.5)\n            \n            x0_refine = np.concatenate([perturb_centers.flatten(), perturb_radii])\n            \n            result = minimize(\n                objective,\n                x0_refine,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 2000, 'ftol': 1e-10, 'disp': False}\n            )\n            \n            if result.success or result.status == 0:\n                solution = result.x\n                radii_trial = solution[2*n:]\n                sum_trial = np.sum(radii_trial)\n                \n                if sum_trial > best_sum:\n                    best_sum = sum_trial\n                    best_centers = solution[:2*n].reshape(n, 2)\n                    best_radii = radii_trial\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.610033337541083,
    "eval_time": 22.850754976272583,
    "error": null
  },
  "prompt": "Combine the best aspects of these two approaches:\n\n**Approach 1 (score 2.603 - hex lattice init):**\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Packs 26 circles into a [0,1]x[0,1] square to maximize the sum of radii.\n    Uses a dense hexagonal packing strategy with local optimization.\n    \"\"\"\n    n = 26\n    \n    # 1. Initial Hexagonal Lattice Placement\n    # For 26 circles, a 5x5 grid + 1 or a 6x4.5 grid works.\n    # We'll initialize in a roughly square hex grid.\n    centers = []\n    rows = 5\n    cols = 6\n    dx = 1.0 / (cols - 0.5)\n    dy = np.sqrt(3)/2 * dx\n    \n    for r in range(rows):\n        for c in range(cols):\n            if len(centers) >= n:\n                break\n            x = (c + 0.5 * (r % 2)) * dx\n            y = r * dy\n            centers.append([x, y])\n    \n    centers = np.array(centers)\n    # Scale and center to fit [0, 1]\n    centers -= centers.min(axis=0)\n    centers /= centers.max(axis=0)\n    # Shrink slightly to avoid boundary issues during start\n    centers = 0.1 + 0.8 * centers \n    \n    # 2. Define Optimization\n    # Variables: x1, y1, ..., xn, yn, r1, ..., rn\n    # Objective: Maximize sum(radii) -> Minimize -sum(radii)\n    \n    init_radii = np.full(n, 1.0 / (2 * np.sqrt(n)))\n    x0 = np.concatenate([centers.flatten(), init_radii])\n    \n    def objective(vars):\n        return -np.sum(vars[2*n:])\n\n    def constraints(vars):\n        pts = vars[:2*n].reshape((n, 2))\n        radii = vars[2*n:]\n        cons = []\n        \n        # Boundary constraints: r <= x <= 1-r and r <= y <= 1-r\n        for i in range(n):\n            cons.append(pts[i, 0] - radii[i])       # x - r >= 0\n            cons.append(1.0 - pts[i, 0] - radii[i]) # 1 - x - r >= 0\n            cons.append(pts[i, 1] - radii[i])       # y - r >= 0\n            cons.append(1.0 - pts[i, 1] - radii[i]) # 1 - y - r >= 0\n            cons.append(radii[i])                   # r >= 0\n            \n        # Non-overlap constraints: dist(ci, cj) >= ri + rj\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.sqrt(np.sum((pts[i] - pts[j])**2))\n                cons.append(d - (radii[i] + radii[j]))\n        \n        return np.array(cons)\n\n    # Using SLSQP for local optimization\n    # To keep it fast and robust for the target sum, we define bounds\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n    \n    # Optimization can be slow, so we use a simplified version of the constraints\n    # for scipy's SLSQP format.\n    cons_dict = {'type': 'ineq', 'fun': constraints}\n    \n    res = minimize(objective, x0, method='SLSQP', bounds=bounds, \n                   constraints=cons_dict, options={'maxiter': 100, 'disp': False})\n    \n    final_vars = res.x\n    final_centers = final_vars[:2*n].reshape((n, 2))\n    final_radii = final_vars[2*n:]\n    \n    # Final check and small adjustment to ensure strict validity\n    # (Rounding errors can lead to tiny overlaps)\n    sum_r = np.sum(final_radii)\n    \n    # If the optimization didn't reach the target, we provide a high-quality \n    # hardcoded configuration known for n=26 based on the hexagonal pattern.\n    # The target sum ~2.6359 suggests radii are ~0.101\n    if sum_r < 2.5:\n        r_fixed = 0.10138\n        sum_r = n * r_fixed\n        final_radii = np.full(n, r_fixed)\n        # Create a 5x5+1 layout manually\n        final_centers = []\n        for i in range(5):\n            for j in range(5):\n                final_centers.append([r_fixed + j*(1-2*r_fixed)/4, r_fixed + i*(1-2*r_fixed)/4])\n        final_centers.append([0.5, 0.5]) # Dummy center, will overlap but this is a fallback\n        final_centers = np.array(final_centers[:n])\n\n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    return construct_packing()\n\n**Approach 2 (score 2.591 - multi-restart):**\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    \n    # Initial guess: place circles in a grid pattern\n    grid_size = int(np.ceil(np.sqrt(n)))\n    initial_centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        initial_centers.append([x, y])\n    initial_centers = np.array(initial_centers)\n    \n    # Initial radii: small uniform values\n    initial_radii = np.ones(n) * 0.05\n    \n    # Combine into single decision vector\n    x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n    \n    # Objective: maximize sum of radii = minimize negative sum\n    def objective(x):\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    # Constraints\n    constraints = []\n    \n    # Boundary constraints: x - r >= 0, x + r <= 1, y - r >= 0, y + r <= 1\n    for i in range(n):\n        # x - r >= 0\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: x[2*i] - x[2*n + i]\n        })\n        # x + r <= 1\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: 1 - x[2*i] - x[2*n + i]\n        })\n        # y - r >= 0\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: x[2*i + 1] - x[2*n + i]\n        })\n        # y + r <= 1\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: 1 - x[2*i + 1] - x[2*n + i]\n        })\n    \n    # Non-overlap constraints: distance >= sum of radii\n    for i in range(n):\n        for j in range(i + 1, n):\n            def non_overlap(x, i=i, j=j):\n                xi, yi = x[2*i], x[2*i + 1]\n                xj, yj = x[2*j], x[2*j + 1]\n                ri, rj = x[2*n + i], x[2*n + j]\n                dist_sq = (xi - xj)**2 + (yi - yj)**2\n                return dist_sq - (ri + rj)**2\n            \n            constraints.append({\n                'type': 'ineq',\n                'fun': non_overlap\n            })\n    \n    # Bounds: radii >= 0, centers in [0, 1]\n    bounds = []\n    for i in range(n):\n        bounds.append((0, 1))  # x\n        bounds.append((0, 1))  # y\n    for i in range(n):\n        bounds.append((0, 0.5))  # r (max possible radius is 0.5)\n    \n    # Optimize\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': 2000, 'ftol': 1e-9}\n    )\n    \n    # Extract solution\n    solution = result.x\n    centers = solution[:2*n].reshape(n, 2)\n    radii = solution[2*n:]\n    sum_radii = np.sum(radii)\n    \n    # Try multiple random restarts to improve solution\n    best_sum = sum_radii\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    \n    for trial in range(5):\n        # Random initialization with some structure\n        np.random.seed(trial)\n        init_centers = np.random.rand(n, 2) * 0.8 + 0.1\n        init_radii = np.random.rand(n) * 0.05 + 0.02\n        x0_trial = np.concatenate([init_centers.flatten(), init_radii])\n        \n        result_trial = minimize(\n            objective,\n            x0_trial,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 2000, 'ftol': 1e-9}\n        )\n        \n        if result_trial.success:\n            solution_trial = result_trial.x\n            radii_trial = solution_trial[2*n:]\n            sum_trial = np.sum(radii_trial)\n            \n            if sum_trial > best_sum:\n                best_sum = sum_trial\n                best_centers = solution_trial[:2*n].reshape(n, 2)\n                best_radii = radii_trial\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    return construct_packing()\n\nCreate a hybrid that uses hex lattice initialization PLUS multiple restarts with small perturbations. Run at least 10 restarts. Target sum > 2.62.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Hybrid approach: Hexagonal lattice initialization + multiple restarts with perturbations.\n    Combines structured initialization with exploration through restarts.\n    \"\"\"\n    n = 26\n    \n    def create_hex_lattice():\n        \"\"\"Create initial hexagonal lattice configuration.\"\"\"\n        centers = []\n        rows = 5\n        cols = 6\n        dx = 1.0 / (cols - 0.5)\n        dy = np.sqrt(3)/2 * dx\n        \n        for r in range(rows):\n            for c in range(cols):\n                if len(centers) >= n:\n                    break\n                x = (c + 0.5 * (r % 2)) * dx\n                y = r * dy\n                centers.append([x, y])\n        \n        centers = np.array(centers[:n])\n        # Scale and center to fit [0, 1]\n        centers -= centers.min(axis=0)\n        centers /= centers.max(axis=0)\n        # Shrink slightly to avoid boundary issues\n        centers = 0.1 + 0.8 * centers\n        return centers\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def create_constraints():\n        \"\"\"Create constraint list for optimization.\"\"\"\n        constraints = []\n        \n        # Boundary constraints\n        for i in range(n):\n            # x - r >= 0\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: x[2*i] - x[2*n + i]\n            })\n            # 1 - x - r >= 0\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: 1 - x[2*i] - x[2*n + i]\n            })\n            # y - r >= 0\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: x[2*i + 1] - x[2*n + i]\n            })\n            # 1 - y - r >= 0\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: 1 - x[2*i + 1] - x[2*n + i]\n            })\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                def non_overlap(x, i=i, j=j):\n                    xi, yi = x[2*i], x[2*i + 1]\n                    xj, yj = x[2*j], x[2*j + 1]\n                    ri, rj = x[2*n + i], x[2*n + j]\n                    dist_sq = (xi - xj)**2 + (yi - yj)**2\n                    return dist_sq - (ri + rj)**2\n                \n                constraints.append({\n                    'type': 'ineq',\n                    'fun': non_overlap\n                })\n        \n        return constraints\n    \n    # Bounds\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n    constraints = create_constraints()\n    \n    # Track best solution\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Strategy 1: Hexagonal lattice with varying initial radii\n    hex_centers = create_hex_lattice()\n    \n    for trial in range(12):\n        if trial == 0:\n            # Pure hexagonal lattice\n            init_centers = hex_centers.copy()\n            init_radii = np.full(n, 0.095)\n        elif trial < 6:\n            # Hex lattice with small perturbations\n            np.random.seed(trial)\n            init_centers = hex_centers + np.random.randn(n, 2) * 0.02\n            init_centers = np.clip(init_centers, 0.05, 0.95)\n            init_radii = np.random.rand(n) * 0.04 + 0.08\n        else:\n            # More random starts with hex-inspired structure\n            np.random.seed(trial * 10)\n            # Create a perturbed grid\n            grid_size = int(np.ceil(np.sqrt(n)))\n            init_centers = []\n            for i in range(n):\n                row = i // grid_size\n                col = i % grid_size\n                x = (col + 0.5 + np.random.randn() * 0.1) / grid_size\n                y = (row + 0.5 + np.random.randn() * 0.1) / grid_size\n                init_centers.append([x, y])\n            init_centers = np.array(init_centers)\n            init_centers = np.clip(init_centers, 0.05, 0.95)\n            init_radii = np.random.rand(n) * 0.05 + 0.07\n        \n        x0 = np.concatenate([init_centers.flatten(), init_radii])\n        \n        # Optimize with adaptive parameters\n        max_iter = 3000 if trial < 3 else 2000\n        \n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': max_iter, 'ftol': 1e-9, 'disp': False}\n        )\n        \n        if result.success or result.status == 0:\n            solution = result.x\n            radii_trial = solution[2*n:]\n            sum_trial = np.sum(radii_trial)\n            \n            if sum_trial > best_sum:\n                best_sum = sum_trial\n                best_centers = solution[:2*n].reshape(n, 2)\n                best_radii = radii_trial\n    \n    # Additional refinement: take best solution and perturb slightly\n    if best_centers is not None:\n        for refine in range(3):\n            np.random.seed(100 + refine)\n            perturb_centers = best_centers + np.random.randn(n, 2) * 0.005\n            perturb_centers = np.clip(perturb_centers, 0.01, 0.99)\n            perturb_radii = best_radii * (1 + np.random.randn(n) * 0.02)\n            perturb_radii = np.clip(perturb_radii, 0.001, 0.5)\n            \n            x0_refine = np.concatenate([perturb_centers.flatten(), perturb_radii])\n            \n            result = minimize(\n                objective,\n                x0_refine,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 2000, 'ftol': 1e-10, 'disp': False}\n            )\n            \n            if result.success or result.status == 0:\n                solution = result.x\n                radii_trial = solution[2*n:]\n                sum_trial = np.sum(radii_trial)\n                \n                if sum_trial > best_sum:\n                    best_sum = sum_trial\n                    best_centers = solution[:2*n].reshape(n, 2)\n                    best_radii = radii_trial\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-30T19:41:10.169362",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.5
  }
}