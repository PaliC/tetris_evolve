{
  "trial_id": "trial_-1_3",
  "generation": -1,
  "parent_id": null,
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 0.14405298233032227,
    "error": "ValueError: Code must define run_packing() or construct_packing()"
  },
  "code": "def circles_fit_in_unit_square(centers: list[tuple[float, float]], radii: list[float]) -> bool:\n    \"\"\"\n    Check if all circles fit inside the unit square [0,1]x[0,1] without overlapping.\n    \n    Args:\n        centers: List of (x, y) tuples representing circle centers\n        radii: List of radii corresponding to each circle\n    \n    Returns:\n        True if all circles fit inside the unit square without overlapping, False otherwise\n    \n    Raises:\n        ValueError: If inputs are invalid (mismatched lengths, negative radii, etc.)\n    \"\"\"\n    # Validate inputs\n    if centers is None or radii is None:\n        raise ValueError(\"Centers and radii cannot be None\")\n    \n    if len(centers) != len(radii):\n        raise ValueError(f\"Number of centers ({len(centers)}) must match number of radii ({len(radii)})\")\n    \n    # Empty list case - trivially true\n    if len(centers) == 0:\n        return True\n    \n    # Validate each center and radius\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        # Validate center is a tuple/list with 2 elements\n        if not hasattr(center, '__len__') or len(center) != 2:\n            raise ValueError(f\"Center at index {i} must be a tuple/list of 2 coordinates\")\n        \n        x, y = center\n        \n        # Check for valid numeric types\n        if not isinstance(x, (int, float)) or not isinstance(y, (int, float)):\n            raise ValueError(f\"Center coordinates at index {i} must be numeric\")\n        \n        if not isinstance(radius, (int, float)):\n            raise ValueError(f\"Radius at index {i} must be numeric\")\n        \n        # Check for NaN or infinity\n        if not (isinstance(x, int) or (isinstance(x, float) and x == x and abs(x) != float('inf'))):\n            raise ValueError(f\"Center x-coordinate at index {i} is invalid (NaN or infinity)\")\n        if not (isinstance(y, int) or (isinstance(y, float) and y == y and abs(y) != float('inf'))):\n            raise ValueError(f\"Center y-coordinate at index {i} is invalid (NaN or infinity)\")\n        if not (isinstance(radius, int) or (isinstance(radius, float) and radius == radius and abs(radius) != float('inf'))):\n            raise ValueError(f\"Radius at index {i} is invalid (NaN or infinity)\")\n        \n        # Check for negative radius\n        if radius < 0:\n            raise ValueError(f\"Radius at index {i} cannot be negative: {radius}\")\n    \n    n = len(centers)\n    \n    # Check if each circle fits within the unit square [0,1]x[0,1]\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        x, y = center\n        \n        # Circle must not extend beyond unit square boundaries\n        # x - r >= 0 and x + r <= 1\n        # y - r >= 0 and y + r <= 1\n        if x - radius < 0 or x + radius > 1:\n            return False\n        if y - radius < 0 or y + radius > 1:\n            return False\n    \n    # Check for overlapping between all pairs of circles\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = centers[i]\n            x2, y2 = centers[j]\n            r1 = radii[i]\n            r2 = radii[j]\n            \n            # Calculate distance between centers\n            distance_squared = (x2 - x1) ** 2 + (y2 - y1) ** 2\n            sum_of_radii = r1 + r2\n            \n            # Circles overlap if distance < r1 + r2\n            # Using squared values to avoid floating point issues with sqrt\n            # Circles are non-overlapping if distance >= r1 + r2\n            if distance_squared < sum_of_radii ** 2:\n                return False\n    \n    return True\n\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test 1: Single circle that fits\n    assert circles_fit_in_unit_square([(0.5, 0.5)], [0.4]) == True\n    print(\"Test 1 passed: Single circle that fits\")\n    \n    # Test 2: Single circle that doesn't fit (extends beyond boundary)\n    assert circles_fit_in_unit_square([(0.5, 0.5)], [0.6]) == False\n    print(\"Test 2 passed: Single circle too large\")\n    \n    # Test 3: Two non-overlapping circles\n    assert circles_fit_in_unit_square([(0.25, 0.5), (0.75, 0.5)], [0.2, 0.2]) == True\n    print(\"Test 3 passed: Two non-overlapping circles\")\n    \n    # Test 4: Two overlapping circles\n    assert circles_fit_in_unit_square([(0.4, 0.5), (0.6, 0.5)], [0.2, 0.2]) == False\n    print(\"Test 4 passed: Two overlapping circles\")\n    \n    # Test 5: Circle touching boundary (exactly fits)\n    assert circles_fit_in_unit_square([(0.5, 0.5)], [0.5]) == True\n    print(\"Test 5 passed: Circle exactly fits\")\n    \n    # Test 6: Empty lists\n    assert circles_fit_in_unit_square([], []) == True\n    print(\"Test 6 passed: Empty lists\")\n    \n    # Test 7: Circle at corner\n    assert circles_fit_in_unit_square([(0.1, 0.1)], [0.1]) == True\n    print(\"Test 7 passed: Circle at corner\")\n    \n    # Test 8: Circle exceeds left boundary\n    assert circles_fit_in_unit_square([(0.05, 0.5)], [0.1]) == False\n    print(\"Test 8 passed: Circle exceeds left boundary\")\n    \n    # Test 9: Multiple circles, one pair overlapping\n    assert circles_fit_in_unit_square([(0.2, 0.2), (0.8, 0.8), (0.25, 0.25)], [0.1, 0.1, 0.1]) == False\n    print(\"Test 9 passed: Multiple circles with overlap\")\n    \n    # Test 10: Circles just touching (not overlapping)\n    assert circles_fit_in_unit_square([(0.3, 0.5), (0.7, 0.5)], [0.2, 0.2]) == True\n    print(\"Test 10 passed: Circles just touching\")\n    \n    # Test 11: Zero radius circles (points)\n    assert circles_fit_in_unit_square([(0.5, 0.5), (0.5, 0.5)], [0, 0]) == True\n    print(\"Test 11 passed: Zero radius circles at same point\")\n    \n    # Test 12: Negative radius should raise error\n    try:\n        circles_fit_in_unit_square([(0.5, 0.5)], [-0.1])\n        assert False, \"Should have raised ValueError\"\n    except ValueError:\n        print(\"Test 12 passed: Negative radius raises error\")\n    \n    # Test 13: Mismatched lengths should raise error\n    try:\n        circles_fit_in_unit_square([(0.5, 0.5), (0.3, 0.3)], [0.1])\n        assert False, \"Should have raised ValueError\"\n    except ValueError:\n        print(\"Test 13 passed: Mismatched lengths raises error\")\n    \n    print(\"\\nAll tests passed!\")",
  "prompt": "Write a Python function that takes a list of circle centers [(x1,y1), (x2,y2), ...] and radii [r1, r2, ...] and returns True if all circles fit inside the unit square [0,1]x[0,1] without overlapping.\n\nInclude proper validation and edge cases. Return the function in a Python code block.",
  "response": "```python\ndef circles_fit_in_unit_square(centers: list[tuple[float, float]], radii: list[float]) -> bool:\n    \"\"\"\n    Check if all circles fit inside the unit square [0,1]x[0,1] without overlapping.\n    \n    Args:\n        centers: List of (x, y) tuples representing circle centers\n        radii: List of radii corresponding to each circle\n    \n    Returns:\n        True if all circles fit inside the unit square without overlapping, False otherwise\n    \n    Raises:\n        ValueError: If inputs are invalid (mismatched lengths, negative radii, etc.)\n    \"\"\"\n    # Validate inputs\n    if centers is None or radii is None:\n        raise ValueError(\"Centers and radii cannot be None\")\n    \n    if len(centers) != len(radii):\n        raise ValueError(f\"Number of centers ({len(centers)}) must match number of radii ({len(radii)})\")\n    \n    # Empty list case - trivially true\n    if len(centers) == 0:\n        return True\n    \n    # Validate each center and radius\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        # Validate center is a tuple/list with 2 elements\n        if not hasattr(center, '__len__') or len(center) != 2:\n            raise ValueError(f\"Center at index {i} must be a tuple/list of 2 coordinates\")\n        \n        x, y = center\n        \n        # Check for valid numeric types\n        if not isinstance(x, (int, float)) or not isinstance(y, (int, float)):\n            raise ValueError(f\"Center coordinates at index {i} must be numeric\")\n        \n        if not isinstance(radius, (int, float)):\n            raise ValueError(f\"Radius at index {i} must be numeric\")\n        \n        # Check for NaN or infinity\n        if not (isinstance(x, int) or (isinstance(x, float) and x == x and abs(x) != float('inf'))):\n            raise ValueError(f\"Center x-coordinate at index {i} is invalid (NaN or infinity)\")\n        if not (isinstance(y, int) or (isinstance(y, float) and y == y and abs(y) != float('inf'))):\n            raise ValueError(f\"Center y-coordinate at index {i} is invalid (NaN or infinity)\")\n        if not (isinstance(radius, int) or (isinstance(radius, float) and radius == radius and abs(radius) != float('inf'))):\n            raise ValueError(f\"Radius at index {i} is invalid (NaN or infinity)\")\n        \n        # Check for negative radius\n        if radius < 0:\n            raise ValueError(f\"Radius at index {i} cannot be negative: {radius}\")\n    \n    n = len(centers)\n    \n    # Check if each circle fits within the unit square [0,1]x[0,1]\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        x, y = center\n        \n        # Circle must not extend beyond unit square boundaries\n        # x - r >= 0 and x + r <= 1\n        # y - r >= 0 and y + r <= 1\n        if x - radius < 0 or x + radius > 1:\n            return False\n        if y - radius < 0 or y + radius > 1:\n            return False\n    \n    # Check for overlapping between all pairs of circles\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = centers[i]\n            x2, y2 = centers[j]\n            r1 = radii[i]\n            r2 = radii[j]\n            \n            # Calculate distance between centers\n            distance_squared = (x2 - x1) ** 2 + (y2 - y1) ** 2\n            sum_of_radii = r1 + r2\n            \n            # Circles overlap if distance < r1 + r2\n            # Using squared values to avoid floating point issues with sqrt\n            # Circles are non-overlapping if distance >= r1 + r2\n            if distance_squared < sum_of_radii ** 2:\n                return False\n    \n    return True\n\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test 1: Single circle that fits\n    assert circles_fit_in_unit_square([(0.5, 0.5)], [0.4]) == True\n    print(\"Test 1 passed: Single circle that fits\")\n    \n    # Test 2: Single circle that doesn't fit (extends beyond boundary)\n    assert circles_fit_in_unit_square([(0.5, 0.5)], [0.6]) == False\n    print(\"Test 2 passed: Single circle too large\")\n    \n    # Test 3: Two non-overlapping circles\n    assert circles_fit_in_unit_square([(0.25, 0.5), (0.75, 0.5)], [0.2, 0.2]) == True\n    print(\"Test 3 passed: Two non-overlapping circles\")\n    \n    # Test 4: Two overlapping circles\n    assert circles_fit_in_unit_square([(0.4, 0.5), (0.6, 0.5)], [0.2, 0.2]) == False\n    print(\"Test 4 passed: Two overlapping circles\")\n    \n    # Test 5: Circle touching boundary (exactly fits)\n    assert circles_fit_in_unit_square([(0.5, 0.5)], [0.5]) == True\n    print(\"Test 5 passed: Circle exactly fits\")\n    \n    # Test 6: Empty lists\n    assert circles_fit_in_unit_square([], []) == True\n    print(\"Test 6 passed: Empty lists\")\n    \n    # Test 7: Circle at corner\n    assert circles_fit_in_unit_square([(0.1, 0.1)], [0.1]) == True\n    print(\"Test 7 passed: Circle at corner\")\n    \n    # Test 8: Circle exceeds left boundary\n    assert circles_fit_in_unit_square([(0.05, 0.5)], [0.1]) == False\n    print(\"Test 8 passed: Circle exceeds left boundary\")\n    \n    # Test 9: Multiple circles, one pair overlapping\n    assert circles_fit_in_unit_square([(0.2, 0.2), (0.8, 0.8), (0.25, 0.25)], [0.1, 0.1, 0.1]) == False\n    print(\"Test 9 passed: Multiple circles with overlap\")\n    \n    # Test 10: Circles just touching (not overlapping)\n    assert circles_fit_in_unit_square([(0.3, 0.5), (0.7, 0.5)], [0.2, 0.2]) == True\n    print(\"Test 10 passed: Circles just touching\")\n    \n    # Test 11: Zero radius circles (points)\n    assert circles_fit_in_unit_square([(0.5, 0.5), (0.5, 0.5)], [0, 0]) == True\n    print(\"Test 11 passed: Zero radius circles at same point\")\n    \n    # Test 12: Negative radius should raise error\n    try:\n        circles_fit_in_unit_square([(0.5, 0.5)], [-0.1])\n        assert False, \"Should have raised ValueError\"\n    except ValueError:\n        print(\"Test 12 passed: Negative radius raises error\")\n    \n    # Test 13: Mismatched lengths should raise error\n    try:\n        circles_fit_in_unit_square([(0.5, 0.5), (0.3, 0.3)], [0.1])\n        assert False, \"Should have raised ValueError\"\n    except ValueError:\n        print(\"Test 13 passed: Mismatched lengths raises error\")\n    \n    print(\"\\nAll tests passed!\")\n```\n\n## Key Features:\n\n1. **Input Validation**:\n   - Checks for `None` inputs\n   - Validates matching lengths of centers and radii lists\n   - Ensures centers are 2-element tuples/lists\n   - Validates numeric types\n   - Checks for NaN and infinity values\n   - Rejects negative radii\n\n2. **Boundary Checking**:\n   - Verifies each circle stays within [0,1]\u00d7[0,1]\n   - Checks all four boundaries (left, right, top, bottom)\n\n3. **Overlap Detection**:\n   - Compares all pairs of circles\n   - Uses squared distances to avoid floating-point issues with `sqrt`\n   - Two circles overlap if `distance < r1 + r2`\n\n4. **Edge Cases Handled**:\n   - Empty lists (returns `True`)\n   - Zero-radius circles (treated as points)\n   - Circles exactly touching boundaries or each other (allowed)\n   - Single circle",
  "reasoning": "## Key Features:\n\n1. **Input Validation**:\n   - Checks for `None` inputs\n   - Validates matching lengths of centers and radii lists\n   - Ensures centers are 2-element tuples/lists\n   - Validates numeric types\n   - Checks for NaN and infinity values\n   - Rejects negative radii\n\n2. **Boundary Checking**:\n   - Verifies each circle stays within [0,1]\u00d7[0,1]\n   - Checks all four boundaries (left, right, top, bottom)\n\n3. **Overlap Detection**:\n   - Compares all pairs of circles\n   - Uses squared distances to avoid floating-point issues with `sqrt`\n   - Two circles overlap if `distance < r1 + r2`\n\n4. **Edge Cases Handled**:\n   - Empty lists (returns `True`)\n   - Zero-radius circles (treated as points)\n   - Circles exactly touching boundaries or each other (allowed)\n   - Single circle",
  "timestamp": "2025-12-30T19:35:40.552139",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-opus-4.5",
    "temperature": 0.7
  }
}