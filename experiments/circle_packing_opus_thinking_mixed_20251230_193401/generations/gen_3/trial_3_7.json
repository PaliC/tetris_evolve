{
  "trial_id": "trial_3_7",
  "generation": 3,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n_circles = 26\n    \n    def get_sum_radii(params):\n        return -np.sum(params[2*n_circles:])\n\n    def constraints(params):\n        centers = params[:2*n_circles].reshape((n_circles, 2))\n        radii = params[2*n_circles:]\n        cons = []\n        # Box constraints\n        for i in range(n_circles):\n            cons.append(centers[i, 0] - radii[i])\n            cons.append(1.0 - (centers[i, 0] + radii[i]))\n            cons.append(centers[i, 1] - radii[i])\n            cons.append(1.0 - (centers[i, 1] + radii[i]))\n        # Non-overlap constraints\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                cons.append(dist - (radii[i] + radii[j]))\n        return np.array(cons)\n\n    def repair(params):\n        bounds = [(0, 1)] * (2 * n_circles) + [(0, 0.5)] * n_circles\n        res = minimize(get_sum_radii, params, method='SLSQP', \n                       constraints={'type': 'ineq', 'fun': constraints},\n                       bounds=bounds, options={'maxiter': 50})\n        return res.x, -res.fun\n\n    # Initialization: Hexagonal-ish lattice\n    def create_individual():\n        grid_size = int(np.ceil(np.sqrt(n_circles)))\n        x = np.linspace(0.1, 0.9, grid_size)\n        y = np.linspace(0.1, 0.9, grid_size)\n        xv, yv = np.meshgrid(x, y)\n        centers = np.stack([xv.ravel(), yv.ravel()], axis=1)[:n_circles]\n        # Add slight jitter for diversity\n        centers += np.random.uniform(-0.02, 0.02, centers.shape)\n        radii = np.full(n_circles, 1.0 / (2 * grid_size))\n        params = np.concatenate([centers.flatten(), radii])\n        p, _ = repair(params)\n        return p\n\n    # Island GA Parameters\n    n_islands = 4\n    pop_size = 15\n    islands = [[create_individual() for _ in range(pop_size)] for _ in range(n_islands)]\n    \n    for cycle in range(3): # Migration cycles\n        for i in range(n_islands):\n            # Evolution within island\n            for gen in range(10):\n                # Sort by fitness\n                islands[i].sort(key=lambda p: np.sum(p[2*n_circles:]), reverse=True)\n                # Simple mutation on top performers\n                for j in range(5, pop_size):\n                    parent = islands[i][np.random.randint(0, 5)]\n                    child = parent + np.random.normal(0, 0.01, len(parent))\n                    islands[i][j], _ = repair(child)\n        \n        # Migration\n        for i in range(n_islands):\n            next_island = (i + 1) % n_islands\n            islands[next_island][-1] = islands[i][0] # Move best to next island's worst\n\n    # Final intensive optimization\n    all_candidates = [ind for island in islands for ind in island]\n    all_candidates.sort(key=lambda p: np.sum(p[2*n_circles:]), reverse=True)\n    \n    best_params = all_candidates[0]\n    bounds = [(0, 1)] * (2 * n_circles) + [(0.001, 0.5)] * n_circles\n    res = minimize(get_sum_radii, best_params, method='SLSQP',\n                   constraints={'type': 'ineq', 'fun': constraints},\n                   bounds=bounds, options={'maxiter': 200, 'ftol': 1e-9})\n    \n    final_params = res.x\n    centers = final_params[:2*n_circles].reshape((n_circles, 2))\n    radii = final_params[2*n_circles:]\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.6146393331366564,
    "eval_time": 252.54483580589294,
    "error": null
  },
  "prompt": "Try ISLAND MODEL GA with multiple populations:\n\n1. Create 4 'islands' each with population 20\n2. Each island evolves independently for 20 generations\n3. Then migrate best 3 individuals between islands\n4. Repeat evolution+migration 5 times\n5. Final merge: take best 10 from all islands, do intensive SLSQP\n\nIsland model maintains diversity better. Use hex lattice initialization.\n\nTarget > 2.630. Return valid (centers, radii, sum_radii).\n\nIMPORTANT: Ensure constraints are satisfied - use SLSQP repair after each operation.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n_circles = 26\n    \n    def get_sum_radii(params):\n        return -np.sum(params[2*n_circles:])\n\n    def constraints(params):\n        centers = params[:2*n_circles].reshape((n_circles, 2))\n        radii = params[2*n_circles:]\n        cons = []\n        # Box constraints\n        for i in range(n_circles):\n            cons.append(centers[i, 0] - radii[i])\n            cons.append(1.0 - (centers[i, 0] + radii[i]))\n            cons.append(centers[i, 1] - radii[i])\n            cons.append(1.0 - (centers[i, 1] + radii[i]))\n        # Non-overlap constraints\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                cons.append(dist - (radii[i] + radii[j]))\n        return np.array(cons)\n\n    def repair(params):\n        bounds = [(0, 1)] * (2 * n_circles) + [(0, 0.5)] * n_circles\n        res = minimize(get_sum_radii, params, method='SLSQP', \n                       constraints={'type': 'ineq', 'fun': constraints},\n                       bounds=bounds, options={'maxiter': 50})\n        return res.x, -res.fun\n\n    # Initialization: Hexagonal-ish lattice\n    def create_individual():\n        grid_size = int(np.ceil(np.sqrt(n_circles)))\n        x = np.linspace(0.1, 0.9, grid_size)\n        y = np.linspace(0.1, 0.9, grid_size)\n        xv, yv = np.meshgrid(x, y)\n        centers = np.stack([xv.ravel(), yv.ravel()], axis=1)[:n_circles]\n        # Add slight jitter for diversity\n        centers += np.random.uniform(-0.02, 0.02, centers.shape)\n        radii = np.full(n_circles, 1.0 / (2 * grid_size))\n        params = np.concatenate([centers.flatten(), radii])\n        p, _ = repair(params)\n        return p\n\n    # Island GA Parameters\n    n_islands = 4\n    pop_size = 15\n    islands = [[create_individual() for _ in range(pop_size)] for _ in range(n_islands)]\n    \n    for cycle in range(3): # Migration cycles\n        for i in range(n_islands):\n            # Evolution within island\n            for gen in range(10):\n                # Sort by fitness\n                islands[i].sort(key=lambda p: np.sum(p[2*n_circles:]), reverse=True)\n                # Simple mutation on top performers\n                for j in range(5, pop_size):\n                    parent = islands[i][np.random.randint(0, 5)]\n                    child = parent + np.random.normal(0, 0.01, len(parent))\n                    islands[i][j], _ = repair(child)\n        \n        # Migration\n        for i in range(n_islands):\n            next_island = (i + 1) % n_islands\n            islands[next_island][-1] = islands[i][0] # Move best to next island's worst\n\n    # Final intensive optimization\n    all_candidates = [ind for island in islands for ind in island]\n    all_candidates.sort(key=lambda p: np.sum(p[2*n_circles:]), reverse=True)\n    \n    best_params = all_candidates[0]\n    bounds = [(0, 1)] * (2 * n_circles) + [(0.001, 0.5)] * n_circles\n    res = minimize(get_sum_radii, best_params, method='SLSQP',\n                   constraints={'type': 'ineq', 'fun': constraints},\n                   bounds=bounds, options={'maxiter': 200, 'ftol': 1e-9})\n    \n    final_params = res.x\n    centers = final_params[:2*n_circles].reshape((n_circles, 2))\n    radii = final_params[2*n_circles:]\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-30T19:51:38.482319",
  "cost_data": null,
  "model_config": {
    "model": "google/gemini-3-flash-preview",
    "temperature": 0.6
  }
}