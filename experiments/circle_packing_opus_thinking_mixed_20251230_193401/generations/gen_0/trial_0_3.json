{
  "trial_id": "trial_0_3",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    \n    # Initial guess: place circles in a grid pattern\n    grid_size = int(np.ceil(np.sqrt(n)))\n    initial_centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        initial_centers.append([x, y])\n    initial_centers = np.array(initial_centers)\n    \n    # Initial radii: small uniform values\n    initial_radii = np.ones(n) * 0.05\n    \n    # Combine into single decision vector\n    x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n    \n    # Objective: maximize sum of radii = minimize negative sum\n    def objective(x):\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    # Constraints\n    constraints = []\n    \n    # Boundary constraints: x - r >= 0, x + r <= 1, y - r >= 0, y + r <= 1\n    for i in range(n):\n        # x - r >= 0\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: x[2*i] - x[2*n + i]\n        })\n        # x + r <= 1\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: 1 - x[2*i] - x[2*n + i]\n        })\n        # y - r >= 0\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: x[2*i + 1] - x[2*n + i]\n        })\n        # y + r <= 1\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: 1 - x[2*i + 1] - x[2*n + i]\n        })\n    \n    # Non-overlap constraints: distance >= sum of radii\n    for i in range(n):\n        for j in range(i + 1, n):\n            def non_overlap(x, i=i, j=j):\n                xi, yi = x[2*i], x[2*i + 1]\n                xj, yj = x[2*j], x[2*j + 1]\n                ri, rj = x[2*n + i], x[2*n + j]\n                dist_sq = (xi - xj)**2 + (yi - yj)**2\n                return dist_sq - (ri + rj)**2\n            \n            constraints.append({\n                'type': 'ineq',\n                'fun': non_overlap\n            })\n    \n    # Bounds: radii >= 0, centers in [0, 1]\n    bounds = []\n    for i in range(n):\n        bounds.append((0, 1))  # x\n        bounds.append((0, 1))  # y\n    for i in range(n):\n        bounds.append((0, 0.5))  # r (max possible radius is 0.5)\n    \n    # Optimize\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': 2000, 'ftol': 1e-9}\n    )\n    \n    # Extract solution\n    solution = result.x\n    centers = solution[:2*n].reshape(n, 2)\n    radii = solution[2*n:]\n    sum_radii = np.sum(radii)\n    \n    # Try multiple random restarts to improve solution\n    best_sum = sum_radii\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    \n    for trial in range(5):\n        # Random initialization with some structure\n        np.random.seed(trial)\n        init_centers = np.random.rand(n, 2) * 0.8 + 0.1\n        init_radii = np.random.rand(n) * 0.05 + 0.02\n        x0_trial = np.concatenate([init_centers.flatten(), init_radii])\n        \n        result_trial = minimize(\n            objective,\n            x0_trial,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 2000, 'ftol': 1e-9}\n        )\n        \n        if result_trial.success:\n            solution_trial = result_trial.x\n            radii_trial = solution_trial[2*n:]\n            sum_trial = np.sum(radii_trial)\n            \n            if sum_trial > best_sum:\n                best_sum = sum_trial\n                best_centers = solution_trial[:2*n].reshape(n, 2)\n                best_radii = radii_trial\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.591254382831514,
    "eval_time": 22.934849977493286,
    "error": null
  },
  "prompt": "Pack 26 circles into a unit square [0,1]x[0,1] to maximize sum of radii.\n\nUse SCIPY OPTIMIZATION with SLSQP or similar:\n1. Decision variables: 26 centers (x,y) and 26 radii = 78 variables\n2. Objective: maximize sum(radii)\n3. Constraints: r >= 0, x-r >= 0, x+r <= 1, y-r >= 0, y+r <= 1\n4. Constraint: for all i<j: (xi-xj)^2 + (yi-yj)^2 >= (ri+rj)^2\n\nStart from good initial guess (e.g., grid). Return valid (centers, radii, sum_radii).\n\nCode format:\n```python\nimport numpy as np\n\ndef construct_packing():\n    # Your implementation\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    \n    # Initial guess: place circles in a grid pattern\n    grid_size = int(np.ceil(np.sqrt(n)))\n    initial_centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        initial_centers.append([x, y])\n    initial_centers = np.array(initial_centers)\n    \n    # Initial radii: small uniform values\n    initial_radii = np.ones(n) * 0.05\n    \n    # Combine into single decision vector\n    x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n    \n    # Objective: maximize sum of radii = minimize negative sum\n    def objective(x):\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    # Constraints\n    constraints = []\n    \n    # Boundary constraints: x - r >= 0, x + r <= 1, y - r >= 0, y + r <= 1\n    for i in range(n):\n        # x - r >= 0\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: x[2*i] - x[2*n + i]\n        })\n        # x + r <= 1\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: 1 - x[2*i] - x[2*n + i]\n        })\n        # y - r >= 0\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: x[2*i + 1] - x[2*n + i]\n        })\n        # y + r <= 1\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: 1 - x[2*i + 1] - x[2*n + i]\n        })\n    \n    # Non-overlap constraints: distance >= sum of radii\n    for i in range(n):\n        for j in range(i + 1, n):\n            def non_overlap(x, i=i, j=j):\n                xi, yi = x[2*i], x[2*i + 1]\n                xj, yj = x[2*j], x[2*j + 1]\n                ri, rj = x[2*n + i], x[2*n + j]\n                dist_sq = (xi - xj)**2 + (yi - yj)**2\n                return dist_sq - (ri + rj)**2\n            \n            constraints.append({\n                'type': 'ineq',\n                'fun': non_overlap\n            })\n    \n    # Bounds: radii >= 0, centers in [0, 1]\n    bounds = []\n    for i in range(n):\n        bounds.append((0, 1))  # x\n        bounds.append((0, 1))  # y\n    for i in range(n):\n        bounds.append((0, 0.5))  # r (max possible radius is 0.5)\n    \n    # Optimize\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': 2000, 'ftol': 1e-9}\n    )\n    \n    # Extract solution\n    solution = result.x\n    centers = solution[:2*n].reshape(n, 2)\n    radii = solution[2*n:]\n    sum_radii = np.sum(radii)\n    \n    # Try multiple random restarts to improve solution\n    best_sum = sum_radii\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    \n    for trial in range(5):\n        # Random initialization with some structure\n        np.random.seed(trial)\n        init_centers = np.random.rand(n, 2) * 0.8 + 0.1\n        init_radii = np.random.rand(n) * 0.05 + 0.02\n        x0_trial = np.concatenate([init_centers.flatten(), init_radii])\n        \n        result_trial = minimize(\n            objective,\n            x0_trial,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 2000, 'ftol': 1e-9}\n        )\n        \n        if result_trial.success:\n            solution_trial = result_trial.x\n            radii_trial = solution_trial[2*n:]\n            sum_trial = np.sum(radii_trial)\n            \n            if sum_trial > best_sum:\n                best_sum = sum_trial\n                best_centers = solution_trial[:2*n].reshape(n, 2)\n                best_radii = radii_trial\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-30T19:38:42.704392",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.5
  }
}