{
  "trial_id": "trial_0_12",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef construct_packing():\n    np.random.seed(42)\n    n = 26\n    \n    # Initialize with a perturbed grid layout\n    grid_size = int(np.ceil(np.sqrt(n)))\n    centers = []\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if len(centers) < n:\n                x = (i + 0.5) / grid_size + np.random.uniform(-0.05, 0.05)\n                y = (j + 0.5) / grid_size + np.random.uniform(-0.05, 0.05)\n                centers.append([x, y])\n    centers = np.array(centers[:n])\n    \n    # Clip to ensure centers are well within bounds\n    centers = np.clip(centers, 0.05, 0.95)\n    \n    def optimize_radii(centers):\n        \"\"\"Given fixed centers, find optimal radii via linear programming\"\"\"\n        n = len(centers)\n        \n        # Objective: maximize sum of radii = minimize -sum(r_i)\n        c = -np.ones(n)\n        \n        # Inequality constraints: A_ub @ r <= b_ub\n        A_ub = []\n        b_ub = []\n        \n        # Constraint 1: r_i <= distance to boundary for each circle\n        for i in range(n):\n            x, y = centers[i]\n            dist_to_boundary = min(x, 1-x, y, 1-y)\n            constraint = np.zeros(n)\n            constraint[i] = 1\n            A_ub.append(constraint)\n            b_ub.append(dist_to_boundary)\n        \n        # Constraint 2: r_i + r_j <= distance between centers for each pair\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraint = np.zeros(n)\n                constraint[i] = 1\n                constraint[j] = 1\n                A_ub.append(constraint)\n                b_ub.append(dist)\n        \n        A_ub = np.array(A_ub)\n        b_ub = np.array(b_ub)\n        \n        # Bounds: r_i >= 0\n        bounds = [(0, None) for _ in range(n)]\n        \n        # Solve linear program\n        result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if result.success:\n            return result.x, -result.fun\n        else:\n            return np.zeros(n), 0.0\n    \n    def objective(positions):\n        \"\"\"Objective function for position optimization\"\"\"\n        centers = positions.reshape(n, 2)\n        radii, sum_radii = optimize_radii(centers)\n        return -sum_radii  # Minimize negative sum = maximize sum\n    \n    # Iterative optimization: alternate between positions and radii\n    best_centers = centers.copy()\n    best_radii, best_sum = optimize_radii(best_centers)\n    \n    for iteration in range(5):\n        # Optimize positions\n        x0 = best_centers.flatten()\n        \n        # Bounds to keep centers inside [0.02, 0.98]\n        bounds = [(0.02, 0.98) for _ in range(2*n)]\n        \n        result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds,\n                         options={'maxiter': 100, 'ftol': 1e-6})\n        \n        if result.success:\n            new_centers = result.x.reshape(n, 2)\n            new_radii, new_sum = optimize_radii(new_centers)\n            \n            if new_sum > best_sum:\n                best_centers = new_centers\n                best_radii = new_radii\n                best_sum = new_sum\n    \n    # Final radius optimization\n    radii, sum_radii = optimize_radii(best_centers)\n    \n    # Verify constraints\n    for i in range(n):\n        x, y = best_centers[i]\n        r = radii[i]\n        assert x - r >= -1e-6 and x + r <= 1 + 1e-6\n        assert y - r >= -1e-6 and y + r <= 1 + 1e-6\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(best_centers[i] - best_centers[j])\n            assert dist >= radii[i] + radii[j] - 1e-6\n    \n    return best_centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.286536543857427,
    "eval_time": 11.083987951278687,
    "error": null
  },
  "prompt": "Pack 26 circles into a unit square [0,1]x[0,1] to maximize sum of radii.\n\nFocus on RADIUS OPTIMIZATION given fixed positions:\n1. Create a good arrangement of 26 center positions (e.g., perturbed grid, hex pattern)\n2. Given fixed centers, finding optimal radii is a LINEAR PROGRAM:\n   - maximize sum(r_i)\n   - subject to: r_i <= dist_to_boundary for each i\n   - subject to: r_i + r_j <= dist(i,j) for each pair\n3. Use scipy.optimize.linprog\n4. Then iterate: optimize positions, then radii\n\nReturn valid (centers, radii, sum_radii).\n\nCode format:\n```python\nimport numpy as np\n\ndef construct_packing():\n    # Your implementation\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef construct_packing():\n    np.random.seed(42)\n    n = 26\n    \n    # Initialize with a perturbed grid layout\n    grid_size = int(np.ceil(np.sqrt(n)))\n    centers = []\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if len(centers) < n:\n                x = (i + 0.5) / grid_size + np.random.uniform(-0.05, 0.05)\n                y = (j + 0.5) / grid_size + np.random.uniform(-0.05, 0.05)\n                centers.append([x, y])\n    centers = np.array(centers[:n])\n    \n    # Clip to ensure centers are well within bounds\n    centers = np.clip(centers, 0.05, 0.95)\n    \n    def optimize_radii(centers):\n        \"\"\"Given fixed centers, find optimal radii via linear programming\"\"\"\n        n = len(centers)\n        \n        # Objective: maximize sum of radii = minimize -sum(r_i)\n        c = -np.ones(n)\n        \n        # Inequality constraints: A_ub @ r <= b_ub\n        A_ub = []\n        b_ub = []\n        \n        # Constraint 1: r_i <= distance to boundary for each circle\n        for i in range(n):\n            x, y = centers[i]\n            dist_to_boundary = min(x, 1-x, y, 1-y)\n            constraint = np.zeros(n)\n            constraint[i] = 1\n            A_ub.append(constraint)\n            b_ub.append(dist_to_boundary)\n        \n        # Constraint 2: r_i + r_j <= distance between centers for each pair\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraint = np.zeros(n)\n                constraint[i] = 1\n                constraint[j] = 1\n                A_ub.append(constraint)\n                b_ub.append(dist)\n        \n        A_ub = np.array(A_ub)\n        b_ub = np.array(b_ub)\n        \n        # Bounds: r_i >= 0\n        bounds = [(0, None) for _ in range(n)]\n        \n        # Solve linear program\n        result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if result.success:\n            return result.x, -result.fun\n        else:\n            return np.zeros(n), 0.0\n    \n    def objective(positions):\n        \"\"\"Objective function for position optimization\"\"\"\n        centers = positions.reshape(n, 2)\n        radii, sum_radii = optimize_radii(centers)\n        return -sum_radii  # Minimize negative sum = maximize sum\n    \n    # Iterative optimization: alternate between positions and radii\n    best_centers = centers.copy()\n    best_radii, best_sum = optimize_radii(best_centers)\n    \n    for iteration in range(5):\n        # Optimize positions\n        x0 = best_centers.flatten()\n        \n        # Bounds to keep centers inside [0.02, 0.98]\n        bounds = [(0.02, 0.98) for _ in range(2*n)]\n        \n        result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds,\n                         options={'maxiter': 100, 'ftol': 1e-6})\n        \n        if result.success:\n            new_centers = result.x.reshape(n, 2)\n            new_radii, new_sum = optimize_radii(new_centers)\n            \n            if new_sum > best_sum:\n                best_centers = new_centers\n                best_radii = new_radii\n                best_sum = new_sum\n    \n    # Final radius optimization\n    radii, sum_radii = optimize_radii(best_centers)\n    \n    # Verify constraints\n    for i in range(n):\n        x, y = best_centers[i]\n        r = radii[i]\n        assert x - r >= -1e-6 and x + r <= 1 + 1e-6\n        assert y - r >= -1e-6 and y + r <= 1 + 1e-6\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(best_centers[i] - best_centers[j])\n            assert dist >= radii[i] + radii[j] - 1e-6\n    \n    return best_centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-30T19:38:39.034623",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.4
  }
}