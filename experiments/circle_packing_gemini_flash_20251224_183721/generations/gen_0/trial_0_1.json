{
  "trial_id": "trial_0_1",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using a greedy\n    stochastic approach. For each circle, it samples potential positions and\n    selects the one that allows for the largest possible radius given constraints.\n    \"\"\"\n    n_circles = 26\n    n_samples = 1000\n    n_iterations = 20\n    \n    best_sum_radii = -1\n    best_centers = None\n    best_radii = None\n\n    for _ in range(n_iterations):\n        current_centers = []\n        current_radii = []\n        \n        for i in range(n_circles):\n            best_r_for_this_circle = -1\n            best_pos_for_this_circle = None\n            \n            # Sample random points in the unit square\n            samples = np.random.rand(n_samples, 2)\n            \n            for pos in samples:\n                # 1. Distance to boundaries (determines max possible r)\n                # x-min, x-max, y-min, y-max\n                r_bound = min(pos[0], 1.0 - pos[0], pos[1], 1.0 - pos[1])\n                \n                if r_bound <= 0:\n                    continue\n                \n                # 2. Distance to existing circles\n                r_overlap = float('inf')\n                valid_pos = True\n                for j in range(len(current_centers)):\n                    dist = np.linalg.norm(pos - current_centers[j])\n                    # dist must be >= r_new + r_existing\n                    # so r_new <= dist - r_existing\n                    r_possible = dist - current_radii[j]\n                    if r_possible <= 0:\n                        valid_pos = False\n                        break\n                    if r_possible < r_overlap:\n                        r_overlap = r_possible\n                \n                if not valid_pos:\n                    continue\n                \n                # The actual radius for this point is the minimum of boundary and overlap constraints\n                r_final = min(r_bound, r_overlap)\n                \n                if r_final > best_r_for_this_circle:\n                    best_r_for_this_circle = r_final\n                    best_pos_for_this_circle = pos\n            \n            # If we couldn't find a valid spot, add a zero-radius circle at a random spot\n            if best_pos_for_this_circle is None:\n                current_centers.append(np.array([0.5, 0.5]))\n                current_radii.append(0.0)\n            else:\n                current_centers.append(best_pos_for_this_circle)\n                current_radii.append(best_r_for_this_circle)\n        \n        total_r = sum(current_radii)\n        if total_r > best_sum_radii:\n            best_sum_radii = total_r\n            best_centers = np.array(current_centers)\n            best_radii = np.array(current_radii)\n\n    return best_centers, best_radii, best_sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.542258147296518,
    "target_ratio": 0.5852972096001966,
    "combined_score": 0.5852972096001966,
    "eval_time": 1.925307035446167,
    "error": null
  },
  "prompt": "Implement a greedy circle packing algorithm. \n    Place 26 circles one by one. For each circle, sample 1000 random valid positions and pick the one that allows for the largest possible radius given the existing circles and boundaries. \n    Repeat the whole process 20 times and return the best result.",
  "response": "```python\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using a greedy\n    stochastic approach. For each circle, it samples potential positions and\n    selects the one that allows for the largest possible radius given constraints.\n    \"\"\"\n    n_circles = 26\n    n_samples = 1000\n    n_iterations = 20\n    \n    best_sum_radii = -1\n    best_centers = None\n    best_radii = None\n\n    for _ in range(n_iterations):\n        current_centers = []\n        current_radii = []\n        \n        for i in range(n_circles):\n            best_r_for_this_circle = -1\n            best_pos_for_this_circle = None\n            \n            # Sample random points in the unit square\n            samples = np.random.rand(n_samples, 2)\n            \n            for pos in samples:\n                # 1. Distance to boundaries (determines max possible r)\n                # x-min, x-max, y-min, y-max\n                r_bound = min(pos[0], 1.0 - pos[0], pos[1], 1.0 - pos[1])\n                \n                if r_bound <= 0:\n                    continue\n                \n                # 2. Distance to existing circles\n                r_overlap = float('inf')\n                valid_pos = True\n                for j in range(len(current_centers)):\n                    dist = np.linalg.norm(pos - current_centers[j])\n                    # dist must be >= r_new + r_existing\n                    # so r_new <= dist - r_existing\n                    r_possible = dist - current_radii[j]\n                    if r_possible <= 0:\n                        valid_pos = False\n                        break\n                    if r_possible < r_overlap:\n                        r_overlap = r_possible\n                \n                if not valid_pos:\n                    continue\n                \n                # The actual radius for this point is the minimum of boundary and overlap constraints\n                r_final = min(r_bound, r_overlap)\n                \n                if r_final > best_r_for_this_circle:\n                    best_r_for_this_circle = r_final\n                    best_pos_for_this_circle = pos\n            \n            # If we couldn't find a valid spot, add a zero-radius circle at a random spot\n            if best_pos_for_this_circle is None:\n                current_centers.append(np.array([0.5, 0.5]))\n                current_radii.append(0.0)\n            else:\n                current_centers.append(best_pos_for_this_circle)\n                current_radii.append(best_r_for_this_circle)\n        \n        total_r = sum(current_radii)\n        if total_r > best_sum_radii:\n            best_sum_radii = total_r\n            best_centers = np.array(current_centers)\n            best_radii = np.array(current_radii)\n\n    return best_centers, best_radii, best_sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T18:37:39.560512",
  "cost_data": null
}