{
  "trial_id": "trial_5_12",
  "generation": 5,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    n = 26\n    # 1. Initial Guess: Grid-like placement with small random perturbations\n    # A 5x5 grid uses 25 circles; we add one more.\n    grid_size = 6\n    x = np.linspace(0.1, 0.9, grid_size)\n    y = np.linspace(0.1, 0.9, grid_size)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.ravel()[:n], yv.ravel()[:n]], axis=1)\n    radii = np.full(n, 0.08)\n    \n    # Iterative Linear Programming (SLP)\n    iterations = 20\n    step_size = 0.05 # Trust region for center movement\n    \n    for _ in range(iterations):\n        # Variables for LP: [dx1, dy1, dr1, dx2, dy2, dr2, ..., dxn, dyn, drn]\n        # Total variables: 3 * n\n        num_vars = 3 * n\n        \n        # Objective: Maximize sum(r_i + dr_i) => Minimize sum(-dr_i)\n        c = np.zeros(num_vars)\n        c[2::3] = -1.0\n        \n        A_ub = []\n        b_ub = []\n        \n        # Constraints:\n        # 1. Non-overlap: dist(Ci, Cj) >= ri + rj\n        # Linearization: d0 + (grad_x_i * dxi + grad_y_i * dyi + grad_x_j * dxj + grad_y_j * dyj) >= ri + dri + rj + drj\n        for i in range(n):\n            for j in range(i + 1, n):\n                d_vec = centers[i] - centers[j]\n                d0 = np.linalg.norm(d_vec)\n                if d0 < 1e-9: d0 = 1e-9 # Avoid division by zero\n                \n                grad_i = d_vec / d0\n                grad_j = -d_vec / d0\n                \n                # -grad_i*dxi - grad_j*dxj + dri + drj <= d0 - ri - rj\n                row = np.zeros(num_vars)\n                row[3*i] = -grad_i[0]\n                row[3*i+1] = -grad_i[1]\n                row[3*i+2] = 1.0\n                row[3*j] = -grad_j[0]\n                row[3*j+1] = -grad_j[1]\n                row[3*j+2] = 1.0\n                A_ub.append(row)\n                b_ub.append(d0 - radii[i] - radii[j])\n        \n        # 2. Boundary: 0 + ri + dri <= xi + dxi <= 1 - ri - dri\n        # (a) ri + dri - dxi <= xi  => -dxi + dri <= xi - ri\n        # (b) xi + dxi + ri + dri <= 1 => dxi + dri <= 1 - xi - ri\n        for i in range(n):\n            # Left/Bottom\n            row_l = np.zeros(num_vars)\n            row_l[3*i] = -1.0\n            row_l[3*i+2] = 1.0\n            A_ub.append(row_l)\n            b_ub.append(centers[i, 0] - radii[i])\n            \n            row_b = np.zeros(num_vars)\n            row_b[3*i+1] = -1.0\n            row_b[3*i+2] = 1.0\n            A_ub.append(row_b)\n            b_ub.append(centers[i, 1] - radii[i])\n            \n            # Right/Top\n            row_r = np.zeros(num_vars)\n            row_r[3*i] = 1.0\n            row_r[3*i+2] = 1.0\n            A_ub.append(row_r)\n            b_ub.append(1.0 - centers[i, 0] - radii[i])\n            \n            row_t = np.zeros(num_vars)\n            row_t[3*i+1] = 1.0\n            row_t[3*i+2] = 1.0\n            A_ub.append(row_t)\n            b_ub.append(1.0 - centers[i, 1] - radii[i])\n\n        # Bounds for delta variables\n        bounds = []\n        for i in range(n):\n            bounds.append((-step_size, step_size)) # dx\n            bounds.append((-step_size, step_size)) # dy\n            bounds.append((-radii[i], 0.5))        # dr (ensure r + dr >= 0)\n            \n        res = linprog(c, A_ub=np.array(A_ub), b_ub=np.array(b_ub), bounds=bounds, method='highs')\n        \n        if res.success:\n            delta = res.x.reshape((n, 3))\n            centers += delta[:, :2]\n            radii += delta[:, 2]\n            # Clip centers to unit square to maintain feasibility\n            centers = np.clip(centers, 0, 1)\n            radii = np.maximum(radii, 0)\n            step_size *= 0.95 # Decay trust region\n        else:\n            break\n\n    # Final sanity check: Adjust radii to strictly satisfy non-overlap and boundary\n    for i in range(n):\n        # Boundary constraint\n        radii[i] = min(radii[i], centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n        for j in range(i):\n            # Pairwise constraint\n            d = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > d:\n                # Reduce both proportionally\n                reduction = (radii[i] + radii[j] - d) / 2\n                radii[i] -= reduction + 1e-9\n                radii[j] -= reduction + 1e-9\n    \n    radii = np.maximum(radii, 0)\n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.599978022879872,
    "target_ratio": 0.9867089270891355,
    "combined_score": 0.9867089270891355,
    "eval_time": 0.25818800926208496,
    "error": null
  },
  "prompt": "Approximate the circle packing problem as a sequence of Linear Programming problems by linearizing the non-overlap constraints around the current trial_4_0 solution. Iterate 20 times.",
  "response": "To maximize the sum of radii for 26 circles in a unit square, we can employ a Sequential Linear Programming (SLP) approach. We linearize the non-overlap constraints ($d_{ij} \\ge r_i + r_j$) using a first-order Taylor expansion around the current centers. By iteratively solving these LPs with a trust-region-like constraint on center movement, we can converge to a high-quality local optimum.\n\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    n = 26\n    # 1. Initial Guess: Grid-like placement with small random perturbations\n    # A 5x5 grid uses 25 circles; we add one more.\n    grid_size = 6\n    x = np.linspace(0.1, 0.9, grid_size)\n    y = np.linspace(0.1, 0.9, grid_size)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.ravel()[:n], yv.ravel()[:n]], axis=1)\n    radii = np.full(n, 0.08)\n    \n    # Iterative Linear Programming (SLP)\n    iterations = 20\n    step_size = 0.05 # Trust region for center movement\n    \n    for _ in range(iterations):\n        # Variables for LP: [dx1, dy1, dr1, dx2, dy2, dr2, ..., dxn, dyn, drn]\n        # Total variables: 3 * n\n        num_vars = 3 * n\n        \n        # Objective: Maximize sum(r_i + dr_i) => Minimize sum(-dr_i)\n        c = np.zeros(num_vars)\n        c[2::3] = -1.0\n        \n        A_ub = []\n        b_ub = []\n        \n        # Constraints:\n        # 1. Non-overlap: dist(Ci, Cj) >= ri + rj\n        # Linearization: d0 + (grad_x_i * dxi + grad_y_i * dyi + grad_x_j * dxj + grad_y_j * dyj) >= ri + dri + rj + drj\n        for i in range(n):\n            for j in range(i + 1, n):\n                d_vec = centers[i] - centers[j]\n                d0 = np.linalg.norm(d_vec)\n                if d0 < 1e-9: d0 = 1e-9 # Avoid division by zero\n                \n                grad_i = d_vec / d0\n                grad_j = -d_vec / d0\n                \n                # -grad_i*dxi - grad_j*dxj + dri + drj <= d0 - ri - rj\n                row = np.zeros(num_vars)\n                row[3*i] = -grad_i[0]\n                row[3*i+1] = -grad_i[1]\n                row[3*i+2] = 1.0\n                row[3*j] = -grad_j[0]\n                row[3*j+1] = -grad_j[1]\n                row[3*j+2] = 1.0\n                A_ub.append(row)\n                b_ub.append(d0 - radii[i] - radii[j])\n        \n        # 2. Boundary: 0 + ri + dri <= xi + dxi <= 1 - ri - dri\n        # (a) ri + dri - dxi <= xi  => -dxi + dri <= xi - ri\n        # (b) xi + dxi + ri + dri <= 1 => dxi + dri <= 1 - xi - ri\n        for i in range(n):\n            # Left/Bottom\n            row_l = np.zeros(num_vars)\n            row_l[3*i] = -1.0\n            row_l[3*i+2] = 1.0\n            A_ub.append(row_l)\n            b_ub.append(centers[i, 0] - radii[i])\n            \n            row_b = np.zeros(num_vars)\n            row_b[3*i+1] = -1.0\n            row_b[3*i+2] = 1.0\n            A_ub.append(row_b)\n            b_ub.append(centers[i, 1] - radii[i])\n            \n            # Right/Top\n            row_r = np.zeros(num_vars)\n            row_r[3*i] = 1.0\n            row_r[3*i+2] = 1.0\n            A_ub.append(row_r)\n            b_ub.append(1.0 - centers[i, 0] - radii[i])\n            \n            row_t = np.zeros(num_vars)\n            row_t[3*i+1] = 1.0\n            row_t[3*i+2] = 1.0\n            A_ub.append(row_t)\n            b_ub.append(1.0 - centers[i, 1] - radii[i])\n\n        # Bounds for delta variables\n        bounds = []\n        for i in range(n):\n            bounds.append((-step_size, step_size)) # dx\n            bounds.append((-step_size, step_size)) # dy\n            bounds.append((-radii[i], 0.5))        # dr (ensure r + dr >= 0)\n            \n        res = linprog(c, A_ub=np.array(A_ub), b_ub=np.array(b_ub), bounds=bounds, method='highs')\n        \n        if res.success:\n            delta = res.x.reshape((n, 3))\n            centers += delta[:, :2]\n            radii += delta[:, 2]\n            # Clip centers to unit square to maintain feasibility\n            centers = np.clip(centers, 0, 1)\n            radii = np.maximum(radii, 0)\n            step_size *= 0.95 # Decay trust region\n        else:\n            break\n\n    # Final sanity check: Adjust radii to strictly satisfy non-overlap and boundary\n    for i in range(n):\n        # Boundary constraint\n        radii[i] = min(radii[i], centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n        for j in range(i):\n            # Pairwise constraint\n            d = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > d:\n                # Reduce both proportionally\n                reduction = (radii[i] + radii[j] - d) / 2\n                radii[i] -= reduction + 1e-9\n                radii[j] -= reduction + 1e-9\n    \n    radii = np.maximum(radii, 0)\n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "To maximize the sum of radii for 26 circles in a unit square, we can employ a Sequential Linear Programming (SLP) approach. We linearize the non-overlap constraints ($d_{ij} \\ge r_i + r_j$) using a first-order Taylor expansion around the current centers. By iteratively solving these LPs with a trust-region-like constraint on center movement, we can converge to a high-quality local optimum.",
  "timestamp": "2025-12-24T18:41:42.996722",
  "cost_data": null
}