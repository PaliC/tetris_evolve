{
  "trial_id": "trial_3_14",
  "generation": 3,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Optimizes the packing of 26 circles in a unit square to maximize the sum of radii.\n    Incorporates multiple initialization strategies and a polishing step.\n    \"\"\"\n    n = 26\n\n    def get_initial_guesses():\n        seeds = []\n        # Strategy 1: Grid-like with jitter (trial_2_1 style)\n        grid_size = int(np.ceil(np.sqrt(n)))\n        x, y = np.meshgrid(np.linspace(0.1, 0.9, grid_size), np.linspace(0.1, 0.9, grid_size))\n        pts = np.column_stack([x.ravel(), y.ravel()])[:n]\n        seeds.append((pts, np.full(n, 0.05)))\n\n        # Strategy 2: Random Uniform (trial_2_2 style)\n        seeds.append((np.random.rand(n, 2) * 0.8 + 0.1, np.full(n, 0.04)))\n\n        # Strategy 3: Concentric/Circular (trial_2_3 style)\n        theta = np.linspace(0, 2*np.pi, n, endpoint=False)\n        pts_circ = 0.5 + 0.35 * np.column_stack([np.cos(theta), np.sin(theta)])\n        seeds.append((pts_circ, np.full(n, 0.03)))\n        \n        return seeds\n\n    def objective(params):\n        # We want to maximize sum(r), so minimize -sum(r)\n        r = params[2*n:]\n        return -np.sum(r)\n\n    def constraints(params):\n        x = params[:n]\n        y = params[n:2*n]\n        r = params[2*n:]\n        cons = []\n        \n        # Boundary constraints: x-r >= 0, x+r <= 1, y-r >= 0, y+r <= 1\n        cons.extend(x - r)\n        cons.extend(1.0 - (x + r))\n        cons.extend(y - r)\n        cons.extend(1.0 - (y + r))\n        \n        # Non-overlap constraints: dist(i, j) >= r_i + r_j\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx = x[i] - x[j]\n                dy = y[i] - y[j]\n                dist_sq = dx*dx + dy*dy\n                sum_r = r[i] + r[j]\n                cons.append(dist_sq - sum_r*sum_r)\n        \n        return np.array(cons)\n\n    best_params = None\n    best_sum = -1\n\n    # Run optimization for each seed\n    for pts, rs in get_initial_guesses():\n        init_params = np.concatenate([pts[:, 0], pts[:, 1], rs])\n        \n        # Bounds for x, y, r\n        bounds = [(0, 1)] * (2 * n) + [(0.001, 0.5)] * n\n        \n        res = minimize(\n            objective, \n            init_params, \n            method='SLSQP',\n            constraints={'type': 'ineq', 'fun': constraints},\n            bounds=bounds,\n            options={'maxiter': 100}\n        )\n        \n        if res.success or res.fun < 0:\n            current_sum = -res.fun\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_params = res.x\n\n    # Polishing Step: Shaking and Re-optimizing the best result\n    if best_params is not None:\n        # Slight jitter to escape local minima\n        best_params[:2*n] += np.random.normal(0, 0.001, 2*n)\n        res_polished = minimize(\n            objective, \n            best_params, \n            method='SLSQP',\n            constraints={'type': 'ineq', 'fun': constraints},\n            bounds=[(0, 1)] * (2 * n) + [(0.001, 0.5)] * n,\n            options={'maxiter': 150}\n        )\n        final_params = res_polished.x\n    else:\n        # Fallback to a simple grid if all else fails\n        final_params = init_params\n\n    # Extract final configuration\n    centers = np.column_stack([final_params[:n], final_params[n:2*n]])\n    radii = final_params[2*n:]\n    \n    # Final check: ensure radii are strictly valid (evaluator might be sensitive)\n    # Clip slightly to ensure boundary constraints are robust\n    for i in range(n):\n        radii[i] = min(radii[i], centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.5518056456338467,
    "target_ratio": 0.9684271899938698,
    "combined_score": 0.9684271899938698,
    "eval_time": 1.123939037322998,
    "error": null
  },
  "prompt": "Combine the initialization logic of trial_2_2, trial_2_3, and trial_2_1. Run a parallel optimization on all three and perform a final 'shaking' and 'polishing' step on the winner.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Optimizes the packing of 26 circles in a unit square to maximize the sum of radii.\n    Incorporates multiple initialization strategies and a polishing step.\n    \"\"\"\n    n = 26\n\n    def get_initial_guesses():\n        seeds = []\n        # Strategy 1: Grid-like with jitter (trial_2_1 style)\n        grid_size = int(np.ceil(np.sqrt(n)))\n        x, y = np.meshgrid(np.linspace(0.1, 0.9, grid_size), np.linspace(0.1, 0.9, grid_size))\n        pts = np.column_stack([x.ravel(), y.ravel()])[:n]\n        seeds.append((pts, np.full(n, 0.05)))\n\n        # Strategy 2: Random Uniform (trial_2_2 style)\n        seeds.append((np.random.rand(n, 2) * 0.8 + 0.1, np.full(n, 0.04)))\n\n        # Strategy 3: Concentric/Circular (trial_2_3 style)\n        theta = np.linspace(0, 2*np.pi, n, endpoint=False)\n        pts_circ = 0.5 + 0.35 * np.column_stack([np.cos(theta), np.sin(theta)])\n        seeds.append((pts_circ, np.full(n, 0.03)))\n        \n        return seeds\n\n    def objective(params):\n        # We want to maximize sum(r), so minimize -sum(r)\n        r = params[2*n:]\n        return -np.sum(r)\n\n    def constraints(params):\n        x = params[:n]\n        y = params[n:2*n]\n        r = params[2*n:]\n        cons = []\n        \n        # Boundary constraints: x-r >= 0, x+r <= 1, y-r >= 0, y+r <= 1\n        cons.extend(x - r)\n        cons.extend(1.0 - (x + r))\n        cons.extend(y - r)\n        cons.extend(1.0 - (y + r))\n        \n        # Non-overlap constraints: dist(i, j) >= r_i + r_j\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx = x[i] - x[j]\n                dy = y[i] - y[j]\n                dist_sq = dx*dx + dy*dy\n                sum_r = r[i] + r[j]\n                cons.append(dist_sq - sum_r*sum_r)\n        \n        return np.array(cons)\n\n    best_params = None\n    best_sum = -1\n\n    # Run optimization for each seed\n    for pts, rs in get_initial_guesses():\n        init_params = np.concatenate([pts[:, 0], pts[:, 1], rs])\n        \n        # Bounds for x, y, r\n        bounds = [(0, 1)] * (2 * n) + [(0.001, 0.5)] * n\n        \n        res = minimize(\n            objective, \n            init_params, \n            method='SLSQP',\n            constraints={'type': 'ineq', 'fun': constraints},\n            bounds=bounds,\n            options={'maxiter': 100}\n        )\n        \n        if res.success or res.fun < 0:\n            current_sum = -res.fun\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_params = res.x\n\n    # Polishing Step: Shaking and Re-optimizing the best result\n    if best_params is not None:\n        # Slight jitter to escape local minima\n        best_params[:2*n] += np.random.normal(0, 0.001, 2*n)\n        res_polished = minimize(\n            objective, \n            best_params, \n            method='SLSQP',\n            constraints={'type': 'ineq', 'fun': constraints},\n            bounds=[(0, 1)] * (2 * n) + [(0.001, 0.5)] * n,\n            options={'maxiter': 150}\n        )\n        final_params = res_polished.x\n    else:\n        # Fallback to a simple grid if all else fails\n        final_params = init_params\n\n    # Extract final configuration\n    centers = np.column_stack([final_params[:n], final_params[n:2*n]])\n    radii = final_params[2*n:]\n    \n    # Final check: ensure radii are strictly valid (evaluator might be sensitive)\n    # Clip slightly to ensure boundary constraints are robust\n    for i in range(n):\n        radii[i] = min(radii[i], centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T18:39:39.946079",
  "cost_data": null
}