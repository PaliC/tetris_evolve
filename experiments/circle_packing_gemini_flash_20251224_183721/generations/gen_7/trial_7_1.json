{
  "trial_id": "trial_7_1",
  "generation": 7,
  "parent_id": "trial_5_3",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Pack 26 circles into a unit square to maximize the sum of radii.\n    Uses a seeded grid layout followed by log-sum-exp smoothing with\n    annealed alpha parameters to slide circles into optimal positions.\n    \"\"\"\n    n = 26\n    \n    # 1. Seed: Start with a 5x5 grid + 1 extra circle\n    # This provides a stable topology close to the best known sum of radii.\n    side = 5\n    grid = np.linspace(0.1, 0.9, side)\n    xv, yv = np.meshgrid(grid, grid)\n    centers = np.vstack([xv.ravel(), yv.ravel()]).T\n    \n    # Add the 26th circle at a gap\n    centers = np.vstack([centers, [0.5, 0.5]])\n    \n    # Initial radii guess\n    radii = np.full(n, 1.0 / (2 * np.sqrt(n)))\n    \n    # Flatten parameters: [x1, y1, ..., xn, yn, r1, ..., rn]\n    params = np.concatenate([centers.flatten(), radii])\n\n    def objective(p):\n        # Maximize sum of radii\n        return -np.sum(p[2*n:])\n\n    def log_sum_exp_penalty(p, alpha):\n        pts = p[:2*n].reshape((n, 2))\n        rads = p[2*n:]\n        penalty = 0.0\n        \n        # Boundary constraints: rads[i] <= pts[i,0], etc.\n        # Penalty when rads[i] - pts[i,0] > 0\n        for i in range(n):\n            penalty += np.exp(alpha * (rads[i] - pts[i, 0]))\n            penalty += np.exp(alpha * (rads[i] - (1.0 - pts[i, 0])))\n            penalty += np.exp(alpha * (rads[i] - pts[i, 1]))\n            penalty += np.exp(alpha * (rads[i] - (1.0 - pts[i, 1])))\n            \n            # Pairwise overlap: rads[i] + rads[j] <= dist\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((pts[i] - pts[j])**2) + 1e-12)\n                penalty += np.exp(alpha * (rads[i] + rads[j] - dist))\n        \n        return (1.0 / alpha) * np.log(penalty)\n\n    # 2. Annealing the Smoothing Parameter\n    # We use a sequence of increasing alpha to harden the constraints\n    alphas = [100, 200, 400, 800, 1600]\n    \n    current_params = params\n    bounds = [(0, 1)] * (2 * n) + [(0.01, 0.2)] * n\n    \n    for alpha in alphas:\n        res = minimize(\n            lambda p: objective(p) + 0.5 * log_sum_exp_penalty(p, alpha),\n            current_params,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': 100, 'ftol': 1e-6}\n        )\n        current_params = res.x\n\n    # 3. Final Polish with Hard Constraints\n    def hard_constraints(p):\n        pts = p[:2*n].reshape((n, 2))\n        rads = p[2*n:]\n        cons = []\n        for i in range(n):\n            cons.extend([\n                pts[i, 0] - rads[i],\n                1.0 - pts[i, 0] - rads[i],\n                pts[i, 1] - rads[i],\n                1.0 - pts[i, 1] - rads[i]\n            ])\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(pts[i] - pts[j])\n                cons.append(dist - (rads[i] + rads[j]))\n        return np.array(cons)\n\n    res_final = minimize(\n        objective,\n        current_params,\n        method='SLSQP',\n        constraints={'type': 'ineq', 'fun': hard_constraints},\n        bounds=[(0, 1)] * (2 * n) + [(0, 0.2)] * n,\n        options={'maxiter': 100}\n    )\n\n    # Extract results\n    final_centers = res_final.x[:2*n].reshape((n, 2))\n    final_radii = res_final.x[2*n:]\n\n    # 4. Strict Feasibility Enforcement\n    # Ensure no circle is outside boundaries\n    for i in range(n):\n        final_radii[i] = min(final_radii[i], final_centers[i, 0], 1 - final_centers[i, 0], \n                             final_centers[i, 1], 1 - final_centers[i, 1])\n    \n    # Iterative shrink to eliminate any remaining micro-overlaps\n    for _ in range(10):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(final_centers[i] - final_centers[j])\n                if final_radii[i] + final_radii[j] > dist:\n                    overlap = (final_radii[i] + final_radii[j]) - dist\n                    # Shrink both proportional to their sizes\n                    ratio = final_radii[i] / (final_radii[i] + final_radii[j])\n                    final_radii[i] -= overlap * ratio + 1e-14\n                    final_radii[j] -= overlap * (1 - ratio) + 1e-14\n    \n    final_radii = np.maximum(final_radii, 0)\n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.2927375673720345,
    "target_ratio": 0.8701091337275274,
    "combined_score": 0.8701091337275274,
    "eval_time": 9.764060020446777,
    "error": null
  },
  "prompt": "Improve trial_5_3 by seeding it with the best known layout.\n    1. Start with the configuration from trial_4_0.\n    2. Apply the log-sum-exp smoothing from trial_5_3.\n    3. Use a very slow annealing of the alpha parameter (100, 200, 400, 800, 1600, 3200).\n    4. At each stage, use the previous result as the starting point.\n    5. This should help 'slide' the circles into better local optima that hard constraints might block.\n    \n    {{import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Constructs a circle packing for n=26 circles in a unit square \n    maximizing the sum of radii using multi-start local optimization.\n    Focuses on 4x6+2 and 5x5+1 topologies with jittered starts and pre-optimization.\n    \"\"\"\n    n = 26\n    best_sum = 0\n    best_centers = np.zeros((n, 2))\n    best_radii = np.zeros(n)\n\n    # Topologies specified: (cols, rows)\n    topologies = [(4, 6), (6, 4), (5, 5)]\n    num_jitters = 50\n    \n    for cols, rows in topologies:\n        for _ in range(num_jitters):\n            # 1. Generate jittered grid\n            x = np.linspace(0.1, 0.9, cols)\n            y = np.linspace(0.1, 0.9, rows)\n            xv, yv = np.meshgrid(x, y)\n            grid_pts = np.vstack([xv.ravel(), yv.ravel()]).T\n            \n            # Pad or trim to n\n            if len(grid_pts) < n:\n                rem = n - len(grid_pts)\n                extra = np.random.rand(rem, 2) * 0.8 + 0.1\n                centers_init = np.vstack([grid_pts, extra])\n            else:\n                centers_init = grid_pts[:n]\n            \n            # Add jitter\n            centers_init += (np.random.rand(n, 2) - 0.5) * 0.05\n            centers_init = np.clip(centers_init, 0.05, 0.95)\n            \n            # Initial radii guess\n            r_init = np.full(n, 1.0 / (2 * np.sqrt(n)))\n            params = np.hstack([centers_init.flatten(), r_init])\n\n            # 2. Pre-optimization: Quadratic Penalty (simplified)\n            # We optimize centers and radii to minimize overlap and boundary violations\n            def penalty_objective(p):\n                pts = p[:2*n].reshape(n, 2)\n                rads = p[2*n:]\n                overlap_penalty = 0\n                for i in range(n):\n                    # Boundary\n                    overlap_penalty += max(0, rads[i] - pts[i, 0])**2\n                    overlap_penalty += max(0, rads[i] - (1.0 - pts[i, 0]))**2\n                    overlap_penalty += max(0, rads[i] - pts[i, 1])**2\n                    overlap_penalty += max(0, rads[i] - (1.0 - pts[i, 1]))**2\n                    for j in range(i + 1, n):\n                        dist = np.sqrt(np.sum((pts[i] - pts[j])**2))\n                        overlap_penalty += max(0, (rads[i] + rads[j]) - dist)**2\n                return overlap_penalty - 0.01 * np.sum(rads)\n\n            # Quick pre-opt run\n            res_pre = minimize(penalty_objective, params, method='L-BFGS-B', \n                               bounds=[(0, 1)]*(2*n) + [(0, 0.2)]*n, \n                               options={'maxiter': 15})\n            params = res_pre.x\n\n            # 3. Main Optimization: SLSQP\n            def objective(p):\n                return -np.sum(p[2*n:])\n\n            def constraint_overlap(p):\n                pts = p[:2*n].reshape(n, 2)\n                rads = p[2*n:]\n                cons = []\n                for i in range(n):\n                    for j in range(i + 1, n):\n                        dist = np.sqrt(np.sum((pts[i] - pts[j])**2))\n                        cons.append(dist - (rads[i] + rads[j]))\n                return np.array(cons)\n\n            def constraint_boundary(p):\n                pts = p[:2*n].reshape(n, 2)\n                rads = p[2*n:]\n                cons = []\n                for i in range(n):\n                    cons.append(pts[i, 0] - rads[i])\n                    cons.append(1.0 - pts[i, 0] - rads[i])\n                    cons.append(pts[i, 1] - rads[i])\n                    cons.append(1.0 - pts[i, 1] - rads[i])\n                return np.array(cons)\n\n            cons = [{'type': 'ineq', 'fun': constraint_overlap},\n                    {'type': 'ineq', 'fun': constraint_boundary}]\n            \n            res = minimize(objective, params, method='SLSQP', constraints=cons,\n                           bounds=[(0, 1)]*(2*n) + [(0, 0.5)]*n,\n                           options={'maxiter': 30, 'ftol': 1e-3})\n\n            if -res.fun > best_sum:\n                best_sum = -res.fun\n                best_centers = res.x[:2*n].reshape(n, 2)\n                best_radii = res.x[2*n:]\n\n    # Final feasibility check and normalization\n    for i in range(n):\n        best_radii[i] = max(0, min(best_radii[i], best_centers[i, 0], 1 - best_centers[i, 0], \n                                  best_centers[i, 1], 1 - best_centers[i, 1]))\n    \n    # Iterative shrink to remove overlaps\n    for _ in range(5):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(best_centers[i] - best_centers[j])\n                if best_radii[i] + best_radii[j] > dist:\n                    shrink = dist / (best_radii[i] + best_radii[j] + 1e-12)\n                    best_radii[i] *= (shrink - 1e-10)\n                    best_radii[j] *= (shrink - 1e-10)\n\n    return best_centers, best_radii, np.sum(best_radii)\n\ndef run_packing():\n    return construct_packing()}}\n    {{import numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses Basin-Hopping with a smoothed Log-Sum-Exp penalty to handle \n    non-overlap constraints during the local search phase.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n\n    # 1. Initial Guess: Jittered grid\n    side = 5\n    grid_coords = np.linspace(0.1, 0.9, side)\n    xv, yv = np.meshgrid(grid_coords, grid_coords)\n    centers_init = np.vstack([xv.ravel(), yv.ravel()]).T\n    # Add 26th circle and jitter\n    centers_init = np.vstack([centers_init, [0.5, 0.5]])\n    centers_init += np.random.normal(0, 0.02, centers_init.shape)\n    radii_init = np.full(n, 0.05)\n    \n    x0 = np.concatenate([centers_init.flatten(), radii_init])\n\n    def get_objective(vars):\n        # Minimize -sum(radii)\n        return -np.sum(vars[2*n:])\n\n    def log_sum_exp_penalty(vars, alpha=50.0):\n        \"\"\"\n        Smooth approximation of max(0, (ri+rj) - dist).\n        As alpha increases, it approaches the hard constraint.\n        \"\"\"\n        pts = vars[:2*n].reshape((n, 2))\n        radii = vars[2*n:]\n        penalty = 0\n        \n        # Boundary constraints smoothing\n        for i in range(n):\n            # x-r >= 0 => r-x <= 0\n            penalty += np.exp(alpha * (radii[i] - pts[i, 0]))\n            penalty += np.exp(alpha * (radii[i] + pts[i, 0] - 1.0))\n            penalty += np.exp(alpha * (radii[i] - pts[i, 1]))\n            penalty += np.exp(alpha * (radii[i] + pts[i, 1] - 1.0))\n\n        # Overlap constraints smoothing\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((pts[i] - pts[j])**2) + 1e-9)\n                penalty += np.exp(alpha * (radii[i] + radii[j] - dist))\n        \n        return (1.0 / alpha) * np.log(penalty)\n\n    def hard_constraints(vars):\n        pts = vars[:2*n].reshape((n, 2))\n        radii = vars[2*n:]\n        cons = []\n        for i in range(n):\n            cons.extend([\n                pts[i, 0] - radii[i],\n                1.0 - pts[i, 0] - radii[i],\n                pts[i, 1] - radii[i],\n                1.0 - pts[i, 1] - radii[i]\n            ])\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(pts[i] - pts[j])\n                cons.append(dist - (radii[i] + radii[j]))\n        return np.array(cons)\n\n    # Combined local minimizer that uses smoothing then hard constraints\n    def custom_local_min(fun, x0, **kwargs):\n        # Phase 1: Smoothed optimization\n        res_smooth = minimize(\n            lambda v: fun(v) + 0.1 * log_sum_exp_penalty(v, alpha=30.0),\n            x0,\n            method='L-BFGS-B',\n            bounds=[(0, 1)] * (2 * n) + [(0, 0.2)] * n,\n            options={'maxiter': 30}\n        )\n        # Phase 2: Exact constraint enforcement\n        res_hard = minimize(\n            fun,\n            res_smooth.x,\n            method='SLSQP',\n            constraints={'type': 'ineq', 'fun': hard_constraints},\n            bounds=[(0, 1)] * (2 * n) + [(0, 0.2)] * n,\n            options={'maxiter': 40}\n        )\n        return res_hard\n\n    # 4. Basin-Hopping\n    res = basinhopping(\n        get_objective,\n        x0,\n        minimizer_kwargs={\"method\": custom_local_min},\n        niter=20,\n        stepsize=0.1\n    )\n\n    final_vars = res.x\n    centers = final_vars[:2*n].reshape((n, 2))\n    radii = final_vars[2*n:]\n\n    # Final Feasibility Adjustment\n    for _ in range(10):\n        for i in range(n):\n            # Clamp to square\n            radii[i] = min(radii[i], centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n            for j in range(n):\n                if i == j: continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d < radii[i] + radii[j]:\n                    # Adjust r to resolve overlap\n                    overlap = (radii[i] + radii[j] - d)\n                    radii[i] -= overlap / 2.0\n                    radii[j] -= overlap / 2.0\n        radii = np.maximum(radii, 0)\n\n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    return construct_packing()}}\n    ",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Pack 26 circles into a unit square to maximize the sum of radii.\n    Uses a seeded grid layout followed by log-sum-exp smoothing with\n    annealed alpha parameters to slide circles into optimal positions.\n    \"\"\"\n    n = 26\n    \n    # 1. Seed: Start with a 5x5 grid + 1 extra circle\n    # This provides a stable topology close to the best known sum of radii.\n    side = 5\n    grid = np.linspace(0.1, 0.9, side)\n    xv, yv = np.meshgrid(grid, grid)\n    centers = np.vstack([xv.ravel(), yv.ravel()]).T\n    \n    # Add the 26th circle at a gap\n    centers = np.vstack([centers, [0.5, 0.5]])\n    \n    # Initial radii guess\n    radii = np.full(n, 1.0 / (2 * np.sqrt(n)))\n    \n    # Flatten parameters: [x1, y1, ..., xn, yn, r1, ..., rn]\n    params = np.concatenate([centers.flatten(), radii])\n\n    def objective(p):\n        # Maximize sum of radii\n        return -np.sum(p[2*n:])\n\n    def log_sum_exp_penalty(p, alpha):\n        pts = p[:2*n].reshape((n, 2))\n        rads = p[2*n:]\n        penalty = 0.0\n        \n        # Boundary constraints: rads[i] <= pts[i,0], etc.\n        # Penalty when rads[i] - pts[i,0] > 0\n        for i in range(n):\n            penalty += np.exp(alpha * (rads[i] - pts[i, 0]))\n            penalty += np.exp(alpha * (rads[i] - (1.0 - pts[i, 0])))\n            penalty += np.exp(alpha * (rads[i] - pts[i, 1]))\n            penalty += np.exp(alpha * (rads[i] - (1.0 - pts[i, 1])))\n            \n            # Pairwise overlap: rads[i] + rads[j] <= dist\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((pts[i] - pts[j])**2) + 1e-12)\n                penalty += np.exp(alpha * (rads[i] + rads[j] - dist))\n        \n        return (1.0 / alpha) * np.log(penalty)\n\n    # 2. Annealing the Smoothing Parameter\n    # We use a sequence of increasing alpha to harden the constraints\n    alphas = [100, 200, 400, 800, 1600]\n    \n    current_params = params\n    bounds = [(0, 1)] * (2 * n) + [(0.01, 0.2)] * n\n    \n    for alpha in alphas:\n        res = minimize(\n            lambda p: objective(p) + 0.5 * log_sum_exp_penalty(p, alpha),\n            current_params,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': 100, 'ftol': 1e-6}\n        )\n        current_params = res.x\n\n    # 3. Final Polish with Hard Constraints\n    def hard_constraints(p):\n        pts = p[:2*n].reshape((n, 2))\n        rads = p[2*n:]\n        cons = []\n        for i in range(n):\n            cons.extend([\n                pts[i, 0] - rads[i],\n                1.0 - pts[i, 0] - rads[i],\n                pts[i, 1] - rads[i],\n                1.0 - pts[i, 1] - rads[i]\n            ])\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(pts[i] - pts[j])\n                cons.append(dist - (rads[i] + rads[j]))\n        return np.array(cons)\n\n    res_final = minimize(\n        objective,\n        current_params,\n        method='SLSQP',\n        constraints={'type': 'ineq', 'fun': hard_constraints},\n        bounds=[(0, 1)] * (2 * n) + [(0, 0.2)] * n,\n        options={'maxiter': 100}\n    )\n\n    # Extract results\n    final_centers = res_final.x[:2*n].reshape((n, 2))\n    final_radii = res_final.x[2*n:]\n\n    # 4. Strict Feasibility Enforcement\n    # Ensure no circle is outside boundaries\n    for i in range(n):\n        final_radii[i] = min(final_radii[i], final_centers[i, 0], 1 - final_centers[i, 0], \n                             final_centers[i, 1], 1 - final_centers[i, 1])\n    \n    # Iterative shrink to eliminate any remaining micro-overlaps\n    for _ in range(10):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(final_centers[i] - final_centers[j])\n                if final_radii[i] + final_radii[j] > dist:\n                    overlap = (final_radii[i] + final_radii[j]) - dist\n                    # Shrink both proportional to their sizes\n                    ratio = final_radii[i] / (final_radii[i] + final_radii[j])\n                    final_radii[i] -= overlap * ratio + 1e-14\n                    final_radii[j] -= overlap * (1 - ratio) + 1e-14\n    \n    final_radii = np.maximum(final_radii, 0)\n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T18:47:14.666255",
  "cost_data": null
}