{
  "trial_id": "trial_7_5",
  "generation": 7,
  "parent_id": "trial_6_3",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef construct_packing():\n    \"\"\"\n    Pack 26 circles into a unit square to maximize sum of radii.\n    Uses Basin-Hopping with a 'smart' displacement biased away from neighbors.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n\n    # 1. Initial configuration: 5x5 grid + 1 circle at center\n    side = 5\n    coords = np.linspace(0.15, 0.85, side)\n    xv, yv = np.meshgrid(coords, coords)\n    centers_init = np.vstack([xv.ravel(), yv.ravel()]).T\n    centers_init = np.vstack([centers_init, [0.5, 0.5]])\n    radii_init = np.full(n, 0.08)\n    \n    x0 = np.concatenate([centers_init.ravel(), radii_init])\n\n    def objective(params):\n        return -np.sum(params[2*n:])\n\n    def constraints(params):\n        pts = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        # Boundary constraints\n        c_boundary = np.concatenate([\n            pts[:, 0] - r,\n            1.0 - pts[:, 0] - r,\n            pts[:, 1] - r,\n            1.0 - pts[:, 1] - r\n        ])\n        # Overlap constraints\n        c_overlap = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((pts[i] - pts[j])**2))\n                c_overlap.append(dist - (r[i] + r[j]))\n        return np.concatenate([c_boundary, c_overlap])\n\n    class SmartDisplacement:\n        \"\"\"Biases displacement away from the nearest neighbor.\"\"\"\n        def __init__(self, stepsize=0.03):\n            self.stepsize = stepsize\n\n        def __call__(self, x):\n            pts = x[:2*n].reshape((n, 2))\n            radii = x[2*n:]\n            new_pts = pts.copy()\n            \n            for i in range(n):\n                # Find closest neighbor\n                dists = np.linalg.norm(pts - pts[i], axis=1)\n                dists[i] = np.inf\n                nearest_idx = np.argmin(dists)\n                \n                # Direction away from nearest neighbor\n                direction = pts[i] - pts[nearest_idx]\n                norm = np.linalg.norm(direction)\n                if norm > 0:\n                    direction /= norm\n                else:\n                    direction = np.random.randn(2)\n                \n                # Move with bias\n                move = direction * self.stepsize * np.random.rand()\n                # Add small random noise\n                move += np.random.normal(0, self.stepsize * 0.2, 2)\n                new_pts[i] += move\n            \n            # Keep centers within [0,1]\n            new_pts = np.clip(new_pts, 0, 1)\n            # Add small jitter to radii\n            new_radii = np.clip(radii + np.random.normal(0, 0.005, n), 0.001, 0.2)\n            return np.concatenate([new_pts.ravel(), new_radii])\n\n    # Local minimization step\n    minimizer_kwargs = {\n        \"method\": \"SLSQP\",\n        \"constraints\": {\"type\": \"ineq\", \"fun\": constraints},\n        \"bounds\": [(0, 1)] * (2 * n) + [(0.001, 0.2)] * n,\n        \"options\": {\"maxiter\": 50}\n    }\n\n    # Basin Hopping with smart displacement and low temperature\n    res = basinhopping(\n        objective,\n        x0,\n        minimizer_kwargs=minimizer_kwargs,\n        take_step=SmartDisplacement(stepsize=0.05),\n        niter=30,\n        T=0.01\n    )\n\n    final_params = res.x\n    centers = final_params[:2*n].reshape((n, 2))\n    radii = final_params[2*n:]\n\n    # Final feasibility enforcement (Strict)\n    for _ in range(20):\n        for i in range(n):\n            # Boundary check\n            radii[i] = min(radii[i], centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n            for j in range(n):\n                if i == j: continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d < radii[i] + radii[j]:\n                    # Shrink to remove overlap\n                    overlap = (radii[i] + radii[j] - d)\n                    shrink = (overlap / 2.0) + 1e-12\n                    radii[i] -= shrink\n                    radii[j] -= shrink\n        radii = np.maximum(radii, 0)\n\n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.6241194760367295,
    "target_ratio": 0.9958707688943945,
    "combined_score": 0.9958707688943945,
    "eval_time": 8.962096929550171,
    "error": null
  },
  "prompt": "Improve trial_6_3 by making the displacement 'smart'.\n    1. Use trial_4_0 as the base.\n    2. Instead of random Gaussian noise, the displacement should be biased towards moving circles away from their closest neighbors.\n    3. Run Basin Hopping for 30 iterations with a very low temperature.\n    \n    {{import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses a high-density 5x5+1 arrangement as a seed and optimizes using SLSQP.\n    The goal is to maximize the sum of radii.\n    \"\"\"\n    n = 26\n    \n    # 1. Initial configuration: 5x5 grid + 1 circle in the center or corner\n    # Grid spacing for 5x5 is roughly 0.2\n    x = np.linspace(0.1, 0.9, 5)\n    y = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(x, y)\n    centers_init = np.vstack([xv.ravel(), yv.ravel()]).T\n    # Add 26th circle at a likely gap\n    centers_init = np.vstack([centers_init, [0.5, 0.5]])\n    \n    # Initial radius guess\n    r_init = 1.0 / (2 * np.sqrt(n)) \n    radii_init = np.full(n, r_init)\n    \n    # Flatten for optimizer: [x0, y0, ..., xn, yn, r0, ..., rn]\n    initial_params = np.concatenate([centers_init.ravel(), radii_init])\n\n    def objective(params):\n        # Maximize sum(r) -> Minimize -sum(r)\n        return -np.sum(params[2*n:])\n\n    def constraints(params):\n        pts = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        c = []\n        \n        # Boundary constraints: center_i +/- r_i must be in [0, 1]\n        for i in range(n):\n            c.append(pts[i, 0] - r[i])          # x - r >= 0\n            c.append(1.0 - pts[i, 0] - r[i])    # x + r <= 1\n            c.append(pts[i, 1] - r[i])          # y - r >= 0\n            c.append(1.0 - pts[i, 1] - r[i])    # y + r <= 1\n            \n        # Non-overlap constraints: dist(i, j) >= r_i + r_j\n        # Vectorized implementation for speed\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx = pts[i, 0] - pts[j, 0]\n                dy = pts[i, 1] - pts[j, 1]\n                dist = np.sqrt(dx*dx + dy*dy)\n                c.append(dist - (r[i] + r[j]))\n        return np.array(c)\n\n    # Bounds: coordinates in [0, 1], radii in [0, 0.5]\n    bounds = [(0, 1)] * (2 * n) + [(0.001, 0.5)] * n\n\n    # Optimization using Sequential Least Squares Programming\n    res = minimize(\n        objective, \n        initial_params, \n        method='SLSQP', \n        bounds=bounds, \n        constraints={'type': 'ineq', 'fun': constraints},\n        options={'maxiter': 200, 'ftol': 1e-7}\n    )\n\n    final_params = res.x\n    centers = final_params[:2*n].reshape((n, 2))\n    radii = final_params[2*n:]\n\n    # --- Post-processing: Ensure strict feasibility ---\n    # 1. Force circles into square\n    for i in range(n):\n        radii[i] = min(radii[i], centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n    \n    # 2. Resolve overlaps by shrinking radii iteratively\n    for _ in range(10):\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d < radii[i] + radii[j]:\n                    # Proportional shrinkage\n                    overlap = (radii[i] + radii[j]) - d\n                    shrinkage = (overlap / 2.0) * 1.000001\n                    radii[i] -= shrinkage\n                    radii[j] -= shrinkage\n    \n    radii = np.maximum(radii, 0)\n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()}}\n    {{import numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses Basin-Hopping with a smoothed Log-Sum-Exp penalty to handle \n    non-overlap constraints during the local search phase.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n\n    # 1. Initial Guess: Jittered grid\n    side = 5\n    grid_coords = np.linspace(0.1, 0.9, side)\n    xv, yv = np.meshgrid(grid_coords, grid_coords)\n    centers_init = np.vstack([xv.ravel(), yv.ravel()]).T\n    # Add 26th circle and jitter\n    centers_init = np.vstack([centers_init, [0.5, 0.5]])\n    centers_init += np.random.normal(0, 0.02, centers_init.shape)\n    radii_init = np.full(n, 0.05)\n    \n    x0 = np.concatenate([centers_init.flatten(), radii_init])\n\n    def get_objective(vars):\n        # Minimize -sum(radii)\n        return -np.sum(vars[2*n:])\n\n    def log_sum_exp_penalty(vars, alpha=50.0):\n        \"\"\"\n        Smooth approximation of max(0, (ri+rj) - dist).\n        As alpha increases, it approaches the hard constraint.\n        \"\"\"\n        pts = vars[:2*n].reshape((n, 2))\n        radii = vars[2*n:]\n        penalty = 0\n        \n        # Boundary constraints smoothing\n        for i in range(n):\n            # x-r >= 0 => r-x <= 0\n            penalty += np.exp(alpha * (radii[i] - pts[i, 0]))\n            penalty += np.exp(alpha * (radii[i] + pts[i, 0] - 1.0))\n            penalty += np.exp(alpha * (radii[i] - pts[i, 1]))\n            penalty += np.exp(alpha * (radii[i] + pts[i, 1] - 1.0))\n\n        # Overlap constraints smoothing\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((pts[i] - pts[j])**2) + 1e-9)\n                penalty += np.exp(alpha * (radii[i] + radii[j] - dist))\n        \n        return (1.0 / alpha) * np.log(penalty)\n\n    def hard_constraints(vars):\n        pts = vars[:2*n].reshape((n, 2))\n        radii = vars[2*n:]\n        cons = []\n        for i in range(n):\n            cons.extend([\n                pts[i, 0] - radii[i],\n                1.0 - pts[i, 0] - radii[i],\n                pts[i, 1] - radii[i],\n                1.0 - pts[i, 1] - radii[i]\n            ])\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(pts[i] - pts[j])\n                cons.append(dist - (radii[i] + radii[j]))\n        return np.array(cons)\n\n    # Combined local minimizer that uses smoothing then hard constraints\n    def custom_local_min(fun, x0, **kwargs):\n        # Phase 1: Smoothed optimization\n        res_smooth = minimize(\n            lambda v: fun(v) + 0.1 * log_sum_exp_penalty(v, alpha=30.0),\n            x0,\n            method='L-BFGS-B',\n            bounds=[(0, 1)] * (2 * n) + [(0, 0.2)] * n,\n            options={'maxiter': 30}\n        )\n        # Phase 2: Exact constraint enforcement\n        res_hard = minimize(\n            fun,\n            res_smooth.x,\n            method='SLSQP',\n            constraints={'type': 'ineq', 'fun': hard_constraints},\n            bounds=[(0, 1)] * (2 * n) + [(0, 0.2)] * n,\n            options={'maxiter': 40}\n        )\n        return res_hard\n\n    # 4. Basin-Hopping\n    res = basinhopping(\n        get_objective,\n        x0,\n        minimizer_kwargs={\"method\": custom_local_min},\n        niter=20,\n        stepsize=0.1\n    )\n\n    final_vars = res.x\n    centers = final_vars[:2*n].reshape((n, 2))\n    radii = final_vars[2*n:]\n\n    # Final Feasibility Adjustment\n    for _ in range(10):\n        for i in range(n):\n            # Clamp to square\n            radii[i] = min(radii[i], centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n            for j in range(n):\n                if i == j: continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d < radii[i] + radii[j]:\n                    # Adjust r to resolve overlap\n                    overlap = (radii[i] + radii[j] - d)\n                    radii[i] -= overlap / 2.0\n                    radii[j] -= overlap / 2.0\n        radii = np.maximum(radii, 0)\n\n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    return construct_packing()}}\n    ",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef construct_packing():\n    \"\"\"\n    Pack 26 circles into a unit square to maximize sum of radii.\n    Uses Basin-Hopping with a 'smart' displacement biased away from neighbors.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n\n    # 1. Initial configuration: 5x5 grid + 1 circle at center\n    side = 5\n    coords = np.linspace(0.15, 0.85, side)\n    xv, yv = np.meshgrid(coords, coords)\n    centers_init = np.vstack([xv.ravel(), yv.ravel()]).T\n    centers_init = np.vstack([centers_init, [0.5, 0.5]])\n    radii_init = np.full(n, 0.08)\n    \n    x0 = np.concatenate([centers_init.ravel(), radii_init])\n\n    def objective(params):\n        return -np.sum(params[2*n:])\n\n    def constraints(params):\n        pts = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        # Boundary constraints\n        c_boundary = np.concatenate([\n            pts[:, 0] - r,\n            1.0 - pts[:, 0] - r,\n            pts[:, 1] - r,\n            1.0 - pts[:, 1] - r\n        ])\n        # Overlap constraints\n        c_overlap = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((pts[i] - pts[j])**2))\n                c_overlap.append(dist - (r[i] + r[j]))\n        return np.concatenate([c_boundary, c_overlap])\n\n    class SmartDisplacement:\n        \"\"\"Biases displacement away from the nearest neighbor.\"\"\"\n        def __init__(self, stepsize=0.03):\n            self.stepsize = stepsize\n\n        def __call__(self, x):\n            pts = x[:2*n].reshape((n, 2))\n            radii = x[2*n:]\n            new_pts = pts.copy()\n            \n            for i in range(n):\n                # Find closest neighbor\n                dists = np.linalg.norm(pts - pts[i], axis=1)\n                dists[i] = np.inf\n                nearest_idx = np.argmin(dists)\n                \n                # Direction away from nearest neighbor\n                direction = pts[i] - pts[nearest_idx]\n                norm = np.linalg.norm(direction)\n                if norm > 0:\n                    direction /= norm\n                else:\n                    direction = np.random.randn(2)\n                \n                # Move with bias\n                move = direction * self.stepsize * np.random.rand()\n                # Add small random noise\n                move += np.random.normal(0, self.stepsize * 0.2, 2)\n                new_pts[i] += move\n            \n            # Keep centers within [0,1]\n            new_pts = np.clip(new_pts, 0, 1)\n            # Add small jitter to radii\n            new_radii = np.clip(radii + np.random.normal(0, 0.005, n), 0.001, 0.2)\n            return np.concatenate([new_pts.ravel(), new_radii])\n\n    # Local minimization step\n    minimizer_kwargs = {\n        \"method\": \"SLSQP\",\n        \"constraints\": {\"type\": \"ineq\", \"fun\": constraints},\n        \"bounds\": [(0, 1)] * (2 * n) + [(0.001, 0.2)] * n,\n        \"options\": {\"maxiter\": 50}\n    }\n\n    # Basin Hopping with smart displacement and low temperature\n    res = basinhopping(\n        objective,\n        x0,\n        minimizer_kwargs=minimizer_kwargs,\n        take_step=SmartDisplacement(stepsize=0.05),\n        niter=30,\n        T=0.01\n    )\n\n    final_params = res.x\n    centers = final_params[:2*n].reshape((n, 2))\n    radii = final_params[2*n:]\n\n    # Final feasibility enforcement (Strict)\n    for _ in range(20):\n        for i in range(n):\n            # Boundary check\n            radii[i] = min(radii[i], centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n            for j in range(n):\n                if i == j: continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d < radii[i] + radii[j]:\n                    # Shrink to remove overlap\n                    overlap = (radii[i] + radii[j] - d)\n                    shrink = (overlap / 2.0) + 1e-12\n                    radii[i] -= shrink\n                    radii[j] -= shrink\n        radii = np.maximum(radii, 0)\n\n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T18:47:13.899851",
  "cost_data": null
}