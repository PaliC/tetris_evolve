{
  "trial_id": "trial_2_12",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    \n    # Initialize with a good starting configuration\n    # Use a grid-based initialization with some randomization\n    np.random.seed(42)\n    \n    # Create initial grid positions\n    grid_size = int(np.ceil(np.sqrt(n)))\n    centers_init = []\n    \n    for i in range(grid_size):\n        for j in range(grid_size):\n            if len(centers_init) < n:\n                x = (i + 0.5) / grid_size + np.random.uniform(-0.02, 0.02)\n                y = (j + 0.5) / grid_size + np.random.uniform(-0.02, 0.02)\n                centers_init.append([x, y])\n    \n    centers_init = np.array(centers_init[:n])\n    \n    # Initial radius estimate\n    r_init = 0.5 / grid_size * 0.8\n    radii_init = np.ones(n) * r_init\n    \n    # Pack into optimization vector: [x1, y1, x2, y2, ..., r1, r2, ...]\n    x0 = np.concatenate([centers_init.flatten(), radii_init])\n    \n    def objective(x):\n        radii = x[2*n:]\n        return -np.sum(radii)  # Maximize sum of radii\n    \n    def constraint_no_overlap(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        constraints = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.sqrt((centers[i,0] - centers[j,0])**2 + (centers[i,1] - centers[j,1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    def constraint_inside_box(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        constraints = []\n        for i in range(n):\n            constraints.append(centers[i,0] - radii[i])  # x - r >= 0\n            constraints.append(1 - centers[i,0] - radii[i])  # 1 - x - r >= 0\n            constraints.append(centers[i,1] - radii[i])  # y - r >= 0\n            constraints.append(1 - centers[i,1] - radii[i])  # 1 - y - r >= 0\n        return np.array(constraints)\n    \n    # Bounds\n    bounds = []\n    for i in range(n):\n        bounds.append((0.01, 0.99))  # x\n        bounds.append((0.01, 0.99))  # y\n    for i in range(n):\n        bounds.append((0.001, 0.5))  # r\n    \n    constraints = [\n        {'type': 'ineq', 'fun': constraint_no_overlap},\n        {'type': 'ineq', 'fun': constraint_inside_box}\n    ]\n    \n    # Multiple optimization attempts with different starting points\n    best_result = None\n    best_sum = 0\n    \n    for attempt in range(5):\n        if attempt > 0:\n            # Perturb initial positions\n            np.random.seed(42 + attempt * 10)\n            centers_init = []\n            for i in range(grid_size):\n                for j in range(grid_size):\n                    if len(centers_init) < n:\n                        x = (i + 0.5) / grid_size + np.random.uniform(-0.05, 0.05)\n                        y = (j + 0.5) / grid_size + np.random.uniform(-0.05, 0.05)\n                        x = np.clip(x, 0.05, 0.95)\n                        y = np.clip(y, 0.05, 0.95)\n                        centers_init.append([x, y])\n            centers_init = np.array(centers_init[:n])\n            x0 = np.concatenate([centers_init.flatten(), radii_init])\n        \n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 2000, 'ftol': 1e-9}\n        )\n        \n        if result.success or True:  # Accept even if not fully converged\n            current_sum = -result.fun\n            if current_sum > best_sum:\n                # Verify constraints\n                x = result.x\n                overlap_ok = np.all(constraint_no_overlap(x) >= -1e-6)\n                inside_ok = np.all(constraint_inside_box(x) >= -1e-6)\n                if overlap_ok and inside_ok:\n                    best_sum = current_sum\n                    best_result = result\n    \n    if best_result is not None:\n        x = best_result.x\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        sum_radii = np.sum(radii)\n        return centers, radii, sum_radii\n    \n    # Fallback: return initial configuration with small radii\n    return centers_init, radii_init * 0.5, np.sum(radii_init * 0.5)\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.5847116224874185,
    "eval_time": 2.6526389122009277,
    "error": null
  },
  "prompt": "Pack 26 circles to maximize sum of radii. Target: 2.636.\n\nAPPROACH: Use known optimal configurations from Packomania database.\n\nFor n=26 circles in a square, look up or approximate the known optimal positions. The optimal packing likely has a specific pattern that's been documented.\n\nTry to construct an initial configuration that matches known results, then refine with SLSQP.\n\nReturn code with:\n```python\nimport numpy as np\n\ndef construct_packing():\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    \n    # Initialize with a good starting configuration\n    # Use a grid-based initialization with some randomization\n    np.random.seed(42)\n    \n    # Create initial grid positions\n    grid_size = int(np.ceil(np.sqrt(n)))\n    centers_init = []\n    \n    for i in range(grid_size):\n        for j in range(grid_size):\n            if len(centers_init) < n:\n                x = (i + 0.5) / grid_size + np.random.uniform(-0.02, 0.02)\n                y = (j + 0.5) / grid_size + np.random.uniform(-0.02, 0.02)\n                centers_init.append([x, y])\n    \n    centers_init = np.array(centers_init[:n])\n    \n    # Initial radius estimate\n    r_init = 0.5 / grid_size * 0.8\n    radii_init = np.ones(n) * r_init\n    \n    # Pack into optimization vector: [x1, y1, x2, y2, ..., r1, r2, ...]\n    x0 = np.concatenate([centers_init.flatten(), radii_init])\n    \n    def objective(x):\n        radii = x[2*n:]\n        return -np.sum(radii)  # Maximize sum of radii\n    \n    def constraint_no_overlap(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        constraints = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.sqrt((centers[i,0] - centers[j,0])**2 + (centers[i,1] - centers[j,1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    def constraint_inside_box(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        constraints = []\n        for i in range(n):\n            constraints.append(centers[i,0] - radii[i])  # x - r >= 0\n            constraints.append(1 - centers[i,0] - radii[i])  # 1 - x - r >= 0\n            constraints.append(centers[i,1] - radii[i])  # y - r >= 0\n            constraints.append(1 - centers[i,1] - radii[i])  # 1 - y - r >= 0\n        return np.array(constraints)\n    \n    # Bounds\n    bounds = []\n    for i in range(n):\n        bounds.append((0.01, 0.99))  # x\n        bounds.append((0.01, 0.99))  # y\n    for i in range(n):\n        bounds.append((0.001, 0.5))  # r\n    \n    constraints = [\n        {'type': 'ineq', 'fun': constraint_no_overlap},\n        {'type': 'ineq', 'fun': constraint_inside_box}\n    ]\n    \n    # Multiple optimization attempts with different starting points\n    best_result = None\n    best_sum = 0\n    \n    for attempt in range(5):\n        if attempt > 0:\n            # Perturb initial positions\n            np.random.seed(42 + attempt * 10)\n            centers_init = []\n            for i in range(grid_size):\n                for j in range(grid_size):\n                    if len(centers_init) < n:\n                        x = (i + 0.5) / grid_size + np.random.uniform(-0.05, 0.05)\n                        y = (j + 0.5) / grid_size + np.random.uniform(-0.05, 0.05)\n                        x = np.clip(x, 0.05, 0.95)\n                        y = np.clip(y, 0.05, 0.95)\n                        centers_init.append([x, y])\n            centers_init = np.array(centers_init[:n])\n            x0 = np.concatenate([centers_init.flatten(), radii_init])\n        \n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 2000, 'ftol': 1e-9}\n        )\n        \n        if result.success or True:  # Accept even if not fully converged\n            current_sum = -result.fun\n            if current_sum > best_sum:\n                # Verify constraints\n                x = result.x\n                overlap_ok = np.all(constraint_no_overlap(x) >= -1e-6)\n                inside_ok = np.all(constraint_inside_box(x) >= -1e-6)\n                if overlap_ok and inside_ok:\n                    best_sum = current_sum\n                    best_result = result\n    \n    if best_result is not None:\n        x = best_result.x\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        sum_radii = np.sum(radii)\n        return centers, radii, sum_radii\n    \n    # Fallback: return initial configuration with small radii\n    return centers_init, radii_init * 0.5, np.sum(radii_init * 0.5)\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-31T14:02:19.784786",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-opus-4.5",
    "temperature": 0.4
  }
}