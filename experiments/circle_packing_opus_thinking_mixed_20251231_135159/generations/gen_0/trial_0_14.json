{
  "trial_id": "trial_0_14",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    \n    # Objective: maximize sum of radii = minimize negative sum of radii\n    def objective(x):\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    # Constraints\n    constraints = []\n    \n    # Non-overlap constraints: distance between centers >= sum of radii\n    for i in range(n):\n        for j in range(i+1, n):\n            def non_overlap(x, i=i, j=j):\n                cx_i, cy_i = x[2*i], x[2*i+1]\n                cx_j, cy_j = x[2*j], x[2*j+1]\n                r_i, r_j = x[2*n+i], x[2*n+j]\n                dist = np.sqrt((cx_i - cx_j)**2 + (cy_i - cy_j)**2)\n                return dist - (r_i + r_j)\n            constraints.append({'type': 'ineq', 'fun': non_overlap})\n    \n    # Boundary constraints: circles must be inside [0,1] x [0,1]\n    for i in range(n):\n        # Left boundary: cx - r >= 0\n        constraints.append({'type': 'ineq', 'fun': lambda x, i=i: x[2*i] - x[2*n+i]})\n        # Right boundary: cx + r <= 1\n        constraints.append({'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i] - x[2*n+i]})\n        # Bottom boundary: cy - r >= 0\n        constraints.append({'type': 'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]})\n        # Top boundary: cy + r <= 1\n        constraints.append({'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]})\n    \n    # Bounds: centers in [0,1], radii >= 0\n    bounds = [(0, 1) for _ in range(2*n)] + [(0, 0.5) for _ in range(n)]\n    \n    # Initial guess: grid layout with small radii\n    grid_size = int(np.ceil(np.sqrt(n)))\n    x0 = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        cx = (col + 0.5) / grid_size\n        cy = (row + 0.5) / grid_size\n        x0.extend([cx, cy])\n    \n    # Initial radii: small uniform values\n    initial_radius = 0.05\n    x0.extend([initial_radius] * n)\n    x0 = np.array(x0)\n    \n    # Optimize with multiple random restarts\n    best_result = None\n    best_value = float('inf')\n    \n    for trial in range(5):\n        if trial == 0:\n            x_init = x0\n        else:\n            # Random initialization\n            x_init = np.random.rand(3*n)\n            x_init[:2*n] = x_init[:2*n]  # centers in [0,1]\n            x_init[2*n:] = np.random.rand(n) * 0.1  # small radii\n        \n        result = minimize(\n            objective,\n            x_init,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-9}\n        )\n        \n        if result.fun < best_value:\n            best_value = result.fun\n            best_result = result\n    \n    # Extract solution\n    x_opt = best_result.x\n    centers = x_opt[:2*n].reshape((n, 2))\n    radii = x_opt[2*n:]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.5731050104852504,
    "eval_time": 17.12825608253479,
    "error": null
  },
  "prompt": "Pack 26 circles into a unit square [0,1]x[0,1] to maximize sum of radii.\n\nConstraints:\n- All circles must be entirely inside the unit square\n- No two circles may overlap\n- All radii must be non-negative\n\nApproach: SCIPY MINIMIZE with SLSQP. Use scipy.optimize.minimize with the SLSQP method which handles inequality constraints directly. Formulate non-overlap and boundary constraints explicitly. Start from a grid initialization.\n\nReturn code with:\n```python\nimport numpy as np\n\ndef construct_packing():\n    # Your implementation\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    \n    # Objective: maximize sum of radii = minimize negative sum of radii\n    def objective(x):\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    # Constraints\n    constraints = []\n    \n    # Non-overlap constraints: distance between centers >= sum of radii\n    for i in range(n):\n        for j in range(i+1, n):\n            def non_overlap(x, i=i, j=j):\n                cx_i, cy_i = x[2*i], x[2*i+1]\n                cx_j, cy_j = x[2*j], x[2*j+1]\n                r_i, r_j = x[2*n+i], x[2*n+j]\n                dist = np.sqrt((cx_i - cx_j)**2 + (cy_i - cy_j)**2)\n                return dist - (r_i + r_j)\n            constraints.append({'type': 'ineq', 'fun': non_overlap})\n    \n    # Boundary constraints: circles must be inside [0,1] x [0,1]\n    for i in range(n):\n        # Left boundary: cx - r >= 0\n        constraints.append({'type': 'ineq', 'fun': lambda x, i=i: x[2*i] - x[2*n+i]})\n        # Right boundary: cx + r <= 1\n        constraints.append({'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i] - x[2*n+i]})\n        # Bottom boundary: cy - r >= 0\n        constraints.append({'type': 'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]})\n        # Top boundary: cy + r <= 1\n        constraints.append({'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]})\n    \n    # Bounds: centers in [0,1], radii >= 0\n    bounds = [(0, 1) for _ in range(2*n)] + [(0, 0.5) for _ in range(n)]\n    \n    # Initial guess: grid layout with small radii\n    grid_size = int(np.ceil(np.sqrt(n)))\n    x0 = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        cx = (col + 0.5) / grid_size\n        cy = (row + 0.5) / grid_size\n        x0.extend([cx, cy])\n    \n    # Initial radii: small uniform values\n    initial_radius = 0.05\n    x0.extend([initial_radius] * n)\n    x0 = np.array(x0)\n    \n    # Optimize with multiple random restarts\n    best_result = None\n    best_value = float('inf')\n    \n    for trial in range(5):\n        if trial == 0:\n            x_init = x0\n        else:\n            # Random initialization\n            x_init = np.random.rand(3*n)\n            x_init[:2*n] = x_init[:2*n]  # centers in [0,1]\n            x_init[2*n:] = np.random.rand(n) * 0.1  # small radii\n        \n        result = minimize(\n            objective,\n            x_init,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-9}\n        )\n        \n        if result.fun < best_value:\n            best_value = result.fun\n            best_result = result\n    \n    # Extract solution\n    x_opt = best_result.x\n    centers = x_opt[:2*n].reshape((n, 2))\n    radii = x_opt[2*n:]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-31T13:53:48.873646",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.6
  }
}