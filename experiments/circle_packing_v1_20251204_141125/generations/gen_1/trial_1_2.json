{
  "trial_id": "trial_1_2",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport matplotlib.pyplot as plt\n\ndef construct_packing():\n    \"\"\"\n    Strategic circle packing with variable radii.\n    Strategy: Corners (large) \u2192 Edges (medium) \u2192 Interior (optimized)\n    \"\"\"\n    centers = []\n    radii = []\n    \n    # Phase 1: Corner circles (4 circles) - largest\n    corner_radius = 0.15\n    corner_positions = [\n        (corner_radius, corner_radius),\n        (1 - corner_radius, corner_radius),\n        (corner_radius, 1 - corner_radius),\n        (1 - corner_radius, 1 - corner_radius)\n    ]\n    \n    for pos in corner_positions:\n        centers.append(pos)\n        radii.append(corner_radius)\n    \n    # Phase 2: Edge circles (12 circles) - medium sized\n    # 3 per edge between corners\n    edge_radius = 0.09\n    \n    # Top edge\n    for i in range(1, 4):\n        x = i * 0.25\n        y = edge_radius\n        centers.append((x, y))\n        radii.append(edge_radius)\n    \n    # Bottom edge\n    for i in range(1, 4):\n        x = i * 0.25\n        y = 1 - edge_radius\n        centers.append((x, y))\n        radii.append(edge_radius)\n    \n    # Left edge\n    for i in range(1, 4):\n        x = edge_radius\n        y = i * 0.25\n        centers.append((x, y))\n        radii.append(edge_radius)\n    \n    # Right edge\n    for i in range(1, 4):\n        x = 1 - edge_radius\n        y = i * 0.25\n        centers.append((x, y))\n        radii.append(edge_radius)\n    \n    # Phase 3: Interior circles (10 circles) - variable sizes\n    # Create a grid-like pattern in the interior\n    interior_positions = [\n        (0.30, 0.30), (0.50, 0.30), (0.70, 0.30),\n        (0.30, 0.50), (0.50, 0.50), (0.70, 0.50),\n        (0.30, 0.70), (0.50, 0.70), (0.70, 0.70),\n        (0.40, 0.40)  # One extra in a good spot\n    ]\n    \n    for pos in interior_positions:\n        # Calculate maximum radius for this position\n        max_r = compute_max_radius(pos, centers, radii)\n        centers.append(pos)\n        radii.append(max_r)\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    \n    # Optimization phase: fine-tune positions and radii\n    centers, radii = optimize_packing(centers, radii)\n    \n    return centers, radii, np.sum(radii)\n\ndef compute_max_radius(pos, existing_centers, existing_radii):\n    \"\"\"Compute maximum radius for a circle at pos given existing circles.\"\"\"\n    x, y = pos\n    \n    # Boundary constraints\n    max_r = min(x, y, 1 - x, 1 - y)\n    \n    # Neighbor constraints\n    for i, (cx, cy) in enumerate(existing_centers):\n        dist = np.sqrt((x - cx)**2 + (y - cy)**2)\n        max_r = min(max_r, dist - existing_radii[i])\n    \n    # Safety margin\n    return max(0.01, max_r * 0.95)\n\ndef optimize_packing(centers, radii, iterations=50):\n    \"\"\"Optimize circle positions and radii to maximize sum of radii.\"\"\"\n    n = len(centers)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    for _ in range(iterations):\n        # Try to expand each circle\n        for i in range(n):\n            # Compute maximum possible radius for circle i\n            pos = centers[i]\n            x, y = pos\n            \n            # Boundary constraints\n            max_r = min(x, y, 1 - x, 1 - y)\n            \n            # Neighbor constraints\n            for j in range(n):\n                if i != j:\n                    dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                    max_r = min(max_r, dist - radii[j])\n            \n            # Update radius if we can expand\n            if max_r > radii[i]:\n                radii[i] = max_r * 0.98  # Safety margin\n        \n        # Try small position adjustments for interior circles (indices 16-25)\n        for i in range(16, n):\n            original_pos = centers[i].copy()\n            original_r = radii[i]\n            \n            # Try random small moves\n            for _ in range(5):\n                delta = np.random.randn(2) * 0.02\n                new_pos = original_pos + delta\n                \n                # Check if valid\n                if (new_pos[0] > 0.1 and new_pos[0] < 0.9 and \n                    new_pos[1] > 0.1 and new_pos[1] < 0.9):\n                    \n                    centers[i] = new_pos\n                    new_r = compute_max_radius(new_pos, \n                                              np.delete(centers, i, axis=0),\n                                              np.delete(radii, i))\n                    \n                    if new_r > original_r:\n                        radii[i] = new_r\n                        break\n                    else:\n                        centers[i] = original_pos\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    return best_centers, best_radii\n\ndef run_packing():\n    \"\"\"Entry point for the packing algorithm.\"\"\"\n    centers, radii, total = construct_packing()\n    \n    # Validation\n    assert centers.shape == (26, 2), f\"Centers shape is {centers.shape}, expected (26, 2)\"\n    assert radii.shape == (26,), f\"Radii shape is {radii.shape}, expected (26,)\"\n    \n    # Check boundaries\n    for i in range(26):\n        assert centers[i, 0] - radii[i] >= -1e-6, f\"Circle {i} exceeds left boundary\"\n        assert centers[i, 0] + radii[i] <= 1 + 1e-6, f\"Circle {i} exceeds right boundary\"\n        assert centers[i, 1] - radii[i] >= -1e-6, f\"Circle {i} exceeds bottom boundary\"\n        assert centers[i, 1] + radii[i] <= 1 + 1e-6, f\"Circle {i} exceeds top boundary\"\n    \n    # Check overlaps\n    for i in range(26):\n        for j in range(i + 1, 26):\n            dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n            assert dist >= radii[i] + radii[j] - 1e-6, f\"Circles {i} and {j} overlap\"\n    \n    print(f\"Sum of radii: {total:.6f}\")\n    print(f\"Radii range: [{np.min(radii):.4f}, {np.max(radii):.4f}]\")\n    \n    return centers, radii, total\n\n# Run and visualize\nif __name__ == \"__main__\":\n    centers, radii, total = run_packing()\n    \n    fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect('equal')\n    \n    for i in range(26):\n        circle = plt.Circle(centers[i], radii[i], fill=False, edgecolor='blue')\n        ax.add_patch(circle)\n        ax.text(centers[i, 0], centers[i, 1], str(i), ha='center', va='center', fontsize=8)\n    \n    ax.set_title(f'Circle Packing: Sum of Radii = {total:.6f}')\n    plt.grid(True, alpha=0.3)\n    plt.show()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 0.5969130992889404,
    "error": "AssertionError: Circles 0 and 4 overlap"
  },
  "prompt": "\nWrite a circle packing algorithm for 26 circles using variable radii strategically.\n\nKey insight: Not all circles need the same radius. Place circles optimally:\n1. Start with 4 larger circles in corners\n2. Place medium circles along edges\n3. Fill interior with smaller circles\n4. Calculate maximum radius for each position considering boundaries and neighbors\n\nRequirements:\n- Define construct_packing() that returns (centers, radii, sum_radii)\n- centers: np.array shape (26, 2)\n- radii: np.array shape (26,) - VARIABLE sizes\n- Define run_packing() as entry point\n- Strategic placement: corners \u2192 edges \u2192 interior\n- For each circle, compute max radius given constraints\n- Ensure all circles within [0,1]x[0,1]\n- Ensure no overlaps\n- Maximize sum of radii\n\nTarget: beat 2.1667 by using variable radii efficiently.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport matplotlib.pyplot as plt\n\ndef construct_packing():\n    \"\"\"\n    Strategic circle packing with variable radii.\n    Strategy: Corners (large) \u2192 Edges (medium) \u2192 Interior (optimized)\n    \"\"\"\n    centers = []\n    radii = []\n    \n    # Phase 1: Corner circles (4 circles) - largest\n    corner_radius = 0.15\n    corner_positions = [\n        (corner_radius, corner_radius),\n        (1 - corner_radius, corner_radius),\n        (corner_radius, 1 - corner_radius),\n        (1 - corner_radius, 1 - corner_radius)\n    ]\n    \n    for pos in corner_positions:\n        centers.append(pos)\n        radii.append(corner_radius)\n    \n    # Phase 2: Edge circles (12 circles) - medium sized\n    # 3 per edge between corners\n    edge_radius = 0.09\n    \n    # Top edge\n    for i in range(1, 4):\n        x = i * 0.25\n        y = edge_radius\n        centers.append((x, y))\n        radii.append(edge_radius)\n    \n    # Bottom edge\n    for i in range(1, 4):\n        x = i * 0.25\n        y = 1 - edge_radius\n        centers.append((x, y))\n        radii.append(edge_radius)\n    \n    # Left edge\n    for i in range(1, 4):\n        x = edge_radius\n        y = i * 0.25\n        centers.append((x, y))\n        radii.append(edge_radius)\n    \n    # Right edge\n    for i in range(1, 4):\n        x = 1 - edge_radius\n        y = i * 0.25\n        centers.append((x, y))\n        radii.append(edge_radius)\n    \n    # Phase 3: Interior circles (10 circles) - variable sizes\n    # Create a grid-like pattern in the interior\n    interior_positions = [\n        (0.30, 0.30), (0.50, 0.30), (0.70, 0.30),\n        (0.30, 0.50), (0.50, 0.50), (0.70, 0.50),\n        (0.30, 0.70), (0.50, 0.70), (0.70, 0.70),\n        (0.40, 0.40)  # One extra in a good spot\n    ]\n    \n    for pos in interior_positions:\n        # Calculate maximum radius for this position\n        max_r = compute_max_radius(pos, centers, radii)\n        centers.append(pos)\n        radii.append(max_r)\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    \n    # Optimization phase: fine-tune positions and radii\n    centers, radii = optimize_packing(centers, radii)\n    \n    return centers, radii, np.sum(radii)\n\ndef compute_max_radius(pos, existing_centers, existing_radii):\n    \"\"\"Compute maximum radius for a circle at pos given existing circles.\"\"\"\n    x, y = pos\n    \n    # Boundary constraints\n    max_r = min(x, y, 1 - x, 1 - y)\n    \n    # Neighbor constraints\n    for i, (cx, cy) in enumerate(existing_centers):\n        dist = np.sqrt((x - cx)**2 + (y - cy)**2)\n        max_r = min(max_r, dist - existing_radii[i])\n    \n    # Safety margin\n    return max(0.01, max_r * 0.95)\n\ndef optimize_packing(centers, radii, iterations=50):\n    \"\"\"Optimize circle positions and radii to maximize sum of radii.\"\"\"\n    n = len(centers)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    for _ in range(iterations):\n        # Try to expand each circle\n        for i in range(n):\n            # Compute maximum possible radius for circle i\n            pos = centers[i]\n            x, y = pos\n            \n            # Boundary constraints\n            max_r = min(x, y, 1 - x, 1 - y)\n            \n            # Neighbor constraints\n            for j in range(n):\n                if i != j:\n                    dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                    max_r = min(max_r, dist - radii[j])\n            \n            # Update radius if we can expand\n            if max_r > radii[i]:\n                radii[i] = max_r * 0.98  # Safety margin\n        \n        # Try small position adjustments for interior circles (indices 16-25)\n        for i in range(16, n):\n            original_pos = centers[i].copy()\n            original_r = radii[i]\n            \n            # Try random small moves\n            for _ in range(5):\n                delta = np.random.randn(2) * 0.02\n                new_pos = original_pos + delta\n                \n                # Check if valid\n                if (new_pos[0] > 0.1 and new_pos[0] < 0.9 and \n                    new_pos[1] > 0.1 and new_pos[1] < 0.9):\n                    \n                    centers[i] = new_pos\n                    new_r = compute_max_radius(new_pos, \n                                              np.delete(centers, i, axis=0),\n                                              np.delete(radii, i))\n                    \n                    if new_r > original_r:\n                        radii[i] = new_r\n                        break\n                    else:\n                        centers[i] = original_pos\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    return best_centers, best_radii\n\ndef run_packing():\n    \"\"\"Entry point for the packing algorithm.\"\"\"\n    centers, radii, total = construct_packing()\n    \n    # Validation\n    assert centers.shape == (26, 2), f\"Centers shape is {centers.shape}, expected (26, 2)\"\n    assert radii.shape == (26,), f\"Radii shape is {radii.shape}, expected (26,)\"\n    \n    # Check boundaries\n    for i in range(26):\n        assert centers[i, 0] - radii[i] >= -1e-6, f\"Circle {i} exceeds left boundary\"\n        assert centers[i, 0] + radii[i] <= 1 + 1e-6, f\"Circle {i} exceeds right boundary\"\n        assert centers[i, 1] - radii[i] >= -1e-6, f\"Circle {i} exceeds bottom boundary\"\n        assert centers[i, 1] + radii[i] <= 1 + 1e-6, f\"Circle {i} exceeds top boundary\"\n    \n    # Check overlaps\n    for i in range(26):\n        for j in range(i + 1, 26):\n            dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n            assert dist >= radii[i] + radii[j] - 1e-6, f\"Circles {i} and {j} overlap\"\n    \n    print(f\"Sum of radii: {total:.6f}\")\n    print(f\"Radii range: [{np.min(radii):.4f}, {np.max(radii):.4f}]\")\n    \n    return centers, radii, total\n\n# Run and visualize\nif __name__ == \"__main__\":\n    centers, radii, total = run_packing()\n    \n    fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect('equal')\n    \n    for i in range(26):\n        circle = plt.Circle(centers[i], radii[i], fill=False, edgecolor='blue')\n        ax.add_patch(circle)\n        ax.text(centers[i, 0], centers[i, 1], str(i), ha='center', va='center', fontsize=8)\n    \n    ax.set_title(f'Circle Packing: Sum of Radii = {total:.6f}')\n    plt.grid(True, alpha=0.3)\n    plt.show()\n```\n\nThis solution uses a strategic variable-radius approach:\n\n1. **Corner circles (4)**: Largest radius (~0.15) to maximize contribution\n2. **Edge circles (12)**: Medium radius (~0.09) placed along boundaries\n3. **Interior circles (10)**: Variable sizes computed based on available space\n4. **Optimization**: Iteratively expands circles and adjusts positions\n\nThe key insight is that circles in corners and edges can be larger since they're constrained by fewer neighbors, while interior circles naturally end up smaller. This should achieve a sum significantly above 2.1667.",
  "reasoning": "This solution uses a strategic variable-radius approach:\n\n1. **Corner circles (4)**: Largest radius (~0.15) to maximize contribution\n2. **Edge circles (12)**: Medium radius (~0.09) placed along boundaries\n3. **Interior circles (10)**: Variable sizes computed based on available space\n4. **Optimization**: Iteratively expands circles and adjusts positions\n\nThe key insight is that circles in corners and edges can be larger since they're constrained by fewer neighbors, while interior circles naturally end up smaller. This should achieve a sum significantly above 2.1667.",
  "timestamp": "2025-12-04T14:15:15.339375",
  "cost_data": null
}