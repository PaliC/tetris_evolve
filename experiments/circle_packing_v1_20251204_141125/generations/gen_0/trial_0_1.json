{
  "trial_id": "trial_0_1",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Greedy circle packing algorithm for 26 circles in unit square [0,1]x[0,1].\n    \n    Returns:\n        centers: np.array shape (26, 2) with (x,y) coordinates\n        radii: np.array shape (26,) with radius values\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    centers = np.zeros((n_circles, 2))\n    radii = np.zeros(n_circles)\n    \n    # Create a fine grid for candidate positions\n    grid_resolution = 50\n    grid_1d = np.linspace(0, 1, grid_resolution)\n    grid_x, grid_y = np.meshgrid(grid_1d, grid_1d)\n    candidate_positions = np.column_stack([grid_x.ravel(), grid_y.ravel()])\n    \n    for i in range(n_circles):\n        best_radius = 0\n        best_position = None\n        \n        # Try each candidate position\n        for pos in candidate_positions:\n            x, y = pos\n            \n            # Calculate maximum radius constrained by square boundaries\n            max_radius = min(x, y, 1 - x, 1 - y)\n            \n            # Calculate maximum radius constrained by existing circles\n            if i > 0:\n                # Distance to all existing circles\n                distances = np.sqrt(np.sum((centers[:i] - pos) ** 2, axis=1))\n                # Maximum radius is limited by nearest circle\n                max_radius_circles = np.min(distances - radii[:i])\n                max_radius = min(max_radius, max_radius_circles)\n            \n            # Update best position if this radius is larger\n            if max_radius > best_radius:\n                best_radius = max_radius\n                best_position = pos\n        \n        # Place the circle at the best position\n        centers[i] = best_position\n        radii[i] = best_radius\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef construct_packing_optimized():\n    \"\"\"\n    Optimized version with adaptive grid refinement and better initial placement.\n    \n    Returns:\n        centers: np.array shape (26, 2) with (x,y) coordinates\n        radii: np.array shape (26,) with radius values\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    centers = np.zeros((n_circles, 2))\n    radii = np.zeros(n_circles)\n    \n    def compute_max_radius(pos, existing_centers, existing_radii, n_existing):\n        \"\"\"Compute maximum radius at position pos given existing circles.\"\"\"\n        x, y = pos\n        \n        # Boundary constraints\n        max_r = min(x, y, 1 - x, 1 - y)\n        \n        if max_r <= 0:\n            return 0\n        \n        # Existing circle constraints\n        if n_existing > 0:\n            distances = np.sqrt(np.sum((existing_centers[:n_existing] - pos) ** 2, axis=1))\n            max_r_circles = np.min(distances - existing_radii[:n_existing])\n            max_r = min(max_r, max_r_circles)\n        \n        return max(0, max_r)\n    \n    # Use adaptive grid resolution (coarser for later circles)\n    for i in range(n_circles):\n        # Adjust grid resolution based on circle number\n        if i < 5:\n            grid_resolution = 80\n        elif i < 15:\n            grid_resolution = 60\n        else:\n            grid_resolution = 40\n        \n        grid_1d = np.linspace(0, 1, grid_resolution)\n        grid_x, grid_y = np.meshgrid(grid_1d, grid_1d)\n        candidate_positions = np.column_stack([grid_x.ravel(), grid_y.ravel()])\n        \n        best_radius = 0\n        best_position = np.array([0.5, 0.5])\n        \n        # Vectorized computation for all candidate positions\n        for pos in candidate_positions:\n            max_radius = compute_max_radius(pos, centers, radii, i)\n            \n            if max_radius > best_radius:\n                best_radius = max_radius\n                best_position = pos\n        \n        centers[i] = best_position\n        radii[i] = best_radius\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for the circle packing algorithm.\n    \n    Returns:\n        centers: np.array shape (26, 2) with (x,y) coordinates\n        radii: np.array shape (26,) with radius values\n        sum_radii: float, sum of all radii\n    \"\"\"\n    centers, radii, sum_radii = construct_packing_optimized()\n    \n    # Verify constraints\n    # 1. All circles within bounds\n    assert np.all(centers - radii[:, np.newaxis] >= -1e-10), \"Some circles extend below boundaries\"\n    assert np.all(centers + radii[:, np.newaxis] <= 1 + 1e-10), \"Some circles extend above boundaries\"\n    \n    # 2. No overlaps\n    distances = cdist(centers, centers)\n    min_distances = radii[:, np.newaxis] + radii[np.newaxis, :]\n    np.fill_diagonal(distances, np.inf)\n    assert np.all(distances >= min_distances - 1e-10), \"Some circles overlap\"\n    \n    print(f\"Successfully packed {len(radii)} circles\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.422695863434074,
    "target_ratio": 0.5399225288174855,
    "combined_score": 0.5399225288174855,
    "eval_time": 0.44309568405151367,
    "error": null
  },
  "prompt": "\nWrite a greedy circle packing algorithm for 26 circles in a unit square [0,1]x[0,1].\n\nAlgorithm approach:\n1. Start with an empty square\n2. For each circle, try to place it at the position that allows the maximum radius\n3. Consider positions on a fine grid and check constraints\n4. Place circles one by one, maximizing each radius given previous placements\n\nRequirements:\n- Define construct_packing() that returns (centers, radii, sum_radii)\n- centers: np.array shape (26, 2) with (x,y) coordinates\n- radii: np.array shape (26,) with radius values\n- Define run_packing() as entry point\n- Ensure all circles are within [0,1]x[0,1]\n- Ensure no overlaps (distance between centers >= sum of radii)\n- Maximize sum of radii\n\nUse numpy for efficient calculations. Consider edge constraints and existing circles when computing maximum radius.\n",
  "response": "Here's a greedy circle packing algorithm for 26 circles in a unit square:\n\n```python\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Greedy circle packing algorithm for 26 circles in unit square [0,1]x[0,1].\n    \n    Returns:\n        centers: np.array shape (26, 2) with (x,y) coordinates\n        radii: np.array shape (26,) with radius values\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    centers = np.zeros((n_circles, 2))\n    radii = np.zeros(n_circles)\n    \n    # Create a fine grid for candidate positions\n    grid_resolution = 50\n    grid_1d = np.linspace(0, 1, grid_resolution)\n    grid_x, grid_y = np.meshgrid(grid_1d, grid_1d)\n    candidate_positions = np.column_stack([grid_x.ravel(), grid_y.ravel()])\n    \n    for i in range(n_circles):\n        best_radius = 0\n        best_position = None\n        \n        # Try each candidate position\n        for pos in candidate_positions:\n            x, y = pos\n            \n            # Calculate maximum radius constrained by square boundaries\n            max_radius = min(x, y, 1 - x, 1 - y)\n            \n            # Calculate maximum radius constrained by existing circles\n            if i > 0:\n                # Distance to all existing circles\n                distances = np.sqrt(np.sum((centers[:i] - pos) ** 2, axis=1))\n                # Maximum radius is limited by nearest circle\n                max_radius_circles = np.min(distances - radii[:i])\n                max_radius = min(max_radius, max_radius_circles)\n            \n            # Update best position if this radius is larger\n            if max_radius > best_radius:\n                best_radius = max_radius\n                best_position = pos\n        \n        # Place the circle at the best position\n        centers[i] = best_position\n        radii[i] = best_radius\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef construct_packing_optimized():\n    \"\"\"\n    Optimized version with adaptive grid refinement and better initial placement.\n    \n    Returns:\n        centers: np.array shape (26, 2) with (x,y) coordinates\n        radii: np.array shape (26,) with radius values\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    centers = np.zeros((n_circles, 2))\n    radii = np.zeros(n_circles)\n    \n    def compute_max_radius(pos, existing_centers, existing_radii, n_existing):\n        \"\"\"Compute maximum radius at position pos given existing circles.\"\"\"\n        x, y = pos\n        \n        # Boundary constraints\n        max_r = min(x, y, 1 - x, 1 - y)\n        \n        if max_r <= 0:\n            return 0\n        \n        # Existing circle constraints\n        if n_existing > 0:\n            distances = np.sqrt(np.sum((existing_centers[:n_existing] - pos) ** 2, axis=1))\n            max_r_circles = np.min(distances - existing_radii[:n_existing])\n            max_r = min(max_r, max_r_circles)\n        \n        return max(0, max_r)\n    \n    # Use adaptive grid resolution (coarser for later circles)\n    for i in range(n_circles):\n        # Adjust grid resolution based on circle number\n        if i < 5:\n            grid_resolution = 80\n        elif i < 15:\n            grid_resolution = 60\n        else:\n            grid_resolution = 40\n        \n        grid_1d = np.linspace(0, 1, grid_resolution)\n        grid_x, grid_y = np.meshgrid(grid_1d, grid_1d)\n        candidate_positions = np.column_stack([grid_x.ravel(), grid_y.ravel()])\n        \n        best_radius = 0\n        best_position = np.array([0.5, 0.5])\n        \n        # Vectorized computation for all candidate positions\n        for pos in candidate_positions:\n            max_radius = compute_max_radius(pos, centers, radii, i)\n            \n            if max_radius > best_radius:\n                best_radius = max_radius\n                best_position = pos\n        \n        centers[i] = best_position\n        radii[i] = best_radius\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for the circle packing algorithm.\n    \n    Returns:\n        centers: np.array shape (26, 2) with (x,y) coordinates\n        radii: np.array shape (26,) with radius values\n        sum_radii: float, sum of all radii\n    \"\"\"\n    centers, radii, sum_radii = construct_packing_optimized()\n    \n    # Verify constraints\n    # 1. All circles within bounds\n    assert np.all(centers - radii[:, np.newaxis] >= -1e-10), \"Some circles extend below boundaries\"\n    assert np.all(centers + radii[:, np.newaxis] <= 1 + 1e-10), \"Some circles extend above boundaries\"\n    \n    # 2. No overlaps\n    distances = cdist(centers, centers)\n    min_distances = radii[:, np.newaxis] + radii[np.newaxis, :]\n    np.fill_diagonal(distances, np.inf)\n    assert np.all(distances >= min_distances - 1e-10), \"Some circles overlap\"\n    \n    print(f\"Successfully packed {len(radii)} circles\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n```\n\nThis implementation includes:\n\n1. **Greedy Algorithm**: Places circles one at a time, maximizing each circle's radius given previous placements.\n\n2. **Grid-based Search**: Uses a fine grid to search for optimal positions.\n\n3. **Constraint Checking**:\n   - Boundary constraints: ensures circles stay within [0,1]\u00d7[0,1]\n   - Circle-to-circle constraints: ensures no overlaps\n\n4. **Optimization**: The optimized version uses adaptive grid resolution (finer for early circles, coarser for later ones) for better performance.\n\n5. **Verification**: Checks all constraints are satisfied before returning.\n\nThe algorithm is greedy and may not find the global optimum, but it efficiently finds a good packing by always choosing the position that allows the largest possible circle at each step.",
  "reasoning": "Here's a greedy circle packing algorithm for 26 circles in a unit square:\n\nThis implementation includes:\n\n1. **Greedy Algorithm**: Places circles one at a time, maximizing each circle's radius given previous placements.\n\n2. **Grid-based Search**: Uses a fine grid to search for optimal positions.\n\n3. **Constraint Checking**:\n   - Boundary constraints: ensures circles stay within [0,1]\u00d7[0,1]\n   - Circle-to-circle constraints: ensures no overlaps\n\n4. **Optimization**: The optimized version uses adaptive grid resolution (finer for early circles, coarser for later ones) for better performance.\n\n5. **Verification**: Checks all constraints are satisfied before returning.\n\nThe algorithm is greedy and may not find the global optimum, but it efficiently finds a good packing by always choosing the position that allows the largest possible circle at each step.",
  "timestamp": "2025-12-04T14:12:47.327686",
  "cost_data": null
}