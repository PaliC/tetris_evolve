{
  "trial_id": "trial_0_9",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom itertools import combinations\n\ndef construct_packing():\n    centers = []\n    radii = []\n    \n    # Helper function to find maximum radius circle tangent to two objects\n    def max_radius_tangent_to_two(obj1, obj2):\n        \"\"\"\n        Find the largest circle tangent to two objects (circles or walls).\n        Returns (center, radius) or None if not feasible.\n        \"\"\"\n        best_center = None\n        best_radius = 0\n        \n        # obj format: ('wall', direction) or ('circle', center, radius)\n        \n        if obj1[0] == 'wall' and obj2[0] == 'wall':\n            # Two walls - place in corner\n            wall1, wall2 = obj1[1], obj2[1]\n            if wall1 == 'left' and wall2 == 'bottom':\n                # Try different radii, find max that fits\n                for r in np.linspace(0, 0.5, 1000):\n                    c = np.array([r, r])\n                    if is_valid_placement(c, r, centers, radii):\n                        if r > best_radius:\n                            best_radius = r\n                            best_center = c\n            elif wall1 == 'left' and wall2 == 'top':\n                for r in np.linspace(0, 0.5, 1000):\n                    c = np.array([r, 1-r])\n                    if is_valid_placement(c, r, centers, radii):\n                        if r > best_radius:\n                            best_radius = r\n                            best_center = c\n            elif wall1 == 'right' and wall2 == 'bottom':\n                for r in np.linspace(0, 0.5, 1000):\n                    c = np.array([1-r, r])\n                    if is_valid_placement(c, r, centers, radii):\n                        if r > best_radius:\n                            best_radius = r\n                            best_center = c\n            elif wall1 == 'right' and wall2 == 'top':\n                for r in np.linspace(0, 0.5, 1000):\n                    c = np.array([1-r, 1-r])\n                    if is_valid_placement(c, r, centers, radii):\n                        if r > best_radius:\n                            best_radius = r\n                            best_center = c\n                            \n        elif obj1[0] == 'wall' and obj2[0] == 'circle':\n            # Wall and circle\n            wall = obj1[1]\n            c2, r2 = obj2[1], obj2[2]\n            \n            # Try multiple candidate positions\n            for r in np.linspace(0.001, 0.3, 500):\n                candidates = []\n                if wall == 'left':\n                    # x = r, tangent to circle at c2\n                    # (x-c2[0])^2 + (y-c2[1])^2 = (r+r2)^2\n                    dx = r - c2[0]\n                    dist_sq = (r + r2)**2\n                    if dist_sq >= dx**2:\n                        dy = np.sqrt(dist_sq - dx**2)\n                        candidates.append(np.array([r, c2[1] + dy]))\n                        candidates.append(np.array([r, c2[1] - dy]))\n                elif wall == 'right':\n                    dx = (1-r) - c2[0]\n                    dist_sq = (r + r2)**2\n                    if dist_sq >= dx**2:\n                        dy = np.sqrt(dist_sq - dx**2)\n                        candidates.append(np.array([1-r, c2[1] + dy]))\n                        candidates.append(np.array([1-r, c2[1] - dy]))\n                elif wall == 'bottom':\n                    dy = r - c2[1]\n                    dist_sq = (r + r2)**2\n                    if dist_sq >= dy**2:\n                        dx = np.sqrt(dist_sq - dy**2)\n                        candidates.append(np.array([c2[0] + dx, r]))\n                        candidates.append(np.array([c2[0] - dx, r]))\n                elif wall == 'top':\n                    dy = (1-r) - c2[1]\n                    dist_sq = (r + r2)**2\n                    if dist_sq >= dy**2:\n                        dx = np.sqrt(dist_sq - dy**2)\n                        candidates.append(np.array([c2[0] + dx, 1-r]))\n                        candidates.append(np.array([c2[0] - dx, 1-r]))\n                \n                for c in candidates:\n                    if is_valid_placement(c, r, centers, radii):\n                        if r > best_radius:\n                            best_radius = r\n                            best_center = c\n                            \n        elif obj1[0] == 'circle' and obj2[0] == 'circle':\n            # Two circles\n            c1, r1 = obj1[1], obj1[2]\n            c2, r2 = obj2[1], obj2[2]\n            \n            # Try multiple radii\n            for r in np.linspace(0.001, 0.3, 500):\n                # Solve for center tangent to both circles\n                candidates = find_tangent_circles(c1, r1, c2, r2, r)\n                for c in candidates:\n                    if is_valid_placement(c, r, centers, radii):\n                        if r > best_radius:\n                            best_radius = r\n                            best_center = c\n        \n        if best_center is not None:\n            return best_center, best_radius\n        return None\n    \n    def find_tangent_circles(c1, r1, c2, r2, r):\n        \"\"\"Find centers of circles with radius r tangent to two given circles.\"\"\"\n        d = np.linalg.norm(c2 - c1)\n        if d < 1e-10:\n            return []\n        \n        candidates = []\n        for sign in [1, -1]:\n            # Distance from c1 to new center\n            d1 = r1 + r\n            d2 = r2 + r\n            \n            # Use law of cosines\n            if abs(d1 + d2 - d) < 1e-6 or abs(abs(d1 - d2) - d) < 1e-6:\n                continue\n            \n            if d**2 + d1**2 < d2**2 or d**2 + d2**2 < d1**2:\n                continue\n                \n            cos_theta = (d**2 + d1**2 - d2**2) / (2 * d * d1)\n            if abs(cos_theta) > 1:\n                continue\n            \n            theta = np.arccos(cos_theta)\n            \n            # Direction from c1 to c2\n            direction = (c2 - c1) / d\n            \n            # Rotate by +/- theta\n            angle = np.arctan2(direction[1], direction[0]) + sign * theta\n            new_center = c1 + d1 * np.array([np.cos(angle), np.sin(angle)])\n            candidates.append(new_center)\n        \n        return candidates\n    \n    def is_valid_placement(center, radius, existing_centers, existing_radii):\n        \"\"\"Check if placement is valid.\"\"\"\n        if radius < 1e-10:\n            return False\n        if center[0] - radius < -1e-9 or center[0] + radius > 1 + 1e-9:\n            return False\n        if center[1] - radius < -1e-9 or center[1] + radius > 1 + 1e-9:\n            return False\n        \n        for i, (ec, er) in enumerate(zip(existing_centers, existing_radii)):\n            dist = np.linalg.norm(center - ec)\n            if dist < radius + er - 1e-9:\n                return False\n        return True\n    \n    # Start with first circle in bottom-left corner\n    walls = [('wall', 'left'), ('wall', 'right'), ('wall', 'top'), ('wall', 'bottom')]\n    \n    # Place first circle\n    result = max_radius_tangent_to_two(('wall', 'left'), ('wall', 'bottom'))\n    if result:\n        centers.append(result[0])\n        radii.append(result[1])\n    \n    # Greedy placement\n    for i in range(1, 26):\n        best_result = None\n        best_r = 0\n        \n        # Try all pairs of existing objects\n        objects = [('circle', centers[j], radii[j]) for j in range(len(centers))] + walls\n        \n        for obj1, obj2 in combinations(objects, 2):\n            result = max_radius_tangent_to_two(obj1, obj2)\n            if result and result[1] > best_r:\n                best_r = result[1]\n                best_result = result\n        \n        if best_result:\n            centers.append(best_result[0])\n            radii.append(best_result[1])\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 1.473326310278214,
    "eval_time": 6.2126381397247314,
    "error": null
  },
  "prompt": "Pack 26 circles in a unit square [0,1]x[0,1] to maximize sum of radii.\n\nApproach: FRONT-BASED GREEDY - maintain a 'front' of placed circles. Each new circle is placed tangent to two existing objects (circles or walls) at the position allowing maximum radius. Like growing a foam from one corner.\n\nImplement construct_packing() returning (centers, radii, sum_radii). Use numpy.",
  "response": "Looking at this problem, I'll implement a front-based greedy algorithm that grows circles from a corner, placing each new circle tangent to two existing objects (circles or walls) to maximize its radius.\n\n```python\nimport numpy as np\nfrom itertools import combinations\n\ndef construct_packing():\n    centers = []\n    radii = []\n    \n    # Helper function to find maximum radius circle tangent to two objects\n    def max_radius_tangent_to_two(obj1, obj2):\n        \"\"\"\n        Find the largest circle tangent to two objects (circles or walls).\n        Returns (center, radius) or None if not feasible.\n        \"\"\"\n        best_center = None\n        best_radius = 0\n        \n        # obj format: ('wall', direction) or ('circle', center, radius)\n        \n        if obj1[0] == 'wall' and obj2[0] == 'wall':\n            # Two walls - place in corner\n            wall1, wall2 = obj1[1], obj2[1]\n            if wall1 == 'left' and wall2 == 'bottom':\n                # Try different radii, find max that fits\n                for r in np.linspace(0, 0.5, 1000):\n                    c = np.array([r, r])\n                    if is_valid_placement(c, r, centers, radii):\n                        if r > best_radius:\n                            best_radius = r\n                            best_center = c\n            elif wall1 == 'left' and wall2 == 'top':\n                for r in np.linspace(0, 0.5, 1000):\n                    c = np.array([r, 1-r])\n                    if is_valid_placement(c, r, centers, radii):\n                        if r > best_radius:\n                            best_radius = r\n                            best_center = c\n            elif wall1 == 'right' and wall2 == 'bottom':\n                for r in np.linspace(0, 0.5, 1000):\n                    c = np.array([1-r, r])\n                    if is_valid_placement(c, r, centers, radii):\n                        if r > best_radius:\n                            best_radius = r\n                            best_center = c\n            elif wall1 == 'right' and wall2 == 'top':\n                for r in np.linspace(0, 0.5, 1000):\n                    c = np.array([1-r, 1-r])\n                    if is_valid_placement(c, r, centers, radii):\n                        if r > best_radius:\n                            best_radius = r\n                            best_center = c\n                            \n        elif obj1[0] == 'wall' and obj2[0] == 'circle':\n            # Wall and circle\n            wall = obj1[1]\n            c2, r2 = obj2[1], obj2[2]\n            \n            # Try multiple candidate positions\n            for r in np.linspace(0.001, 0.3, 500):\n                candidates = []\n                if wall == 'left':\n                    # x = r, tangent to circle at c2\n                    # (x-c2[0])^2 + (y-c2[1])^2 = (r+r2)^2\n                    dx = r - c2[0]\n                    dist_sq = (r + r2)**2\n                    if dist_sq >= dx**2:\n                        dy = np.sqrt(dist_sq - dx**2)\n                        candidates.append(np.array([r, c2[1] + dy]))\n                        candidates.append(np.array([r, c2[1] - dy]))\n                elif wall == 'right':\n                    dx = (1-r) - c2[0]\n                    dist_sq = (r + r2)**2\n                    if dist_sq >= dx**2:\n                        dy = np.sqrt(dist_sq - dx**2)\n                        candidates.append(np.array([1-r, c2[1] + dy]))\n                        candidates.append(np.array([1-r, c2[1] - dy]))\n                elif wall == 'bottom':\n                    dy = r - c2[1]\n                    dist_sq = (r + r2)**2\n                    if dist_sq >= dy**2:\n                        dx = np.sqrt(dist_sq - dy**2)\n                        candidates.append(np.array([c2[0] + dx, r]))\n                        candidates.append(np.array([c2[0] - dx, r]))\n                elif wall == 'top':\n                    dy = (1-r) - c2[1]\n                    dist_sq = (r + r2)**2\n                    if dist_sq >= dy**2:\n                        dx = np.sqrt(dist_sq - dy**2)\n                        candidates.append(np.array([c2[0] + dx, 1-r]))\n                        candidates.append(np.array([c2[0] - dx, 1-r]))\n                \n                for c in candidates:\n                    if is_valid_placement(c, r, centers, radii):\n                        if r > best_radius:\n                            best_radius = r\n                            best_center = c\n                            \n        elif obj1[0] == 'circle' and obj2[0] == 'circle':\n            # Two circles\n            c1, r1 = obj1[1], obj1[2]\n            c2, r2 = obj2[1], obj2[2]\n            \n            # Try multiple radii\n            for r in np.linspace(0.001, 0.3, 500):\n                # Solve for center tangent to both circles\n                candidates = find_tangent_circles(c1, r1, c2, r2, r)\n                for c in candidates:\n                    if is_valid_placement(c, r, centers, radii):\n                        if r > best_radius:\n                            best_radius = r\n                            best_center = c\n        \n        if best_center is not None:\n            return best_center, best_radius\n        return None\n    \n    def find_tangent_circles(c1, r1, c2, r2, r):\n        \"\"\"Find centers of circles with radius r tangent to two given circles.\"\"\"\n        d = np.linalg.norm(c2 - c1)\n        if d < 1e-10:\n            return []\n        \n        candidates = []\n        for sign in [1, -1]:\n            # Distance from c1 to new center\n            d1 = r1 + r\n            d2 = r2 + r\n            \n            # Use law of cosines\n            if abs(d1 + d2 - d) < 1e-6 or abs(abs(d1 - d2) - d) < 1e-6:\n                continue\n            \n            if d**2 + d1**2 < d2**2 or d**2 + d2**2 < d1**2:\n                continue\n                \n            cos_theta = (d**2 + d1**2 - d2**2) / (2 * d * d1)\n            if abs(cos_theta) > 1:\n                continue\n            \n            theta = np.arccos(cos_theta)\n            \n            # Direction from c1 to c2\n            direction = (c2 - c1) / d\n            \n            # Rotate by +/- theta\n            angle = np.arctan2(direction[1], direction[0]) + sign * theta\n            new_center = c1 + d1 * np.array([np.cos(angle), np.sin(angle)])\n            candidates.append(new_center)\n        \n        return candidates\n    \n    def is_valid_placement(center, radius, existing_centers, existing_radii):\n        \"\"\"Check if placement is valid.\"\"\"\n        if radius < 1e-10:\n            return False\n        if center[0] - radius < -1e-9 or center[0] + radius > 1 + 1e-9:\n            return False\n        if center[1] - radius < -1e-9 or center[1] + radius > 1 + 1e-9:\n            return False\n        \n        for i, (ec, er) in enumerate(zip(existing_centers, existing_radii)):\n            dist = np.linalg.norm(center - ec)\n            if dist < radius + er - 1e-9:\n                return False\n        return True\n    \n    # Start with first circle in bottom-left corner\n    walls = [('wall', 'left'), ('wall', 'right'), ('wall', 'top'), ('wall', 'bottom')]\n    \n    # Place first circle\n    result = max_radius_tangent_to_two(('wall', 'left'), ('wall', 'bottom'))\n    if result:\n        centers.append(result[0])\n        radii.append(result[1])\n    \n    # Greedy placement\n    for i in range(1, 26):\n        best_result = None\n        best_r = 0\n        \n        # Try all pairs of existing objects\n        objects = [('circle', centers[j], radii[j]) for j in range(len(centers))] + walls\n        \n        for obj1, obj2 in combinations(objects, 2):\n            result = max_radius_tangent_to_two(obj1, obj2)\n            if result and result[1] > best_r:\n                best_r = result[1]\n                best_result = result\n        \n        if best_result:\n            centers.append(best_result[0])\n            radii.append(best_result[1])\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "Looking at this problem, I'll implement a front-based greedy algorithm that grows circles from a corner, placing each new circle tangent to two existing objects (circles or walls) to maximize its radius.",
  "timestamp": "2025-12-31T00:45:28.562092",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.5
  }
}