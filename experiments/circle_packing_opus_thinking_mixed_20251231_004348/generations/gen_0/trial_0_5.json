{
  "trial_id": "trial_0_5",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Pack 26 circles into unit square using random search with local optimization.\n    Returns (centers, radii, sum_radii)\n    \"\"\"\n    n_circles = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Helper functions\n    def compute_max_radii(centers):\n        \"\"\"Compute maximum radii for given centers without overlaps\"\"\"\n        radii = np.ones(n_circles) * 0.5  # Start with large radii\n        \n        # Iteratively reduce radii to satisfy all constraints\n        for _ in range(100):\n            # Constraint 1: circles inside square\n            for i in range(n_circles):\n                max_r = min(centers[i, 0], centers[i, 1], \n                           1 - centers[i, 0], 1 - centers[i, 1])\n                radii[i] = min(radii[i], max_r)\n            \n            # Constraint 2: no overlaps\n            distances = squareform(pdist(centers))\n            for i in range(n_circles):\n                for j in range(i + 1, n_circles):\n                    if distances[i, j] > 0:\n                        max_sum = distances[i, j]\n                        if radii[i] + radii[j] > max_sum:\n                            # Reduce both proportionally\n                            scale = max_sum / (radii[i] + radii[j]) * 0.999\n                            radii[i] *= scale\n                            radii[j] *= scale\n        \n        return np.maximum(radii, 0)\n    \n    def objective(x):\n        \"\"\"Objective to minimize (negative sum of radii)\"\"\"\n        centers = x.reshape(n_circles, 2)\n        radii = compute_max_radii(centers)\n        return -np.sum(radii)\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if configuration is valid\"\"\"\n        # Check inside square\n        for i in range(n_circles):\n            if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n                centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n                return False\n        \n        # Check no overlaps\n        distances = squareform(pdist(centers))\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                if distances[i, j] < radii[i] + radii[j] - 1e-6:\n                    return False\n        return True\n    \n    # Try multiple random initializations\n    n_attempts = 50\n    \n    for attempt in range(n_attempts):\n        # Generate random initial centers\n        if attempt < 10:\n            # Grid-based initialization\n            grid_size = int(np.ceil(np.sqrt(n_circles)))\n            centers_init = []\n            for i in range(n_circles):\n                row = i // grid_size\n                col = i % grid_size\n                x = (col + 0.5) / grid_size\n                y = (row + 0.5) / grid_size\n                # Add small random perturbation\n                x += np.random.uniform(-0.05, 0.05)\n                y += np.random.uniform(-0.05, 0.05)\n                centers_init.append([np.clip(x, 0.05, 0.95), np.clip(y, 0.05, 0.95)])\n            centers_init = np.array(centers_init)\n        else:\n            # Random initialization\n            centers_init = np.random.uniform(0.05, 0.95, (n_circles, 2))\n        \n        # Local optimization\n        try:\n            result = minimize(\n                objective,\n                centers_init.flatten(),\n                method='L-BFGS-B',\n                bounds=[(0.01, 0.99)] * (2 * n_circles),\n                options={'maxiter': 200, 'ftol': 1e-6}\n            )\n            \n            centers = result.x.reshape(n_circles, 2)\n            radii = compute_max_radii(centers)\n            sum_radii = np.sum(radii)\n            \n            if is_valid(centers, radii) and sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        except:\n            pass\n    \n    # If no valid solution found, use a simple grid\n    if best_centers is None:\n        grid_size = int(np.ceil(np.sqrt(n_circles)))\n        centers = []\n        for i in range(n_circles):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            centers.append([x, y])\n        best_centers = np.array(centers)\n        best_radii = compute_max_radii(best_centers)\n        best_sum = np.sum(best_radii)\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 300.01601099967957,
    "error": "Timeout after 300s"
  },
  "prompt": "Pack 26 circles in a unit square [0,1]x[0,1] to maximize sum of radii.\n\nApproach: RANDOM SEARCH WITH LOCAL OPTIMIZATION. Generate many random valid configurations, then for each, use gradient-free optimization (e.g., coordinate descent or Nelder-Mead) to improve. Return the best found.\n\nImplement construct_packing() returning (centers, radii, sum_radii). Use numpy and scipy.optimize if helpful.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Pack 26 circles into unit square using random search with local optimization.\n    Returns (centers, radii, sum_radii)\n    \"\"\"\n    n_circles = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Helper functions\n    def compute_max_radii(centers):\n        \"\"\"Compute maximum radii for given centers without overlaps\"\"\"\n        radii = np.ones(n_circles) * 0.5  # Start with large radii\n        \n        # Iteratively reduce radii to satisfy all constraints\n        for _ in range(100):\n            # Constraint 1: circles inside square\n            for i in range(n_circles):\n                max_r = min(centers[i, 0], centers[i, 1], \n                           1 - centers[i, 0], 1 - centers[i, 1])\n                radii[i] = min(radii[i], max_r)\n            \n            # Constraint 2: no overlaps\n            distances = squareform(pdist(centers))\n            for i in range(n_circles):\n                for j in range(i + 1, n_circles):\n                    if distances[i, j] > 0:\n                        max_sum = distances[i, j]\n                        if radii[i] + radii[j] > max_sum:\n                            # Reduce both proportionally\n                            scale = max_sum / (radii[i] + radii[j]) * 0.999\n                            radii[i] *= scale\n                            radii[j] *= scale\n        \n        return np.maximum(radii, 0)\n    \n    def objective(x):\n        \"\"\"Objective to minimize (negative sum of radii)\"\"\"\n        centers = x.reshape(n_circles, 2)\n        radii = compute_max_radii(centers)\n        return -np.sum(radii)\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if configuration is valid\"\"\"\n        # Check inside square\n        for i in range(n_circles):\n            if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n                centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n                return False\n        \n        # Check no overlaps\n        distances = squareform(pdist(centers))\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                if distances[i, j] < radii[i] + radii[j] - 1e-6:\n                    return False\n        return True\n    \n    # Try multiple random initializations\n    n_attempts = 50\n    \n    for attempt in range(n_attempts):\n        # Generate random initial centers\n        if attempt < 10:\n            # Grid-based initialization\n            grid_size = int(np.ceil(np.sqrt(n_circles)))\n            centers_init = []\n            for i in range(n_circles):\n                row = i // grid_size\n                col = i % grid_size\n                x = (col + 0.5) / grid_size\n                y = (row + 0.5) / grid_size\n                # Add small random perturbation\n                x += np.random.uniform(-0.05, 0.05)\n                y += np.random.uniform(-0.05, 0.05)\n                centers_init.append([np.clip(x, 0.05, 0.95), np.clip(y, 0.05, 0.95)])\n            centers_init = np.array(centers_init)\n        else:\n            # Random initialization\n            centers_init = np.random.uniform(0.05, 0.95, (n_circles, 2))\n        \n        # Local optimization\n        try:\n            result = minimize(\n                objective,\n                centers_init.flatten(),\n                method='L-BFGS-B',\n                bounds=[(0.01, 0.99)] * (2 * n_circles),\n                options={'maxiter': 200, 'ftol': 1e-6}\n            )\n            \n            centers = result.x.reshape(n_circles, 2)\n            radii = compute_max_radii(centers)\n            sum_radii = np.sum(radii)\n            \n            if is_valid(centers, radii) and sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        except:\n            pass\n    \n    # If no valid solution found, use a simple grid\n    if best_centers is None:\n        grid_size = int(np.ceil(np.sqrt(n_circles)))\n        centers = []\n        for i in range(n_circles):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            centers.append([x, y])\n        best_centers = np.array(centers)\n        best_radii = compute_max_radii(best_centers)\n        best_sum = np.sum(best_radii)\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-31T00:50:09.532742",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.6
  }
}