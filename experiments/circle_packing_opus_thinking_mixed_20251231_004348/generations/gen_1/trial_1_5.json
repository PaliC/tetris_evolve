{
  "trial_id": "trial_1_5",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom itertools import combinations\n\ndef construct_packing():\n    # Start with a greedy sequential placement strategy\n    centers = []\n    radii = []\n    \n    # Place first circle in corner (0,0) tangent to both walls\n    # Maximum radius when tangent to x=0 and y=0 is r\n    # Center at (r, r)\n    r1 = 0.5 / (1 + np.sqrt(2))  # Optimal for corner\n    centers.append([r1, r1])\n    radii.append(r1)\n    \n    # Define walls as line segments\n    walls = [\n        ('bottom', 0),  # y = 0\n        ('top', 1),     # y = 1\n        ('left', 0),    # x = 0\n        ('right', 1)    # x = 1\n    ]\n    \n    def distance_to_wall(center, wall):\n        wall_type, pos = wall\n        if wall_type in ['bottom', 'top']:\n            return abs(center[1] - pos)\n        else:\n            return abs(center[0] - pos)\n    \n    def find_tangent_circle(obj1, obj2, existing_centers, existing_radii):\n        \"\"\"Find largest circle tangent to two objects (walls or circles)\"\"\"\n        best_center = None\n        best_radius = 0\n        \n        # Try many candidate positions\n        for alpha in np.linspace(0, 1, 50):\n            for beta in np.linspace(0, 1, 50):\n                # Candidate center\n                cx, cy = alpha, beta\n                \n                # Calculate required radius for tangency to obj1\n                if isinstance(obj1, tuple):  # Wall\n                    r1_req = distance_to_wall([cx, cy], obj1)\n                else:  # Circle\n                    idx1 = obj1\n                    dist = np.linalg.norm([cx - existing_centers[idx1][0], \n                                          cy - existing_centers[idx1][1]])\n                    r1_req = dist - existing_radii[idx1]\n                \n                # Calculate required radius for tangency to obj2\n                if isinstance(obj2, tuple):  # Wall\n                    r2_req = distance_to_wall([cx, cy], obj2)\n                else:  # Circle\n                    idx2 = obj2\n                    dist = np.linalg.norm([cx - existing_centers[idx2][0], \n                                          cy - existing_centers[idx2][1]])\n                    r2_req = dist - existing_radii[idx2]\n                \n                # Radius must satisfy both tangency conditions\n                r = min(r1_req, r2_req)\n                \n                if r <= 0:\n                    continue\n                \n                # Check if circle fits in square\n                if cx - r < -1e-9 or cx + r > 1 + 1e-9:\n                    continue\n                if cy - r < -1e-9 or cy + r > 1 + 1e-9:\n                    continue\n                \n                # Check no overlaps with existing circles\n                valid = True\n                for i, (ec, er) in enumerate(zip(existing_centers, existing_radii)):\n                    dist = np.linalg.norm([cx - ec[0], cy - ec[1]])\n                    if dist < er + r - 1e-9:\n                        valid = False\n                        break\n                \n                if valid and r > best_radius:\n                    best_radius = r\n                    best_center = [cx, cy]\n        \n        return best_center, best_radius\n    \n    # Place remaining circles\n    for n in range(1, 26):\n        best_center = None\n        best_radius = 0\n        \n        # Try tangent to two walls\n        for w1, w2 in combinations(walls, 2):\n            center, radius = find_tangent_circle(w1, w2, centers, radii)\n            if radius > best_radius:\n                best_radius = radius\n                best_center = center\n        \n        # Try tangent to wall and circle\n        for w in walls:\n            for i in range(len(centers)):\n                center, radius = find_tangent_circle(w, i, centers, radii)\n                if radius > best_radius:\n                    best_radius = radius\n                    best_center = center\n        \n        # Try tangent to two circles\n        for i, j in combinations(range(len(centers)), 2):\n            center, radius = find_tangent_circle(i, j, centers, radii)\n            if radius > best_radius:\n                best_radius = radius\n                best_center = center\n        \n        if best_center is not None:\n            centers.append(best_center)\n            radii.append(best_radius)\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    \n    # Local optimization\n    def objective(x):\n        n = len(radii)\n        c = x[:2*n].reshape(n, 2)\n        r = x[2*n:]\n        return -np.sum(r)  # Minimize negative sum = maximize sum\n    \n    def constraints_func(x):\n        n = len(radii)\n        c = x[:2*n].reshape(n, 2)\n        r = x[2*n:]\n        \n        cons = []\n        # No overlaps\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(c[i] - c[j])\n                cons.append(dist - r[i] - r[j])\n        \n        # Inside square\n        for i in range(n):\n            cons.append(c[i, 0] - r[i])  # left\n            cons.append(1 - c[i, 0] - r[i])  # right\n            cons.append(c[i, 1] - r[i])  # bottom\n            cons.append(1 - c[i, 1] - r[i])  # top\n            cons.append(r[i])  # positive radius\n        \n        return np.array(cons)\n    \n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        constraints={'type': 'ineq', 'fun': constraints_func},\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n    \n    if result.success:\n        n = len(radii)\n        centers = result.x[:2*n].reshape(n, 2)\n        radii = result.x[2*n:]\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.590320956003422,
    "eval_time": 38.23875570297241,
    "error": null
  },
  "prompt": "Pack 26 circles in a unit square [0,1]x[0,1] to maximize sum of radii. Target: 2.636\n\nApproach: SEQUENTIAL TANGENT PLACEMENT with local optimization.\n\n1. Place first circle in corner tangent to 2 walls (large as possible)\n2. Each subsequent circle is placed tangent to 2 existing objects (walls or circles)\n3. Choose the placement that maximizes the new circle's radius\n4. After all 26 placed, use scipy to fine-tune\n\nCRITICAL: Validate no overlaps at each step. Use epsilon tolerance (1e-9).\n\nReturn construct_packing() with (centers, radii, sum_radii).",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom itertools import combinations\n\ndef construct_packing():\n    # Start with a greedy sequential placement strategy\n    centers = []\n    radii = []\n    \n    # Place first circle in corner (0,0) tangent to both walls\n    # Maximum radius when tangent to x=0 and y=0 is r\n    # Center at (r, r)\n    r1 = 0.5 / (1 + np.sqrt(2))  # Optimal for corner\n    centers.append([r1, r1])\n    radii.append(r1)\n    \n    # Define walls as line segments\n    walls = [\n        ('bottom', 0),  # y = 0\n        ('top', 1),     # y = 1\n        ('left', 0),    # x = 0\n        ('right', 1)    # x = 1\n    ]\n    \n    def distance_to_wall(center, wall):\n        wall_type, pos = wall\n        if wall_type in ['bottom', 'top']:\n            return abs(center[1] - pos)\n        else:\n            return abs(center[0] - pos)\n    \n    def find_tangent_circle(obj1, obj2, existing_centers, existing_radii):\n        \"\"\"Find largest circle tangent to two objects (walls or circles)\"\"\"\n        best_center = None\n        best_radius = 0\n        \n        # Try many candidate positions\n        for alpha in np.linspace(0, 1, 50):\n            for beta in np.linspace(0, 1, 50):\n                # Candidate center\n                cx, cy = alpha, beta\n                \n                # Calculate required radius for tangency to obj1\n                if isinstance(obj1, tuple):  # Wall\n                    r1_req = distance_to_wall([cx, cy], obj1)\n                else:  # Circle\n                    idx1 = obj1\n                    dist = np.linalg.norm([cx - existing_centers[idx1][0], \n                                          cy - existing_centers[idx1][1]])\n                    r1_req = dist - existing_radii[idx1]\n                \n                # Calculate required radius for tangency to obj2\n                if isinstance(obj2, tuple):  # Wall\n                    r2_req = distance_to_wall([cx, cy], obj2)\n                else:  # Circle\n                    idx2 = obj2\n                    dist = np.linalg.norm([cx - existing_centers[idx2][0], \n                                          cy - existing_centers[idx2][1]])\n                    r2_req = dist - existing_radii[idx2]\n                \n                # Radius must satisfy both tangency conditions\n                r = min(r1_req, r2_req)\n                \n                if r <= 0:\n                    continue\n                \n                # Check if circle fits in square\n                if cx - r < -1e-9 or cx + r > 1 + 1e-9:\n                    continue\n                if cy - r < -1e-9 or cy + r > 1 + 1e-9:\n                    continue\n                \n                # Check no overlaps with existing circles\n                valid = True\n                for i, (ec, er) in enumerate(zip(existing_centers, existing_radii)):\n                    dist = np.linalg.norm([cx - ec[0], cy - ec[1]])\n                    if dist < er + r - 1e-9:\n                        valid = False\n                        break\n                \n                if valid and r > best_radius:\n                    best_radius = r\n                    best_center = [cx, cy]\n        \n        return best_center, best_radius\n    \n    # Place remaining circles\n    for n in range(1, 26):\n        best_center = None\n        best_radius = 0\n        \n        # Try tangent to two walls\n        for w1, w2 in combinations(walls, 2):\n            center, radius = find_tangent_circle(w1, w2, centers, radii)\n            if radius > best_radius:\n                best_radius = radius\n                best_center = center\n        \n        # Try tangent to wall and circle\n        for w in walls:\n            for i in range(len(centers)):\n                center, radius = find_tangent_circle(w, i, centers, radii)\n                if radius > best_radius:\n                    best_radius = radius\n                    best_center = center\n        \n        # Try tangent to two circles\n        for i, j in combinations(range(len(centers)), 2):\n            center, radius = find_tangent_circle(i, j, centers, radii)\n            if radius > best_radius:\n                best_radius = radius\n                best_center = center\n        \n        if best_center is not None:\n            centers.append(best_center)\n            radii.append(best_radius)\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    \n    # Local optimization\n    def objective(x):\n        n = len(radii)\n        c = x[:2*n].reshape(n, 2)\n        r = x[2*n:]\n        return -np.sum(r)  # Minimize negative sum = maximize sum\n    \n    def constraints_func(x):\n        n = len(radii)\n        c = x[:2*n].reshape(n, 2)\n        r = x[2*n:]\n        \n        cons = []\n        # No overlaps\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(c[i] - c[j])\n                cons.append(dist - r[i] - r[j])\n        \n        # Inside square\n        for i in range(n):\n            cons.append(c[i, 0] - r[i])  # left\n            cons.append(1 - c[i, 0] - r[i])  # right\n            cons.append(c[i, 1] - r[i])  # bottom\n            cons.append(1 - c[i, 1] - r[i])  # top\n            cons.append(r[i])  # positive radius\n        \n        return np.array(cons)\n    \n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        constraints={'type': 'ineq', 'fun': constraints_func},\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n    \n    if result.success:\n        n = len(radii)\n        centers = result.x[:2*n].reshape(n, 2)\n        radii = result.x[2*n:]\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-31T00:52:23.330919",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.5
  }
}