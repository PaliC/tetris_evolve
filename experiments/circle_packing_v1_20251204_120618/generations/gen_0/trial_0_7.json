{
  "trial_id": "trial_0_7",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized circle packing for 26 circles in a unit square.\n    Returns (centers, radii, sum_radii)\n    \"\"\"\n    n_circles = 26\n    \n    def create_hexagonal_initial_guess():\n        \"\"\"Create hexagonal lattice initial positions\"\"\"\n        positions = []\n        # Hexagonal packing pattern\n        rows = 5\n        cols = 6\n        \n        x_spacing = 1.0 / (cols + 0.5)\n        y_spacing = 1.0 / (rows + 0.5)\n        \n        for row in range(rows):\n            for col in range(cols):\n                if len(positions) >= n_circles:\n                    break\n                x = x_spacing * (col + 1 + (0.5 if row % 2 else 0))\n                y = y_spacing * (row + 1)\n                positions.append([x, y])\n            if len(positions) >= n_circles:\n                break\n        \n        # Add any remaining circles\n        while len(positions) < n_circles:\n            positions.append([np.random.uniform(0.2, 0.8), \n                            np.random.uniform(0.2, 0.8)])\n        \n        return np.array(positions[:n_circles])\n    \n    def create_random_initial_guess():\n        \"\"\"Create random initial positions\"\"\"\n        return np.random.uniform(0.2, 0.8, (n_circles, 2))\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii (maximize sum of radii)\"\"\"\n        radii = x[2*n_circles:]\n        return -np.sum(radii)\n    \n    def compute_constraints(x):\n        \"\"\"Compute all constraints as a vector\"\"\"\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        constraints = []\n        \n        # 1. Non-overlap constraints: distance >= r_i + r_j\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt((centers[i,0] - centers[j,0])**2 + \n                             (centers[i,1] - centers[j,1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # 2. Boundary constraints: circles inside [0,1]x[0,1]\n        for i in range(n_circles):\n            constraints.append(centers[i,0] - radii[i])  # left\n            constraints.append(1.0 - centers[i,0] - radii[i])  # right\n            constraints.append(centers[i,1] - radii[i])  # bottom\n            constraints.append(1.0 - centers[i,1] - radii[i])  # top\n        \n        return np.array(constraints)\n    \n    def optimize_from_initial(initial_centers, method='SLSQP'):\n        \"\"\"Run optimization from given initial centers\"\"\"\n        # Estimate initial radii based on nearest neighbor distances\n        initial_radii = []\n        for i in range(n_circles):\n            min_dist_to_boundary = min(\n                initial_centers[i,0], \n                1.0 - initial_centers[i,0],\n                initial_centers[i,1], \n                1.0 - initial_centers[i,1]\n            )\n            \n            min_dist_to_others = float('inf')\n            for j in range(n_circles):\n                if i != j:\n                    dist = np.sqrt(np.sum((initial_centers[i] - initial_centers[j])**2))\n                    min_dist_to_others = min(min_dist_to_others, dist)\n            \n            # Conservative initial radius\n            r = min(min_dist_to_boundary, min_dist_to_others / 2.5) * 0.8\n            initial_radii.append(max(r, 0.01))\n        \n        initial_radii = np.array(initial_radii)\n        x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n        \n        # Bounds: centers in [0,1], radii in [0.001, 0.5]\n        bounds = [(0.01, 0.99)] * (2*n_circles) + [(0.001, 0.5)] * n_circles\n        \n        # Nonlinear constraint: all constraint values >= 0\n        nlc = NonlinearConstraint(compute_constraints, 0, np.inf)\n        \n        options = {\n            'maxiter': 2000,\n            'ftol': 1e-9,\n            'disp': False\n        }\n        \n        result = minimize(\n            objective,\n            x0,\n            method=method,\n            bounds=bounds,\n            constraints=nlc,\n            options=options\n        )\n        \n        return result\n    \n    # Try multiple initial configurations and methods\n    best_result = None\n    best_sum = -np.inf\n    \n    attempts = [\n        ('hexagonal', create_hexagonal_initial_guess()),\n        ('hexagonal_perturbed', create_hexagonal_initial_guess() + np.random.normal(0, 0.02, (n_circles, 2))),\n        ('random1', create_random_initial_guess()),\n        ('random2', create_random_initial_guess()),\n        ('grid_offset', np.array([[i*0.19 + 0.1, j*0.19 + 0.1] \n                                   for i in range(6) for j in range(5)][:n_circles]))\n    ]\n    \n    methods = ['SLSQP', 'trust-constr']\n    \n    print(f\"Running optimization with {len(attempts)} initial configurations and {len(methods)} methods...\")\n    \n    for attempt_name, initial_centers in attempts:\n        for method in methods:\n            try:\n                result = optimize_from_initial(initial_centers, method=method)\n                \n                if result.success or -result.fun > best_sum:\n                    current_sum = -result.fun\n                    if current_sum > best_sum:\n                        best_sum = current_sum\n                        best_result = result\n                        print(f\"  New best from {attempt_name}/{method}: sum_radii = {current_sum:.4f}\")\n            except Exception as e:\n                continue\n    \n    # Extract best solution\n    if best_result is None:\n        print(\"Optimization failed, using fallback\")\n        # Fallback: simple grid with equal radii\n        centers = create_hexagonal_initial_guess()\n        radii = np.full(n_circles, 0.08)\n    else:\n        x_best = best_result.x\n        centers = x_best[:2*n_circles].reshape(n_circles, 2)\n        radii = x_best[2*n_circles:]\n    \n    sum_radii = np.sum(radii)\n    \n    # Verify constraints\n    constraints = compute_constraints(np.concatenate([centers.flatten(), radii]))\n    min_constraint = np.min(constraints)\n    \n    print(f\"\\nFinal result:\")\n    print(f\"  Sum of radii: {sum_radii:.4f}\")\n    print(f\"  Min constraint value: {min_constraint:.6f}\")\n    print(f\"  Radius range: [{np.min(radii):.4f}, {np.max(radii):.4f}]\")\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"\n    Run the circle packing optimization.\n    Returns (centers, radii, sum_radii)\n    \"\"\"\n    return construct_packing()\n\n# Run the optimization\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"\\n{'='*50}\")\n    print(f\"FINAL SUM OF RADII: {sum_radii:.4f}\")\n    print(f\"{'='*50}\")",
  "metrics": {
    "valid": true,
    "sum_radii": 2.618693047756183,
    "target_ratio": 0.9938114033230296,
    "combined_score": 0.9938114033230296,
    "eval_time": 1.614881992340088,
    "error": null
  },
  "prompt": "Write an IMPROVED circle packing algorithm for 26 circles in a unit square [0,1]x[0,1].\n\nBuild upon this scipy optimization approach but enhance it:\n\nIMPROVEMENTS TO MAKE:\n1. Use a better initial guess (hexagonal lattice instead of grid)\n2. Increase optimization iterations and use better solver options\n3. Add multiple restarts from different initial conditions\n4. Use SLSQP or trust-constr method with proper constraint formulation\n5. Optimize both positions AND radii simultaneously\n\nThe current best achieves sum_radii = 2.5212. Try to beat this!\n\nRequirements:\n- Define construct_packing() that returns (centers, radii, sum_radii)\n- Define run_packing() that calls construct_packing()\n- All circles inside [0,1]x[0,1], no overlaps\n- Use scipy.optimize with enhanced parameters\n\nFocus on maximizing the sum of radii beyond 2.5212.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized circle packing for 26 circles in a unit square.\n    Returns (centers, radii, sum_radii)\n    \"\"\"\n    n_circles = 26\n    \n    def create_hexagonal_initial_guess():\n        \"\"\"Create hexagonal lattice initial positions\"\"\"\n        positions = []\n        # Hexagonal packing pattern\n        rows = 5\n        cols = 6\n        \n        x_spacing = 1.0 / (cols + 0.5)\n        y_spacing = 1.0 / (rows + 0.5)\n        \n        for row in range(rows):\n            for col in range(cols):\n                if len(positions) >= n_circles:\n                    break\n                x = x_spacing * (col + 1 + (0.5 if row % 2 else 0))\n                y = y_spacing * (row + 1)\n                positions.append([x, y])\n            if len(positions) >= n_circles:\n                break\n        \n        # Add any remaining circles\n        while len(positions) < n_circles:\n            positions.append([np.random.uniform(0.2, 0.8), \n                            np.random.uniform(0.2, 0.8)])\n        \n        return np.array(positions[:n_circles])\n    \n    def create_random_initial_guess():\n        \"\"\"Create random initial positions\"\"\"\n        return np.random.uniform(0.2, 0.8, (n_circles, 2))\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii (maximize sum of radii)\"\"\"\n        radii = x[2*n_circles:]\n        return -np.sum(radii)\n    \n    def compute_constraints(x):\n        \"\"\"Compute all constraints as a vector\"\"\"\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        constraints = []\n        \n        # 1. Non-overlap constraints: distance >= r_i + r_j\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt((centers[i,0] - centers[j,0])**2 + \n                             (centers[i,1] - centers[j,1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # 2. Boundary constraints: circles inside [0,1]x[0,1]\n        for i in range(n_circles):\n            constraints.append(centers[i,0] - radii[i])  # left\n            constraints.append(1.0 - centers[i,0] - radii[i])  # right\n            constraints.append(centers[i,1] - radii[i])  # bottom\n            constraints.append(1.0 - centers[i,1] - radii[i])  # top\n        \n        return np.array(constraints)\n    \n    def optimize_from_initial(initial_centers, method='SLSQP'):\n        \"\"\"Run optimization from given initial centers\"\"\"\n        # Estimate initial radii based on nearest neighbor distances\n        initial_radii = []\n        for i in range(n_circles):\n            min_dist_to_boundary = min(\n                initial_centers[i,0], \n                1.0 - initial_centers[i,0],\n                initial_centers[i,1], \n                1.0 - initial_centers[i,1]\n            )\n            \n            min_dist_to_others = float('inf')\n            for j in range(n_circles):\n                if i != j:\n                    dist = np.sqrt(np.sum((initial_centers[i] - initial_centers[j])**2))\n                    min_dist_to_others = min(min_dist_to_others, dist)\n            \n            # Conservative initial radius\n            r = min(min_dist_to_boundary, min_dist_to_others / 2.5) * 0.8\n            initial_radii.append(max(r, 0.01))\n        \n        initial_radii = np.array(initial_radii)\n        x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n        \n        # Bounds: centers in [0,1], radii in [0.001, 0.5]\n        bounds = [(0.01, 0.99)] * (2*n_circles) + [(0.001, 0.5)] * n_circles\n        \n        # Nonlinear constraint: all constraint values >= 0\n        nlc = NonlinearConstraint(compute_constraints, 0, np.inf)\n        \n        options = {\n            'maxiter': 2000,\n            'ftol': 1e-9,\n            'disp': False\n        }\n        \n        result = minimize(\n            objective,\n            x0,\n            method=method,\n            bounds=bounds,\n            constraints=nlc,\n            options=options\n        )\n        \n        return result\n    \n    # Try multiple initial configurations and methods\n    best_result = None\n    best_sum = -np.inf\n    \n    attempts = [\n        ('hexagonal', create_hexagonal_initial_guess()),\n        ('hexagonal_perturbed', create_hexagonal_initial_guess() + np.random.normal(0, 0.02, (n_circles, 2))),\n        ('random1', create_random_initial_guess()),\n        ('random2', create_random_initial_guess()),\n        ('grid_offset', np.array([[i*0.19 + 0.1, j*0.19 + 0.1] \n                                   for i in range(6) for j in range(5)][:n_circles]))\n    ]\n    \n    methods = ['SLSQP', 'trust-constr']\n    \n    print(f\"Running optimization with {len(attempts)} initial configurations and {len(methods)} methods...\")\n    \n    for attempt_name, initial_centers in attempts:\n        for method in methods:\n            try:\n                result = optimize_from_initial(initial_centers, method=method)\n                \n                if result.success or -result.fun > best_sum:\n                    current_sum = -result.fun\n                    if current_sum > best_sum:\n                        best_sum = current_sum\n                        best_result = result\n                        print(f\"  New best from {attempt_name}/{method}: sum_radii = {current_sum:.4f}\")\n            except Exception as e:\n                continue\n    \n    # Extract best solution\n    if best_result is None:\n        print(\"Optimization failed, using fallback\")\n        # Fallback: simple grid with equal radii\n        centers = create_hexagonal_initial_guess()\n        radii = np.full(n_circles, 0.08)\n    else:\n        x_best = best_result.x\n        centers = x_best[:2*n_circles].reshape(n_circles, 2)\n        radii = x_best[2*n_circles:]\n    \n    sum_radii = np.sum(radii)\n    \n    # Verify constraints\n    constraints = compute_constraints(np.concatenate([centers.flatten(), radii]))\n    min_constraint = np.min(constraints)\n    \n    print(f\"\\nFinal result:\")\n    print(f\"  Sum of radii: {sum_radii:.4f}\")\n    print(f\"  Min constraint value: {min_constraint:.6f}\")\n    print(f\"  Radius range: [{np.min(radii):.4f}, {np.max(radii):.4f}]\")\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"\n    Run the circle packing optimization.\n    Returns (centers, radii, sum_radii)\n    \"\"\"\n    return construct_packing()\n\n# Run the optimization\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"\\n{'='*50}\")\n    print(f\"FINAL SUM OF RADII: {sum_radii:.4f}\")\n    print(f\"{'='*50}\")\n```\n\nThis improved algorithm includes:\n\n1. **Hexagonal lattice initial guess**: Much better than grid for circle packing\n2. **Simultaneous optimization**: Optimizes both positions AND radii together\n3. **Multiple restarts**: 5 different initial configurations \u00d7 2 methods = 10 attempts\n4. **Better solvers**: Both SLSQP and trust-constr with enhanced options\n5. **Increased iterations**: 2000 max iterations with tight tolerance\n6. **Smart initial radii**: Based on nearest neighbor distances\n7. **Proper constraint formulation**: All constraints as NonlinearConstraint\n8. **Perturbation strategy**: Includes perturbed hexagonal lattices\n\nThe algorithm should achieve sum_radii > 2.52, potentially reaching 2.53-2.55 depending on the run!",
  "reasoning": "This improved algorithm includes:\n\n1. **Hexagonal lattice initial guess**: Much better than grid for circle packing\n2. **Simultaneous optimization**: Optimizes both positions AND radii together\n3. **Multiple restarts**: 5 different initial configurations \u00d7 2 methods = 10 attempts\n4. **Better solvers**: Both SLSQP and trust-constr with enhanced options\n5. **Increased iterations**: 2000 max iterations with tight tolerance\n6. **Smart initial radii**: Based on nearest neighbor distances\n7. **Proper constraint formulation**: All constraints as NonlinearConstraint\n8. **Perturbation strategy**: Includes perturbed hexagonal lattices\n\nThe algorithm should achieve sum_radii > 2.52, potentially reaching 2.53-2.55 depending on the run!",
  "timestamp": "2025-12-04T12:13:48.979012",
  "cost_data": null
}