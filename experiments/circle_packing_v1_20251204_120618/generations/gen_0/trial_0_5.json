{
  "trial_id": "trial_0_5",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nimport math\n\ndef construct_packing(n_circles=26, max_iterations=50000, initial_temp=1.0, cooling_rate=0.9999):\n    \"\"\"\n    Construct a circle packing using simulated annealing.\n    \n    Args:\n        n_circles: Number of circles to pack\n        max_iterations: Maximum number of iterations\n        initial_temp: Initial temperature for simulated annealing\n        cooling_rate: Temperature cooling rate\n    \n    Returns:\n        centers: Array of shape (n_circles, 2) with circle centers\n        radii: Array of shape (n_circles,) with circle radii\n        sum_radii: Sum of all radii\n    \"\"\"\n    np.random.seed(42)\n    \n    # Initialize with grid-based configuration\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    centers = []\n    for i in range(n_circles):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        centers.append([x, y])\n    centers = np.array(centers)\n    \n    # Initialize radii with small uniform values\n    radii = np.full(n_circles, 0.05)\n    \n    def compute_max_radii(centers):\n        \"\"\"Compute maximum possible radii for given centers without overlaps.\"\"\"\n        radii = np.zeros(n_circles)\n        \n        for i in range(n_circles):\n            # Distance to boundaries\n            max_r = min(centers[i, 0], 1 - centers[i, 0], \n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n_circles):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, (dist - radii[j]) / 2)\n            \n            radii[i] = max(0, max_r)\n        \n        return radii\n    \n    def is_valid_packing(centers, radii):\n        \"\"\"Check if packing is valid (no overlaps, all inside unit square).\"\"\"\n        # Check boundaries\n        for i in range(n_circles):\n            if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n                centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n                return False\n        \n        # Check overlaps\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-9:\n                    return False\n        \n        return True\n    \n    def optimize_radii(centers):\n        \"\"\"Optimize radii for given centers using iterative growth.\"\"\"\n        radii = np.zeros(n_circles)\n        \n        # Iteratively increase radii\n        for _ in range(100):\n            for i in range(n_circles):\n                # Find maximum possible radius\n                max_r = min(centers[i, 0], 1 - centers[i, 0], \n                           centers[i, 1], 1 - centers[i, 1])\n                \n                for j in range(n_circles):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        max_r = min(max_r, dist - radii[j])\n                \n                radii[i] = max(0, max_r - 1e-6)\n        \n        return radii\n    \n    # Initial radii optimization\n    radii = optimize_radii(centers)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    current_sum = best_sum\n    temperature = initial_temp\n    \n    # Simulated annealing\n    for iteration in range(max_iterations):\n        # Perturb configuration\n        new_centers = centers.copy()\n        \n        # Choose perturbation type\n        if np.random.random() < 0.3:\n            # Move single circle\n            idx = np.random.randint(n_circles)\n            perturbation = np.random.randn(2) * 0.02 * (1 + temperature)\n            new_centers[idx] += perturbation\n            new_centers[idx] = np.clip(new_centers[idx], 0.01, 0.99)\n        else:\n            # Move all circles slightly\n            perturbation = np.random.randn(n_circles, 2) * 0.01 * (1 + temperature)\n            new_centers += perturbation\n            new_centers = np.clip(new_centers, 0.01, 0.99)\n        \n        # Optimize radii for new centers\n        new_radii = optimize_radii(new_centers)\n        new_sum = np.sum(new_radii)\n        \n        # Simulated annealing acceptance criterion\n        delta = new_sum - current_sum\n        \n        if delta > 0 or np.random.random() < np.exp(delta / temperature):\n            centers = new_centers\n            radii = new_radii\n            current_sum = new_sum\n            \n            # Update best solution\n            if new_sum > best_sum:\n                best_centers = new_centers.copy()\n                best_radii = new_radii.copy()\n                best_sum = new_sum\n        \n        # Cool down temperature\n        temperature *= cooling_rate\n        \n        # Progress reporting\n        if iteration % 10000 == 0:\n            print(f\"Iteration {iteration}: Best sum = {best_sum:.6f}, Current sum = {current_sum:.6f}, Temp = {temperature:.6f}\")\n    \n    # Final validation\n    if not is_valid_packing(best_centers, best_radii):\n        print(\"Warning: Final packing may have minor violations, adjusting...\")\n        best_radii *= 0.999  # Slightly shrink to ensure validity\n    \n    return best_centers, best_radii, best_sum\n\n\ndef run_packing():\n    \"\"\"\n    Run the circle packing algorithm and return results.\n    \n    Returns:\n        centers: Array of shape (26, 2) with circle centers\n        radii: Array of shape (26,) with circle radii\n        sum_radii: Sum of all radii\n    \"\"\"\n    print(\"Starting circle packing optimization...\")\n    centers, radii, sum_radii = construct_packing(n_circles=26)\n    \n    print(f\"\\nFinal Results:\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    # Optional: Visualization\n    try:\n        import matplotlib.pyplot as plt\n        \n        fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n        ax.set_xlim(0, 1)\n        ax.set_ylim(0, 1)\n        ax.set_aspect('equal')\n        ax.set_title(f'Circle Packing (26 circles, sum of radii = {sum_radii:.4f})')\n        \n        for i in range(len(centers)):\n            circle = plt.Circle(centers[i], radii[i], fill=False, edgecolor='blue', linewidth=1.5)\n            ax.add_patch(circle)\n            ax.plot(centers[i, 0], centers[i, 1], 'r.', markersize=3)\n        \n        ax.grid(True, alpha=0.3)\n        plt.tight_layout()\n        plt.savefig('circle_packing.png', dpi=150)\n        print(\"\\nVisualization saved as 'circle_packing.png'\")\n        plt.show()\n    except ImportError:\n        print(\"\\nMatplotlib not available for visualization\")",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 30.004966735839844,
    "error": "Timeout after 30s"
  },
  "prompt": "Write a circle packing algorithm for 26 circles in a unit square [0,1]x[0,1].\n\nUse simulated annealing to optimize the packing:\n1. Start with a grid-based initial configuration\n2. Iteratively perturb positions and radii\n3. Accept improvements always, accept worse solutions with probability exp(-delta/T)\n4. Cool down temperature over time\n5. Return the best configuration found\n\nThis allows escaping local optima to find better packings.\n\nRequirements:\n- Define construct_packing() that returns (centers, radii, sum_radii)\n- Define run_packing() that calls construct_packing()\n- All circles inside [0,1]x[0,1], no overlaps\n\nFocus on maximizing the sum of radii.",
  "response": "```python\nimport numpy as np\nimport math\n\ndef construct_packing(n_circles=26, max_iterations=50000, initial_temp=1.0, cooling_rate=0.9999):\n    \"\"\"\n    Construct a circle packing using simulated annealing.\n    \n    Args:\n        n_circles: Number of circles to pack\n        max_iterations: Maximum number of iterations\n        initial_temp: Initial temperature for simulated annealing\n        cooling_rate: Temperature cooling rate\n    \n    Returns:\n        centers: Array of shape (n_circles, 2) with circle centers\n        radii: Array of shape (n_circles,) with circle radii\n        sum_radii: Sum of all radii\n    \"\"\"\n    np.random.seed(42)\n    \n    # Initialize with grid-based configuration\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    centers = []\n    for i in range(n_circles):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        centers.append([x, y])\n    centers = np.array(centers)\n    \n    # Initialize radii with small uniform values\n    radii = np.full(n_circles, 0.05)\n    \n    def compute_max_radii(centers):\n        \"\"\"Compute maximum possible radii for given centers without overlaps.\"\"\"\n        radii = np.zeros(n_circles)\n        \n        for i in range(n_circles):\n            # Distance to boundaries\n            max_r = min(centers[i, 0], 1 - centers[i, 0], \n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n_circles):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, (dist - radii[j]) / 2)\n            \n            radii[i] = max(0, max_r)\n        \n        return radii\n    \n    def is_valid_packing(centers, radii):\n        \"\"\"Check if packing is valid (no overlaps, all inside unit square).\"\"\"\n        # Check boundaries\n        for i in range(n_circles):\n            if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n                centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n                return False\n        \n        # Check overlaps\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-9:\n                    return False\n        \n        return True\n    \n    def optimize_radii(centers):\n        \"\"\"Optimize radii for given centers using iterative growth.\"\"\"\n        radii = np.zeros(n_circles)\n        \n        # Iteratively increase radii\n        for _ in range(100):\n            for i in range(n_circles):\n                # Find maximum possible radius\n                max_r = min(centers[i, 0], 1 - centers[i, 0], \n                           centers[i, 1], 1 - centers[i, 1])\n                \n                for j in range(n_circles):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        max_r = min(max_r, dist - radii[j])\n                \n                radii[i] = max(0, max_r - 1e-6)\n        \n        return radii\n    \n    # Initial radii optimization\n    radii = optimize_radii(centers)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    current_sum = best_sum\n    temperature = initial_temp\n    \n    # Simulated annealing\n    for iteration in range(max_iterations):\n        # Perturb configuration\n        new_centers = centers.copy()\n        \n        # Choose perturbation type\n        if np.random.random() < 0.3:\n            # Move single circle\n            idx = np.random.randint(n_circles)\n            perturbation = np.random.randn(2) * 0.02 * (1 + temperature)\n            new_centers[idx] += perturbation\n            new_centers[idx] = np.clip(new_centers[idx], 0.01, 0.99)\n        else:\n            # Move all circles slightly\n            perturbation = np.random.randn(n_circles, 2) * 0.01 * (1 + temperature)\n            new_centers += perturbation\n            new_centers = np.clip(new_centers, 0.01, 0.99)\n        \n        # Optimize radii for new centers\n        new_radii = optimize_radii(new_centers)\n        new_sum = np.sum(new_radii)\n        \n        # Simulated annealing acceptance criterion\n        delta = new_sum - current_sum\n        \n        if delta > 0 or np.random.random() < np.exp(delta / temperature):\n            centers = new_centers\n            radii = new_radii\n            current_sum = new_sum\n            \n            # Update best solution\n            if new_sum > best_sum:\n                best_centers = new_centers.copy()\n                best_radii = new_radii.copy()\n                best_sum = new_sum\n        \n        # Cool down temperature\n        temperature *= cooling_rate\n        \n        # Progress reporting\n        if iteration % 10000 == 0:\n            print(f\"Iteration {iteration}: Best sum = {best_sum:.6f}, Current sum = {current_sum:.6f}, Temp = {temperature:.6f}\")\n    \n    # Final validation\n    if not is_valid_packing(best_centers, best_radii):\n        print(\"Warning: Final packing may have minor violations, adjusting...\")\n        best_radii *= 0.999  # Slightly shrink to ensure validity\n    \n    return best_centers, best_radii, best_sum\n\n\ndef run_packing():\n    \"\"\"\n    Run the circle packing algorithm and return results.\n    \n    Returns:\n        centers: Array of shape (26, 2) with circle centers\n        radii: Array of shape (26,) with circle radii\n        sum_radii: Sum of all radii\n    \"\"\"\n    print(\"Starting circle packing optimization...\")\n    centers, radii, sum_radii = construct_packing(n_circles=26)\n    \n    print(f\"\\nFinal Results:\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    # Optional: Visualization\n    try:\n        import matplotlib.pyplot as plt\n        \n        fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n        ax.set_xlim(0, 1)\n        ax.set_ylim(0, 1)\n        ax.set_aspect('equal')\n        ax.set_title(f'Circle Packing (26 circles, sum of radii = {sum_radii:.4f})')\n        \n        for i in range(len(centers)):\n            circle = plt.Circle(centers[i], radii[i], fill=False, edgecolor='blue', linewidth=1.5)\n            ax.add_patch(circle)\n            ax.plot(centers[i, 0], centers[i, 1], 'r.', markersize=3)\n        \n        ax.grid(True, alpha=0.3)\n        plt.tight_layout()\n        plt.savefig('circle_packing.png', dpi=150)\n        print(\"\\nVisualization saved as 'circle_packing.png'\")\n        plt.show()\n    except ImportError:\n        print(\"\\nMatplotlib not available for visualization\")\n```\n\nThis implementation includes:\n\n1. **Grid-based initialization**: Circles start in a regular grid pattern\n2. **Simulated annealing**: \n   - Temperature starts high and cools down gradually\n   - Accepts improvements always\n   - Accepts worse solutions probabilistically based on temperature\n3. **Radius optimization**: For any given center configuration, computes maximum valid radii\n4. **Perturbations**: Randomly moves circles (single or all) to explore the solution space\n5. **Validation**: Ensures no overlaps and all circles stay within [0,1]\u00d7[0,1]\n6. **Visualization**: Optional matplotlib plotting to see the result\n\nThe algorithm maximizes the sum of radii while maintaining valid packing constraints. The simulated annealing approach helps escape local optima to find better solutions.",
  "reasoning": "This implementation includes:\n\n1. **Grid-based initialization**: Circles start in a regular grid pattern\n2. **Simulated annealing**: \n   - Temperature starts high and cools down gradually\n   - Accepts improvements always\n   - Accepts worse solutions probabilistically based on temperature\n3. **Radius optimization**: For any given center configuration, computes maximum valid radii\n4. **Perturbations**: Randomly moves circles (single or all) to explore the solution space\n5. **Validation**: Ensures no overlaps and all circles stay within [0,1]\u00d7[0,1]\n6. **Visualization**: Optional matplotlib plotting to see the result\n\nThe algorithm maximizes the sum of radii while maintaining valid packing constraints. The simulated annealing approach helps escape local optima to find better solutions.",
  "timestamp": "2025-12-04T12:12:10.889993",
  "cost_data": null
}