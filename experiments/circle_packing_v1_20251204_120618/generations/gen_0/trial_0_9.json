{
  "trial_id": "trial_0_9",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef construct_packing():\n    \"\"\"\n    Multi-start circle packing algorithm for 26 circles in unit square.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    n_circles = 26\n    best_result = None\n    best_sum = 0\n    \n    # Try multiple starting configurations\n    starting_configs = [\n        generate_hexagonal_start(n_circles),\n        generate_square_grid_start(n_circles),\n        generate_random_spaced_start(n_circles),\n        generate_boundary_focused_start(n_circles),\n        generate_sunflower_start(n_circles),\n    ]\n    \n    for config_idx, initial_positions in enumerate(starting_configs):\n        result = optimize_packing(initial_positions, n_circles)\n        if result['sum_radii'] > best_sum:\n            best_sum = result['sum_radii']\n            best_result = result\n            print(f\"Config {config_idx}: sum_radii = {best_sum:.4f}\")\n    \n    return best_result['centers'], best_result['radii'], best_result['sum_radii']\n\ndef generate_hexagonal_start(n):\n    \"\"\"Generate hexagonal lattice starting positions\"\"\"\n    positions = []\n    rows = int(np.ceil(np.sqrt(n * 2/np.sqrt(3))))\n    cols = int(np.ceil(n / rows)) + 1\n    \n    for i in range(rows):\n        for j in range(cols):\n            if len(positions) >= n:\n                break\n            x = 0.15 + j * 0.7 / (cols - 1) if cols > 1 else 0.5\n            y = 0.15 + i * 0.7 / (rows - 1) if rows > 1 else 0.5\n            if i % 2 == 1:\n                x += 0.35 / (cols - 1) if cols > 1 else 0\n            positions.append([x, y])\n        if len(positions) >= n:\n            break\n    \n    return np.array(positions[:n])\n\ndef generate_square_grid_start(n):\n    \"\"\"Generate square grid starting positions\"\"\"\n    side = int(np.ceil(np.sqrt(n)))\n    positions = []\n    \n    for i in range(side):\n        for j in range(side):\n            if len(positions) >= n:\n                break\n            x = 0.15 + j * 0.7 / (side - 1) if side > 1 else 0.5\n            y = 0.15 + i * 0.7 / (side - 1) if side > 1 else 0.5\n            positions.append([x, y])\n    \n    return np.array(positions[:n])\n\ndef generate_random_spaced_start(n):\n    \"\"\"Generate random positions with minimum spacing\"\"\"\n    np.random.seed(42)\n    positions = []\n    min_dist = 0.12\n    max_attempts = 1000\n    \n    for _ in range(n):\n        for attempt in range(max_attempts):\n            pos = np.random.uniform(0.15, 0.85, 2)\n            if len(positions) == 0:\n                positions.append(pos)\n                break\n            \n            dists = np.sqrt(np.sum((np.array(positions) - pos)**2, axis=1))\n            if np.min(dists) > min_dist:\n                positions.append(pos)\n                break\n        else:\n            # If we can't place with min_dist, just place randomly\n            positions.append(np.random.uniform(0.15, 0.85, 2))\n    \n    return np.array(positions)\n\ndef generate_boundary_focused_start(n):\n    \"\"\"Generate positions focusing on corners, edges, and interior\"\"\"\n    positions = []\n    \n    # 4 corners\n    corners = [[0.12, 0.12], [0.88, 0.12], [0.12, 0.88], [0.88, 0.88]]\n    positions.extend(corners[:min(4, n)])\n    \n    # Edge positions\n    n_edges = min(12, n - len(positions))\n    if n_edges > 0:\n        for i in range(n_edges):\n            t = (i + 1) / (n_edges + 1)\n            if i % 4 == 0:\n                positions.append([t, 0.12])\n            elif i % 4 == 1:\n                positions.append([t, 0.88])\n            elif i % 4 == 2:\n                positions.append([0.12, t])\n            else:\n                positions.append([0.88, t])\n    \n    # Fill interior with grid\n    remaining = n - len(positions)\n    if remaining > 0:\n        side = int(np.ceil(np.sqrt(remaining)))\n        for i in range(side):\n            for j in range(side):\n                if len(positions) >= n:\n                    break\n                x = 0.3 + j * 0.4 / max(1, side - 1)\n                y = 0.3 + i * 0.4 / max(1, side - 1)\n                positions.append([x, y])\n    \n    return np.array(positions[:n])\n\ndef generate_sunflower_start(n):\n    \"\"\"Generate sunflower spiral pattern\"\"\"\n    positions = []\n    golden_angle = np.pi * (3 - np.sqrt(5))\n    \n    for i in range(n):\n        theta = i * golden_angle\n        r = 0.35 * np.sqrt(i / n)\n        x = 0.5 + r * np.cos(theta)\n        y = 0.5 + r * np.sin(theta)\n        positions.append([x, y])\n    \n    return np.array(positions)\n\ndef optimize_packing(initial_positions, n_circles):\n    \"\"\"Optimize circle packing from initial positions\"\"\"\n    \n    def compute_radii(positions):\n        \"\"\"Compute maximum radii for given positions\"\"\"\n        positions = positions.reshape(n_circles, 2)\n        radii = np.ones(n_circles)\n        \n        for i in range(n_circles):\n            # Distance to boundaries\n            r_max = min(\n                positions[i, 0],\n                1 - positions[i, 0],\n                positions[i, 1],\n                1 - positions[i, 1]\n            )\n            \n            # Distance to other circles\n            for j in range(n_circles):\n                if i != j:\n                    dist = np.sqrt(np.sum((positions[i] - positions[j])**2))\n                    r_max = min(r_max, (dist - radii[j]) / 1.0)\n            \n            radii[i] = max(r_max, 1e-6)\n        \n        return radii\n    \n    def objective(x):\n        \"\"\"Objective: maximize sum of radii (minimize negative sum)\"\"\"\n        positions = x.reshape(n_circles, 2)\n        radii = compute_radii(positions)\n        return -np.sum(radii)\n    \n    def constraint_no_overlap(x):\n        \"\"\"Constraint: circles don't overlap\"\"\"\n        positions = x.reshape(n_circles, 2)\n        radii = compute_radii(positions)\n        \n        constraints = []\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.sqrt(np.sum((positions[i] - positions[j])**2))\n                constraints.append(dist - radii[i] - radii[j])\n        \n        return np.array(constraints)\n    \n    def constraint_inside(x):\n        \"\"\"Constraint: circles inside unit square\"\"\"\n        positions = x.reshape(n_circles, 2)\n        radii = compute_radii(positions)\n        \n        constraints = []\n        for i in range(n_circles):\n            constraints.append(positions[i, 0] - radii[i])\n            constraints.append(1 - positions[i, 0] - radii[i])\n            constraints.append(positions[i, 1] - radii[i])\n            constraints.append(1 - positions[i, 1] - radii[i])\n        \n        return np.array(constraints)\n    \n    # Bounds: keep positions well inside initially\n    bounds = [(0.01, 0.99) for _ in range(2 * n_circles)]\n    \n    # Constraints\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_no_overlap},\n        {'type': 'ineq', 'fun': constraint_inside}\n    ]\n    \n    # Optimize\n    x0 = initial_positions.flatten()\n    \n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': 1000, 'ftol': 1e-8}\n    )\n    \n    # Extract results\n    final_positions = result.x.reshape(n_circles, 2)\n    final_radii = compute_radii(final_positions)\n    sum_radii = np.sum(final_radii)\n    \n    return {\n        'centers': final_positions,\n        'radii': final_radii,\n        'sum_radii': sum_radii\n    }\n\ndef run_packing():\n    \"\"\"Run the packing algorithm\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    print(f\"\\nFinal sum_radii = {sum_radii:.4f}\")\n    return centers, radii, sum_radii\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 0.5000249999999697,
    "target_ratio": 0.18976280834913464,
    "combined_score": 0.18976280834913464,
    "eval_time": 9.71372389793396,
    "error": null
  },
  "prompt": "Write a MULTI-START circle packing algorithm for 26 circles in a unit square [0,1]x[0,1].\n\nUse multiple starting configurations and pick the best result:\n\nSTRATEGY:\n1. Try 3-5 different initial configurations:\n   - Hexagonal lattice\n   - Square grid\n   - Random with large spacing\n   - Boundary-focused (corners + edges + interior)\n2. Run scipy.optimize from each starting point\n3. Return the best result among all runs\n\nThis increases chances of finding the global optimum.\n\nThe current best achieves sum_radii = 2.5212. Beat this!\n\nRequirements:\n- Define construct_packing() that returns (centers, radii, sum_radii)\n- Define run_packing() that calls construct_packing()\n- All circles inside [0,1]x[0,1], no overlaps\n\nFocus on maximizing the sum of radii beyond 2.5212.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef construct_packing():\n    \"\"\"\n    Multi-start circle packing algorithm for 26 circles in unit square.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    n_circles = 26\n    best_result = None\n    best_sum = 0\n    \n    # Try multiple starting configurations\n    starting_configs = [\n        generate_hexagonal_start(n_circles),\n        generate_square_grid_start(n_circles),\n        generate_random_spaced_start(n_circles),\n        generate_boundary_focused_start(n_circles),\n        generate_sunflower_start(n_circles),\n    ]\n    \n    for config_idx, initial_positions in enumerate(starting_configs):\n        result = optimize_packing(initial_positions, n_circles)\n        if result['sum_radii'] > best_sum:\n            best_sum = result['sum_radii']\n            best_result = result\n            print(f\"Config {config_idx}: sum_radii = {best_sum:.4f}\")\n    \n    return best_result['centers'], best_result['radii'], best_result['sum_radii']\n\ndef generate_hexagonal_start(n):\n    \"\"\"Generate hexagonal lattice starting positions\"\"\"\n    positions = []\n    rows = int(np.ceil(np.sqrt(n * 2/np.sqrt(3))))\n    cols = int(np.ceil(n / rows)) + 1\n    \n    for i in range(rows):\n        for j in range(cols):\n            if len(positions) >= n:\n                break\n            x = 0.15 + j * 0.7 / (cols - 1) if cols > 1 else 0.5\n            y = 0.15 + i * 0.7 / (rows - 1) if rows > 1 else 0.5\n            if i % 2 == 1:\n                x += 0.35 / (cols - 1) if cols > 1 else 0\n            positions.append([x, y])\n        if len(positions) >= n:\n            break\n    \n    return np.array(positions[:n])\n\ndef generate_square_grid_start(n):\n    \"\"\"Generate square grid starting positions\"\"\"\n    side = int(np.ceil(np.sqrt(n)))\n    positions = []\n    \n    for i in range(side):\n        for j in range(side):\n            if len(positions) >= n:\n                break\n            x = 0.15 + j * 0.7 / (side - 1) if side > 1 else 0.5\n            y = 0.15 + i * 0.7 / (side - 1) if side > 1 else 0.5\n            positions.append([x, y])\n    \n    return np.array(positions[:n])\n\ndef generate_random_spaced_start(n):\n    \"\"\"Generate random positions with minimum spacing\"\"\"\n    np.random.seed(42)\n    positions = []\n    min_dist = 0.12\n    max_attempts = 1000\n    \n    for _ in range(n):\n        for attempt in range(max_attempts):\n            pos = np.random.uniform(0.15, 0.85, 2)\n            if len(positions) == 0:\n                positions.append(pos)\n                break\n            \n            dists = np.sqrt(np.sum((np.array(positions) - pos)**2, axis=1))\n            if np.min(dists) > min_dist:\n                positions.append(pos)\n                break\n        else:\n            # If we can't place with min_dist, just place randomly\n            positions.append(np.random.uniform(0.15, 0.85, 2))\n    \n    return np.array(positions)\n\ndef generate_boundary_focused_start(n):\n    \"\"\"Generate positions focusing on corners, edges, and interior\"\"\"\n    positions = []\n    \n    # 4 corners\n    corners = [[0.12, 0.12], [0.88, 0.12], [0.12, 0.88], [0.88, 0.88]]\n    positions.extend(corners[:min(4, n)])\n    \n    # Edge positions\n    n_edges = min(12, n - len(positions))\n    if n_edges > 0:\n        for i in range(n_edges):\n            t = (i + 1) / (n_edges + 1)\n            if i % 4 == 0:\n                positions.append([t, 0.12])\n            elif i % 4 == 1:\n                positions.append([t, 0.88])\n            elif i % 4 == 2:\n                positions.append([0.12, t])\n            else:\n                positions.append([0.88, t])\n    \n    # Fill interior with grid\n    remaining = n - len(positions)\n    if remaining > 0:\n        side = int(np.ceil(np.sqrt(remaining)))\n        for i in range(side):\n            for j in range(side):\n                if len(positions) >= n:\n                    break\n                x = 0.3 + j * 0.4 / max(1, side - 1)\n                y = 0.3 + i * 0.4 / max(1, side - 1)\n                positions.append([x, y])\n    \n    return np.array(positions[:n])\n\ndef generate_sunflower_start(n):\n    \"\"\"Generate sunflower spiral pattern\"\"\"\n    positions = []\n    golden_angle = np.pi * (3 - np.sqrt(5))\n    \n    for i in range(n):\n        theta = i * golden_angle\n        r = 0.35 * np.sqrt(i / n)\n        x = 0.5 + r * np.cos(theta)\n        y = 0.5 + r * np.sin(theta)\n        positions.append([x, y])\n    \n    return np.array(positions)\n\ndef optimize_packing(initial_positions, n_circles):\n    \"\"\"Optimize circle packing from initial positions\"\"\"\n    \n    def compute_radii(positions):\n        \"\"\"Compute maximum radii for given positions\"\"\"\n        positions = positions.reshape(n_circles, 2)\n        radii = np.ones(n_circles)\n        \n        for i in range(n_circles):\n            # Distance to boundaries\n            r_max = min(\n                positions[i, 0],\n                1 - positions[i, 0],\n                positions[i, 1],\n                1 - positions[i, 1]\n            )\n            \n            # Distance to other circles\n            for j in range(n_circles):\n                if i != j:\n                    dist = np.sqrt(np.sum((positions[i] - positions[j])**2))\n                    r_max = min(r_max, (dist - radii[j]) / 1.0)\n            \n            radii[i] = max(r_max, 1e-6)\n        \n        return radii\n    \n    def objective(x):\n        \"\"\"Objective: maximize sum of radii (minimize negative sum)\"\"\"\n        positions = x.reshape(n_circles, 2)\n        radii = compute_radii(positions)\n        return -np.sum(radii)\n    \n    def constraint_no_overlap(x):\n        \"\"\"Constraint: circles don't overlap\"\"\"\n        positions = x.reshape(n_circles, 2)\n        radii = compute_radii(positions)\n        \n        constraints = []\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.sqrt(np.sum((positions[i] - positions[j])**2))\n                constraints.append(dist - radii[i] - radii[j])\n        \n        return np.array(constraints)\n    \n    def constraint_inside(x):\n        \"\"\"Constraint: circles inside unit square\"\"\"\n        positions = x.reshape(n_circles, 2)\n        radii = compute_radii(positions)\n        \n        constraints = []\n        for i in range(n_circles):\n            constraints.append(positions[i, 0] - radii[i])\n            constraints.append(1 - positions[i, 0] - radii[i])\n            constraints.append(positions[i, 1] - radii[i])\n            constraints.append(1 - positions[i, 1] - radii[i])\n        \n        return np.array(constraints)\n    \n    # Bounds: keep positions well inside initially\n    bounds = [(0.01, 0.99) for _ in range(2 * n_circles)]\n    \n    # Constraints\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_no_overlap},\n        {'type': 'ineq', 'fun': constraint_inside}\n    ]\n    \n    # Optimize\n    x0 = initial_positions.flatten()\n    \n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': 1000, 'ftol': 1e-8}\n    )\n    \n    # Extract results\n    final_positions = result.x.reshape(n_circles, 2)\n    final_radii = compute_radii(final_positions)\n    sum_radii = np.sum(final_radii)\n    \n    return {\n        'centers': final_positions,\n        'radii': final_radii,\n        'sum_radii': sum_radii\n    }\n\ndef run_packing():\n    \"\"\"Run the packing algorithm\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    print(f\"\\nFinal sum_radii = {sum_radii:.4f}\")\n    return centers, radii, sum_radii\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-04T12:15:12.562652",
  "cost_data": null
}