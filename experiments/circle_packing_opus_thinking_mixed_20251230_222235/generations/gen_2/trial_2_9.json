{
  "trial_id": "trial_2_9",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom dataclasses import dataclass\n\n@dataclass\nclass PackingState:\n    centers: np.ndarray\n    radii: np.ndarray\n    \n    @property\n    def sum_radii(self):\n        return np.sum(self.radii)\n\ndef construct_packing():\n    n_circles = 26\n    np.random.seed(42)\n    \n    def simulated_annealing():\n        # Initialize with grid-like pattern\n        grid_size = int(np.ceil(np.sqrt(n_circles)))\n        centers = []\n        for i in range(n_circles):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            centers.append([x, y])\n        centers = np.array(centers)\n        \n        # Initial radii estimate\n        radii = np.ones(n_circles) * 0.05\n        \n        best_state = PackingState(centers.copy(), radii.copy())\n        current_state = PackingState(centers.copy(), radii.copy())\n        \n        # SA parameters\n        T_initial = 0.1\n        T_final = 1e-6\n        n_iterations = 5000\n        cooling_rate = (T_final / T_initial) ** (1.0 / n_iterations)\n        \n        T = T_initial\n        \n        for iteration in range(n_iterations):\n            # Perturb configuration\n            new_centers = current_state.centers.copy()\n            new_radii = current_state.radii.copy()\n            \n            # Random move type\n            move_type = np.random.choice(['move_center', 'adjust_radius', 'swap'])\n            \n            if move_type == 'move_center':\n                idx = np.random.randint(n_circles)\n                new_centers[idx] += np.random.randn(2) * 0.02 * T / T_initial\n                new_centers[idx] = np.clip(new_centers[idx], 0, 1)\n            elif move_type == 'adjust_radius':\n                idx = np.random.randint(n_circles)\n                new_radii[idx] += np.random.randn() * 0.01 * T / T_initial\n                new_radii[idx] = max(0, new_radii[idx])\n            else:  # swap\n                i, j = np.random.choice(n_circles, 2, replace=False)\n                new_centers[[i, j]] = new_centers[[j, i]]\n            \n            # Compute maximum feasible radii for new configuration\n            new_radii = compute_max_radii(new_centers)\n            new_sum = np.sum(new_radii)\n            \n            # Accept or reject\n            delta = new_sum - current_state.sum_radii\n            if delta > 0 or np.random.rand() < np.exp(delta / T):\n                current_state = PackingState(new_centers, new_radii)\n                if current_state.sum_radii > best_state.sum_radii:\n                    best_state = PackingState(new_centers.copy(), new_radii.copy())\n            \n            T *= cooling_rate\n        \n        return best_state\n    \n    def compute_max_radii(centers):\n        \"\"\"Compute maximum feasible radii given centers\"\"\"\n        radii = np.ones(n_circles) * 1.0  # Start optimistic\n        \n        for _ in range(100):  # Iterative refinement\n            for i in range(n_circles):\n                # Constraint from boundaries\n                max_r = min(\n                    centers[i, 0],\n                    1 - centers[i, 0],\n                    centers[i, 1],\n                    1 - centers[i, 1]\n                )\n                \n                # Constraint from other circles\n                for j in range(n_circles):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        max_r = min(max_r, dist - radii[j])\n                \n                radii[i] = max(0, max_r)\n        \n        return radii\n    \n    def optimize_with_slsqp(initial_state):\n        \"\"\"Refine using SLSQP\"\"\"\n        # Pack variables: [x1, y1, ..., xn, yn, r1, ..., rn]\n        x0 = np.concatenate([initial_state.centers.flatten(), initial_state.radii])\n        \n        def objective(x):\n            radii = x[2*n_circles:]\n            return -np.sum(radii)  # Minimize negative sum = maximize sum\n        \n        def make_constraints():\n            constraints = []\n            \n            # Boundary constraints\n            for i in range(n_circles):\n                # x_i - r_i >= 0\n                constraints.append({\n                    'type': 'ineq',\n                    'fun': lambda x, i=i: x[2*i] - x[2*n_circles + i]\n                })\n                # x_i + r_i <= 1\n                constraints.append({\n                    'type': 'ineq',\n                    'fun': lambda x, i=i: 1 - x[2*i] - x[2*n_circles + i]\n                })\n                # y_i - r_i >= 0\n                constraints.append({\n                    'type': 'ineq',\n                    'fun': lambda x, i=i: x[2*i + 1] - x[2*n_circles + i]\n                })\n                # y_i + r_i <= 1\n                constraints.append({\n                    'type': 'ineq',\n                    'fun': lambda x, i=i: 1 - x[2*i + 1] - x[2*n_circles + i]\n                })\n            \n            # Non-overlap constraints\n            for i in range(n_circles):\n                for j in range(i + 1, n_circles):\n                    def constraint_func(x, i=i, j=j):\n                        dx = x[2*i] - x[2*j]\n                        dy = x[2*i + 1] - x[2*j + 1]\n                        dist = np.sqrt(dx**2 + dy**2)\n                        return dist - x[2*n_circles + i] - x[2*n_circles + j]\n                    \n                    constraints.append({\n                        'type': 'ineq',\n                        'fun': constraint_func\n                    })\n            \n            return constraints\n        \n        bounds = [(0, 1)] * (2 * n_circles) + [(0, 0.5)] * n_circles\n        \n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=make_constraints(),\n            options={'maxiter': 2000, 'ftol': 1e-9}\n        )\n        \n        centers = result.x[:2*n_circles].reshape(n_circles, 2)\n        radii = result.x[2*n_circles:]\n        \n        return centers, radii, np.sum(radii)\n    \n    # Run SA warmup\n    sa_state = simulated_annealing()\n    \n    # Refine with SLSQP\n    centers, radii, sum_radii = optimize_with_slsqp(sa_state)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 300.0108301639557,
    "error": "Timeout after 300s"
  },
  "prompt": "Circle packing: Pack 26 circles in unit square [0,1]x[0,1], maximize sum of radii. Target: 2.636\n\nSIMULATED ANNEALING warmup + SLSQP finish:\n\n1. SA phase: explore configuration space with random moves\n   - Accept worse solutions with decreasing probability\n   - Run 5000 iterations\n2. SLSQP phase: refine the best SA configuration\n   - High iterations, tight tolerance\n\nSA can escape local optima, SLSQP can find precise optimum.\n\nReturn complete Python code.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom dataclasses import dataclass\n\n@dataclass\nclass PackingState:\n    centers: np.ndarray\n    radii: np.ndarray\n    \n    @property\n    def sum_radii(self):\n        return np.sum(self.radii)\n\ndef construct_packing():\n    n_circles = 26\n    np.random.seed(42)\n    \n    def simulated_annealing():\n        # Initialize with grid-like pattern\n        grid_size = int(np.ceil(np.sqrt(n_circles)))\n        centers = []\n        for i in range(n_circles):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            centers.append([x, y])\n        centers = np.array(centers)\n        \n        # Initial radii estimate\n        radii = np.ones(n_circles) * 0.05\n        \n        best_state = PackingState(centers.copy(), radii.copy())\n        current_state = PackingState(centers.copy(), radii.copy())\n        \n        # SA parameters\n        T_initial = 0.1\n        T_final = 1e-6\n        n_iterations = 5000\n        cooling_rate = (T_final / T_initial) ** (1.0 / n_iterations)\n        \n        T = T_initial\n        \n        for iteration in range(n_iterations):\n            # Perturb configuration\n            new_centers = current_state.centers.copy()\n            new_radii = current_state.radii.copy()\n            \n            # Random move type\n            move_type = np.random.choice(['move_center', 'adjust_radius', 'swap'])\n            \n            if move_type == 'move_center':\n                idx = np.random.randint(n_circles)\n                new_centers[idx] += np.random.randn(2) * 0.02 * T / T_initial\n                new_centers[idx] = np.clip(new_centers[idx], 0, 1)\n            elif move_type == 'adjust_radius':\n                idx = np.random.randint(n_circles)\n                new_radii[idx] += np.random.randn() * 0.01 * T / T_initial\n                new_radii[idx] = max(0, new_radii[idx])\n            else:  # swap\n                i, j = np.random.choice(n_circles, 2, replace=False)\n                new_centers[[i, j]] = new_centers[[j, i]]\n            \n            # Compute maximum feasible radii for new configuration\n            new_radii = compute_max_radii(new_centers)\n            new_sum = np.sum(new_radii)\n            \n            # Accept or reject\n            delta = new_sum - current_state.sum_radii\n            if delta > 0 or np.random.rand() < np.exp(delta / T):\n                current_state = PackingState(new_centers, new_radii)\n                if current_state.sum_radii > best_state.sum_radii:\n                    best_state = PackingState(new_centers.copy(), new_radii.copy())\n            \n            T *= cooling_rate\n        \n        return best_state\n    \n    def compute_max_radii(centers):\n        \"\"\"Compute maximum feasible radii given centers\"\"\"\n        radii = np.ones(n_circles) * 1.0  # Start optimistic\n        \n        for _ in range(100):  # Iterative refinement\n            for i in range(n_circles):\n                # Constraint from boundaries\n                max_r = min(\n                    centers[i, 0],\n                    1 - centers[i, 0],\n                    centers[i, 1],\n                    1 - centers[i, 1]\n                )\n                \n                # Constraint from other circles\n                for j in range(n_circles):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        max_r = min(max_r, dist - radii[j])\n                \n                radii[i] = max(0, max_r)\n        \n        return radii\n    \n    def optimize_with_slsqp(initial_state):\n        \"\"\"Refine using SLSQP\"\"\"\n        # Pack variables: [x1, y1, ..., xn, yn, r1, ..., rn]\n        x0 = np.concatenate([initial_state.centers.flatten(), initial_state.radii])\n        \n        def objective(x):\n            radii = x[2*n_circles:]\n            return -np.sum(radii)  # Minimize negative sum = maximize sum\n        \n        def make_constraints():\n            constraints = []\n            \n            # Boundary constraints\n            for i in range(n_circles):\n                # x_i - r_i >= 0\n                constraints.append({\n                    'type': 'ineq',\n                    'fun': lambda x, i=i: x[2*i] - x[2*n_circles + i]\n                })\n                # x_i + r_i <= 1\n                constraints.append({\n                    'type': 'ineq',\n                    'fun': lambda x, i=i: 1 - x[2*i] - x[2*n_circles + i]\n                })\n                # y_i - r_i >= 0\n                constraints.append({\n                    'type': 'ineq',\n                    'fun': lambda x, i=i: x[2*i + 1] - x[2*n_circles + i]\n                })\n                # y_i + r_i <= 1\n                constraints.append({\n                    'type': 'ineq',\n                    'fun': lambda x, i=i: 1 - x[2*i + 1] - x[2*n_circles + i]\n                })\n            \n            # Non-overlap constraints\n            for i in range(n_circles):\n                for j in range(i + 1, n_circles):\n                    def constraint_func(x, i=i, j=j):\n                        dx = x[2*i] - x[2*j]\n                        dy = x[2*i + 1] - x[2*j + 1]\n                        dist = np.sqrt(dx**2 + dy**2)\n                        return dist - x[2*n_circles + i] - x[2*n_circles + j]\n                    \n                    constraints.append({\n                        'type': 'ineq',\n                        'fun': constraint_func\n                    })\n            \n            return constraints\n        \n        bounds = [(0, 1)] * (2 * n_circles) + [(0, 0.5)] * n_circles\n        \n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=make_constraints(),\n            options={'maxiter': 2000, 'ftol': 1e-9}\n        )\n        \n        centers = result.x[:2*n_circles].reshape(n_circles, 2)\n        radii = result.x[2*n_circles:]\n        \n        return centers, radii, np.sum(radii)\n    \n    # Run SA warmup\n    sa_state = simulated_annealing()\n    \n    # Refine with SLSQP\n    centers, radii, sum_radii = optimize_with_slsqp(sa_state)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-30T22:43:00.526193",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.5
  }
}