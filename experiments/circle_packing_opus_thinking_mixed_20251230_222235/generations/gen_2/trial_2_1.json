{
  "trial_id": "trial_2_1",
  "generation": 2,
  "parent_id": "trial_1_4",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    \n    def create_initial_config_grid(seed=0):\n        \"\"\"5x5 grid + 1 extra point\"\"\"\n        np.random.seed(seed)\n        grid_size = 5\n        x = np.linspace(0.1, 0.9, grid_size)\n        y = np.linspace(0.1, 0.9, grid_size)\n        xv, yv = np.meshgrid(x, y)\n        centers = np.vstack([xv.ravel(), yv.ravel()]).T\n        centers = np.vstack([centers, [[0.5, 0.5]]])\n        centers += np.random.normal(0, 0.02, centers.shape)\n        centers = np.clip(centers, 0.05, 0.95)\n        radii = np.full(n, 0.08)\n        return np.concatenate([centers.flatten(), radii])\n    \n    def create_initial_config_rect(seed=0):\n        \"\"\"5x6 rectangular grid\"\"\"\n        np.random.seed(seed)\n        positions = []\n        for i in range(5):\n            for j in range(6):\n                if len(positions) >= n:\n                    break\n                x = (i + 0.5) / 5\n                y = (j + 0.5) / 6\n                positions.append([x, y])\n        positions = np.array(positions[:n])\n        positions += np.random.randn(n, 2) * 0.02\n        positions = np.clip(positions, 0.05, 0.95)\n        radii = np.full(n, 0.08)\n        return np.concatenate([positions.flatten(), radii])\n    \n    def create_initial_config_structured(seed=0):\n        \"\"\"Corner-edge-interior structure\"\"\"\n        np.random.seed(seed)\n        centers = []\n        radii = []\n        \n        # 4 corner circles\n        r_corner = 0.15\n        corners = [(r_corner, r_corner), (1-r_corner, r_corner),\n                   (r_corner, 1-r_corner), (1-r_corner, 1-r_corner)]\n        for c in corners:\n            centers.append(c)\n            radii.append(r_corner)\n        \n        # 8 edge circles\n        r_edge = 0.10\n        edges = [(0.5, r_edge), (0.5, 1-r_edge),\n                 (r_edge, 0.5), (1-r_edge, 0.5),\n                 (0.25, r_edge), (0.75, r_edge),\n                 (r_edge, 0.25), (r_edge, 0.75)]\n        for c in edges:\n            centers.append(c)\n            radii.append(r_edge)\n        \n        # Fill remaining with interior circles\n        r_small = 0.08\n        remaining = n - len(centers)\n        for i in range(remaining):\n            angle = 2 * np.pi * i / remaining\n            radius_pos = 0.3 + 0.1 * (i % 3)\n            x = 0.5 + radius_pos * np.cos(angle)\n            y = 0.5 + radius_pos * np.sin(angle)\n            centers.append((x, y))\n            radii.append(r_small)\n        \n        centers = np.array(centers[:n])\n        radii = np.array(radii[:n])\n        centers += np.random.randn(n, 2) * 0.02\n        centers = np.clip(centers, 0.05, 0.95)\n        \n        return np.concatenate([centers.flatten(), radii])\n    \n    def objective(params):\n        \"\"\"Maximize sum of radii\"\"\"\n        radii = params[2*n:]\n        return -np.sum(radii)\n    \n    def constraints_func(params):\n        \"\"\"All inequality constraints: g(x) >= 0\"\"\"\n        centers = params[:2*n].reshape((n, 2))\n        radii = params[2*n:]\n        cons = []\n        \n        # Boundary constraints\n        for i in range(n):\n            cons.append(centers[i, 0] - radii[i])  # left\n            cons.append(1.0 - centers[i, 0] - radii[i])  # right\n            cons.append(centers[i, 1] - radii[i])  # bottom\n            cons.append(1.0 - centers[i, 1] - radii[i])  # top\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                cons.append(dist - (radii[i] + radii[j]))\n        \n        return np.array(cons)\n    \n    # Bounds\n    bounds = [(0, 1)] * (2*n) + [(0.001, 0.5)] * n\n    \n    best_result = None\n    best_sum = -np.inf\n    \n    # Try multiple initialization strategies with restarts\n    init_funcs = [create_initial_config_grid, create_initial_config_rect, \n                  create_initial_config_structured]\n    \n    for init_func in init_funcs:\n        for seed in range(10):\n            x0 = init_func(seed)\n            \n            # Add perturbation for diversity (except first trial)\n            if seed > 0:\n                x0[:2*n] += np.random.uniform(-0.05, 0.05, 2*n)\n                x0[2*n:] += np.random.uniform(-0.02, 0.02, n)\n                x0 = np.clip(x0, [b[0] for b in bounds], [b[1] for b in bounds])\n            \n            try:\n                result = minimize(\n                    objective,\n                    x0,\n                    method='SLSQP',\n                    bounds=bounds,\n                    constraints={'type': 'ineq', 'fun': constraints_func},\n                    options={'maxiter': 500, 'ftol': 1e-9}\n                )\n                \n                sum_radii = -result.fun\n                if sum_radii > best_sum:\n                    best_sum = sum_radii\n                    best_result = result\n            except:\n                continue\n    \n    # Extract best solution\n    if best_result is None:\n        x0 = create_initial_config_grid(0)\n        best_result = type('obj', (object,), {'x': x0})()\n    \n    final_params = best_result.x\n    best_centers = final_params[:2*n].reshape((n, 2))\n    best_radii = final_params[2*n:]\n    \n    # Final cleanup: ensure all constraints are satisfied\n    for i in range(n):\n        # Boundary constraints\n        max_r = min(best_centers[i, 0], 1 - best_centers[i, 0],\n                    best_centers[i, 1], 1 - best_centers[i, 1])\n        best_radii[i] = min(best_radii[i], max_r)\n        \n        # Non-overlap constraints\n        for j in range(n):\n            if i == j:\n                continue\n            d = np.linalg.norm(best_centers[i] - best_centers[j])\n            if best_radii[i] + best_radii[j] > d:\n                # Shrink both radii proportionally\n                scale = 0.999 * d / (best_radii[i] + best_radii[j])\n                best_radii[i] *= scale\n                best_radii[j] *= scale\n    \n    best_radii = np.maximum(best_radii, 0)\n    \n    return best_centers, best_radii, np.sum(best_radii)\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 0.0,
    "eval_time": 23.18752408027649,
    "error": null
  },
  "prompt": "Circle packing: Pack 26 circles in unit square [0,1]x[0,1], maximize sum of radii. Target: 2.636\n\nHere are the top 3 approaches (all ~2.61):\n\nTrial 1 (2.616) - 5x5 grid + SLSQP:\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    \n    # 1. Structured Initialization: 5x5 grid + 1 extra point\n    # This provides a much better starting point than pure random\n    grid_size = 5\n    x = np.linspace(0.1, 0.9, grid_size)\n    y = np.linspace(0.1, 0.9, grid_size)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.vstack([xv.ravel(), yv.ravel()])\n    # Add 26th point at a random spot or center\n    centers = np.column_stack([centers, [0.5, 0.5]])\n    centers = centers.T # Shape (26, 2)\n\n    # Add small noise to break symmetry for the optimizer\n    centers += np.random.normal(0, 0.01, centers.shape)\n\n    # 2. Optimization Function\n    # We want to maximize sum(r_i) subject to:\n    # r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n    # r_i + r_j <= dist(c_i, c_j)\n    \n    def objective(params):\n        # params: [x1, y1, ..., xn, yn, r1, ..., rn]\n        r = params[2*n:]\n        return -np.sum(r)\n\n    def constraints(params):\n        pts = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        cons = []\n        \n        # Boundary constraints: r_i <= dist to edge\n        for i in range(n):\n            cons.append(pts[i, 0] - r[i])\n            cons.append(1.0 - pts[i, 0] - r[i])\n            cons.append(pts[i, 1] - r[i])\n            cons.append(1.0 - pts[i, 1] - r[i])\n        \n        # Overlap constraints: dist(i, j) >= r_i + r_j\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((pts[i] - pts[j])**2))\n                cons.append(dist - (r[i] + r[j]))\n        return np.array(cons)\n\n    # Initial guess for radii\n    r_init = np.full(n, 1.0 / (2 * np.sqrt(n)))\n    initial_params = np.concatenate([centers.flatten(), r_init])\n\n    # Bounds for coordinates and radii\n    bounds = []\n    for _ in range(n):\n        bounds.append((0, 1)) # x\n        bounds.append((0, 1)) # y\n    for _ in range(n):\n        bounds.append((0, 0.5)) # r\n\n    # 3. Solve using SLSQP\n    # Note: For speed in this environment, we use a limited number of iterations.\n    # In a full run, more iterations or multiple starts would be used.\n    res = minimize(\n        objective, \n        initial_params, \n        method='SLSQP', \n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraints},\n        options={'maxiter': 100, 'ftol': 1e-6}\n    )\n\n    final_params = res.x\n    best_centers = final_params[:2*n].reshape((n, 2))\n    best_radii = final_params[2*n:]\n    best_sum = np.sum(best_radii)\n\n    # Final cleanup: ensure no tiny boundary violations due to solver precision\n    for i in range(n):\n        best_radii[i] = min(best_radii[i], best_centers[i, 0], 1 - best_centers[i, 0], \n                            best_centers[i, 1], 1 - best_centers[i, 1])\n        for j in range(n):\n            if i == j: continue\n            d = np.linalg.norm(best_centers[i] - best_centers[j])\n            if best_radii[i] + best_radii[j] > d:\n                # Shrink radius to fit\n                best_radii[i] = max(0, d - best_radii[j])\n\n    return best_centers, best_radii, np.sum(best_radii)\n\ndef run_packing():\n    return construct_packing()\n\nTrial 2 (2.610) - tangent + SLSQP:\nimport numpy as np\nfrom scipy.optimize import minimize, fsolve\n\ndef construct_packing():\n    # Use optimization to find the best packing of 26 circles\n    # Start with a good initial configuration based on known patterns\n    \n    def circle_tangent_to_two_walls_and_circle(wall1, wall2, cx, cy, cr):\n        \"\"\"\n        Find circle tangent to two walls and an existing circle.\n        wall1, wall2 are 'left', 'right', 'bottom', 'top'\n        \"\"\"\n        # For corner regions\n        if wall1 == 'left' and wall2 == 'bottom':\n            # Center at (r, r), tangent to circle at (cx, cy, cr)\n            # Distance = r + cr, so sqrt((r-cx)^2 + (r-cy)^2) = r + cr\n            def eq(r):\n                return (r - cx)**2 + (r - cy)**2 - (r + cr)**2\n            r_init = 0.05\n            sol = fsolve(eq, r_init, full_output=True)\n            r = sol[0][0]\n            if r > 0:\n                return r, r, r\n        elif wall1 == 'right' and wall2 == 'bottom':\n            def eq(r):\n                return (1-r - cx)**2 + (r - cy)**2 - (r + cr)**2\n            sol = fsolve(eq, 0.05, full_output=True)\n            r = sol[0][0]\n            if r > 0:\n                return 1-r, r, r\n        elif wall1 == 'left' and wall2 == 'top':\n            def eq(r):\n                return (r - cx)**2 + (1-r - cy)**2 - (r + cr)**2\n            sol = fsolve(eq, 0.05, full_output=True)\n            r = sol[0][0]\n            if r > 0:\n                return r, 1-r, r\n        elif wall1 == 'right' and wall2 == 'top':\n            def eq(r):\n                return (1-r - cx)**2 + (1-r - cy)**2 - (r + cr)**2\n            sol = fsolve(eq, 0.05, full_output=True)\n            r = sol[0][0]\n            if r > 0:\n                return 1-r, 1-r, r\n        return None\n    \n    def circle_tangent_to_wall_and_two_circles(wall, c1, c2):\n        \"\"\"\n        Find circle tangent to one wall and two existing circles.\n        c1, c2 are (cx, cy, cr) tuples\n        \"\"\"\n        x1, y1, r1 = c1\n        x2, y2, r2 = c2\n        \n        if wall == 'bottom':\n            # Center at (x, r), tangent to both circles\n            def eqs(params):\n                x, r = params\n                eq1 = (x - x1)**2 + (r - y1)**2 - (r + r1)**2\n                eq2 = (x - x2)**2 + (r - y2)**2 - (r + r2)**2\n                return [eq1, eq2]\n            x_init = (x1 + x2) / 2\n            sol = fsolve(eqs, [x_init, 0.05], full_output=True)\n            x, r = sol[0]\n            if r > 0 and 0 < x < 1:\n                return x, r, r\n        elif wall == 'top':\n            def eqs(params):\n                x, r = params\n                eq1 = (x - x1)**2 + (1-r - y1)**2 - (r + r1)**2\n                eq2 = (x - x2)**2 + (1-r - y2)**2 - (r + r2)**2\n                return [eq1, eq2]\n            x_init = (x1 + x2) / 2\n            sol = fsolve(eqs, [x_init, 0.05], full_output=True)\n            x, r = sol[0]\n            if r > 0 and 0 < x < 1:\n                return x, 1-r, r\n        elif wall == 'left':\n            def eqs(params):\n                y, r = params\n                eq1 = (r - x1)**2 + (y - y1)**2 - (r + r1)**2\n                eq2 = (r - x2)**2 + (y - y2)**2 - (r + r2)**2\n                return [eq1, eq2]\n            y_init = (y1 + y2) / 2\n            sol = fsolve(eqs, [y_init, 0.05], full_output=True)\n            y, r = sol[0]\n            if r > 0 and 0 < y < 1:\n                return r, y, r\n        elif wall == 'right':\n            def eqs(params):\n                y, r = params\n                eq1 = (1-r - x1)**2 + (y - y1)**2 - (r + r1)**2\n                eq2 = (1-r - x2)**2 + (y - y2)**2 - (r + r2)**2\n                return [eq1, eq2]\n            y_init = (y1 + y2) / 2\n            sol = fsolve(eqs, [y_init, 0.05], full_output=True)\n            y, r = sol[0]\n            if r > 0 and 0 < y < 1:\n                return 1-r, y, r\n        return None\n\n    def optimize_packing(x0):\n        \"\"\"Optimize circle positions and radii.\"\"\"\n        n = 26\n        \n        def objective(params):\n            radii = params[2*n:]\n            return -np.sum(radii)\n        \n        def constraint_inside(params):\n            centers = params[:2*n].reshape(n, 2)\n            radii = params[2*n:]\n            constraints = []\n            for i in range(n):\n                constraints.append(centers[i, 0] - radii[i])  # x - r >= 0\n                constraints.append(centers[i, 1] - radii[i])  # y - r >= 0\n                constraints.append(1 - centers[i, 0] - radii[i])  # 1 - x - r >= 0\n                constraints.append(1 - centers[i, 1] - radii[i])  # 1 - y - r >= 0\n            return np.array(constraints)\n        \n        def constraint_no_overlap(params):\n            centers = params[:2*n].reshape(n, 2)\n            radii = params[2*n:]\n            constraints = []\n            for i in range(n):\n                for j in range(i+1, n):\n                    dist = np.sqrt((centers[i,0]-centers[j,0])**2 + (centers[i,1]-centers[j,1])**2)\n                    constraints.append(dist - radii[i] - radii[j])\n            return np.array(constraints)\n        \n        constraints = [\n            {'type': 'ineq', 'fun': constraint_inside},\n            {'type': 'ineq', 'fun': constraint_no_overlap}\n        ]\n        \n        bounds = [(0, 1)] * (2*n) + [(0.001, 0.5)] * n\n        \n        result = minimize(objective, x0, method='SLSQP', bounds=bounds, \n                         constraints=constraints, options={'maxiter': 1000, 'ftol': 1e-9})\n        return result\n    \n    # Build initial configuration\n    n = 26\n    \n    # Known good configuration pattern for 26 circles\n    # Use a structured approach with larger corner circles and fill gaps\n    \n    # Start with approximate positions based on hexagonal-like packing\n    initial_centers = []\n    initial_radii = []\n    \n    # Large corner circles\n    r_corner = 0.17\n    corners = [(r_corner, r_corner), (1-r_corner, r_corner), \n               (r_corner, 1-r_corner), (1-r_corner, 1-r_corner)]\n    for c in corners:\n        initial_centers.append(c)\n        initial_radii.append(r_corner)\n    \n    # Medium circles along edges\n    r_edge = 0.11\n    # Bottom edge\n    initial_centers.append((0.5, r_edge))\n    initial_radii.append(r_edge)\n    # Top edge\n    initial_centers.append((0.5, 1-r_edge))\n    initial_radii.append(r_edge)\n    # Left edge\n    initial_centers.append((r_edge, 0.5))\n    initial_radii.append(r_edge)\n    # Right edge\n    initial_centers.append((1-r_edge, 0.5))\n    initial_radii.append(r_edge)\n    \n    # Fill remaining with smaller circles\n    r_small = 0.08\n    positions = [\n        (0.33, 0.33), (0.67, 0.33), (0.33, 0.67), (0.67, 0.67),\n        (0.5, 0.5),\n        (0.25, 0.5), (0.75, 0.5), (0.5, 0.25), (0.5, 0.75),\n        (0.15, 0.35), (0.85, 0.35), (0.15, 0.65), (0.85, 0.65),\n        (0.35, 0.15), (0.65, 0.15), (0.35, 0.85), (0.65, 0.85),\n        (0.25, 0.25)\n    ]\n    \n    for pos in positions[:n - len(initial_centers)]:\n        initial_centers.append(pos)\n        initial_radii.append(r_small)\n    \n    # Convert to optimization format\n    x0 = np.zeros(3*n)\n    for i in range(n):\n        x0[2*i] = initial_centers[i][0]\n        x0[2*i+1] = initial_centers[i][1]\n        x0[2*n+i] = initial_radii[i]\n    \n    # Run optimization multiple times with perturbations\n    best_result = None\n    best_sum = 0\n    \n    for trial in range(5):\n        if trial > 0:\n            # Perturb initial guess\n            x0_perturbed = x0.copy()\n            x0_perturbed[:2*n] += np.random.uniform(-0.05, 0.05, 2*n)\n            x0_perturbed[2*n:] += np.random.uniform(-0.02, 0.02, n)\n            x0_perturbed = np.clip(x0_perturbed, 0.01, 0.99)\n        else:\n            x0_perturbed = x0.copy()\n        \n        result = optimize_packing(x0_perturbed)\n        \n        if result.success or True:  # Try even if not fully converged\n            current_sum = -result.fun\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_result = result\n    \n    # Extract results\n    params = best_result.x\n    centers = params[:2*n].reshape(n, 2)\n    radii = params[2*n:]\n    \n    # Ensure all constraints are satisfied\n    radii = np.maximum(radii, 0)\n    \n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, total = run_packing()\n    print(f\"Sum of radii: {total}\")\n    print(f\"Target: 2.635983099011548\")\n\nTrial 3 (2.610) - 5x6 grid + SLSQP with 10 restarts:\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    \n    def create_initial_config(seed=0):\n        \"\"\"Create strategic initial configuration\"\"\"\n        np.random.seed(seed)\n        \n        # Start with a grid-like arrangement with some randomization\n        # Use 5x6 grid (30 positions, use 26)\n        grid_x = 5\n        grid_y = 6\n        \n        positions = []\n        for i in range(grid_x):\n            for j in range(grid_y):\n                if len(positions) >= n:\n                    break\n                x = (i + 0.5) / grid_x\n                y = (j + 0.5) / grid_y\n                positions.append([x, y])\n        \n        positions = np.array(positions[:n])\n        \n        # Add small random perturbation\n        positions += np.random.randn(n, 2) * 0.01\n        positions = np.clip(positions, 0.1, 0.9)\n        \n        # Initial radii - conservative estimate\n        initial_radius = 0.08\n        radii = np.ones(n) * initial_radius\n        \n        # Pack into single vector [x1, y1, r1, x2, y2, r2, ...]\n        x0 = np.zeros(3 * n)\n        for i in range(n):\n            x0[3*i] = positions[i, 0]\n            x0[3*i + 1] = positions[i, 1]\n            x0[3*i + 2] = radii[i]\n        \n        return x0\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii (maximize sum of radii)\"\"\"\n        radii = x[2::3]\n        return -np.sum(radii)\n    \n    def create_constraints():\n        \"\"\"Create all inequality constraints: g(x) >= 0\"\"\"\n        constraints = []\n        \n        # Boundary constraints for each circle\n        for i in range(n):\n            # Left wall: x_i - r_i >= 0\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: x[3*i] - x[3*i + 2]\n            })\n            \n            # Right wall: 1 - x_i - r_i >= 0\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: 1 - x[3*i] - x[3*i + 2]\n            })\n            \n            # Bottom wall: y_i - r_i >= 0\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: x[3*i + 1] - x[3*i + 2]\n            })\n            \n            # Top wall: 1 - y_i - r_i >= 0\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: 1 - x[3*i + 1] - x[3*i + 2]\n            })\n        \n        # Non-overlap constraints for each pair\n        for i in range(n):\n            for j in range(i + 1, n):\n                def make_constraint(i, j):\n                    def constraint(x):\n                        xi, yi, ri = x[3*i], x[3*i + 1], x[3*i + 2]\n                        xj, yj, rj = x[3*j], x[3*j + 1], x[3*j + 2]\n                        dist = np.sqrt((xi - xj)**2 + (yi - yj)**2)\n                        return dist - ri - rj\n                    return constraint\n                \n                constraints.append({\n                    'type': 'ineq',\n                    'fun': make_constraint(i, j)\n                })\n        \n        return constraints\n    \n    # Bounds: x, y in [0, 1], r >= 0\n    bounds = []\n    for i in range(n):\n        bounds.append((0, 1))  # x_i\n        bounds.append((0, 1))  # y_i\n        bounds.append((0, 0.5))  # r_i (max possible radius is 0.5)\n    \n    constraints = create_constraints()\n    \n    best_result = None\n    best_sum = -np.inf\n    \n    # Try multiple starting configurations\n    for seed in range(10):\n        x0 = create_initial_config(seed)\n        \n        try:\n            result = minimize(\n                objective,\n                x0,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={\n                    'maxiter': 1000,\n                    'ftol': 1e-9,\n                    'disp': False\n                }\n            )\n            \n            if result.success or True:  # Check even if not marked as success\n                sum_radii = -result.fun\n                if sum_radii > best_sum:\n                    best_sum = sum_radii\n                    best_result = result\n        except:\n            continue\n    \n    if best_result is None:\n        # Fallback to initial configuration\n        x0 = create_initial_config(0)\n        best_result = type('obj', (object,), {'x': x0})()\n    \n    # Extract solution\n    x_opt = best_result.x\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        centers[i, 0] = x_opt[3*i]\n        centers[i, 1] = x_opt[3*i + 1]\n        radii[i] = x_opt[3*i + 2]\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n\nCOMBINE THE BEST ELEMENTS:\n1. Use multiple initial configs: 5x5+1, 5x6, corner-edge-interior\n2. Run SLSQP with high iterations (500+)\n3. Use 20+ restarts with perturbations\n4. Keep the best result across all\n5. Final cleanup to ensure validity\n\nReturn complete Python code.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    \n    def create_initial_config_grid(seed=0):\n        \"\"\"5x5 grid + 1 extra point\"\"\"\n        np.random.seed(seed)\n        grid_size = 5\n        x = np.linspace(0.1, 0.9, grid_size)\n        y = np.linspace(0.1, 0.9, grid_size)\n        xv, yv = np.meshgrid(x, y)\n        centers = np.vstack([xv.ravel(), yv.ravel()]).T\n        centers = np.vstack([centers, [[0.5, 0.5]]])\n        centers += np.random.normal(0, 0.02, centers.shape)\n        centers = np.clip(centers, 0.05, 0.95)\n        radii = np.full(n, 0.08)\n        return np.concatenate([centers.flatten(), radii])\n    \n    def create_initial_config_rect(seed=0):\n        \"\"\"5x6 rectangular grid\"\"\"\n        np.random.seed(seed)\n        positions = []\n        for i in range(5):\n            for j in range(6):\n                if len(positions) >= n:\n                    break\n                x = (i + 0.5) / 5\n                y = (j + 0.5) / 6\n                positions.append([x, y])\n        positions = np.array(positions[:n])\n        positions += np.random.randn(n, 2) * 0.02\n        positions = np.clip(positions, 0.05, 0.95)\n        radii = np.full(n, 0.08)\n        return np.concatenate([positions.flatten(), radii])\n    \n    def create_initial_config_structured(seed=0):\n        \"\"\"Corner-edge-interior structure\"\"\"\n        np.random.seed(seed)\n        centers = []\n        radii = []\n        \n        # 4 corner circles\n        r_corner = 0.15\n        corners = [(r_corner, r_corner), (1-r_corner, r_corner),\n                   (r_corner, 1-r_corner), (1-r_corner, 1-r_corner)]\n        for c in corners:\n            centers.append(c)\n            radii.append(r_corner)\n        \n        # 8 edge circles\n        r_edge = 0.10\n        edges = [(0.5, r_edge), (0.5, 1-r_edge),\n                 (r_edge, 0.5), (1-r_edge, 0.5),\n                 (0.25, r_edge), (0.75, r_edge),\n                 (r_edge, 0.25), (r_edge, 0.75)]\n        for c in edges:\n            centers.append(c)\n            radii.append(r_edge)\n        \n        # Fill remaining with interior circles\n        r_small = 0.08\n        remaining = n - len(centers)\n        for i in range(remaining):\n            angle = 2 * np.pi * i / remaining\n            radius_pos = 0.3 + 0.1 * (i % 3)\n            x = 0.5 + radius_pos * np.cos(angle)\n            y = 0.5 + radius_pos * np.sin(angle)\n            centers.append((x, y))\n            radii.append(r_small)\n        \n        centers = np.array(centers[:n])\n        radii = np.array(radii[:n])\n        centers += np.random.randn(n, 2) * 0.02\n        centers = np.clip(centers, 0.05, 0.95)\n        \n        return np.concatenate([centers.flatten(), radii])\n    \n    def objective(params):\n        \"\"\"Maximize sum of radii\"\"\"\n        radii = params[2*n:]\n        return -np.sum(radii)\n    \n    def constraints_func(params):\n        \"\"\"All inequality constraints: g(x) >= 0\"\"\"\n        centers = params[:2*n].reshape((n, 2))\n        radii = params[2*n:]\n        cons = []\n        \n        # Boundary constraints\n        for i in range(n):\n            cons.append(centers[i, 0] - radii[i])  # left\n            cons.append(1.0 - centers[i, 0] - radii[i])  # right\n            cons.append(centers[i, 1] - radii[i])  # bottom\n            cons.append(1.0 - centers[i, 1] - radii[i])  # top\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                cons.append(dist - (radii[i] + radii[j]))\n        \n        return np.array(cons)\n    \n    # Bounds\n    bounds = [(0, 1)] * (2*n) + [(0.001, 0.5)] * n\n    \n    best_result = None\n    best_sum = -np.inf\n    \n    # Try multiple initialization strategies with restarts\n    init_funcs = [create_initial_config_grid, create_initial_config_rect, \n                  create_initial_config_structured]\n    \n    for init_func in init_funcs:\n        for seed in range(10):\n            x0 = init_func(seed)\n            \n            # Add perturbation for diversity (except first trial)\n            if seed > 0:\n                x0[:2*n] += np.random.uniform(-0.05, 0.05, 2*n)\n                x0[2*n:] += np.random.uniform(-0.02, 0.02, n)\n                x0 = np.clip(x0, [b[0] for b in bounds], [b[1] for b in bounds])\n            \n            try:\n                result = minimize(\n                    objective,\n                    x0,\n                    method='SLSQP',\n                    bounds=bounds,\n                    constraints={'type': 'ineq', 'fun': constraints_func},\n                    options={'maxiter': 500, 'ftol': 1e-9}\n                )\n                \n                sum_radii = -result.fun\n                if sum_radii > best_sum:\n                    best_sum = sum_radii\n                    best_result = result\n            except:\n                continue\n    \n    # Extract best solution\n    if best_result is None:\n        x0 = create_initial_config_grid(0)\n        best_result = type('obj', (object,), {'x': x0})()\n    \n    final_params = best_result.x\n    best_centers = final_params[:2*n].reshape((n, 2))\n    best_radii = final_params[2*n:]\n    \n    # Final cleanup: ensure all constraints are satisfied\n    for i in range(n):\n        # Boundary constraints\n        max_r = min(best_centers[i, 0], 1 - best_centers[i, 0],\n                    best_centers[i, 1], 1 - best_centers[i, 1])\n        best_radii[i] = min(best_radii[i], max_r)\n        \n        # Non-overlap constraints\n        for j in range(n):\n            if i == j:\n                continue\n            d = np.linalg.norm(best_centers[i] - best_centers[j])\n            if best_radii[i] + best_radii[j] > d:\n                # Shrink both radii proportionally\n                scale = 0.999 * d / (best_radii[i] + best_radii[j])\n                best_radii[i] *= scale\n                best_radii[j] *= scale\n    \n    best_radii = np.maximum(best_radii, 0)\n    \n    return best_centers, best_radii, np.sum(best_radii)\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-30T22:38:25.056302",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.4
  }
}