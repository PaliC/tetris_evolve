{
  "trial_id": "trial_2_13",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.spatial.distance import pdist, squareform\nimport time\n\ndef construct_packing():\n    \"\"\"\n    Ensemble approach: try multiple initialization strategies and optimization methods.\n    Return the best packing found.\n    \"\"\"\n    \n    def check_constraints(centers, radii):\n        \"\"\"Check if packing is valid\"\"\"\n        n = len(centers)\n        \n        # Check boundaries\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n                centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n                return False\n        \n        # Check overlaps\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-6:\n                    return False\n        \n        return True\n    \n    def compute_max_radii(centers):\n        \"\"\"Compute maximum radii for given centers\"\"\"\n        n = len(centers)\n        radii = np.zeros(n)\n        \n        for i in range(n):\n            # Distance to boundaries\n            max_r = min(centers[i, 0], 1 - centers[i, 0],\n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, (dist - radii[j]) / 2 if radii[j] > 0 else dist / 2)\n            \n            radii[i] = max(0, max_r)\n        \n        # Iterative refinement\n        for _ in range(10):\n            for i in range(n):\n                max_r = min(centers[i, 0], 1 - centers[i, 0],\n                           centers[i, 1], 1 - centers[i, 1])\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        max_r = min(max_r, dist - radii[j])\n                radii[i] = max(0, max_r)\n        \n        return radii\n    \n    def objective(x, n):\n        \"\"\"Objective: minimize negative sum of radii\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_max_radii(centers)\n        return -np.sum(radii)\n    \n    def optimize_packing(centers_init, method='SLSQP', maxiter=500):\n        \"\"\"Optimize packing from initial centers\"\"\"\n        n = len(centers_init)\n        x0 = centers_init.flatten()\n        \n        # Bounds: all centers in [0, 1] x [0, 1]\n        bounds = [(0, 1)] * (2 * n)\n        \n        result = minimize(\n            lambda x: objective(x, n),\n            x0,\n            method=method,\n            bounds=bounds,\n            options={'maxiter': maxiter, 'ftol': 1e-9}\n        )\n        \n        centers = result.x.reshape(n, 2)\n        radii = compute_max_radii(centers)\n        return centers, radii, np.sum(radii)\n    \n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0\n    \n    start_time = time.time()\n    time_limit = 280  # Leave some buffer\n    \n    strategies = []\n    \n    # Strategy 1: Grid-based initialization\n    def grid_init():\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(centers) < n:\n                    x = (i + 0.5) / grid_size\n                    y = (j + 0.5) / grid_size\n                    centers.append([x, y])\n        return np.array(centers[:n])\n    \n    strategies.append(('Grid', grid_init))\n    \n    # Strategy 2: Hexagonal lattice\n    def hex_init():\n        centers = []\n        rows = 6\n        for row in range(rows):\n            cols = 5 if row % 2 == 0 else 4\n            for col in range(cols):\n                if len(centers) < n:\n                    x = (col + 0.5 + (0.25 if row % 2 == 1 else 0)) / 5\n                    y = (row + 0.5) / 6\n                    centers.append([x, y])\n        return np.array(centers[:n])\n    \n    strategies.append(('Hexagonal', hex_init))\n    \n    # Strategy 3: Corner/edge/interior\n    def corner_edge_init():\n        centers = []\n        # Corners\n        margin = 0.1\n        corners = [[margin, margin], [1-margin, margin], \n                  [margin, 1-margin], [1-margin, 1-margin]]\n        centers.extend(corners)\n        \n        # Edges\n        for i in range(4):\n            x = margin + i * (1 - 2*margin) / 3\n            centers.append([x, margin])\n            centers.append([x, 1-margin])\n        \n        for i in range(4):\n            y = margin + i * (1 - 2*margin) / 3\n            centers.append([margin, y])\n            centers.append([1-margin, y])\n        \n        # Fill interior\n        while len(centers) < n:\n            centers.append([0.3 + 0.4*np.random.rand(), \n                          0.3 + 0.4*np.random.rand()])\n        \n        return np.array(centers[:n])\n    \n    strategies.append(('Corner-Edge', corner_edge_init))\n    \n    # Strategy 4: Random with multiple restarts\n    def random_init():\n        return np.random.rand(n, 2)\n    \n    # Run each strategy\n    for strategy_name, init_func in strategies:\n        if time.time() - start_time > time_limit:\n            break\n        \n        # Multiple restarts for each strategy\n        restarts = 3 if strategy_name == 'Random' else 2\n        \n        for restart in range(restarts):\n            if time.time() - start_time > time_limit:\n                break\n            \n            try:\n                centers_init = init_func()\n                centers, radii, sum_radii = optimize_packing(centers_init, maxiter=300)\n                \n                if check_constraints(centers, radii) and sum_radii > best_sum:\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n                    best_sum = sum_radii\n                    print(f\"{strategy_name} restart {restart}: {sum_radii:.6f}\")\n            except:\n                pass\n    \n    # Additional random restarts with remaining time\n    while time.time() - start_time < time_limit:\n        try:\n            centers_init = np.random.rand(n, 2)\n            centers, radii, sum_radii = optimize_packing(centers_init, maxiter=200)\n            \n            if check_constraints(centers, radii) and sum_radii > best_sum:\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                best_sum = sum_radii\n                print(f\"Random extra: {sum_radii:.6f}\")\n        except:\n            pass\n    \n    if best_centers is None:\n        # Fallback: simple grid\n        best_centers = grid_init()\n        best_radii = compute_max_radii(best_centers)\n        best_sum = np.sum(best_radii)\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 300.0094449520111,
    "error": "Timeout after 300s"
  },
  "prompt": "Circle packing: Pack 26 circles in unit square [0,1]x[0,1], maximize sum of radii. Target: 2.636\n\nENSEMBLE approach - run ALL methods, keep best:\n\n1. 5x5 grid + SLSQP\n2. Hexagonal lattice + SLSQP\n3. Random positions + physics + SLSQP\n4. Corner/edge/interior + SLSQP\n\nRun each with multiple restarts, return best overall.\n\nBudget time carefully (total < 300s).\n\nReturn complete Python code.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.spatial.distance import pdist, squareform\nimport time\n\ndef construct_packing():\n    \"\"\"\n    Ensemble approach: try multiple initialization strategies and optimization methods.\n    Return the best packing found.\n    \"\"\"\n    \n    def check_constraints(centers, radii):\n        \"\"\"Check if packing is valid\"\"\"\n        n = len(centers)\n        \n        # Check boundaries\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n                centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n                return False\n        \n        # Check overlaps\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-6:\n                    return False\n        \n        return True\n    \n    def compute_max_radii(centers):\n        \"\"\"Compute maximum radii for given centers\"\"\"\n        n = len(centers)\n        radii = np.zeros(n)\n        \n        for i in range(n):\n            # Distance to boundaries\n            max_r = min(centers[i, 0], 1 - centers[i, 0],\n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, (dist - radii[j]) / 2 if radii[j] > 0 else dist / 2)\n            \n            radii[i] = max(0, max_r)\n        \n        # Iterative refinement\n        for _ in range(10):\n            for i in range(n):\n                max_r = min(centers[i, 0], 1 - centers[i, 0],\n                           centers[i, 1], 1 - centers[i, 1])\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        max_r = min(max_r, dist - radii[j])\n                radii[i] = max(0, max_r)\n        \n        return radii\n    \n    def objective(x, n):\n        \"\"\"Objective: minimize negative sum of radii\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_max_radii(centers)\n        return -np.sum(radii)\n    \n    def optimize_packing(centers_init, method='SLSQP', maxiter=500):\n        \"\"\"Optimize packing from initial centers\"\"\"\n        n = len(centers_init)\n        x0 = centers_init.flatten()\n        \n        # Bounds: all centers in [0, 1] x [0, 1]\n        bounds = [(0, 1)] * (2 * n)\n        \n        result = minimize(\n            lambda x: objective(x, n),\n            x0,\n            method=method,\n            bounds=bounds,\n            options={'maxiter': maxiter, 'ftol': 1e-9}\n        )\n        \n        centers = result.x.reshape(n, 2)\n        radii = compute_max_radii(centers)\n        return centers, radii, np.sum(radii)\n    \n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0\n    \n    start_time = time.time()\n    time_limit = 280  # Leave some buffer\n    \n    strategies = []\n    \n    # Strategy 1: Grid-based initialization\n    def grid_init():\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(centers) < n:\n                    x = (i + 0.5) / grid_size\n                    y = (j + 0.5) / grid_size\n                    centers.append([x, y])\n        return np.array(centers[:n])\n    \n    strategies.append(('Grid', grid_init))\n    \n    # Strategy 2: Hexagonal lattice\n    def hex_init():\n        centers = []\n        rows = 6\n        for row in range(rows):\n            cols = 5 if row % 2 == 0 else 4\n            for col in range(cols):\n                if len(centers) < n:\n                    x = (col + 0.5 + (0.25 if row % 2 == 1 else 0)) / 5\n                    y = (row + 0.5) / 6\n                    centers.append([x, y])\n        return np.array(centers[:n])\n    \n    strategies.append(('Hexagonal', hex_init))\n    \n    # Strategy 3: Corner/edge/interior\n    def corner_edge_init():\n        centers = []\n        # Corners\n        margin = 0.1\n        corners = [[margin, margin], [1-margin, margin], \n                  [margin, 1-margin], [1-margin, 1-margin]]\n        centers.extend(corners)\n        \n        # Edges\n        for i in range(4):\n            x = margin + i * (1 - 2*margin) / 3\n            centers.append([x, margin])\n            centers.append([x, 1-margin])\n        \n        for i in range(4):\n            y = margin + i * (1 - 2*margin) / 3\n            centers.append([margin, y])\n            centers.append([1-margin, y])\n        \n        # Fill interior\n        while len(centers) < n:\n            centers.append([0.3 + 0.4*np.random.rand(), \n                          0.3 + 0.4*np.random.rand()])\n        \n        return np.array(centers[:n])\n    \n    strategies.append(('Corner-Edge', corner_edge_init))\n    \n    # Strategy 4: Random with multiple restarts\n    def random_init():\n        return np.random.rand(n, 2)\n    \n    # Run each strategy\n    for strategy_name, init_func in strategies:\n        if time.time() - start_time > time_limit:\n            break\n        \n        # Multiple restarts for each strategy\n        restarts = 3 if strategy_name == 'Random' else 2\n        \n        for restart in range(restarts):\n            if time.time() - start_time > time_limit:\n                break\n            \n            try:\n                centers_init = init_func()\n                centers, radii, sum_radii = optimize_packing(centers_init, maxiter=300)\n                \n                if check_constraints(centers, radii) and sum_radii > best_sum:\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n                    best_sum = sum_radii\n                    print(f\"{strategy_name} restart {restart}: {sum_radii:.6f}\")\n            except:\n                pass\n    \n    # Additional random restarts with remaining time\n    while time.time() - start_time < time_limit:\n        try:\n            centers_init = np.random.rand(n, 2)\n            centers, radii, sum_radii = optimize_packing(centers_init, maxiter=200)\n            \n            if check_constraints(centers, radii) and sum_radii > best_sum:\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                best_sum = sum_radii\n                print(f\"Random extra: {sum_radii:.6f}\")\n        except:\n            pass\n    \n    if best_centers is None:\n        # Fallback: simple grid\n        best_centers = grid_init()\n        best_radii = compute_max_radii(best_centers)\n        best_sum = np.sum(best_radii)\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-30T22:43:03.636585",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.4
  }
}