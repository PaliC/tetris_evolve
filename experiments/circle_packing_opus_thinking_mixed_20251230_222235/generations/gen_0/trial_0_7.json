{
  "trial_id": "trial_0_7",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import basinhopping, minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Pack 26 circles in unit square using basin hopping optimization.\n    Returns (centers, radii, sum_radii)\n    \"\"\"\n    n_circles = 26\n    \n    def compute_optimal_radii(centers):\n        \"\"\"Given centers, compute maximum radii that satisfy constraints.\"\"\"\n        centers = centers.reshape(n_circles, 2)\n        \n        # Compute pairwise distances\n        dists = squareform(pdist(centers))\n        np.fill_diagonal(dists, np.inf)\n        \n        # For each circle, maximum radius is limited by:\n        # 1. Distance to boundaries\n        # 2. Half distance to nearest neighbor\n        radii = np.zeros(n_circles)\n        \n        for i in range(n_circles):\n            # Distance to boundaries\n            r_max = min(centers[i, 0], 1 - centers[i, 0],\n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles (half of minimum distance)\n            min_dist = np.min(dists[i])\n            r_max = min(r_max, min_dist / 2)\n            \n            radii[i] = max(0, r_max)\n        \n        return radii\n    \n    def objective(x):\n        \"\"\"Objective to minimize: negative sum of radii.\"\"\"\n        centers = x.reshape(n_circles, 2)\n        \n        # Check if centers are in bounds\n        if np.any(centers < 0) or np.any(centers > 1):\n            return 1e10\n        \n        radii = compute_optimal_radii(x)\n        return -np.sum(radii)\n    \n    class RandomDisplacementBounds:\n        \"\"\"Custom step-taking routine with bounds.\"\"\"\n        def __init__(self, stepsize=0.1):\n            self.stepsize = stepsize\n        \n        def __call__(self, x):\n            \"\"\"Take a random step within bounds.\"\"\"\n            x_new = x + np.random.uniform(-self.stepsize, self.stepsize, x.shape)\n            # Reflect at boundaries\n            x_new = np.clip(x_new, 0.01, 0.99)\n            return x_new\n    \n    def try_optimization(seed):\n        \"\"\"Run basin hopping with a specific random seed.\"\"\"\n        np.random.seed(seed)\n        \n        # Initialize with grid + small random perturbation\n        grid_size = int(np.ceil(np.sqrt(n_circles)))\n        centers_init = []\n        \n        for i in range(n_circles):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size + np.random.uniform(-0.05, 0.05)\n            y = (row + 0.5) / grid_size + np.random.uniform(-0.05, 0.05)\n            centers_init.append([x, y])\n        \n        x0 = np.array(centers_init).flatten()\n        x0 = np.clip(x0, 0.01, 0.99)\n        \n        # Custom step-taking\n        take_step = RandomDisplacementBounds(stepsize=0.15)\n        \n        # Basin hopping\n        result = basinhopping(\n            objective,\n            x0,\n            niter=200,\n            T=1.0,\n            stepsize=0.15,\n            take_step=take_step,\n            minimizer_kwargs={\n                'method': 'L-BFGS-B',\n                'bounds': [(0.01, 0.99)] * (2 * n_circles)\n            },\n            seed=seed\n        )\n        \n        return result\n    \n    # Try multiple random starts\n    best_result = None\n    best_score = float('inf')\n    \n    # Try different seeds\n    for seed in [42, 123, 456, 789, 1011, 2023, 3141, 5926]:\n        result = try_optimization(seed)\n        if result.fun < best_score:\n            best_score = result.fun\n            best_result = result\n    \n    # Extract best solution\n    centers = best_result.x.reshape(n_circles, 2)\n    radii = compute_optimal_radii(best_result.x)\n    sum_radii = np.sum(radii)\n    \n    # Try a hexagonal packing as alternative\n    hex_centers = []\n    spacing = 1.0 / 6\n    for row in range(6):\n        y = (row + 0.5) * spacing\n        offset = (spacing / 2) if row % 2 == 1 else 0\n        for col in range(5 if row % 2 == 1 else 6):\n            x = (col + 0.5) * spacing + offset\n            if len(hex_centers) < n_circles:\n                hex_centers.append([x, y])\n    \n    hex_centers = np.array(hex_centers[:n_circles])\n    hex_radii = compute_optimal_radii(hex_centers.flatten())\n    hex_sum = np.sum(hex_radii)\n    \n    # Return best of basin hopping or hexagonal\n    if hex_sum > sum_radii:\n        return hex_centers, hex_radii, hex_sum\n    else:\n        return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 300.013060092926,
    "error": "Timeout after 300s"
  },
  "prompt": "Circle packing: Pack 26 circles in unit square [0,1]x[0,1], maximize sum of radii.\n\nUse BASIN HOPPING (scipy.optimize.basinhopping):\n1. Combines random jumps with local minimization\n2. Can escape local minima\n3. For each center configuration, compute optimal radii\n\nTry multiple starting configurations.\n\nReturn complete Python code:\nimport numpy as np\nfrom scipy.optimize import basinhopping\n\ndef construct_packing():\n    # Returns (centers, radii, sum_radii)\n    ...\n\ndef run_packing():\n    return construct_packing()",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import basinhopping, minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Pack 26 circles in unit square using basin hopping optimization.\n    Returns (centers, radii, sum_radii)\n    \"\"\"\n    n_circles = 26\n    \n    def compute_optimal_radii(centers):\n        \"\"\"Given centers, compute maximum radii that satisfy constraints.\"\"\"\n        centers = centers.reshape(n_circles, 2)\n        \n        # Compute pairwise distances\n        dists = squareform(pdist(centers))\n        np.fill_diagonal(dists, np.inf)\n        \n        # For each circle, maximum radius is limited by:\n        # 1. Distance to boundaries\n        # 2. Half distance to nearest neighbor\n        radii = np.zeros(n_circles)\n        \n        for i in range(n_circles):\n            # Distance to boundaries\n            r_max = min(centers[i, 0], 1 - centers[i, 0],\n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles (half of minimum distance)\n            min_dist = np.min(dists[i])\n            r_max = min(r_max, min_dist / 2)\n            \n            radii[i] = max(0, r_max)\n        \n        return radii\n    \n    def objective(x):\n        \"\"\"Objective to minimize: negative sum of radii.\"\"\"\n        centers = x.reshape(n_circles, 2)\n        \n        # Check if centers are in bounds\n        if np.any(centers < 0) or np.any(centers > 1):\n            return 1e10\n        \n        radii = compute_optimal_radii(x)\n        return -np.sum(radii)\n    \n    class RandomDisplacementBounds:\n        \"\"\"Custom step-taking routine with bounds.\"\"\"\n        def __init__(self, stepsize=0.1):\n            self.stepsize = stepsize\n        \n        def __call__(self, x):\n            \"\"\"Take a random step within bounds.\"\"\"\n            x_new = x + np.random.uniform(-self.stepsize, self.stepsize, x.shape)\n            # Reflect at boundaries\n            x_new = np.clip(x_new, 0.01, 0.99)\n            return x_new\n    \n    def try_optimization(seed):\n        \"\"\"Run basin hopping with a specific random seed.\"\"\"\n        np.random.seed(seed)\n        \n        # Initialize with grid + small random perturbation\n        grid_size = int(np.ceil(np.sqrt(n_circles)))\n        centers_init = []\n        \n        for i in range(n_circles):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size + np.random.uniform(-0.05, 0.05)\n            y = (row + 0.5) / grid_size + np.random.uniform(-0.05, 0.05)\n            centers_init.append([x, y])\n        \n        x0 = np.array(centers_init).flatten()\n        x0 = np.clip(x0, 0.01, 0.99)\n        \n        # Custom step-taking\n        take_step = RandomDisplacementBounds(stepsize=0.15)\n        \n        # Basin hopping\n        result = basinhopping(\n            objective,\n            x0,\n            niter=200,\n            T=1.0,\n            stepsize=0.15,\n            take_step=take_step,\n            minimizer_kwargs={\n                'method': 'L-BFGS-B',\n                'bounds': [(0.01, 0.99)] * (2 * n_circles)\n            },\n            seed=seed\n        )\n        \n        return result\n    \n    # Try multiple random starts\n    best_result = None\n    best_score = float('inf')\n    \n    # Try different seeds\n    for seed in [42, 123, 456, 789, 1011, 2023, 3141, 5926]:\n        result = try_optimization(seed)\n        if result.fun < best_score:\n            best_score = result.fun\n            best_result = result\n    \n    # Extract best solution\n    centers = best_result.x.reshape(n_circles, 2)\n    radii = compute_optimal_radii(best_result.x)\n    sum_radii = np.sum(radii)\n    \n    # Try a hexagonal packing as alternative\n    hex_centers = []\n    spacing = 1.0 / 6\n    for row in range(6):\n        y = (row + 0.5) * spacing\n        offset = (spacing / 2) if row % 2 == 1 else 0\n        for col in range(5 if row % 2 == 1 else 6):\n            x = (col + 0.5) * spacing + offset\n            if len(hex_centers) < n_circles:\n                hex_centers.append([x, y])\n    \n    hex_centers = np.array(hex_centers[:n_circles])\n    hex_radii = compute_optimal_radii(hex_centers.flatten())\n    hex_sum = np.sum(hex_radii)\n    \n    # Return best of basin hopping or hexagonal\n    if hex_sum > sum_radii:\n        return hex_centers, hex_radii, hex_sum\n    else:\n        return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-30T22:29:26.190092",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.5
  }
}