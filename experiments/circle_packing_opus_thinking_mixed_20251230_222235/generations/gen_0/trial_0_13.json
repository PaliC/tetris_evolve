{
  "trial_id": "trial_0_13",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    np.random.seed(42)\n    \n    n_circles = 26\n    pop_size = 200\n    n_generations = 1000\n    elite_size = 20\n    mutation_rate = 0.15\n    \n    def compute_radii(centers):\n        \"\"\"Compute maximum radii for given centers\"\"\"\n        radii = np.zeros(n_circles)\n        \n        for i in range(n_circles):\n            # Distance to boundaries\n            x, y = centers[i]\n            r_max = min(x, 1-x, y, 1-y)\n            \n            # Distance to other circles\n            for j in range(n_circles):\n                if i != j:\n                    dist = np.sqrt((centers[i,0] - centers[j,0])**2 + \n                                 (centers[i,1] - centers[j,1])**2)\n                    r_max = min(r_max, (dist - radii[j]) / 2 if radii[j] > 0 \n                               else dist / 2)\n            \n            radii[i] = max(0, r_max)\n        \n        return radii\n    \n    def fitness(centers):\n        \"\"\"Compute fitness with penalty for invalid configurations\"\"\"\n        radii = compute_radii(centers)\n        \n        # Check validity\n        valid = True\n        \n        # Check boundaries\n        for i in range(n_circles):\n            x, y, r = centers[i,0], centers[i,1], radii[i]\n            if x - r < -1e-9 or x + r > 1 + 1e-9 or y - r < -1e-9 or y + r > 1 + 1e-9:\n                valid = False\n                break\n        \n        # Check overlaps\n        if valid:\n            for i in range(n_circles):\n                for j in range(i+1, n_circles):\n                    dist = np.sqrt((centers[i,0] - centers[j,0])**2 + \n                                 (centers[i,1] - centers[j,1])**2)\n                    if dist < radii[i] + radii[j] - 1e-9:\n                        valid = False\n                        break\n                if not valid:\n                    break\n        \n        sum_radii = np.sum(radii)\n        \n        if not valid:\n            sum_radii *= 0.5  # Penalty\n        \n        return sum_radii, radii\n    \n    def initialize_population():\n        \"\"\"Create initial population with various strategies\"\"\"\n        population = []\n        \n        # Grid-based initialization\n        for _ in range(pop_size // 3):\n            grid_size = int(np.ceil(np.sqrt(n_circles)))\n            centers = np.zeros((n_circles, 2))\n            idx = 0\n            for i in range(grid_size):\n                for j in range(grid_size):\n                    if idx >= n_circles:\n                        break\n                    centers[idx] = [\n                        (i + 0.5 + np.random.uniform(-0.2, 0.2)) / grid_size,\n                        (j + 0.5 + np.random.uniform(-0.2, 0.2)) / grid_size\n                    ]\n                    idx += 1\n            population.append(centers)\n        \n        # Hexagonal packing inspired\n        for _ in range(pop_size // 3):\n            centers = np.zeros((n_circles, 2))\n            idx = 0\n            rows = 6\n            for row in range(rows):\n                cols = 5 if row % 2 == 0 else 4\n                for col in range(cols):\n                    if idx >= n_circles:\n                        break\n                    x = (col + 0.5) / 5 + (0.1 if row % 2 == 1 else 0)\n                    y = (row + 0.5) / 6\n                    centers[idx] = [\n                        x + np.random.uniform(-0.05, 0.05),\n                        y + np.random.uniform(-0.05, 0.05)\n                    ]\n                    idx += 1\n            population.append(centers)\n        \n        # Random initialization\n        for _ in range(pop_size - 2 * (pop_size // 3)):\n            centers = np.random.uniform(0.1, 0.9, (n_circles, 2))\n            population.append(centers)\n        \n        return population\n    \n    def crossover(parent1, parent2):\n        \"\"\"Blend crossover\"\"\"\n        alpha = 0.5\n        child = alpha * parent1 + (1 - alpha) * parent2\n        child = np.clip(child, 0, 1)\n        return child\n    \n    def mutate(centers):\n        \"\"\"Mutate by adding Gaussian noise\"\"\"\n        if np.random.rand() < mutation_rate:\n            mutation = np.random.normal(0, 0.05, centers.shape)\n            centers = centers + mutation\n            centers = np.clip(centers, 0, 1)\n        return centers\n    \n    # Initialize\n    population = initialize_population()\n    best_centers = None\n    best_radii = None\n    best_sum = 0\n    \n    # Evolution\n    for gen in range(n_generations):\n        # Evaluate fitness\n        fitness_scores = []\n        radii_list = []\n        \n        for centers in population:\n            score, radii = fitness(centers)\n            fitness_scores.append(score)\n            radii_list.append(radii)\n        \n        fitness_scores = np.array(fitness_scores)\n        \n        # Track best\n        best_idx = np.argmax(fitness_scores)\n        if fitness_scores[best_idx] > best_sum:\n            best_sum = fitness_scores[best_idx]\n            best_centers = population[best_idx].copy()\n            best_radii = radii_list[best_idx].copy()\n        \n        # Selection\n        sorted_indices = np.argsort(fitness_scores)[::-1]\n        elite = [population[i].copy() for i in sorted_indices[:elite_size]]\n        \n        # Create new population\n        new_population = elite.copy()\n        \n        while len(new_population) < pop_size:\n            # Tournament selection\n            idx1, idx2 = np.random.choice(elite_size, 2, replace=False)\n            parent1 = elite[idx1]\n            parent2 = elite[idx2]\n            \n            # Crossover\n            child = crossover(parent1, parent2)\n            \n            # Mutation\n            child = mutate(child)\n            \n            new_population.append(child)\n        \n        population = new_population\n        \n        # Adaptive mutation\n        if gen % 100 == 0 and gen > 0:\n            mutation_rate = max(0.05, mutation_rate * 0.95)\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 1.7030332143193592,
    "eval_time": 174.45884490013123,
    "error": null
  },
  "prompt": "Circle packing: Pack 26 circles in unit square [0,1]x[0,1], maximize sum of radii.\n\nUse GENETIC ALGORITHM:\n1. Population of packing configurations\n2. Fitness = sum of radii (penalize invalid)\n3. Selection, crossover, mutation\n4. Run for many generations\n\nEncoding: each individual is 26 (x,y) pairs, compute radii from constraints.\n\nReturn complete Python code:\nimport numpy as np\n\ndef construct_packing():\n    # Returns (centers, radii, sum_radii)\n    ...\n\ndef run_packing():\n    return construct_packing()",
  "response": "```python\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    np.random.seed(42)\n    \n    n_circles = 26\n    pop_size = 200\n    n_generations = 1000\n    elite_size = 20\n    mutation_rate = 0.15\n    \n    def compute_radii(centers):\n        \"\"\"Compute maximum radii for given centers\"\"\"\n        radii = np.zeros(n_circles)\n        \n        for i in range(n_circles):\n            # Distance to boundaries\n            x, y = centers[i]\n            r_max = min(x, 1-x, y, 1-y)\n            \n            # Distance to other circles\n            for j in range(n_circles):\n                if i != j:\n                    dist = np.sqrt((centers[i,0] - centers[j,0])**2 + \n                                 (centers[i,1] - centers[j,1])**2)\n                    r_max = min(r_max, (dist - radii[j]) / 2 if radii[j] > 0 \n                               else dist / 2)\n            \n            radii[i] = max(0, r_max)\n        \n        return radii\n    \n    def fitness(centers):\n        \"\"\"Compute fitness with penalty for invalid configurations\"\"\"\n        radii = compute_radii(centers)\n        \n        # Check validity\n        valid = True\n        \n        # Check boundaries\n        for i in range(n_circles):\n            x, y, r = centers[i,0], centers[i,1], radii[i]\n            if x - r < -1e-9 or x + r > 1 + 1e-9 or y - r < -1e-9 or y + r > 1 + 1e-9:\n                valid = False\n                break\n        \n        # Check overlaps\n        if valid:\n            for i in range(n_circles):\n                for j in range(i+1, n_circles):\n                    dist = np.sqrt((centers[i,0] - centers[j,0])**2 + \n                                 (centers[i,1] - centers[j,1])**2)\n                    if dist < radii[i] + radii[j] - 1e-9:\n                        valid = False\n                        break\n                if not valid:\n                    break\n        \n        sum_radii = np.sum(radii)\n        \n        if not valid:\n            sum_radii *= 0.5  # Penalty\n        \n        return sum_radii, radii\n    \n    def initialize_population():\n        \"\"\"Create initial population with various strategies\"\"\"\n        population = []\n        \n        # Grid-based initialization\n        for _ in range(pop_size // 3):\n            grid_size = int(np.ceil(np.sqrt(n_circles)))\n            centers = np.zeros((n_circles, 2))\n            idx = 0\n            for i in range(grid_size):\n                for j in range(grid_size):\n                    if idx >= n_circles:\n                        break\n                    centers[idx] = [\n                        (i + 0.5 + np.random.uniform(-0.2, 0.2)) / grid_size,\n                        (j + 0.5 + np.random.uniform(-0.2, 0.2)) / grid_size\n                    ]\n                    idx += 1\n            population.append(centers)\n        \n        # Hexagonal packing inspired\n        for _ in range(pop_size // 3):\n            centers = np.zeros((n_circles, 2))\n            idx = 0\n            rows = 6\n            for row in range(rows):\n                cols = 5 if row % 2 == 0 else 4\n                for col in range(cols):\n                    if idx >= n_circles:\n                        break\n                    x = (col + 0.5) / 5 + (0.1 if row % 2 == 1 else 0)\n                    y = (row + 0.5) / 6\n                    centers[idx] = [\n                        x + np.random.uniform(-0.05, 0.05),\n                        y + np.random.uniform(-0.05, 0.05)\n                    ]\n                    idx += 1\n            population.append(centers)\n        \n        # Random initialization\n        for _ in range(pop_size - 2 * (pop_size // 3)):\n            centers = np.random.uniform(0.1, 0.9, (n_circles, 2))\n            population.append(centers)\n        \n        return population\n    \n    def crossover(parent1, parent2):\n        \"\"\"Blend crossover\"\"\"\n        alpha = 0.5\n        child = alpha * parent1 + (1 - alpha) * parent2\n        child = np.clip(child, 0, 1)\n        return child\n    \n    def mutate(centers):\n        \"\"\"Mutate by adding Gaussian noise\"\"\"\n        if np.random.rand() < mutation_rate:\n            mutation = np.random.normal(0, 0.05, centers.shape)\n            centers = centers + mutation\n            centers = np.clip(centers, 0, 1)\n        return centers\n    \n    # Initialize\n    population = initialize_population()\n    best_centers = None\n    best_radii = None\n    best_sum = 0\n    \n    # Evolution\n    for gen in range(n_generations):\n        # Evaluate fitness\n        fitness_scores = []\n        radii_list = []\n        \n        for centers in population:\n            score, radii = fitness(centers)\n            fitness_scores.append(score)\n            radii_list.append(radii)\n        \n        fitness_scores = np.array(fitness_scores)\n        \n        # Track best\n        best_idx = np.argmax(fitness_scores)\n        if fitness_scores[best_idx] > best_sum:\n            best_sum = fitness_scores[best_idx]\n            best_centers = population[best_idx].copy()\n            best_radii = radii_list[best_idx].copy()\n        \n        # Selection\n        sorted_indices = np.argsort(fitness_scores)[::-1]\n        elite = [population[i].copy() for i in sorted_indices[:elite_size]]\n        \n        # Create new population\n        new_population = elite.copy()\n        \n        while len(new_population) < pop_size:\n            # Tournament selection\n            idx1, idx2 = np.random.choice(elite_size, 2, replace=False)\n            parent1 = elite[idx1]\n            parent2 = elite[idx2]\n            \n            # Crossover\n            child = crossover(parent1, parent2)\n            \n            # Mutation\n            child = mutate(child)\n            \n            new_population.append(child)\n        \n        population = new_population\n        \n        # Adaptive mutation\n        if gen % 100 == 0 and gen > 0:\n            mutation_rate = max(0.05, mutation_rate * 0.95)\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-30T22:27:29.704329",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.6
  }
}