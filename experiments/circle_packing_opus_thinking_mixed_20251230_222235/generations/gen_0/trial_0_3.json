{
  "trial_id": "trial_0_3",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    np.random.seed(42)\n    \n    n_circles = 26\n    \n    # Initial configuration: grid-like placement with small radii\n    def initialize_state():\n        grid_size = int(np.ceil(np.sqrt(n_circles)))\n        centers = []\n        for i in range(n_circles):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            centers.append([x, y])\n        centers = np.array(centers)\n        \n        # Start with small radii\n        radii = np.full(n_circles, 0.05)\n        \n        # Repair to make valid\n        centers, radii = repair_state(centers, radii)\n        return centers, radii\n    \n    def repair_state(centers, radii):\n        \"\"\"Repair state to satisfy constraints\"\"\"\n        # Clip centers to be inside square with margin\n        max_iter = 100\n        for _ in range(max_iter):\n            # Ensure circles inside square\n            for i in range(n_circles):\n                centers[i, 0] = np.clip(centers[i, 0], radii[i], 1 - radii[i])\n                centers[i, 1] = np.clip(centers[i, 1], radii[i], 1 - radii[i])\n            \n            # Fix overlaps by reducing radii\n            valid = True\n            for i in range(n_circles):\n                for j in range(i + 1, n_circles):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    if dist < radii[i] + radii[j]:\n                        # Reduce both radii proportionally\n                        overlap = radii[i] + radii[j] - dist\n                        total_r = radii[i] + radii[j]\n                        if total_r > 0:\n                            radii[i] -= overlap * radii[i] / total_r * 1.01\n                            radii[j] -= overlap * radii[j] / total_r * 1.01\n                        radii[i] = max(0.001, radii[i])\n                        radii[j] = max(0.001, radii[j])\n                        valid = False\n            \n            if valid:\n                break\n        \n        radii = np.maximum(radii, 0.001)\n        return centers, radii\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if configuration is valid\"\"\"\n        # Check inside square\n        for i in range(n_circles):\n            if (centers[i, 0] - radii[i] < -1e-6 or centers[i, 0] + radii[i] > 1 + 1e-6 or\n                centers[i, 1] - radii[i] < -1e-6 or centers[i, 1] + radii[i] > 1 + 1e-6):\n                return False\n        \n        # Check no overlaps\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-6:\n                    return False\n        \n        return True\n    \n    def objective(centers, radii):\n        \"\"\"Objective with penalty for constraint violations\"\"\"\n        sum_radii = np.sum(radii)\n        \n        penalty = 0.0\n        # Penalty for being outside square\n        for i in range(n_circles):\n            penalty += max(0, radii[i] - centers[i, 0]) * 10\n            penalty += max(0, radii[i] - centers[i, 1]) * 10\n            penalty += max(0, centers[i, 0] + radii[i] - 1) * 10\n            penalty += max(0, centers[i, 1] + radii[i] - 1) * 10\n        \n        # Penalty for overlaps\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    penalty += overlap * 20\n        \n        return sum_radii - penalty\n    \n    # Initialize\n    centers, radii = initialize_state()\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_score = objective(centers, radii)\n    \n    # Simulated annealing\n    temperature = 1.0\n    cooling_rate = 0.9995\n    n_iterations = 15000\n    \n    for iteration in range(n_iterations):\n        # Perturb state\n        new_centers = centers.copy()\n        new_radii = radii.copy()\n        \n        # Random perturbation\n        if np.random.rand() < 0.7:\n            # Move a circle\n            idx = np.random.randint(n_circles)\n            new_centers[idx] += np.random.randn(2) * 0.05 * temperature\n        else:\n            # Adjust radii\n            idx = np.random.randint(n_circles)\n            new_radii[idx] += np.random.randn() * 0.02 * temperature\n        \n        # Repair\n        new_centers, new_radii = repair_state(new_centers, new_radii)\n        \n        # Evaluate\n        new_score = objective(new_centers, new_radii)\n        \n        # Accept or reject\n        delta = new_score - objective(centers, radii)\n        if delta > 0 or np.random.rand() < np.exp(delta / temperature):\n            centers = new_centers\n            radii = new_radii\n            \n            if new_score > best_score:\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                best_score = new_score\n        \n        temperature *= cooling_rate\n    \n    # Local optimization: maximize radii given fixed centers\n    def optimize_radii(centers):\n        \"\"\"Maximize radii for fixed centers\"\"\"\n        radii = np.zeros(n_circles)\n        \n        for i in range(n_circles):\n            # Max radius constrained by square\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            \n            # Max radius constrained by other circles\n            for j in range(n_circles):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, dist - radii[j])\n            \n            radii[i] = max(0, max_r)\n        \n        return radii\n    \n    # Iteratively optimize radii\n    for _ in range(50):\n        best_radii = optimize_radii(best_centers)\n    \n    sum_radii = np.sum(best_radii)\n    \n    return best_centers, best_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.166666666666667,
    "eval_time": 23.984489917755127,
    "error": null
  },
  "prompt": "Circle packing: Pack 26 circles in unit square [0,1]x[0,1], maximize sum of radii.\n\nUse SIMULATED ANNEALING:\n1. State: 26 (x, y, r) tuples\n2. Objective: Maximize sum(radii)\n3. Moves: Perturbations to positions and radii\n4. Handle constraints via penalty or repair\n5. After SA, local optimization to maximize radii\n\nRun 10000+ iterations. Start with valid configuration.\n\nReturn complete Python code:\nimport numpy as np\n\ndef construct_packing():\n    # Returns (centers, radii, sum_radii)\n    ...\n\ndef run_packing():\n    return construct_packing()",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    np.random.seed(42)\n    \n    n_circles = 26\n    \n    # Initial configuration: grid-like placement with small radii\n    def initialize_state():\n        grid_size = int(np.ceil(np.sqrt(n_circles)))\n        centers = []\n        for i in range(n_circles):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            centers.append([x, y])\n        centers = np.array(centers)\n        \n        # Start with small radii\n        radii = np.full(n_circles, 0.05)\n        \n        # Repair to make valid\n        centers, radii = repair_state(centers, radii)\n        return centers, radii\n    \n    def repair_state(centers, radii):\n        \"\"\"Repair state to satisfy constraints\"\"\"\n        # Clip centers to be inside square with margin\n        max_iter = 100\n        for _ in range(max_iter):\n            # Ensure circles inside square\n            for i in range(n_circles):\n                centers[i, 0] = np.clip(centers[i, 0], radii[i], 1 - radii[i])\n                centers[i, 1] = np.clip(centers[i, 1], radii[i], 1 - radii[i])\n            \n            # Fix overlaps by reducing radii\n            valid = True\n            for i in range(n_circles):\n                for j in range(i + 1, n_circles):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    if dist < radii[i] + radii[j]:\n                        # Reduce both radii proportionally\n                        overlap = radii[i] + radii[j] - dist\n                        total_r = radii[i] + radii[j]\n                        if total_r > 0:\n                            radii[i] -= overlap * radii[i] / total_r * 1.01\n                            radii[j] -= overlap * radii[j] / total_r * 1.01\n                        radii[i] = max(0.001, radii[i])\n                        radii[j] = max(0.001, radii[j])\n                        valid = False\n            \n            if valid:\n                break\n        \n        radii = np.maximum(radii, 0.001)\n        return centers, radii\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if configuration is valid\"\"\"\n        # Check inside square\n        for i in range(n_circles):\n            if (centers[i, 0] - radii[i] < -1e-6 or centers[i, 0] + radii[i] > 1 + 1e-6 or\n                centers[i, 1] - radii[i] < -1e-6 or centers[i, 1] + radii[i] > 1 + 1e-6):\n                return False\n        \n        # Check no overlaps\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-6:\n                    return False\n        \n        return True\n    \n    def objective(centers, radii):\n        \"\"\"Objective with penalty for constraint violations\"\"\"\n        sum_radii = np.sum(radii)\n        \n        penalty = 0.0\n        # Penalty for being outside square\n        for i in range(n_circles):\n            penalty += max(0, radii[i] - centers[i, 0]) * 10\n            penalty += max(0, radii[i] - centers[i, 1]) * 10\n            penalty += max(0, centers[i, 0] + radii[i] - 1) * 10\n            penalty += max(0, centers[i, 1] + radii[i] - 1) * 10\n        \n        # Penalty for overlaps\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    penalty += overlap * 20\n        \n        return sum_radii - penalty\n    \n    # Initialize\n    centers, radii = initialize_state()\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_score = objective(centers, radii)\n    \n    # Simulated annealing\n    temperature = 1.0\n    cooling_rate = 0.9995\n    n_iterations = 15000\n    \n    for iteration in range(n_iterations):\n        # Perturb state\n        new_centers = centers.copy()\n        new_radii = radii.copy()\n        \n        # Random perturbation\n        if np.random.rand() < 0.7:\n            # Move a circle\n            idx = np.random.randint(n_circles)\n            new_centers[idx] += np.random.randn(2) * 0.05 * temperature\n        else:\n            # Adjust radii\n            idx = np.random.randint(n_circles)\n            new_radii[idx] += np.random.randn() * 0.02 * temperature\n        \n        # Repair\n        new_centers, new_radii = repair_state(new_centers, new_radii)\n        \n        # Evaluate\n        new_score = objective(new_centers, new_radii)\n        \n        # Accept or reject\n        delta = new_score - objective(centers, radii)\n        if delta > 0 or np.random.rand() < np.exp(delta / temperature):\n            centers = new_centers\n            radii = new_radii\n            \n            if new_score > best_score:\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                best_score = new_score\n        \n        temperature *= cooling_rate\n    \n    # Local optimization: maximize radii given fixed centers\n    def optimize_radii(centers):\n        \"\"\"Maximize radii for fixed centers\"\"\"\n        radii = np.zeros(n_circles)\n        \n        for i in range(n_circles):\n            # Max radius constrained by square\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            \n            # Max radius constrained by other circles\n            for j in range(n_circles):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, dist - radii[j])\n            \n            radii[i] = max(0, max_r)\n        \n        return radii\n    \n    # Iteratively optimize radii\n    for _ in range(50):\n        best_radii = optimize_radii(best_centers)\n    \n    sum_radii = np.sum(best_radii)\n    \n    return best_centers, best_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-30T22:24:52.472715",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.5
  }
}