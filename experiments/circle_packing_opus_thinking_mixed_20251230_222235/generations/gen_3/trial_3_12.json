{
  "trial_id": "trial_3_12",
  "generation": 3,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    n = 26\n    \n    def unpack(params):\n        centers = params[:2*n].reshape(n, 2)\n        radii = params[2*n:]\n        return centers, radii\n    \n    def pack(centers, radii):\n        return np.concatenate([centers.flatten(), radii])\n    \n    def objective_and_grad(params):\n        centers, radii = unpack(params)\n        obj = -np.sum(radii)\n        grad = np.zeros(3*n)\n        grad[2*n:] = -1.0  # gradient w.r.t. radii\n        return obj, grad\n    \n    def boundary_constraints(params):\n        centers, radii = unpack(params)\n        constraints = []\n        # x - r >= 0, y - r >= 0, 1 - x - r >= 0, 1 - y - r >= 0\n        constraints.extend(centers[:, 0] - radii)  # left\n        constraints.extend(centers[:, 1] - radii)  # bottom\n        constraints.extend(1 - centers[:, 0] - radii)  # right\n        constraints.extend(1 - centers[:, 1] - radii)  # top\n        return np.array(constraints)\n    \n    def boundary_jacobian(params):\n        centers, radii = unpack(params)\n        jac = np.zeros((4*n, 3*n))\n        for i in range(n):\n            # left: x_i - r_i >= 0\n            jac[i, 2*i] = 1.0  # d/dx_i\n            jac[i, 2*n + i] = -1.0  # d/dr_i\n            # bottom: y_i - r_i >= 0\n            jac[n + i, 2*i + 1] = 1.0  # d/dy_i\n            jac[n + i, 2*n + i] = -1.0  # d/dr_i\n            # right: 1 - x_i - r_i >= 0\n            jac[2*n + i, 2*i] = -1.0  # d/dx_i\n            jac[2*n + i, 2*n + i] = -1.0  # d/dr_i\n            # top: 1 - y_i - r_i >= 0\n            jac[3*n + i, 2*i + 1] = -1.0  # d/dy_i\n            jac[3*n + i, 2*n + i] = -1.0  # d/dr_i\n        return jac\n    \n    def overlap_constraints(params):\n        centers, radii = unpack(params)\n        constraints = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                dist = np.sqrt(dx*dx + dy*dy)\n                constraints.append(dist - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    def overlap_jacobian(params):\n        centers, radii = unpack(params)\n        num_pairs = n * (n - 1) // 2\n        jac = np.zeros((num_pairs, 3*n))\n        idx = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                dist = np.sqrt(dx*dx + dy*dy)\n                if dist > 1e-12:\n                    # d(dist)/d(x_i) = dx/dist\n                    jac[idx, 2*i] = dx / dist\n                    jac[idx, 2*i + 1] = dy / dist\n                    jac[idx, 2*j] = -dx / dist\n                    jac[idx, 2*j + 1] = -dy / dist\n                jac[idx, 2*n + i] = -1.0\n                jac[idx, 2*n + j] = -1.0\n                idx += 1\n        return jac\n    \n    def generate_initial(seed):\n        np.random.seed(seed)\n        # Grid-based initialization\n        grid_size = int(np.ceil(np.sqrt(n)))\n        spacing = 1.0 / (grid_size + 1)\n        centers = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(centers) < n:\n                    x = (i + 1) * spacing + np.random.uniform(-0.02, 0.02)\n                    y = (j + 1) * spacing + np.random.uniform(-0.02, 0.02)\n                    centers.append([x, y])\n        centers = np.array(centers[:n])\n        centers = np.clip(centers, 0.05, 0.95)\n        \n        # Initialize radii based on available space\n        radii = np.ones(n) * 0.03\n        return pack(centers, radii)\n    \n    bounds = [(0.01, 0.99)] * (2*n) + [(1e-6, 0.5)] * n\n    \n    constraints = [\n        {'type': 'ineq', 'fun': boundary_constraints, 'jac': boundary_jacobian},\n        {'type': 'ineq', 'fun': overlap_constraints, 'jac': overlap_jacobian}\n    ]\n    \n    best_result = None\n    best_sum = -np.inf\n    \n    # Try multiple starting points\n    for seed in range(30):\n        x0 = generate_initial(seed)\n        \n        try:\n            result = minimize(\n                objective_and_grad,\n                x0,\n                method='SLSQP',\n                jac=True,\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 2000, 'ftol': 1e-12}\n            )\n            \n            if result.success or True:  # Check even if not converged\n                centers, radii = unpack(result.x)\n                radii = np.maximum(radii, 0)\n                current_sum = np.sum(radii)\n                \n                # Verify constraints\n                boundary_ok = np.all(boundary_constraints(result.x) >= -1e-6)\n                overlap_ok = np.all(overlap_constraints(result.x) >= -1e-6)\n                \n                if boundary_ok and overlap_ok and current_sum > best_sum:\n                    best_sum = current_sum\n                    best_result = result.x.copy()\n        except:\n            continue\n    \n    # Local refinement with tighter tolerances\n    if best_result is not None:\n        for _ in range(5):\n            try:\n                result = minimize(\n                    objective_and_grad,\n                    best_result,\n                    method='SLSQP',\n                    jac=True,\n                    bounds=bounds,\n                    constraints=constraints,\n                    options={'maxiter': 3000, 'ftol': 1e-14}\n                )\n                centers, radii = unpack(result.x)\n                radii = np.maximum(radii, 0)\n                current_sum = np.sum(radii)\n                \n                boundary_ok = np.all(boundary_constraints(result.x) >= -1e-6)\n                overlap_ok = np.all(overlap_constraints(result.x) >= -1e-6)\n                \n                if boundary_ok and overlap_ok and current_sum > best_sum:\n                    best_sum = current_sum\n                    best_result = result.x.copy()\n            except:\n                break\n    \n    centers, radii = unpack(best_result)\n    radii = np.maximum(radii, 0)\n    \n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.60731426739155,
    "eval_time": 3.6894519329071045,
    "error": null
  },
  "prompt": "Circle packing: Pack 26 circles in unit square [0,1]x[0,1], maximize sum of radii. Target: 2.636\n\nUse ANALYTIC GRADIENTS for faster optimization:\n\nFor objective -sum(radii), the gradient w.r.t. center positions can be computed.\nscipy SLSQP can use jacobians.\n\nProvide jacobian to minimize():\n```python\ndef objective_with_grad(params):\n    # returns (objective_value, gradient)\n```\n\nUse method='SLSQP' with jac=True or provide separate jac function.\n\nThis enables much faster convergence.\n\nReturn complete Python code.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    n = 26\n    \n    def unpack(params):\n        centers = params[:2*n].reshape(n, 2)\n        radii = params[2*n:]\n        return centers, radii\n    \n    def pack(centers, radii):\n        return np.concatenate([centers.flatten(), radii])\n    \n    def objective_and_grad(params):\n        centers, radii = unpack(params)\n        obj = -np.sum(radii)\n        grad = np.zeros(3*n)\n        grad[2*n:] = -1.0  # gradient w.r.t. radii\n        return obj, grad\n    \n    def boundary_constraints(params):\n        centers, radii = unpack(params)\n        constraints = []\n        # x - r >= 0, y - r >= 0, 1 - x - r >= 0, 1 - y - r >= 0\n        constraints.extend(centers[:, 0] - radii)  # left\n        constraints.extend(centers[:, 1] - radii)  # bottom\n        constraints.extend(1 - centers[:, 0] - radii)  # right\n        constraints.extend(1 - centers[:, 1] - radii)  # top\n        return np.array(constraints)\n    \n    def boundary_jacobian(params):\n        centers, radii = unpack(params)\n        jac = np.zeros((4*n, 3*n))\n        for i in range(n):\n            # left: x_i - r_i >= 0\n            jac[i, 2*i] = 1.0  # d/dx_i\n            jac[i, 2*n + i] = -1.0  # d/dr_i\n            # bottom: y_i - r_i >= 0\n            jac[n + i, 2*i + 1] = 1.0  # d/dy_i\n            jac[n + i, 2*n + i] = -1.0  # d/dr_i\n            # right: 1 - x_i - r_i >= 0\n            jac[2*n + i, 2*i] = -1.0  # d/dx_i\n            jac[2*n + i, 2*n + i] = -1.0  # d/dr_i\n            # top: 1 - y_i - r_i >= 0\n            jac[3*n + i, 2*i + 1] = -1.0  # d/dy_i\n            jac[3*n + i, 2*n + i] = -1.0  # d/dr_i\n        return jac\n    \n    def overlap_constraints(params):\n        centers, radii = unpack(params)\n        constraints = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                dist = np.sqrt(dx*dx + dy*dy)\n                constraints.append(dist - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    def overlap_jacobian(params):\n        centers, radii = unpack(params)\n        num_pairs = n * (n - 1) // 2\n        jac = np.zeros((num_pairs, 3*n))\n        idx = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                dist = np.sqrt(dx*dx + dy*dy)\n                if dist > 1e-12:\n                    # d(dist)/d(x_i) = dx/dist\n                    jac[idx, 2*i] = dx / dist\n                    jac[idx, 2*i + 1] = dy / dist\n                    jac[idx, 2*j] = -dx / dist\n                    jac[idx, 2*j + 1] = -dy / dist\n                jac[idx, 2*n + i] = -1.0\n                jac[idx, 2*n + j] = -1.0\n                idx += 1\n        return jac\n    \n    def generate_initial(seed):\n        np.random.seed(seed)\n        # Grid-based initialization\n        grid_size = int(np.ceil(np.sqrt(n)))\n        spacing = 1.0 / (grid_size + 1)\n        centers = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(centers) < n:\n                    x = (i + 1) * spacing + np.random.uniform(-0.02, 0.02)\n                    y = (j + 1) * spacing + np.random.uniform(-0.02, 0.02)\n                    centers.append([x, y])\n        centers = np.array(centers[:n])\n        centers = np.clip(centers, 0.05, 0.95)\n        \n        # Initialize radii based on available space\n        radii = np.ones(n) * 0.03\n        return pack(centers, radii)\n    \n    bounds = [(0.01, 0.99)] * (2*n) + [(1e-6, 0.5)] * n\n    \n    constraints = [\n        {'type': 'ineq', 'fun': boundary_constraints, 'jac': boundary_jacobian},\n        {'type': 'ineq', 'fun': overlap_constraints, 'jac': overlap_jacobian}\n    ]\n    \n    best_result = None\n    best_sum = -np.inf\n    \n    # Try multiple starting points\n    for seed in range(30):\n        x0 = generate_initial(seed)\n        \n        try:\n            result = minimize(\n                objective_and_grad,\n                x0,\n                method='SLSQP',\n                jac=True,\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 2000, 'ftol': 1e-12}\n            )\n            \n            if result.success or True:  # Check even if not converged\n                centers, radii = unpack(result.x)\n                radii = np.maximum(radii, 0)\n                current_sum = np.sum(radii)\n                \n                # Verify constraints\n                boundary_ok = np.all(boundary_constraints(result.x) >= -1e-6)\n                overlap_ok = np.all(overlap_constraints(result.x) >= -1e-6)\n                \n                if boundary_ok and overlap_ok and current_sum > best_sum:\n                    best_sum = current_sum\n                    best_result = result.x.copy()\n        except:\n            continue\n    \n    # Local refinement with tighter tolerances\n    if best_result is not None:\n        for _ in range(5):\n            try:\n                result = minimize(\n                    objective_and_grad,\n                    best_result,\n                    method='SLSQP',\n                    jac=True,\n                    bounds=bounds,\n                    constraints=constraints,\n                    options={'maxiter': 3000, 'ftol': 1e-14}\n                )\n                centers, radii = unpack(result.x)\n                radii = np.maximum(radii, 0)\n                current_sum = np.sum(radii)\n                \n                boundary_ok = np.all(boundary_constraints(result.x) >= -1e-6)\n                overlap_ok = np.all(overlap_constraints(result.x) >= -1e-6)\n                \n                if boundary_ok and overlap_ok and current_sum > best_sum:\n                    best_sum = current_sum\n                    best_result = result.x.copy()\n            except:\n                break\n    \n    centers, radii = unpack(best_result)\n    radii = np.maximum(radii, 0)\n    \n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-30T22:44:45.486881",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-opus-4.5",
    "temperature": 0.4
  }
}