{
  "trial_id": "trial_1_13",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a packing of 26 circles in [0,1]x[0,1] to maximize sum of radii.\n    Uses optimization with strategic initialization.\n    \"\"\"\n    \n    def compute_radii(positions):\n        \"\"\"Compute maximum radius for each circle given positions.\"\"\"\n        n = len(positions)\n        radii = np.zeros(n)\n        \n        for i in range(n):\n            x, y = positions[i]\n            \n            # Distance to walls\n            max_r = min(x, y, 1-x, 1-y)\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(positions[i] - positions[j])\n                    max_r = min(max_r, (dist - radii[j]) / 2 if radii[j] > 0 else dist)\n            \n            radii[i] = max(0, max_r)\n        \n        return radii\n    \n    def objective(x):\n        \"\"\"Negative sum of radii (to minimize).\"\"\"\n        positions = x.reshape(-1, 2)\n        radii = compute_radii(positions)\n        return -np.sum(radii)\n    \n    def constraint_inside(x):\n        \"\"\"All circles inside [0,1]x[0,1].\"\"\"\n        positions = x.reshape(-1, 2)\n        radii = compute_radii(positions)\n        constraints = []\n        for i in range(len(positions)):\n            constraints.extend([\n                positions[i, 0] - radii[i],  # left\n                positions[i, 1] - radii[i],  # bottom\n                1 - positions[i, 0] - radii[i],  # right\n                1 - positions[i, 1] - radii[i]   # top\n            ])\n        return np.array(constraints)\n    \n    def constraint_no_overlap(x):\n        \"\"\"No overlaps between circles.\"\"\"\n        positions = x.reshape(-1, 2)\n        radii = compute_radii(positions)\n        constraints = []\n        n = len(positions)\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(positions[i] - positions[j])\n                constraints.append(dist - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    # Strategic initialization: hexagonal-like pattern with corner emphasis\n    n = 26\n    \n    # Start with a grid-like pattern, then optimize\n    # Use 5x6 grid with some adjustments\n    init_positions = []\n    \n    # 4 corner circles (larger spacing from corners)\n    corner_offset = 0.19\n    corners = [\n        [corner_offset, corner_offset],\n        [1-corner_offset, corner_offset],\n        [corner_offset, 1-corner_offset],\n        [1-corner_offset, 1-corner_offset]\n    ]\n    init_positions.extend(corners)\n    \n    # Edge circles (8 total: 2 per edge excluding corners)\n    edge_positions = [\n        [0.5, 0.15],  # bottom\n        [0.5, 0.85],  # top\n        [0.15, 0.5],  # left\n        [0.85, 0.5],  # right\n        [0.33, 0.12],  # bottom-left\n        [0.67, 0.12],  # bottom-right\n        [0.33, 0.88],  # top-left\n        [0.67, 0.88],  # top-right\n    ]\n    init_positions.extend(edge_positions)\n    \n    # Interior circles (14 total)\n    # Hexagonal-like arrangement\n    interior = []\n    for row in range(3):\n        y = 0.35 + row * 0.15\n        if row % 2 == 0:\n            xs = [0.35, 0.5, 0.65]\n        else:\n            xs = [0.42, 0.58]\n        for x in xs:\n            interior.append([x, y])\n    \n    # Add more interior circles\n    interior.extend([\n        [0.5, 0.5],\n        [0.35, 0.65],\n        [0.65, 0.65],\n        [0.42, 0.28],\n        [0.58, 0.28],\n        [0.42, 0.72],\n        [0.58, 0.72],\n    ])\n    \n    init_positions.extend(interior[:14])\n    init_positions = np.array(init_positions[:26])\n    \n    # Add small random perturbations\n    np.random.seed(42)\n    init_positions += np.random.randn(26, 2) * 0.01\n    init_positions = np.clip(init_positions, 0.1, 0.9)\n    \n    # Optimize\n    x0 = init_positions.flatten()\n    \n    constraints = [\n        {'type': 'ineq', 'fun': constraint_inside},\n        {'type': 'ineq', 'fun': constraint_no_overlap}\n    ]\n    \n    bounds = [(0.05, 0.95) for _ in range(52)]  # 26 circles * 2 coordinates\n    \n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n    \n    # Extract final positions and compute radii\n    final_positions = result.x.reshape(-1, 2)\n    final_radii = compute_radii(final_positions)\n    sum_radii = np.sum(final_radii)\n    \n    return final_positions, final_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 1.9137213795113253,
    "eval_time": 30.44721484184265,
    "error": null
  },
  "prompt": "Circle packing: Pack 26 circles in unit square [0,1]x[0,1], maximize sum of radii. Target: 2.636\n\nThe optimal packing for n=26 likely follows established patterns from packing literature.\n\nTypical optimal configurations have:\n- Circles of varying sizes (not uniform)\n- Circles touching walls and each other (many contacts)\n- Near-hexagonal local structure in interior\n- Larger circles in corners\n\nCreate a configuration that mimics known optimal packings:\n1. 4 corner circles (largest, radius ~0.18-0.21)\n2. ~8 edge circles (medium)\n3. ~14 interior circles (varying sizes)\n\nCompute exact tangent positions where circles touch.\nThen optimize to maximize sum.\n\nReturn complete Python code.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a packing of 26 circles in [0,1]x[0,1] to maximize sum of radii.\n    Uses optimization with strategic initialization.\n    \"\"\"\n    \n    def compute_radii(positions):\n        \"\"\"Compute maximum radius for each circle given positions.\"\"\"\n        n = len(positions)\n        radii = np.zeros(n)\n        \n        for i in range(n):\n            x, y = positions[i]\n            \n            # Distance to walls\n            max_r = min(x, y, 1-x, 1-y)\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(positions[i] - positions[j])\n                    max_r = min(max_r, (dist - radii[j]) / 2 if radii[j] > 0 else dist)\n            \n            radii[i] = max(0, max_r)\n        \n        return radii\n    \n    def objective(x):\n        \"\"\"Negative sum of radii (to minimize).\"\"\"\n        positions = x.reshape(-1, 2)\n        radii = compute_radii(positions)\n        return -np.sum(radii)\n    \n    def constraint_inside(x):\n        \"\"\"All circles inside [0,1]x[0,1].\"\"\"\n        positions = x.reshape(-1, 2)\n        radii = compute_radii(positions)\n        constraints = []\n        for i in range(len(positions)):\n            constraints.extend([\n                positions[i, 0] - radii[i],  # left\n                positions[i, 1] - radii[i],  # bottom\n                1 - positions[i, 0] - radii[i],  # right\n                1 - positions[i, 1] - radii[i]   # top\n            ])\n        return np.array(constraints)\n    \n    def constraint_no_overlap(x):\n        \"\"\"No overlaps between circles.\"\"\"\n        positions = x.reshape(-1, 2)\n        radii = compute_radii(positions)\n        constraints = []\n        n = len(positions)\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(positions[i] - positions[j])\n                constraints.append(dist - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    # Strategic initialization: hexagonal-like pattern with corner emphasis\n    n = 26\n    \n    # Start with a grid-like pattern, then optimize\n    # Use 5x6 grid with some adjustments\n    init_positions = []\n    \n    # 4 corner circles (larger spacing from corners)\n    corner_offset = 0.19\n    corners = [\n        [corner_offset, corner_offset],\n        [1-corner_offset, corner_offset],\n        [corner_offset, 1-corner_offset],\n        [1-corner_offset, 1-corner_offset]\n    ]\n    init_positions.extend(corners)\n    \n    # Edge circles (8 total: 2 per edge excluding corners)\n    edge_positions = [\n        [0.5, 0.15],  # bottom\n        [0.5, 0.85],  # top\n        [0.15, 0.5],  # left\n        [0.85, 0.5],  # right\n        [0.33, 0.12],  # bottom-left\n        [0.67, 0.12],  # bottom-right\n        [0.33, 0.88],  # top-left\n        [0.67, 0.88],  # top-right\n    ]\n    init_positions.extend(edge_positions)\n    \n    # Interior circles (14 total)\n    # Hexagonal-like arrangement\n    interior = []\n    for row in range(3):\n        y = 0.35 + row * 0.15\n        if row % 2 == 0:\n            xs = [0.35, 0.5, 0.65]\n        else:\n            xs = [0.42, 0.58]\n        for x in xs:\n            interior.append([x, y])\n    \n    # Add more interior circles\n    interior.extend([\n        [0.5, 0.5],\n        [0.35, 0.65],\n        [0.65, 0.65],\n        [0.42, 0.28],\n        [0.58, 0.28],\n        [0.42, 0.72],\n        [0.58, 0.72],\n    ])\n    \n    init_positions.extend(interior[:14])\n    init_positions = np.array(init_positions[:26])\n    \n    # Add small random perturbations\n    np.random.seed(42)\n    init_positions += np.random.randn(26, 2) * 0.01\n    init_positions = np.clip(init_positions, 0.1, 0.9)\n    \n    # Optimize\n    x0 = init_positions.flatten()\n    \n    constraints = [\n        {'type': 'ineq', 'fun': constraint_inside},\n        {'type': 'ineq', 'fun': constraint_no_overlap}\n    ]\n    \n    bounds = [(0.05, 0.95) for _ in range(52)]  # 26 circles * 2 coordinates\n    \n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n    \n    # Extract final positions and compute radii\n    final_positions = result.x.reshape(-1, 2)\n    final_radii = compute_radii(final_positions)\n    sum_radii = np.sum(final_radii)\n    \n    return final_positions, final_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-30T22:31:47.212074",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.4
  }
}