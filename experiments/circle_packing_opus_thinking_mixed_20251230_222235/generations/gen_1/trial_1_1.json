{
  "trial_id": "trial_1_1",
  "generation": 1,
  "parent_id": "trial_0_6",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n_circles = 26\n    \n    def strategic_initialization():\n        \"\"\"Strategic initial placement: corners, edges, interior\"\"\"\n        centers = []\n        radii = []\n        \n        # Corner circles (4 circles, tangent to 2 walls)\n        corner_r = 0.12\n        corners = [(corner_r, corner_r), (1-corner_r, corner_r), \n                   (corner_r, 1-corner_r), (1-corner_r, 1-corner_r)]\n        for c in corners:\n            centers.append(c)\n            radii.append(corner_r)\n        \n        # Primary edge circles (4 circles, centered on edges)\n        edge_r = 0.10\n        centers.extend([(0.5, edge_r), (0.5, 1-edge_r), \n                       (edge_r, 0.5), (1-edge_r, 0.5)])\n        radii.extend([edge_r] * 4)\n        \n        # Secondary edge circles (8 circles)\n        small_edge_r = 0.08\n        positions = [\n            (0.25, small_edge_r), (0.75, small_edge_r),  # bottom\n            (0.25, 1-small_edge_r), (0.75, 1-small_edge_r),  # top\n            (small_edge_r, 0.25), (small_edge_r, 0.75),  # left\n            (1-small_edge_r, 0.25), (1-small_edge_r, 0.75),  # right\n        ]\n        centers.extend(positions)\n        radii.extend([small_edge_r] * 8)\n        \n        # Interior circles (10 circles)\n        interior_r = 0.07\n        interior_pos = [\n            (0.5, 0.5),  # center\n            (0.3, 0.3), (0.7, 0.3), (0.3, 0.7), (0.7, 0.7),  # inner corners\n            (0.5, 0.3), (0.5, 0.7), (0.3, 0.5), (0.7, 0.5),  # inner edges\n            (0.4, 0.6),  # filler\n        ]\n        centers.extend(interior_pos)\n        radii.extend([interior_r] * 10)\n        \n        return np.array(centers), np.array(radii)\n    \n    def repair_state(centers, radii, aggressive=False):\n        \"\"\"Repair state to satisfy all constraints\"\"\"\n        max_iter = 200 if aggressive else 100\n        \n        for iteration in range(max_iter):\n            # Ensure circles inside square\n            for i in range(n_circles):\n                centers[i, 0] = np.clip(centers[i, 0], radii[i], 1 - radii[i])\n                centers[i, 1] = np.clip(centers[i, 1], radii[i], 1 - radii[i])\n            \n            # Fix overlaps\n            valid = True\n            for i in range(n_circles):\n                for j in range(i + 1, n_circles):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    overlap = radii[i] + radii[j] - dist\n                    if overlap > 1e-9:\n                        # Reduce both radii proportionally\n                        total_r = radii[i] + radii[j]\n                        if total_r > 0:\n                            shrink_factor = 0.999 if aggressive else 1.01\n                            radii[i] -= overlap * radii[i] / total_r * shrink_factor\n                            radii[j] -= overlap * radii[j] / total_r * shrink_factor\n                        radii[i] = max(0.001, radii[i])\n                        radii[j] = max(0.001, radii[j])\n                        valid = False\n            \n            if valid:\n                break\n        \n        radii = np.maximum(radii, 0.001)\n        return centers, radii\n    \n    def objective_with_penalty(centers, radii):\n        \"\"\"Objective with penalties for constraint violations\"\"\"\n        sum_radii = np.sum(radii)\n        penalty = 0.0\n        \n        # Penalty for being outside square\n        for i in range(n_circles):\n            penalty += max(0, radii[i] - centers[i, 0]) * 100\n            penalty += max(0, radii[i] - centers[i, 1]) * 100\n            penalty += max(0, centers[i, 0] + radii[i] - 1) * 100\n            penalty += max(0, centers[i, 1] + radii[i] - 1) * 100\n        \n        # Penalty for overlaps\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    penalty += overlap * 50\n        \n        return sum_radii - penalty\n    \n    def simulated_annealing(init_centers, init_radii):\n        \"\"\"Enhanced simulated annealing\"\"\"\n        centers = init_centers.copy()\n        radii = init_radii.copy()\n        \n        best_centers = centers.copy()\n        best_radii = radii.copy()\n        best_score = objective_with_penalty(centers, radii)\n        \n        temperature = 2.0\n        cooling_rate = 0.9997\n        n_iterations = 25000\n        \n        for iteration in range(n_iterations):\n            new_centers = centers.copy()\n            new_radii = radii.copy()\n            \n            # Adaptive perturbation\n            temp_factor = temperature / 2.0\n            \n            if np.random.rand() < 0.5:\n                # Move a circle\n                idx = np.random.randint(n_circles)\n                new_centers[idx] += np.random.randn(2) * 0.04 * temp_factor\n            elif np.random.rand() < 0.7:\n                # Adjust radius\n                idx = np.random.randint(n_circles)\n                new_radii[idx] += np.random.randn() * 0.03 * temp_factor\n            else:\n                # Swap two circles\n                i, j = np.random.choice(n_circles, 2, replace=False)\n                new_centers[i], new_centers[j] = new_centers[j].copy(), new_centers[i].copy()\n                new_radii[i], new_radii[j] = new_radii[j], new_radii[i]\n            \n            # Repair\n            new_centers, new_radii = repair_state(new_centers, new_radii)\n            \n            # Evaluate\n            new_score = objective_with_penalty(new_centers, new_radii)\n            current_score = objective_with_penalty(centers, radii)\n            \n            # Accept or reject\n            delta = new_score - current_score\n            if delta > 0 or np.random.rand() < np.exp(delta / temperature):\n                centers = new_centers\n                radii = new_radii\n                \n                if new_score > best_score:\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n                    best_score = new_score\n            \n            temperature *= cooling_rate\n        \n        return best_centers, best_radii\n    \n    def optimize_radii_greedy(centers):\n        \"\"\"Greedily maximize radii for fixed centers\"\"\"\n        radii = np.zeros(n_circles)\n        \n        # Sort by potential (distance to nearest boundary)\n        potentials = []\n        for i in range(n_circles):\n            pot = min(centers[i, 0], centers[i, 1], \n                     1 - centers[i, 0], 1 - centers[i, 1])\n            potentials.append((pot, i))\n        potentials.sort(reverse=True)\n        \n        for _, i in potentials:\n            # Max radius constrained by square\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            \n            # Max radius constrained by other circles\n            for j in range(n_circles):\n                if i != j and radii[j] > 0:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, dist - radii[j])\n            \n            radii[i] = max(0, max_r * 0.9999)  # Small safety margin\n        \n        return radii\n    \n    def local_optimization(centers, radii):\n        \"\"\"Aggressive local optimization using scipy\"\"\"\n        def pack_variables(c, r):\n            return np.concatenate([c.flatten(), r])\n        \n        def unpack_variables(x):\n            c = x[:2*n_circles].reshape(n_circles, 2)\n            r = x[2*n_circles:]\n            return c, r\n        \n        def objective(x):\n            _, r = unpack_variables(x)\n            return -np.sum(r)\n        \n        def constraint_func(x):\n            c, r = unpack_variables(x)\n            violations = []\n            \n            # Boundary constraints\n            for i in range(n_circles):\n                violations.append(c[i, 0] - r[i])\n                violations.append(c[i, 1] - r[i])\n                violations.append(1 - c[i, 0] - r[i])\n                violations.append(1 - c[i, 1] - r[i])\n            \n            # Non-overlap constraints\n            for i in range(n_circles):\n                for j in range(i + 1, n_circles):\n                    dist = np.linalg.norm(c[i] - c[j])\n                    violations.append(dist - r[i] - r[j])\n            \n            return np.array(violations)\n        \n        x0 = pack_variables(centers, radii)\n        bounds = [(0, 1)] * (2 * n_circles) + [(0, 0.5)] * n_circles\n        \n        constraints = {'type': 'ineq', 'fun': constraint_func}\n        \n        result = minimize(objective, x0, method='SLSQP', bounds=bounds,\n                         constraints=constraints, options={'maxiter': 1000, 'ftol': 1e-9})\n        \n        if result.success or True:  # Use result even if not fully converged\n            centers_opt, radii_opt = unpack_variables(result.x)\n            # Verify and repair\n            centers_opt, radii_opt = repair_state(centers_opt, radii_opt, aggressive=True)\n            return centers_opt, radii_opt\n        \n        return centers, radii\n    \n    # Main optimization loop\n    best_sum = 0\n    best_result = None\n    \n    for trial in range(3):\n        np.random.seed(trial * 123)\n        \n        # Initialize strategically\n        centers, radii = strategic_initialization()\n        centers, radii = repair_state(centers, radii)\n        \n        # Simulated annealing\n        centers, radii = simulated_annealing(centers, radii)\n        \n        # Iterative radii optimization\n        for _ in range(100):\n            radii = optimize_radii_greedy(centers)\n        \n        # Local optimization with scipy\n        centers, radii = local_optimization(centers, radii)\n        \n        # Final greedy radii optimization\n        for _ in range(50):\n            radii = optimize_radii_greedy(centers)\n        \n        # Final repair\n        centers, radii = repair_state(centers, radii, aggressive=True)\n        \n        sum_radii = np.sum(radii)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_result = (centers, radii, sum_radii)\n    \n    return best_result\n\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 1.422467198508312,
    "eval_time": 130.30662488937378,
    "error": null
  },
  "prompt": "Circle packing: Pack 26 circles in unit square [0,1]x[0,1], maximize sum of radii. Target: 2.636\n\nHere is a simulated annealing approach scoring 2.167:\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    np.random.seed(42)\n    \n    n_circles = 26\n    \n    # Initial configuration: grid-like placement with small radii\n    def initialize_state():\n        grid_size = int(np.ceil(np.sqrt(n_circles)))\n        centers = []\n        for i in range(n_circles):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            centers.append([x, y])\n        centers = np.array(centers)\n        \n        # Start with small radii\n        radii = np.full(n_circles, 0.05)\n        \n        # Repair to make valid\n        centers, radii = repair_state(centers, radii)\n        return centers, radii\n    \n    def repair_state(centers, radii):\n        \"\"\"Repair state to satisfy constraints\"\"\"\n        # Clip centers to be inside square with margin\n        max_iter = 100\n        for _ in range(max_iter):\n            # Ensure circles inside square\n            for i in range(n_circles):\n                centers[i, 0] = np.clip(centers[i, 0], radii[i], 1 - radii[i])\n                centers[i, 1] = np.clip(centers[i, 1], radii[i], 1 - radii[i])\n            \n            # Fix overlaps by reducing radii\n            valid = True\n            for i in range(n_circles):\n                for j in range(i + 1, n_circles):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    if dist < radii[i] + radii[j]:\n                        # Reduce both radii proportionally\n                        overlap = radii[i] + radii[j] - dist\n                        total_r = radii[i] + radii[j]\n                        if total_r > 0:\n                            radii[i] -= overlap * radii[i] / total_r * 1.01\n                            radii[j] -= overlap * radii[j] / total_r * 1.01\n                        radii[i] = max(0.001, radii[i])\n                        radii[j] = max(0.001, radii[j])\n                        valid = False\n            \n            if valid:\n                break\n        \n        radii = np.maximum(radii, 0.001)\n        return centers, radii\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if configuration is valid\"\"\"\n        # Check inside square\n        for i in range(n_circles):\n            if (centers[i, 0] - radii[i] < -1e-6 or centers[i, 0] + radii[i] > 1 + 1e-6 or\n                centers[i, 1] - radii[i] < -1e-6 or centers[i, 1] + radii[i] > 1 + 1e-6):\n                return False\n        \n        # Check no overlaps\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-6:\n                    return False\n        \n        return True\n    \n    def objective(centers, radii):\n        \"\"\"Objective with penalty for constraint violations\"\"\"\n        sum_radii = np.sum(radii)\n        \n        penalty = 0.0\n        # Penalty for being outside square\n        for i in range(n_circles):\n            penalty += max(0, radii[i] - centers[i, 0]) * 10\n            penalty += max(0, radii[i] - centers[i, 1]) * 10\n            penalty += max(0, centers[i, 0] + radii[i] - 1) * 10\n            penalty += max(0, centers[i, 1] + radii[i] - 1) * 10\n        \n        # Penalty for overlaps\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    penalty += overlap * 20\n        \n        return sum_radii - penalty\n    \n    # Initialize\n    centers, radii = initialize_state()\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_score = objective(centers, radii)\n    \n    # Simulated annealing\n    temperature = 1.0\n    cooling_rate = 0.9995\n    n_iterations = 15000\n    \n    for iteration in range(n_iterations):\n        # Perturb state\n        new_centers = centers.copy()\n        new_radii = radii.copy()\n        \n        # Random perturbation\n        if np.random.rand() < 0.7:\n            # Move a circle\n            idx = np.random.randint(n_circles)\n            new_centers[idx] += np.random.randn(2) * 0.05 * temperature\n        else:\n            # Adjust radii\n            idx = np.random.randint(n_circles)\n            new_radii[idx] += np.random.randn() * 0.02 * temperature\n        \n        # Repair\n        new_centers, new_radii = repair_state(new_centers, new_radii)\n        \n        # Evaluate\n        new_score = objective(new_centers, new_radii)\n        \n        # Accept or reject\n        delta = new_score - objective(centers, radii)\n        if delta > 0 or np.random.rand() < np.exp(delta / temperature):\n            centers = new_centers\n            radii = new_radii\n            \n            if new_score > best_score:\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                best_score = new_score\n        \n        temperature *= cooling_rate\n    \n    # Local optimization: maximize radii given fixed centers\n    def optimize_radii(centers):\n        \"\"\"Maximize radii for fixed centers\"\"\"\n        radii = np.zeros(n_circles)\n        \n        for i in range(n_circles):\n            # Max radius constrained by square\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            \n            # Max radius constrained by other circles\n            for j in range(n_circles):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, dist - radii[j])\n            \n            radii[i] = max(0, max_r)\n        \n        return radii\n    \n    # Iteratively optimize radii\n    for _ in range(50):\n        best_radii = optimize_radii(best_centers)\n    \n    sum_radii = np.sum(best_radii)\n    \n    return best_centers, best_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n\nAnd here is a better-performing approach scoring 2.290:\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\n\ndef construct_packing():\n    n_circles = 26\n    \n    # Start with a strategic initial configuration\n    # Use a combination of corner circles, edge circles, and interior circles\n    \n    def pack_circles_optimization():\n        # Initial placement strategy: grid-based with varying sizes\n        centers = []\n        radii = []\n        \n        # Corner circles (tangent to 2 walls)\n        corner_r = 0.15\n        corners = [(corner_r, corner_r), (1-corner_r, corner_r), \n                   (corner_r, 1-corner_r), (1-corner_r, 1-corner_r)]\n        for c in corners:\n            centers.append(c)\n            radii.append(corner_r)\n        \n        # Edge circles (tangent to 1 wall)\n        edge_r = 0.10\n        # Bottom edge\n        centers.append((0.5, edge_r))\n        radii.append(edge_r)\n        # Top edge\n        centers.append((0.5, 1-edge_r))\n        radii.append(edge_r)\n        # Left edge\n        centers.append((edge_r, 0.5))\n        radii.append(edge_r)\n        # Right edge\n        centers.append((1-edge_r, 0.5))\n        radii.append(edge_r)\n        \n        # More edge circles\n        small_r = 0.07\n        positions = [\n            (0.3, small_r), (0.7, small_r),  # bottom\n            (0.3, 1-small_r), (0.7, 1-small_r),  # top\n            (small_r, 0.3), (small_r, 0.7),  # left\n            (1-small_r, 0.3), (1-small_r, 0.7),  # right\n        ]\n        for p in positions:\n            centers.append(p)\n            radii.append(small_r)\n        \n        # Interior circles\n        interior_r = 0.08\n        interior_pos = [\n            (0.5, 0.5),\n            (0.3, 0.3), (0.7, 0.3), (0.3, 0.7), (0.7, 0.7),\n            (0.5, 0.3), (0.5, 0.7), (0.3, 0.5), (0.7, 0.5),\n            (0.4, 0.4),\n        ]\n        for p in interior_pos[:n_circles - len(centers)]:\n            centers.append(p)\n            radii.append(interior_r)\n        \n        return np.array(centers), np.array(radii)\n    \n    def objective(x):\n        # x contains [x1, y1, r1, x2, y2, r2, ...]\n        radii = x[2::3]\n        return -np.sum(radii)  # Negative because we minimize\n    \n    def constraint_violations(x):\n        n = len(x) // 3\n        violations = 0.0\n        \n        for i in range(n):\n            xi, yi, ri = x[3*i], x[3*i+1], x[3*i+2]\n            \n            # Boundary constraints\n            violations += max(0, ri - xi)**2\n            violations += max(0, ri - yi)**2\n            violations += max(0, xi + ri - 1)**2\n            violations += max(0, yi + ri - 1)**2\n            violations += max(0, -ri)**2\n            \n            # Non-overlap constraints\n            for j in range(i+1, n):\n                xj, yj, rj = x[3*j], x[3*j+1], x[3*j+2]\n                dist = np.sqrt((xi-xj)**2 + (yi-yj)**2)\n                violations += max(0, ri + rj - dist)**2\n        \n        return violations\n    \n    def penalized_objective(x):\n        penalty = 1e6\n        return objective(x) + penalty * constraint_violations(x)\n    \n    # Initialize\n    init_centers, init_radii = pack_circles_optimization()\n    x0 = []\n    for i in range(n_circles):\n        x0.extend([init_centers[i, 0], init_centers[i, 1], init_radii[i]])\n    x0 = np.array(x0)\n    \n    # Bounds\n    bounds = []\n    for i in range(n_circles):\n        bounds.extend([(0.01, 0.99), (0.01, 0.99), (0.01, 0.4)])\n    \n    # Optimize using L-BFGS-B with penalty method\n    result = minimize(penalized_objective, x0, method='L-BFGS-B', bounds=bounds,\n                     options={'maxiter': 5000, 'ftol': 1e-12})\n    \n    x = result.x\n    \n    # Try differential evolution for better global solution\n    def de_objective(x):\n        return penalized_objective(x)\n    \n    # Use current best as seed for local refinement\n    for _ in range(3):\n        result = minimize(penalized_objective, x, method='L-BFGS-B', bounds=bounds,\n                         options={'maxiter': 2000, 'ftol': 1e-14})\n        x = result.x\n    \n    # Extract solution\n    centers = np.zeros((n_circles, 2))\n    radii = np.zeros(n_circles)\n    for i in range(n_circles):\n        centers[i, 0] = x[3*i]\n        centers[i, 1] = x[3*i+1]\n        radii[i] = max(0, x[3*i+2])\n    \n    # Verify and fix any violations\n    for i in range(n_circles):\n        # Ensure inside bounds\n        radii[i] = min(radii[i], centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n        radii[i] = max(0, radii[i])\n    \n    # Fix overlaps by shrinking\n    for _ in range(100):\n        changed = False\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 1e-10:\n                    # Shrink both proportionally\n                    factor = dist / (radii[i] + radii[j] + 1e-10) * 0.999\n                    radii[i] *= factor\n                    radii[j] *= factor\n                    changed = True\n        if not changed:\n            break\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    # Run multiple times and take best\n    best_sum = 0\n    best_result = None\n    \n    for trial in range(5):\n        np.random.seed(trial * 42)\n        centers, radii, sum_radii = construct_packing()\n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_result = (centers, radii, sum_radii)\n    \n    return best_result\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    print(f\"Target: 2.635983099011548\")\n\nCOMBINE THESE: Use the strategic initialization from trial_0_6 but improve the SA optimization from trial_0_3:\n1. Start with corner/edge/interior placement like trial_0_6\n2. Use SA to explore with proper cooling schedule\n3. More iterations (20000+)\n4. After SA, do aggressive local optimization\n\nReturn complete working Python code.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n_circles = 26\n    \n    def strategic_initialization():\n        \"\"\"Strategic initial placement: corners, edges, interior\"\"\"\n        centers = []\n        radii = []\n        \n        # Corner circles (4 circles, tangent to 2 walls)\n        corner_r = 0.12\n        corners = [(corner_r, corner_r), (1-corner_r, corner_r), \n                   (corner_r, 1-corner_r), (1-corner_r, 1-corner_r)]\n        for c in corners:\n            centers.append(c)\n            radii.append(corner_r)\n        \n        # Primary edge circles (4 circles, centered on edges)\n        edge_r = 0.10\n        centers.extend([(0.5, edge_r), (0.5, 1-edge_r), \n                       (edge_r, 0.5), (1-edge_r, 0.5)])\n        radii.extend([edge_r] * 4)\n        \n        # Secondary edge circles (8 circles)\n        small_edge_r = 0.08\n        positions = [\n            (0.25, small_edge_r), (0.75, small_edge_r),  # bottom\n            (0.25, 1-small_edge_r), (0.75, 1-small_edge_r),  # top\n            (small_edge_r, 0.25), (small_edge_r, 0.75),  # left\n            (1-small_edge_r, 0.25), (1-small_edge_r, 0.75),  # right\n        ]\n        centers.extend(positions)\n        radii.extend([small_edge_r] * 8)\n        \n        # Interior circles (10 circles)\n        interior_r = 0.07\n        interior_pos = [\n            (0.5, 0.5),  # center\n            (0.3, 0.3), (0.7, 0.3), (0.3, 0.7), (0.7, 0.7),  # inner corners\n            (0.5, 0.3), (0.5, 0.7), (0.3, 0.5), (0.7, 0.5),  # inner edges\n            (0.4, 0.6),  # filler\n        ]\n        centers.extend(interior_pos)\n        radii.extend([interior_r] * 10)\n        \n        return np.array(centers), np.array(radii)\n    \n    def repair_state(centers, radii, aggressive=False):\n        \"\"\"Repair state to satisfy all constraints\"\"\"\n        max_iter = 200 if aggressive else 100\n        \n        for iteration in range(max_iter):\n            # Ensure circles inside square\n            for i in range(n_circles):\n                centers[i, 0] = np.clip(centers[i, 0], radii[i], 1 - radii[i])\n                centers[i, 1] = np.clip(centers[i, 1], radii[i], 1 - radii[i])\n            \n            # Fix overlaps\n            valid = True\n            for i in range(n_circles):\n                for j in range(i + 1, n_circles):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    overlap = radii[i] + radii[j] - dist\n                    if overlap > 1e-9:\n                        # Reduce both radii proportionally\n                        total_r = radii[i] + radii[j]\n                        if total_r > 0:\n                            shrink_factor = 0.999 if aggressive else 1.01\n                            radii[i] -= overlap * radii[i] / total_r * shrink_factor\n                            radii[j] -= overlap * radii[j] / total_r * shrink_factor\n                        radii[i] = max(0.001, radii[i])\n                        radii[j] = max(0.001, radii[j])\n                        valid = False\n            \n            if valid:\n                break\n        \n        radii = np.maximum(radii, 0.001)\n        return centers, radii\n    \n    def objective_with_penalty(centers, radii):\n        \"\"\"Objective with penalties for constraint violations\"\"\"\n        sum_radii = np.sum(radii)\n        penalty = 0.0\n        \n        # Penalty for being outside square\n        for i in range(n_circles):\n            penalty += max(0, radii[i] - centers[i, 0]) * 100\n            penalty += max(0, radii[i] - centers[i, 1]) * 100\n            penalty += max(0, centers[i, 0] + radii[i] - 1) * 100\n            penalty += max(0, centers[i, 1] + radii[i] - 1) * 100\n        \n        # Penalty for overlaps\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    penalty += overlap * 50\n        \n        return sum_radii - penalty\n    \n    def simulated_annealing(init_centers, init_radii):\n        \"\"\"Enhanced simulated annealing\"\"\"\n        centers = init_centers.copy()\n        radii = init_radii.copy()\n        \n        best_centers = centers.copy()\n        best_radii = radii.copy()\n        best_score = objective_with_penalty(centers, radii)\n        \n        temperature = 2.0\n        cooling_rate = 0.9997\n        n_iterations = 25000\n        \n        for iteration in range(n_iterations):\n            new_centers = centers.copy()\n            new_radii = radii.copy()\n            \n            # Adaptive perturbation\n            temp_factor = temperature / 2.0\n            \n            if np.random.rand() < 0.5:\n                # Move a circle\n                idx = np.random.randint(n_circles)\n                new_centers[idx] += np.random.randn(2) * 0.04 * temp_factor\n            elif np.random.rand() < 0.7:\n                # Adjust radius\n                idx = np.random.randint(n_circles)\n                new_radii[idx] += np.random.randn() * 0.03 * temp_factor\n            else:\n                # Swap two circles\n                i, j = np.random.choice(n_circles, 2, replace=False)\n                new_centers[i], new_centers[j] = new_centers[j].copy(), new_centers[i].copy()\n                new_radii[i], new_radii[j] = new_radii[j], new_radii[i]\n            \n            # Repair\n            new_centers, new_radii = repair_state(new_centers, new_radii)\n            \n            # Evaluate\n            new_score = objective_with_penalty(new_centers, new_radii)\n            current_score = objective_with_penalty(centers, radii)\n            \n            # Accept or reject\n            delta = new_score - current_score\n            if delta > 0 or np.random.rand() < np.exp(delta / temperature):\n                centers = new_centers\n                radii = new_radii\n                \n                if new_score > best_score:\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n                    best_score = new_score\n            \n            temperature *= cooling_rate\n        \n        return best_centers, best_radii\n    \n    def optimize_radii_greedy(centers):\n        \"\"\"Greedily maximize radii for fixed centers\"\"\"\n        radii = np.zeros(n_circles)\n        \n        # Sort by potential (distance to nearest boundary)\n        potentials = []\n        for i in range(n_circles):\n            pot = min(centers[i, 0], centers[i, 1], \n                     1 - centers[i, 0], 1 - centers[i, 1])\n            potentials.append((pot, i))\n        potentials.sort(reverse=True)\n        \n        for _, i in potentials:\n            # Max radius constrained by square\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            \n            # Max radius constrained by other circles\n            for j in range(n_circles):\n                if i != j and radii[j] > 0:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, dist - radii[j])\n            \n            radii[i] = max(0, max_r * 0.9999)  # Small safety margin\n        \n        return radii\n    \n    def local_optimization(centers, radii):\n        \"\"\"Aggressive local optimization using scipy\"\"\"\n        def pack_variables(c, r):\n            return np.concatenate([c.flatten(), r])\n        \n        def unpack_variables(x):\n            c = x[:2*n_circles].reshape(n_circles, 2)\n            r = x[2*n_circles:]\n            return c, r\n        \n        def objective(x):\n            _, r = unpack_variables(x)\n            return -np.sum(r)\n        \n        def constraint_func(x):\n            c, r = unpack_variables(x)\n            violations = []\n            \n            # Boundary constraints\n            for i in range(n_circles):\n                violations.append(c[i, 0] - r[i])\n                violations.append(c[i, 1] - r[i])\n                violations.append(1 - c[i, 0] - r[i])\n                violations.append(1 - c[i, 1] - r[i])\n            \n            # Non-overlap constraints\n            for i in range(n_circles):\n                for j in range(i + 1, n_circles):\n                    dist = np.linalg.norm(c[i] - c[j])\n                    violations.append(dist - r[i] - r[j])\n            \n            return np.array(violations)\n        \n        x0 = pack_variables(centers, radii)\n        bounds = [(0, 1)] * (2 * n_circles) + [(0, 0.5)] * n_circles\n        \n        constraints = {'type': 'ineq', 'fun': constraint_func}\n        \n        result = minimize(objective, x0, method='SLSQP', bounds=bounds,\n                         constraints=constraints, options={'maxiter': 1000, 'ftol': 1e-9})\n        \n        if result.success or True:  # Use result even if not fully converged\n            centers_opt, radii_opt = unpack_variables(result.x)\n            # Verify and repair\n            centers_opt, radii_opt = repair_state(centers_opt, radii_opt, aggressive=True)\n            return centers_opt, radii_opt\n        \n        return centers, radii\n    \n    # Main optimization loop\n    best_sum = 0\n    best_result = None\n    \n    for trial in range(3):\n        np.random.seed(trial * 123)\n        \n        # Initialize strategically\n        centers, radii = strategic_initialization()\n        centers, radii = repair_state(centers, radii)\n        \n        # Simulated annealing\n        centers, radii = simulated_annealing(centers, radii)\n        \n        # Iterative radii optimization\n        for _ in range(100):\n            radii = optimize_radii_greedy(centers)\n        \n        # Local optimization with scipy\n        centers, radii = local_optimization(centers, radii)\n        \n        # Final greedy radii optimization\n        for _ in range(50):\n            radii = optimize_radii_greedy(centers)\n        \n        # Final repair\n        centers, radii = repair_state(centers, radii, aggressive=True)\n        \n        sum_radii = np.sum(radii)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_result = (centers, radii, sum_radii)\n    \n    return best_result\n\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-30T22:33:54.785911",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.4
  }
}