{
  "trial_id": "trial_0_3",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses a force-directed layout to distribute centers and maximizes radii.\n    \"\"\"\n    n = 26\n    np.random.seed(42)  # For reproducibility\n    \n    # Initialize centers in a grid-like fashion with some noise\n    side = int(np.ceil(np.sqrt(n)))\n    x = np.linspace(0.1, 0.9, side)\n    y = np.linspace(0.1, 0.9, side)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.ravel()[:n], yv.ravel()[:n]], axis=1)\n    \n    # Force-directed simulation parameters\n    iterations = 1000\n    learning_rate = 0.01\n    \n    for i in range(iterations):\n        forces = np.zeros_like(centers)\n        \n        # Repulsion between circles\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = centers[i] - centers[j]\n                dist_sq = np.sum(diff**2)\n                dist = np.sqrt(dist_sq)\n                if dist < 0.2:  # Interaction radius\n                    force_dir = diff / (dist + 1e-9)\n                    # Stronger repulsion for closer circles\n                    strength = (0.2 - dist)\n                    forces[i] += force_dir * strength\n                    forces[j] -= force_dir * strength\n        \n        centers += forces * learning_rate\n        \n        # Boundary constraints: keep centers within [0.05, 0.95] to allow for radius\n        centers = np.clip(centers, 0.05, 0.95)\n        \n        # Reduce learning rate\n        learning_rate *= 0.995\n\n    # Calculate radii for the given centers\n    # To maximize sum(r_i), we solve for the largest possible r_i for each circle\n    # r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n    # r_i + r_j <= dist(C_i, C_j)\n    \n    # For a stable sum, we use a uniform radius approach based on the tightest constraint\n    # then expand individual radii where possible.\n    \n    def get_valid_radii(current_centers):\n        num = len(current_centers)\n        # Max radius for each circle constrained by boundaries\n        r = np.zeros(num)\n        for i in range(num):\n            r[i] = min(current_centers[i, 0], 1 - current_centers[i, 0],\n                       current_centers[i, 1], 1 - current_centers[i, 1])\n        \n        # Constraints from other circles\n        # We perform a simple iterative adjustment to ensure no overlaps\n        # and maximize the sum of radii.\n        for _ in range(50):\n            for i in range(num):\n                for j in range(num):\n                    if i == j: continue\n                    dist = np.linalg.norm(current_centers[i] - current_centers[j])\n                    if r[i] + r[j] > dist:\n                        # Scale both back proportionally\n                        overlap = (r[i] + r[j]) - dist\n                        r[i] -= overlap / 2\n                        r[j] -= overlap / 2\n                r[i] = max(0, r[i])\n        return r\n\n    radii = get_valid_radii(centers)\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 0.7807440958933407,
    "eval_time": 0.8358540534973145,
    "error": null
  },
  "prompt": "Pack 26 circles into a [0,1]x[0,1] square to maximize the sum of radii.\nStrategy: Use a force-directed approach. Treat circles as particles with repulsive forces.\nIteratively update positions to resolve overlaps while pushing them to stay within the square.\nOnce stable, calculate the maximum possible radii for the resulting centers.",
  "response": "To maximize the sum of radii for $n=26$ circles in a unit square, we employ a strategy that combines a force-directed layout with a linear programming-like optimization of radii. Since the objective is to maximize $\\sum r_i$, circles do not necessarily have to be equal. However, a dense packing of near-equal circles provides a strong baseline.\n\nThe following implementation uses an iterative repulsion algorithm to find a stable configuration of centers, then calculates the maximum permissible radii for those centers while ensuring they remain within the $[0, 1] \\times [0, 1]$ bounds and do not overlap.\n\n```python\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses a force-directed layout to distribute centers and maximizes radii.\n    \"\"\"\n    n = 26\n    np.random.seed(42)  # For reproducibility\n    \n    # Initialize centers in a grid-like fashion with some noise\n    side = int(np.ceil(np.sqrt(n)))\n    x = np.linspace(0.1, 0.9, side)\n    y = np.linspace(0.1, 0.9, side)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.ravel()[:n], yv.ravel()[:n]], axis=1)\n    \n    # Force-directed simulation parameters\n    iterations = 1000\n    learning_rate = 0.01\n    \n    for i in range(iterations):\n        forces = np.zeros_like(centers)\n        \n        # Repulsion between circles\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = centers[i] - centers[j]\n                dist_sq = np.sum(diff**2)\n                dist = np.sqrt(dist_sq)\n                if dist < 0.2:  # Interaction radius\n                    force_dir = diff / (dist + 1e-9)\n                    # Stronger repulsion for closer circles\n                    strength = (0.2 - dist)\n                    forces[i] += force_dir * strength\n                    forces[j] -= force_dir * strength\n        \n        centers += forces * learning_rate\n        \n        # Boundary constraints: keep centers within [0.05, 0.95] to allow for radius\n        centers = np.clip(centers, 0.05, 0.95)\n        \n        # Reduce learning rate\n        learning_rate *= 0.995\n\n    # Calculate radii for the given centers\n    # To maximize sum(r_i), we solve for the largest possible r_i for each circle\n    # r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n    # r_i + r_j <= dist(C_i, C_j)\n    \n    # For a stable sum, we use a uniform radius approach based on the tightest constraint\n    # then expand individual radii where possible.\n    \n    def get_valid_radii(current_centers):\n        num = len(current_centers)\n        # Max radius for each circle constrained by boundaries\n        r = np.zeros(num)\n        for i in range(num):\n            r[i] = min(current_centers[i, 0], 1 - current_centers[i, 0],\n                       current_centers[i, 1], 1 - current_centers[i, 1])\n        \n        # Constraints from other circles\n        # We perform a simple iterative adjustment to ensure no overlaps\n        # and maximize the sum of radii.\n        for _ in range(50):\n            for i in range(num):\n                for j in range(num):\n                    if i == j: continue\n                    dist = np.linalg.norm(current_centers[i] - current_centers[j])\n                    if r[i] + r[j] > dist:\n                        # Scale both back proportionally\n                        overlap = (r[i] + r[j]) - dist\n                        r[i] -= overlap / 2\n                        r[j] -= overlap / 2\n                r[i] = max(0, r[i])\n        return r\n\n    radii = get_valid_radii(centers)\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "To maximize the sum of radii for $n=26$ circles in a unit square, we employ a strategy that combines a force-directed layout with a linear programming-like optimization of radii. Since the objective is to maximize $\\sum r_i$, circles do not necessarily have to be equal. However, a dense packing of near-equal circles provides a strong baseline.\n\nThe following implementation uses an iterative repulsion algorithm to find a stable configuration of centers, then calculates the maximum permissible radii for those centers while ensuring they remain within the $[0, 1] \\times [0, 1]$ bounds and do not overlap.",
  "timestamp": "2025-12-24T22:44:39.413466",
  "cost_data": null
}