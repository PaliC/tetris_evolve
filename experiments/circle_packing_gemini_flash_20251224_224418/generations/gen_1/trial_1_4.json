{
  "trial_id": "trial_1_4",
  "generation": 1,
  "parent_id": "trial_0_3",
  "code": "import numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses a force-directed simulation to find center positions, then\n    solves a Linear Program to maximize the sum of radii for those fixed centers.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # 1. Initialize centers using a jittered grid\n    side = 6\n    x = np.linspace(0.1, 0.9, side)\n    y = np.linspace(0.1, 0.9, side)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.ravel()[:n], yv.ravel()[:n]], axis=1)\n    centers += np.random.normal(0, 0.01, centers.shape)\n\n    # 2. Force-directed simulation to spread centers\n    # We use a repulsive force to maximize the minimum distance between centers\n    iterations = 2000\n    dt = 0.02\n    for i in range(iterations):\n        forces = np.zeros_like(centers)\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff) + 1e-9\n                if dist < 0.25:\n                    # Repulsive force inversely proportional to distance\n                    f = (diff / dist) * (1.0 / dist**2)\n                    forces[i] += f\n                    forces[j] -= f\n        \n        centers += forces * dt\n        # Keep centers strictly inside to avoid zero radii\n        centers = np.clip(centers, 0.02, 0.98)\n        dt *= 0.998 # Cooling\n\n    # 3. Optimize radii for fixed centers using Linear Programming\n    # Objective: Maximize sum(r_i)\n    # Constraints:\n    # 1. r_i + r_j <= dist(C_i, C_j)  (No overlap)\n    # 2. r_i <= C_i.x, r_i <= 1 - C_i.x, r_i <= C_i.y, r_i <= 1 - C_i.y (Boundary)\n    # 3. r_i >= 0\n    \n    c = -np.ones(n) # Negative for maximization\n    \n    A_ub = []\n    b_ub = []\n    \n    # Pairwise constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            A_ub.append(row)\n            b_ub.append(dist)\n            \n    # Boundary constraints\n    bounds = []\n    for i in range(n):\n        max_r_boundary = min(centers[i, 0], 1.0 - centers[i, 0], \n                             centers[i, 1], 1.0 - centers[i, 1])\n        bounds.append((0, max_r_boundary))\n        \n    res = linprog(c, A_ub=np.array(A_ub), b_ub=np.array(b_ub), bounds=bounds, method='highs')\n    \n    if res.success:\n        radii = res.x\n    else:\n        # Fallback to a very small safe radius if LP fails\n        radii = np.full(n, 0.01)\n\n    # Final check for validity (numerical precision)\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > d:\n                # Shrink slightly to ensure hard constraint\n                shrink = (radii[i] + radii[j]) / d + 1e-10\n                radii[i] /= (shrink + 1e-11)\n                radii[j] /= (shrink + 1e-11)\n    \n    # Boundary check\n    for i in range(n):\n        max_r = min(centers[i, 0], 1.0 - centers[i, 0], centers[i, 1], 1.0 - centers[i, 1])\n        if radii[i] > max_r:\n            radii[i] = max_r\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 0.2875038094251575,
    "eval_time": 1.6095821857452393,
    "error": null
  },
  "prompt": "Trial_0_3 had a valid but very low score (0.78). The issue is likely that the radii \nwere set too conservatively. \nModify the force-directed simulation to:\n1. Use a more aggressive expansion force (increase target radii over time).\n2. Once the simulation stabilizes, calculate the maximum possible individual radii for the centers:\n   r_i = min(x_i, 1-x_i, y_i, 1-y_i, min_j(dist(i,j) - r_j))\n   Actually, solve for radii r_i such that r_i + r_j <= dist(i,j) and sum(r_i) is maximized. \n   This can be formulated as a linear program for fixed centers.\n\n{{import numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses a force-directed layout to distribute centers and maximizes radii.\n    \"\"\"\n    n = 26\n    np.random.seed(42)  # For reproducibility\n    \n    # Initialize centers in a grid-like fashion with some noise\n    side = int(np.ceil(np.sqrt(n)))\n    x = np.linspace(0.1, 0.9, side)\n    y = np.linspace(0.1, 0.9, side)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.ravel()[:n], yv.ravel()[:n]], axis=1)\n    \n    # Force-directed simulation parameters\n    iterations = 1000\n    learning_rate = 0.01\n    \n    for i in range(iterations):\n        forces = np.zeros_like(centers)\n        \n        # Repulsion between circles\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = centers[i] - centers[j]\n                dist_sq = np.sum(diff**2)\n                dist = np.sqrt(dist_sq)\n                if dist < 0.2:  # Interaction radius\n                    force_dir = diff / (dist + 1e-9)\n                    # Stronger repulsion for closer circles\n                    strength = (0.2 - dist)\n                    forces[i] += force_dir * strength\n                    forces[j] -= force_dir * strength\n        \n        centers += forces * learning_rate\n        \n        # Boundary constraints: keep centers within [0.05, 0.95] to allow for radius\n        centers = np.clip(centers, 0.05, 0.95)\n        \n        # Reduce learning rate\n        learning_rate *= 0.995\n\n    # Calculate radii for the given centers\n    # To maximize sum(r_i), we solve for the largest possible r_i for each circle\n    # r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n    # r_i + r_j <= dist(C_i, C_j)\n    \n    # For a stable sum, we use a uniform radius approach based on the tightest constraint\n    # then expand individual radii where possible.\n    \n    def get_valid_radii(current_centers):\n        num = len(current_centers)\n        # Max radius for each circle constrained by boundaries\n        r = np.zeros(num)\n        for i in range(num):\n            r[i] = min(current_centers[i, 0], 1 - current_centers[i, 0],\n                       current_centers[i, 1], 1 - current_centers[i, 1])\n        \n        # Constraints from other circles\n        # We perform a simple iterative adjustment to ensure no overlaps\n        # and maximize the sum of radii.\n        for _ in range(50):\n            for i in range(num):\n                for j in range(num):\n                    if i == j: continue\n                    dist = np.linalg.norm(current_centers[i] - current_centers[j])\n                    if r[i] + r[j] > dist:\n                        # Scale both back proportionally\n                        overlap = (r[i] + r[j]) - dist\n                        r[i] -= overlap / 2\n                        r[j] -= overlap / 2\n                r[i] = max(0, r[i])\n        return r\n\n    radii = get_valid_radii(centers)\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()}}",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses a force-directed simulation to find center positions, then\n    solves a Linear Program to maximize the sum of radii for those fixed centers.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # 1. Initialize centers using a jittered grid\n    side = 6\n    x = np.linspace(0.1, 0.9, side)\n    y = np.linspace(0.1, 0.9, side)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.ravel()[:n], yv.ravel()[:n]], axis=1)\n    centers += np.random.normal(0, 0.01, centers.shape)\n\n    # 2. Force-directed simulation to spread centers\n    # We use a repulsive force to maximize the minimum distance between centers\n    iterations = 2000\n    dt = 0.02\n    for i in range(iterations):\n        forces = np.zeros_like(centers)\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff) + 1e-9\n                if dist < 0.25:\n                    # Repulsive force inversely proportional to distance\n                    f = (diff / dist) * (1.0 / dist**2)\n                    forces[i] += f\n                    forces[j] -= f\n        \n        centers += forces * dt\n        # Keep centers strictly inside to avoid zero radii\n        centers = np.clip(centers, 0.02, 0.98)\n        dt *= 0.998 # Cooling\n\n    # 3. Optimize radii for fixed centers using Linear Programming\n    # Objective: Maximize sum(r_i)\n    # Constraints:\n    # 1. r_i + r_j <= dist(C_i, C_j)  (No overlap)\n    # 2. r_i <= C_i.x, r_i <= 1 - C_i.x, r_i <= C_i.y, r_i <= 1 - C_i.y (Boundary)\n    # 3. r_i >= 0\n    \n    c = -np.ones(n) # Negative for maximization\n    \n    A_ub = []\n    b_ub = []\n    \n    # Pairwise constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            A_ub.append(row)\n            b_ub.append(dist)\n            \n    # Boundary constraints\n    bounds = []\n    for i in range(n):\n        max_r_boundary = min(centers[i, 0], 1.0 - centers[i, 0], \n                             centers[i, 1], 1.0 - centers[i, 1])\n        bounds.append((0, max_r_boundary))\n        \n    res = linprog(c, A_ub=np.array(A_ub), b_ub=np.array(b_ub), bounds=bounds, method='highs')\n    \n    if res.success:\n        radii = res.x\n    else:\n        # Fallback to a very small safe radius if LP fails\n        radii = np.full(n, 0.01)\n\n    # Final check for validity (numerical precision)\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > d:\n                # Shrink slightly to ensure hard constraint\n                shrink = (radii[i] + radii[j]) / d + 1e-10\n                radii[i] /= (shrink + 1e-11)\n                radii[j] /= (shrink + 1e-11)\n    \n    # Boundary check\n    for i in range(n):\n        max_r = min(centers[i, 0], 1.0 - centers[i, 0], centers[i, 1], 1.0 - centers[i, 1])\n        if radii[i] > max_r:\n            radii[i] = max_r\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T22:45:08.812915",
  "cost_data": null
}