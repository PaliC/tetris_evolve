{
  "trial_id": "trial_4_9",
  "generation": 4,
  "parent_id": "trial_3_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses a combination of a structured grid search, LP-based radius optimization,\n    and a pattern-search-like local refinement to maximize the sum of radii.\n    \"\"\"\n    n = 26\n    \n    def solve_radii_lp(centers):\n        \"\"\"Given fixed centers, solve for max sum of radii using Linear Programming.\"\"\"\n        # Objective: Maximize sum(r_i) -> Minimize -sum(r_i)\n        c_lp = -np.ones(n)\n        \n        # Constraints:\n        # 1. r_i + r_j <= ||c_i - c_j||\n        # 2. r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n        # 3. r_i >= 0\n        \n        A_ub = []\n        b_ub = []\n        \n        # Overlap constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                row = np.zeros(n)\n                row[i] = 1\n                row[j] = 1\n                A_ub.append(row)\n                b_ub.append(dist)\n        \n        # Boundary constraints\n        for i in range(n):\n            r_max_boundary = min(centers[i, 0], 1 - centers[i, 0], \n                                 centers[i, 1], 1 - centers[i, 1])\n            row = np.zeros(n)\n            row[i] = 1\n            A_ub.append(row)\n            b_ub.append(max(0, r_max_boundary))\n            \n        res = linprog(c_lp, A_ub=np.array(A_ub), b_ub=np.array(b_ub), \n                      bounds=(0, 0.5), method='highs')\n        \n        if res.success:\n            return res.x, -res.fun\n        else:\n            return np.zeros(n), 0.0\n\n    # Initial Strategy: 5x5 grid + 1 point\n    x = np.linspace(0.1, 0.9, 5)\n    y = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.vstack([xv.ravel(), yv.ravel()]).T\n    centers = np.vstack([centers, [0.5, 0.5]]) # 26th point\n    \n    best_centers = centers.copy()\n    radii, best_score = solve_radii_lp(best_centers)\n\n    # Simplified Hooke-Jeeves / Pattern Search on centers\n    step_size = 0.02\n    min_step = 1e-5\n    \n    while step_size > min_step:\n        improved = False\n        # Try moving each center in 4 directions\n        for i in range(n):\n            original_pt = best_centers[i].copy()\n            for dx, dy in [(step_size, 0), (-step_size, 0), (0, step_size), (0, -step_size)]:\n                best_centers[i] = np.clip(original_pt + [dx, dy], 0, 1)\n                new_radii, new_score = solve_radii_lp(best_centers)\n                \n                if new_score > best_score + 1e-7:\n                    best_score = new_score\n                    radii = new_radii\n                    improved = True\n                    break # Move to next circle\n                else:\n                    best_centers[i] = original_pt\n        \n        if not improved:\n            step_size *= 0.5\n\n    # Final Polish: Local SLSQP to nudge centers and radii simultaneously\n    def objective(params):\n        return -np.sum(params[2*n:])\n\n    def constraints_func(params):\n        c = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        cons = []\n        for i in range(n):\n            cons.append(c[i, 0] - r[i])\n            cons.append(1.0 - (c[i, 0] + r[i]))\n            cons.append(c[i, 1] - r[i])\n            cons.append(1.0 - (c[i, 1] + r[i]))\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((c[i] - c[j])**2) + 1e-14)\n                cons.append(dist - (r[i] + r[j]))\n        return np.array(cons)\n\n    init_params = np.concatenate([best_centers.flatten(), radii])\n    res = minimize(objective, init_params, method='SLSQP', \n                   constraints={'type': 'ineq', 'fun': constraints_func},\n                   bounds=[(0, 1)]*(2*n) + [(0, 0.5)]*n,\n                   options={'maxiter': 100})\n\n    final_params = res.x\n    final_centers = final_params[:2*n].reshape((n, 2))\n    final_radii = final_params[2*n:]\n\n    # Strict feasibility enforcement\n    final_centers = np.clip(final_centers, 0, 1)\n    for i in range(n):\n        r_b = min(final_centers[i, 0], 1 - final_centers[i, 0], \n                  final_centers[i, 1], 1 - final_centers[i, 1])\n        final_radii[i] = min(final_radii[i], r_b)\n        \n    for _ in range(10): # Shrink to remove overlaps\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(final_centers[i] - final_centers[j])\n                if final_radii[i] + final_radii[j] > d:\n                    diff = (final_radii[i] + final_radii[j] - d) / 2.0 + 1e-12\n                    final_radii[i] -= diff\n                    final_radii[j] -= diff\n            final_radii[i] = max(0, final_radii[i])\n\n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.6082558389822834,
    "eval_time": 4.656408071517944,
    "error": null
  },
  "prompt": "Apply the Hooke-Jeeves pattern search algorithm to the centers of the circles, \nusing the sum of radii (calculated via LP) as the objective.\nThis method is good at following narrow valleys in the search space that SLSQP might jump over.\nStart from the trial_3_0 best result.\n\n{{import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Maximizes the sum of radii using multiple grid starts and deep local optimization.\n    \"\"\"\n    n = 26\n    \n    def objective(params):\n        # Maximize sum of radii -> minimize negative sum\n        r = params[2*n:]\n        return -np.sum(r)\n\n    def constraints_func(params):\n        c = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        cons = []\n        # Boundary constraints: center +/- radius must be within [0, 1]\n        for i in range(n):\n            cons.append(c[i, 0] - r[i])          \n            cons.append(1.0 - (c[i, 0] + r[i]))  \n            cons.append(c[i, 1] - r[i])          \n            cons.append(1.0 - (c[i, 1] + r[i]))  \n        # Non-overlap constraints: dist(ci, cj) >= ri + rj\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx = c[i, 0] - c[j, 0]\n                dy = c[i, 1] - c[j, 1]\n                dist = np.sqrt(dx*dx + dy*dy + 1e-12)\n                cons.append(dist - (r[i] + r[j]))\n        return np.array(cons)\n\n    bounds = [(0, 1)] * (2 * n) + [(0.0, 0.5)] * n\n    best_overall_params = None\n    best_overall_score = float('inf')\n\n    # 1. Define starting topologies\n    topologies = [\n        (5, 5, 1), # 5x5 grid + 1 extra\n        (4, 6, 2), # 4x6 grid + 2 extra\n        (6, 4, 2), # 6x4 grid + 2 extra\n    ]\n    \n    # Total starts distributed across topologies and random perturbations\n    n_starts = 100\n    \n    for start_idx in range(n_starts):\n        topo = topologies[start_idx % len(topologies)]\n        nx, ny, extra = topo\n        \n        # Create base grid\n        x = np.linspace(0.1, 0.9, nx)\n        y = np.linspace(0.1, 0.9, ny)\n        xv, yv = np.meshgrid(x, y)\n        pts = np.vstack([xv.ravel(), yv.ravel()]).T\n        \n        # Add extra points randomly\n        if extra > 0:\n            extra_pts = np.random.rand(extra, 2)\n            pts = np.vstack([pts, extra_pts])\n        \n        # Ensure we have exactly n points\n        if len(pts) > n:\n            pts = pts[:n]\n        elif len(pts) < n:\n            pts = np.vstack([pts, np.random.rand(n-len(pts), 2)])\n            \n        # Add jitter\n        centers = pts + np.random.normal(0, 0.05, (n, 2))\n        centers = np.clip(centers, 0.1, 0.9)\n        radii = np.full(n, 1.0 / (2 * np.sqrt(n)))\n        \n        current_params = np.concatenate([centers.flatten(), radii])\n\n        # Fast optimization\n        res = minimize(\n            objective, \n            current_params, \n            method='SLSQP', \n            bounds=bounds,\n            constraints={'type': 'ineq', 'fun': constraints_func},\n            options={'maxiter': 50, 'ftol': 1e-4}\n        )\n        \n        if res.success or res.fun < best_overall_score:\n            if res.fun < best_overall_score:\n                best_overall_score = res.fun\n                best_overall_params = res.x\n\n    # 2. Sophisticated Polish Phase\n    # Re-run SLSQP with jitters on the best result to find deeper local minima\n    current_best = best_overall_params\n    for _ in range(5):\n        # Apply slight jitter to centers\n        jittered_centers = current_best[:2*n] + np.random.normal(0, 0.002, 2*n)\n        jittered_params = np.concatenate([jittered_centers, current_best[2*n:]])\n        \n        res = minimize(\n            objective, \n            jittered_params, \n            method='SLSQP', \n            bounds=bounds,\n            constraints={'type': 'ineq', 'fun': constraints_func},\n            options={'maxiter': 150, 'ftol': 1e-8}\n        )\n        if res.fun < best_overall_score:\n            best_overall_score = res.fun\n            current_best = res.x\n\n    # 3. Final Strict Feasibility Enforcement\n    final_centers = current_best[:2*n].reshape((n, 2))\n    final_radii = current_best[2*n:]\n    \n    # Clip centers to unit square\n    final_centers = np.clip(final_centers, 0, 1)\n    \n    # Adjust radii to satisfy boundary and overlap strictly\n    for i in range(n):\n        r_bound = min(final_centers[i, 0], 1 - final_centers[i, 0],\n                      final_centers[i, 1], 1 - final_centers[i, 1])\n        final_radii[i] = min(final_radii[i], r_bound)\n\n    # Iterative shrinkage to resolve any remaining overlaps\n    for _ in range(50):\n        max_overlap = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(final_centers[i] - final_centers[j])\n                if final_radii[i] + final_radii[j] > dist:\n                    overlap = (final_radii[i] + final_radii[j]) - dist\n                    max_overlap = max(max_overlap, overlap)\n                    shrink = (overlap / 2.0) + 1e-12\n                    final_radii[i] -= shrink\n                    final_radii[j] -= shrink\n            final_radii[i] = max(0, final_radii[i])\n        if max_overlap < 1e-11:\n            break\n\n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()}}",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses a combination of a structured grid search, LP-based radius optimization,\n    and a pattern-search-like local refinement to maximize the sum of radii.\n    \"\"\"\n    n = 26\n    \n    def solve_radii_lp(centers):\n        \"\"\"Given fixed centers, solve for max sum of radii using Linear Programming.\"\"\"\n        # Objective: Maximize sum(r_i) -> Minimize -sum(r_i)\n        c_lp = -np.ones(n)\n        \n        # Constraints:\n        # 1. r_i + r_j <= ||c_i - c_j||\n        # 2. r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n        # 3. r_i >= 0\n        \n        A_ub = []\n        b_ub = []\n        \n        # Overlap constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                row = np.zeros(n)\n                row[i] = 1\n                row[j] = 1\n                A_ub.append(row)\n                b_ub.append(dist)\n        \n        # Boundary constraints\n        for i in range(n):\n            r_max_boundary = min(centers[i, 0], 1 - centers[i, 0], \n                                 centers[i, 1], 1 - centers[i, 1])\n            row = np.zeros(n)\n            row[i] = 1\n            A_ub.append(row)\n            b_ub.append(max(0, r_max_boundary))\n            \n        res = linprog(c_lp, A_ub=np.array(A_ub), b_ub=np.array(b_ub), \n                      bounds=(0, 0.5), method='highs')\n        \n        if res.success:\n            return res.x, -res.fun\n        else:\n            return np.zeros(n), 0.0\n\n    # Initial Strategy: 5x5 grid + 1 point\n    x = np.linspace(0.1, 0.9, 5)\n    y = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.vstack([xv.ravel(), yv.ravel()]).T\n    centers = np.vstack([centers, [0.5, 0.5]]) # 26th point\n    \n    best_centers = centers.copy()\n    radii, best_score = solve_radii_lp(best_centers)\n\n    # Simplified Hooke-Jeeves / Pattern Search on centers\n    step_size = 0.02\n    min_step = 1e-5\n    \n    while step_size > min_step:\n        improved = False\n        # Try moving each center in 4 directions\n        for i in range(n):\n            original_pt = best_centers[i].copy()\n            for dx, dy in [(step_size, 0), (-step_size, 0), (0, step_size), (0, -step_size)]:\n                best_centers[i] = np.clip(original_pt + [dx, dy], 0, 1)\n                new_radii, new_score = solve_radii_lp(best_centers)\n                \n                if new_score > best_score + 1e-7:\n                    best_score = new_score\n                    radii = new_radii\n                    improved = True\n                    break # Move to next circle\n                else:\n                    best_centers[i] = original_pt\n        \n        if not improved:\n            step_size *= 0.5\n\n    # Final Polish: Local SLSQP to nudge centers and radii simultaneously\n    def objective(params):\n        return -np.sum(params[2*n:])\n\n    def constraints_func(params):\n        c = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        cons = []\n        for i in range(n):\n            cons.append(c[i, 0] - r[i])\n            cons.append(1.0 - (c[i, 0] + r[i]))\n            cons.append(c[i, 1] - r[i])\n            cons.append(1.0 - (c[i, 1] + r[i]))\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((c[i] - c[j])**2) + 1e-14)\n                cons.append(dist - (r[i] + r[j]))\n        return np.array(cons)\n\n    init_params = np.concatenate([best_centers.flatten(), radii])\n    res = minimize(objective, init_params, method='SLSQP', \n                   constraints={'type': 'ineq', 'fun': constraints_func},\n                   bounds=[(0, 1)]*(2*n) + [(0, 0.5)]*n,\n                   options={'maxiter': 100})\n\n    final_params = res.x\n    final_centers = final_params[:2*n].reshape((n, 2))\n    final_radii = final_params[2*n:]\n\n    # Strict feasibility enforcement\n    final_centers = np.clip(final_centers, 0, 1)\n    for i in range(n):\n        r_b = min(final_centers[i, 0], 1 - final_centers[i, 0], \n                  final_centers[i, 1], 1 - final_centers[i, 1])\n        final_radii[i] = min(final_radii[i], r_b)\n        \n    for _ in range(10): # Shrink to remove overlaps\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(final_centers[i] - final_centers[j])\n                if final_radii[i] + final_radii[j] > d:\n                    diff = (final_radii[i] + final_radii[j] - d) / 2.0 + 1e-12\n                    final_radii[i] -= diff\n                    final_radii[j] -= diff\n            final_radii[i] = max(0, final_radii[i])\n\n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T22:47:25.833127",
  "cost_data": null
}