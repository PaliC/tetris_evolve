{
  "trial_id": "trial_2_2",
  "generation": 2,
  "parent_id": "trial_1_9",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses a simulated annealing approach with neighborhood swaps and \n    compaction, followed by SLSQP refinement to maximize sum of radii.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n\n    # 1. Initial State: Grid-based initialization\n    # 5x5 grid + 1 extra\n    grid_side = 5\n    centers = []\n    for i in range(grid_side):\n        for j in range(grid_side):\n            centers.append([(i + 0.5) / grid_side, (j + 0.5) / grid_side])\n    centers.append([0.5, 0.5])\n    centers = np.array(centers)\n    radii = np.full(n, 0.1)\n\n    def get_valid_radii(c):\n        \"\"\"Greedily determine radii for fixed centers to satisfy constraints.\"\"\"\n        r = np.zeros(n)\n        # Boundary constraints\n        for i in range(n):\n            r[i] = min(c[i, 0], 1.0 - c[i, 0], c[i, 1], 1.0 - c[i, 1])\n        \n        # Iterative shrinkage to resolve overlaps\n        for _ in range(10):\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist = np.linalg.norm(c[i] - c[j])\n                    if r[i] + r[j] > dist:\n                        # Shrink proportional to current radius\n                        total_r = r[i] + r[j]\n                        excess = total_r - dist + 1e-9\n                        r[i] -= excess * (r[i] / total_r)\n                        r[j] -= excess * (r[j] / total_r)\n            r = np.maximum(r, 0)\n        return r\n\n    # 2. Simulated Annealing with Enhancements\n    current_centers = centers.copy()\n    current_radii = get_valid_radii(current_centers)\n    current_sum = np.sum(current_radii)\n    \n    best_centers = current_centers.copy()\n    best_sum = current_sum\n\n    iterations = 2500\n    temp = 0.1\n    cooling_rate = 0.998\n\n    for k in range(iterations):\n        new_centers = current_centers.copy()\n        \n        # Enhancement 1: Neighbor function - Move or Swap\n        if np.random.rand() < 0.2:\n            # Swap positions of a 'small' and 'large' circle area\n            idx = np.random.choice(n, 2, replace=False)\n            new_centers[idx[0]], new_centers[idx[1]] = new_centers[idx[1]].copy(), new_centers[idx[0]].copy()\n        else:\n            # Standard move\n            idx = np.random.randint(n)\n            new_centers[idx] += (np.random.rand(2) - 0.5) * temp\n            new_centers[idx] = np.clip(new_centers[idx], 0.01, 0.99)\n\n        # Enhancement 2: Compaction step every 100 iterations\n        if k % 100 == 0:\n            # Push circles slightly towards nearest corner/edge to open space\n            for i in range(n):\n                push = np.array([0.5, 0.5]) - new_centers[i]\n                new_centers[i] += 0.05 * push * temp\n\n        new_radii = get_valid_radii(new_centers)\n        new_sum = np.sum(new_radii)\n\n        # Acceptance criteria\n        if new_sum > current_sum or np.exp((new_sum - current_sum) / (temp + 1e-9)) > np.random.rand():\n            current_centers = new_centers\n            current_sum = new_sum\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_centers = current_centers.copy()\n\n        # Enhancement 3: Geometric cooling\n        temp *= cooling_rate\n\n    # 3. Final Local Optimization (SLSQP)\n    def objective(params):\n        return -np.sum(params[2*n:])\n\n    def constraints(params):\n        c = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        cons = []\n        for i in range(n):\n            cons.extend([c[i, 0] - r[i], 1.0 - c[i, 0] - r[i],\n                         c[i, 1] - r[i], 1.0 - c[i, 1] - r[i]])\n            for j in range(i + 1, n):\n                cons.append(np.linalg.norm(c[i] - c[j]) - (r[i] + r[j]))\n        return np.array(cons)\n\n    best_radii = get_valid_radii(best_centers)\n    initial_params = np.concatenate([best_centers.flatten(), best_radii])\n    \n    res = minimize(\n        objective, \n        initial_params, \n        method='SLSQP', \n        constraints={'type': 'ineq', 'fun': constraints},\n        bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n        options={'maxiter': 100}\n    )\n\n    final_params = res.x\n    final_centers = final_params[:2*n].reshape((n, 2))\n    final_radii = final_params[2*n:]\n\n    # Final feasibility cleanup\n    for _ in range(10):\n        for i in range(n):\n            final_radii[i] = min(final_radii[i], final_centers[i, 0], 1 - final_centers[i, 0],\n                                 final_centers[i, 1], 1 - final_centers[i, 1])\n            for j in range(i + 1, n):\n                d = np.linalg.norm(final_centers[i] - final_centers[j])\n                if final_radii[i] + final_radii[j] > d:\n                    overlap = (final_radii[i] + final_radii[j] - d) + 1e-12\n                    final_radii[i] -= overlap / 2\n                    final_radii[j] -= overlap / 2\n        final_radii = np.maximum(final_radii, 0)\n\n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.6171799834151646,
    "eval_time": 10.369322061538696,
    "error": null
  },
  "prompt": "Trial_1_9 uses simulated annealing. \nEnhance the 'neighbor' function:\n1. Instead of moving just one circle, try 'swapping' the positions of a small circle and a large circle's gap.\n2. Incorporate a 'compaction' step every 100 iterations where you push all circles towards the nearest corner or edge to create larger central gaps.\n3. Increase the total number of iterations and use a geometric cooling schedule.\n\n{{import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses a grid-based start followed by iterative local optimization\n    to maximize the sum of radii.\n    \"\"\"\n    n = 26\n    \n    # Initial Guess: 5x5 grid + 1 extra circle\n    # This provides a structured starting point.\n    centers = []\n    grid_size = 5\n    for i in range(grid_size):\n        for j in range(grid_size):\n            centers.append([(i + 0.5) / grid_size, (j + 0.5) / grid_size])\n    \n    # Add the 26th circle at a location likely to have space\n    centers.append([0.5, 0.5])\n    centers = np.array(centers)\n    \n    # Add small jitter to break symmetry\n    np.random.seed(42)\n    centers += (np.random.rand(n, 2) - 0.5) * 0.02\n    \n    # Initial radii\n    radii = np.full(n, 0.08)\n    \n    # Flatten variables for optimizer: [x1, y1, ..., xn, yn, r1, r2, ..., rn]\n    initial_params = np.concatenate([centers.flatten(), radii])\n    \n    def objective(params):\n        # Maximize sum of radii\n        r = params[2*n:]\n        return -np.sum(r)\n    \n    def constraints(params):\n        c = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        cons = []\n        \n        # Boundary constraints: center_i +/- r_i must be in [0, 1]\n        for i in range(n):\n            cons.append(c[i, 0] - r[i])          # x - r >= 0\n            cons.append(1.0 - (c[i, 0] + r[i]))  # x + r <= 1\n            cons.append(c[i, 1] - r[i])          # y - r >= 0\n            cons.append(1.0 - (c[i, 1] + r[i]))  # y + r <= 1\n            \n        # Non-overlap constraints: dist(ci, cj) >= ri + rj\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Using squared distance is often more stable, \n                # but standard distance is fine for SLSQP here.\n                dist = np.sqrt(np.sum((c[i] - c[j])**2))\n                cons.append(dist - (r[i] + r[j]))\n                \n        return np.array(cons)\n\n    # Variable bounds\n    bounds = [(0, 1)] * (2 * n) + [(0.001, 0.5)] * n\n        \n    # Optimization Loop\n    # We run a few iterations to refine the positions.\n    res = minimize(\n        objective, \n        initial_params, \n        method='SLSQP', \n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraints},\n        options={'maxiter': 60, 'disp': False}\n    )\n    \n    # Extract results\n    final_params = res.x\n    final_centers = final_params[:2*n].reshape((n, 2))\n    final_radii = final_params[2*n:]\n    \n    # Post-processing to ensure absolute feasibility (numerical safety)\n    # 1. Force into boundary\n    for i in range(n):\n        final_centers[i] = np.clip(final_centers[i], final_radii[i], 1.0 - final_radii[i])\n    \n    # 2. Resolve overlaps by slightly shrinking radii if necessary\n    for _ in range(5): # Iterative refinement\n        for i in range(n):\n            # Check boundary\n            final_radii[i] = min(final_radii[i], final_centers[i, 0], 1 - final_centers[i, 0],\n                                 final_centers[i, 1], 1 - final_centers[i, 1])\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(final_centers[i] - final_centers[j])\n                if final_radii[i] + final_radii[j] > dist:\n                    # Shrink both slightly\n                    overlap = (final_radii[i] + final_radii[j] - dist)\n                    final_radii[i] -= overlap / 2.0 + 1e-10\n                    final_radii[j] -= overlap / 2.0 + 1e-10\n                    final_radii[i] = max(final_radii[i], 0)\n                    final_radii[j] = max(final_radii[j], 0)\n\n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()}}",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses a simulated annealing approach with neighborhood swaps and \n    compaction, followed by SLSQP refinement to maximize sum of radii.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n\n    # 1. Initial State: Grid-based initialization\n    # 5x5 grid + 1 extra\n    grid_side = 5\n    centers = []\n    for i in range(grid_side):\n        for j in range(grid_side):\n            centers.append([(i + 0.5) / grid_side, (j + 0.5) / grid_side])\n    centers.append([0.5, 0.5])\n    centers = np.array(centers)\n    radii = np.full(n, 0.1)\n\n    def get_valid_radii(c):\n        \"\"\"Greedily determine radii for fixed centers to satisfy constraints.\"\"\"\n        r = np.zeros(n)\n        # Boundary constraints\n        for i in range(n):\n            r[i] = min(c[i, 0], 1.0 - c[i, 0], c[i, 1], 1.0 - c[i, 1])\n        \n        # Iterative shrinkage to resolve overlaps\n        for _ in range(10):\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist = np.linalg.norm(c[i] - c[j])\n                    if r[i] + r[j] > dist:\n                        # Shrink proportional to current radius\n                        total_r = r[i] + r[j]\n                        excess = total_r - dist + 1e-9\n                        r[i] -= excess * (r[i] / total_r)\n                        r[j] -= excess * (r[j] / total_r)\n            r = np.maximum(r, 0)\n        return r\n\n    # 2. Simulated Annealing with Enhancements\n    current_centers = centers.copy()\n    current_radii = get_valid_radii(current_centers)\n    current_sum = np.sum(current_radii)\n    \n    best_centers = current_centers.copy()\n    best_sum = current_sum\n\n    iterations = 2500\n    temp = 0.1\n    cooling_rate = 0.998\n\n    for k in range(iterations):\n        new_centers = current_centers.copy()\n        \n        # Enhancement 1: Neighbor function - Move or Swap\n        if np.random.rand() < 0.2:\n            # Swap positions of a 'small' and 'large' circle area\n            idx = np.random.choice(n, 2, replace=False)\n            new_centers[idx[0]], new_centers[idx[1]] = new_centers[idx[1]].copy(), new_centers[idx[0]].copy()\n        else:\n            # Standard move\n            idx = np.random.randint(n)\n            new_centers[idx] += (np.random.rand(2) - 0.5) * temp\n            new_centers[idx] = np.clip(new_centers[idx], 0.01, 0.99)\n\n        # Enhancement 2: Compaction step every 100 iterations\n        if k % 100 == 0:\n            # Push circles slightly towards nearest corner/edge to open space\n            for i in range(n):\n                push = np.array([0.5, 0.5]) - new_centers[i]\n                new_centers[i] += 0.05 * push * temp\n\n        new_radii = get_valid_radii(new_centers)\n        new_sum = np.sum(new_radii)\n\n        # Acceptance criteria\n        if new_sum > current_sum or np.exp((new_sum - current_sum) / (temp + 1e-9)) > np.random.rand():\n            current_centers = new_centers\n            current_sum = new_sum\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_centers = current_centers.copy()\n\n        # Enhancement 3: Geometric cooling\n        temp *= cooling_rate\n\n    # 3. Final Local Optimization (SLSQP)\n    def objective(params):\n        return -np.sum(params[2*n:])\n\n    def constraints(params):\n        c = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        cons = []\n        for i in range(n):\n            cons.extend([c[i, 0] - r[i], 1.0 - c[i, 0] - r[i],\n                         c[i, 1] - r[i], 1.0 - c[i, 1] - r[i]])\n            for j in range(i + 1, n):\n                cons.append(np.linalg.norm(c[i] - c[j]) - (r[i] + r[j]))\n        return np.array(cons)\n\n    best_radii = get_valid_radii(best_centers)\n    initial_params = np.concatenate([best_centers.flatten(), best_radii])\n    \n    res = minimize(\n        objective, \n        initial_params, \n        method='SLSQP', \n        constraints={'type': 'ineq', 'fun': constraints},\n        bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n        options={'maxiter': 100}\n    )\n\n    final_params = res.x\n    final_centers = final_params[:2*n].reshape((n, 2))\n    final_radii = final_params[2*n:]\n\n    # Final feasibility cleanup\n    for _ in range(10):\n        for i in range(n):\n            final_radii[i] = min(final_radii[i], final_centers[i, 0], 1 - final_centers[i, 0],\n                                 final_centers[i, 1], 1 - final_centers[i, 1])\n            for j in range(i + 1, n):\n                d = np.linalg.norm(final_centers[i] - final_centers[j])\n                if final_radii[i] + final_radii[j] > d:\n                    overlap = (final_radii[i] + final_radii[j] - d) + 1e-12\n                    final_radii[i] -= overlap / 2\n                    final_radii[j] -= overlap / 2\n        final_radii = np.maximum(final_radii, 0)\n\n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T22:46:04.082482",
  "cost_data": null
}