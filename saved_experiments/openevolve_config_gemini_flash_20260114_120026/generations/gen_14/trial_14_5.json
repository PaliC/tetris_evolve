{
  "trial_id": "trial_14_5",
  "generation": 14,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized packing of 26 circles in a unit square.\n    Returns:\n        - centers: np.array shape (26, 2) with circle centers\n        - radii: np.array shape (26,) with circle radii\n        - sum_radii: sum of all radii\n    \"\"\"\n    # Number of circles\n    n_circles = 26\n    \n    # Initial configuration - hexagonal pattern with perturbation\n    centers = initialize_centers(n_circles)\n    \n    # Optimize the centers and radii\n    centers, radii = optimize_packing(centers)\n    \n    # Calculate the sum of radii\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef initialize_centers(n_circles):\n    \"\"\"Initialize centers using a perturbed grid pattern.\"\"\"\n    # Create a grid with more points than needed\n    grid_size = int(np.ceil(np.sqrt(n_circles * 1.5)))\n    x = np.linspace(0.1, 0.9, grid_size)\n    y = np.linspace(0.1, 0.9, grid_size)\n    xx, yy = np.meshgrid(x, y)\n    \n    # Add slight perturbation\n    xx += np.random.uniform(-0.03, 0.03, xx.shape)\n    yy += np.random.uniform(-0.03, 0.03, yy.shape)\n    \n    # Flatten and combine\n    points = np.vstack([xx.ravel(), yy.ravel()]).T\n    \n    # Select n_circles points that are most spread out\n    # Start with a random point\n    selected = [np.random.randint(len(points))]\n    remaining = list(range(len(points)))\n    remaining.remove(selected[0])\n    \n    # Iteratively select the point that maximizes the minimum distance to already selected points\n    while len(selected) < n_circles:\n        best_idx = max(remaining, key=lambda i: min(np.linalg.norm(points[i] - points[j]) for j in selected))\n        selected.append(best_idx)\n        remaining.remove(best_idx)\n    \n    return points[selected]\n\ndef calculate_radii(centers):\n    \"\"\"Calculate maximum possible radii for given centers.\"\"\"\n    n = centers.shape[0]\n    \n    # Calculate pairwise distances between centers\n    distances = squareform(pdist(centers))\n    np.fill_diagonal(distances, np.inf)  # Avoid self-distances\n    \n    # Calculate distances to boundaries\n    boundary_distances = np.minimum.reduce([\n        centers[:, 0],                # Distance to left boundary\n        1 - centers[:, 0],            # Distance to right boundary\n        centers[:, 1],                # Distance to bottom boundary\n        1 - centers[:, 1]             # Distance to top boundary\n    ])\n    \n    # For each center, the maximum radius is limited by:\n    # 1. Half the minimum distance to any other center\n    # 2. The distance to the nearest boundary\n    radii = np.minimum(\n        np.min(distances, axis=1) / 2,  # Half the minimum distance to other centers\n        boundary_distances               # Distance to nearest boundary\n    )\n    \n    return radii\n\ndef objective_function(x, n_circles):\n    \"\"\"Objective function to maximize sum of radii.\"\"\"\n    # Reshape x into centers\n    centers = x.reshape(n_circles, 2)\n    \n    # Calculate radii\n    radii = calculate_radii(centers)\n    \n    # Return negative sum of radii (since we're minimizing)\n    return -np.sum(radii)\n\ndef constraint_function(x, n_circles):\n    \"\"\"Constraint function ensuring all circles are within the unit square.\"\"\"\n    # Reshape x into centers\n    centers = x.reshape(n_circles, 2)\n    \n    # Calculate radii\n    radii = calculate_radii(centers)\n    \n    # Calculate constraints: each center must be at least its radius away from boundaries\n    constraints = []\n    \n    # Left boundary: x_i - r_i >= 0\n    constraints.extend(centers[:, 0] - radii)\n    \n    # Right boundary: x_i + r_i <= 1\n    constraints.extend(1 - centers[:, 0] - radii)\n    \n    # Bottom boundary: y_i - r_i >= 0\n    constraints.extend(centers[:, 1] - radii)\n    \n    # Top boundary: y_i + r_i <= 1\n    constraints.extend(1 - centers[:, 1] - radii)\n    \n    return np.array(constraints)\n\ndef optimize_packing(initial_centers):\n    \"\"\"Optimize the packing using numerical optimization.\"\"\"\n    n_circles = initial_centers.shape[0]\n    \n    # Flatten centers for optimization\n    x0 = initial_centers.flatten()\n    \n    # Define bounds to keep centers within [0,1] x [0,1]\n    bounds = [(0, 1)] * (2 * n_circles)\n    \n    # Define constraint\n    constraint = {\n        'type': 'ineq',\n        'fun': constraint_function,\n        'args': (n_circles,)\n    }\n    \n    # Run optimization\n    result = minimize(\n        objective_function,\n        x0,\n        args=(n_circles,),\n        bounds=bounds,\n        constraints=constraint,\n        method='SLSQP',\n        options={'maxiter': 500, 'ftol': 1e-8}\n    )\n    \n    # Extract optimized centers\n    optimized_centers = result.x.reshape(n_circles, 2)\n    \n    # Calculate radii for optimized centers\n    optimized_radii = calculate_radii(optimized_centers)\n    \n    # Apply multi-start optimization to improve the solution\n    for _ in range(3):\n        # Perturb the current solution slightly\n        perturbed_centers = optimized_centers + np.random.uniform(-0.01, 0.01, optimized_centers.shape)\n        perturbed_centers = np.clip(perturbed_centers, 0.01, 0.99)  # Keep away from boundaries\n        \n        # Optimize from this new starting point\n        x0 = perturbed_centers.flatten()\n        result = minimize(\n            objective_function,\n            x0,\n            args=(n_circles,),\n            bounds=bounds,\n            constraints=constraint,\n            method='SLSQP',\n            options={'maxiter': 300, 'ftol': 1e-8}\n        )\n        \n        # Extract centers and calculate radii\n        new_centers = result.x.reshape(n_circles, 2)\n        new_radii = calculate_radii(new_centers)\n        \n        # If the new solution is better, keep it\n        if np.sum(new_radii) > np.sum(optimized_radii):\n            optimized_centers = new_centers\n            optimized_radii = new_radii\n    \n    return optimized_centers, optimized_radii\n\ndef run_packing():\n    \"\"\"Run the circle packing algorithm and return the results.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.508991608450177,
    "eval_time": 1.19942307472229,
    "error": null
  },
  "prompt": "Develop a circle packing solution using geometric patterns and mathematical principles.\n\nGoal: Pack 26 circles in a unit square [0,1] x [0,1] to maximize sum of radii.\n- All circles must stay inside the unit square\n- No two circles can overlap\n- All radii must be non-negative\n\nUse principles from:\n1. Voronoi diagrams for space partitioning\n2. Mathematical packing theory\n3. Symmetry and pattern-based approaches\n4. Circle packing in regular polygons\n5. Iterative growth methods\n\nCombine these geometric approaches with optimization to find a high-quality solution.\n\nReturn complete, executable code implementing this geometric approach.",
  "response": "# Circle Packing Solution\n\nI'll develop a solution combining geometric principles with optimization techniques to pack 26 circles in a unit square while maximizing the sum of their radii.\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized packing of 26 circles in a unit square.\n    Returns:\n        - centers: np.array shape (26, 2) with circle centers\n        - radii: np.array shape (26,) with circle radii\n        - sum_radii: sum of all radii\n    \"\"\"\n    # Number of circles\n    n_circles = 26\n    \n    # Initial configuration - hexagonal pattern with perturbation\n    centers = initialize_centers(n_circles)\n    \n    # Optimize the centers and radii\n    centers, radii = optimize_packing(centers)\n    \n    # Calculate the sum of radii\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef initialize_centers(n_circles):\n    \"\"\"Initialize centers using a perturbed grid pattern.\"\"\"\n    # Create a grid with more points than needed\n    grid_size = int(np.ceil(np.sqrt(n_circles * 1.5)))\n    x = np.linspace(0.1, 0.9, grid_size)\n    y = np.linspace(0.1, 0.9, grid_size)\n    xx, yy = np.meshgrid(x, y)\n    \n    # Add slight perturbation\n    xx += np.random.uniform(-0.03, 0.03, xx.shape)\n    yy += np.random.uniform(-0.03, 0.03, yy.shape)\n    \n    # Flatten and combine\n    points = np.vstack([xx.ravel(), yy.ravel()]).T\n    \n    # Select n_circles points that are most spread out\n    # Start with a random point\n    selected = [np.random.randint(len(points))]\n    remaining = list(range(len(points)))\n    remaining.remove(selected[0])\n    \n    # Iteratively select the point that maximizes the minimum distance to already selected points\n    while len(selected) < n_circles:\n        best_idx = max(remaining, key=lambda i: min(np.linalg.norm(points[i] - points[j]) for j in selected))\n        selected.append(best_idx)\n        remaining.remove(best_idx)\n    \n    return points[selected]\n\ndef calculate_radii(centers):\n    \"\"\"Calculate maximum possible radii for given centers.\"\"\"\n    n = centers.shape[0]\n    \n    # Calculate pairwise distances between centers\n    distances = squareform(pdist(centers))\n    np.fill_diagonal(distances, np.inf)  # Avoid self-distances\n    \n    # Calculate distances to boundaries\n    boundary_distances = np.minimum.reduce([\n        centers[:, 0],                # Distance to left boundary\n        1 - centers[:, 0],            # Distance to right boundary\n        centers[:, 1],                # Distance to bottom boundary\n        1 - centers[:, 1]             # Distance to top boundary\n    ])\n    \n    # For each center, the maximum radius is limited by:\n    # 1. Half the minimum distance to any other center\n    # 2. The distance to the nearest boundary\n    radii = np.minimum(\n        np.min(distances, axis=1) / 2,  # Half the minimum distance to other centers\n        boundary_distances               # Distance to nearest boundary\n    )\n    \n    return radii\n\ndef objective_function(x, n_circles):\n    \"\"\"Objective function to maximize sum of radii.\"\"\"\n    # Reshape x into centers\n    centers = x.reshape(n_circles, 2)\n    \n    # Calculate radii\n    radii = calculate_radii(centers)\n    \n    # Return negative sum of radii (since we're minimizing)\n    return -np.sum(radii)\n\ndef constraint_function(x, n_circles):\n    \"\"\"Constraint function ensuring all circles are within the unit square.\"\"\"\n    # Reshape x into centers\n    centers = x.reshape(n_circles, 2)\n    \n    # Calculate radii\n    radii = calculate_radii(centers)\n    \n    # Calculate constraints: each center must be at least its radius away from boundaries\n    constraints = []\n    \n    # Left boundary: x_i - r_i >= 0\n    constraints.extend(centers[:, 0] - radii)\n    \n    # Right boundary: x_i + r_i <= 1\n    constraints.extend(1 - centers[:, 0] - radii)\n    \n    # Bottom boundary: y_i - r_i >= 0\n    constraints.extend(centers[:, 1] - radii)\n    \n    # Top boundary: y_i + r_i <= 1\n    constraints.extend(1 - centers[:, 1] - radii)\n    \n    return np.array(constraints)\n\ndef optimize_packing(initial_centers):\n    \"\"\"Optimize the packing using numerical optimization.\"\"\"\n    n_circles = initial_centers.shape[0]\n    \n    # Flatten centers for optimization\n    x0 = initial_centers.flatten()\n    \n    # Define bounds to keep centers within [0,1] x [0,1]\n    bounds = [(0, 1)] * (2 * n_circles)\n    \n    # Define constraint\n    constraint = {\n        'type': 'ineq',\n        'fun': constraint_function,\n        'args': (n_circles,)\n    }\n    \n    # Run optimization\n    result = minimize(\n        objective_function,\n        x0,\n        args=(n_circles,),\n        bounds=bounds,\n        constraints=constraint,\n        method='SLSQP',\n        options={'maxiter': 500, 'ftol': 1e-8}\n    )\n    \n    # Extract optimized centers\n    optimized_centers = result.x.reshape(n_circles, 2)\n    \n    # Calculate radii for optimized centers\n    optimized_radii = calculate_radii(optimized_centers)\n    \n    # Apply multi-start optimization to improve the solution\n    for _ in range(3):\n        # Perturb the current solution slightly\n        perturbed_centers = optimized_centers + np.random.uniform(-0.01, 0.01, optimized_centers.shape)\n        perturbed_centers = np.clip(perturbed_centers, 0.01, 0.99)  # Keep away from boundaries\n        \n        # Optimize from this new starting point\n        x0 = perturbed_centers.flatten()\n        result = minimize(\n            objective_function,\n            x0,\n            args=(n_circles,),\n            bounds=bounds,\n            constraints=constraint,\n            method='SLSQP',\n            options={'maxiter': 300, 'ftol': 1e-8}\n        )\n        \n        # Extract centers and calculate radii\n        new_centers = result.x.reshape(n_circles, 2)\n        new_radii = calculate_radii(new_centers)\n        \n        # If the new solution is better, keep it\n        if np.sum(new_radii) > np.sum(optimized_radii):\n            optimized_centers = new_centers\n            optimized_radii = new_radii\n    \n    return optimized_centers, optimized_radii\n\ndef run_packing():\n    \"\"\"Run the circle packing algorithm and return the results.\"\"\"\n    return construct_packing()\n```\n\nThis solution combines several geometric principles:\n\n1. **Initialization with spatial distribution**: The algorithm starts with a grid-based pattern with slight perturbation, selecting points that are well-distributed across the space.\n\n2. **Voronoi-inspired spacing**: The initialization algorithm maximizes minimum distances between centers, similar to principles in Voronoi diagrams.\n\n3. **Iterative optimization**: The solution uses numerical optimization to fine-tune the centers, maximizing the sum of radii while maintaining constraints.\n\n4. **Multi-start optimization**: To avoid local optima, the algorithm applies multiple optimization runs with perturbed starting points.\n\n5. **Boundary awareness**: The algorithm carefully handles constraints to ensure circles remain within the unit square while maximizing their sizes.\n\nThe result is a circle packing that efficiently utilizes the available space in the unit square to maximize the sum of all radii.",
  "reasoning": "# Circle Packing Solution\n\nI'll develop a solution combining geometric principles with optimization techniques to pack 26 circles in a unit square while maximizing the sum of their radii.\n\nThis solution combines several geometric principles:\n\n1. **Initialization with spatial distribution**: The algorithm starts with a grid-based pattern with slight perturbation, selecting points that are well-distributed across the space.\n\n2. **Voronoi-inspired spacing**: The initialization algorithm maximizes minimum distances between centers, similar to principles in Voronoi diagrams.\n\n3. **Iterative optimization**: The solution uses numerical optimization to fine-tune the centers, maximizing the sum of radii while maintaining constraints.\n\n4. **Multi-start optimization**: To avoid local optima, the algorithm applies multiple optimization runs with perturbed starting points.\n\n5. **Boundary awareness**: The algorithm carefully handles constraints to ensure circles remain within the unit square while maximizing their sizes.\n\nThe result is a circle packing that efficiently utilizes the available space in the unit square to maximize the sum of all radii.",
  "timestamp": "2026-01-14T13:21:33.644360",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-3.7-sonnet",
    "temperature": 0.7
  }
}