{
  "trial_id": "trial_14_6",
  "generation": 14,
  "parent_id": null,
  "code": "import numpy as np\nimport cma\n\ndef construct_packing():\n    \"\"\"\n    Constructs a packing of 26 circles in a unit square to maximize the sum of their radii\n    using CMA-ES.\n    \"\"\"\n\n    def fitness(x):\n        \"\"\"\n        Fitness function to be maximized.\n        x: array of shape (78,) representing circle centers and radii.\n           x[:52] are the x and y coordinates of the circle centers.\n           x[52:] are the radii of the circles.\n        \"\"\"\n        centers = x[:52].reshape(26, 2)\n        radii = x[52:]\n\n        # Constraint handling using penalty functions\n        penalty = 0\n\n        # 1. Circle centers within the unit square\n        for i in range(26):\n            if centers[i, 0] < radii[i] or centers[i, 0] > 1 - radii[i]:\n                penalty += 100  # Increased penalty\n            if centers[i, 1] < radii[i] or centers[i, 1] > 1 - radii[i]:\n                penalty += 100  # Increased penalty\n\n        # 2. No overlapping circles\n        for i in range(26):\n            for j in range(i + 1, 26):\n                distance = np.linalg.norm(centers[i] - centers[j])\n                if distance < radii[i] + radii[j]:\n                    penalty += 100 * (radii[i] + radii[j] - distance)  # Increased penalty and scaled by violation\n\n        # 3. Radii must be non-negative\n        for i in range(26):\n            if radii[i] < 0:\n                penalty += 100 * abs(radii[i])  # Increased penalty and scaled by violation\n\n        # Calculate the sum of radii and apply the penalty\n        sum_radii = np.sum(radii)\n        return sum_radii - penalty\n\n\n    # Initial guess for the circle centers and radii\n    x0 = np.random.rand(78)\n    x0[52:] = x0[52:] * 0.1  # Initialize radii to smaller values\n\n    # Define the bounds for the parameters\n    bounds = [[0, 1]] * 52 + [[0, 0.5]] * 26  # Radii between 0 and 0.5\n    bounds = np.array(bounds).T.tolist()\n\n    # CMA-ES optimization\n    options = {\n        'bounds': bounds,\n        'popsize': 20,\n        'maxiter': 5000,\n        'tolx': 1e-6,\n        'tolfun': 1e-6,\n        'verb_disp': 0 # Suppress output\n    }\n    es = cma.CMAEvolutionStrategy(x0, 0.2, options)\n\n    while not es.stop():\n        solutions = es.ask()\n        fitness_values = [-fitness(x) for x in solutions]  # CMA-ES minimizes, so negate fitness\n        es.tell(solutions, fitness_values)\n        #es.disp()  # Suppress output\n        #es.logger.plot() # Suppress output\n\n    # Get the best solution\n    best_x = es.result.xbest\n    best_centers = best_x[:52].reshape(26, 2)\n    best_radii = best_x[52:]\n    best_sum_radii = np.sum(best_radii)\n\n    return best_centers, best_radii, best_sum_radii\n\n\ndef run_packing():\n    return construct_packing()\n\nif __name__ == '__main__':\n    centers, radii, sum_radii = run_packing()\n    print(\"Sum of radii:\", sum_radii)\n    print(\"Centers:\\n\", centers)\n    print(\"Radii:\\n\", radii)",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 0.05733013153076172,
    "error": "ModuleNotFoundError: No module named 'cma'"
  },
  "prompt": "Implement a circle packing solution using evolutionary optimization techniques.\n\nGoal: Pack 26 circles in a unit square [0,1] x [0,1] to maximize sum of radii.\n- All circles must stay inside the unit square\n- No two circles can overlap\n- All radii must be non-negative\n\nImplement using:\n1. CMA-ES (Covariance Matrix Adaptation Evolution Strategy)\n2. Custom mutation and recombination operators\n3. Population-based optimization\n4. Fitness-based selection\n5. Constraint handling using penalty functions\n\nReturn complete, executable code implementing this evolutionary approach.",
  "response": "```python\nimport numpy as np\nimport cma\n\ndef construct_packing():\n    \"\"\"\n    Constructs a packing of 26 circles in a unit square to maximize the sum of their radii\n    using CMA-ES.\n    \"\"\"\n\n    def fitness(x):\n        \"\"\"\n        Fitness function to be maximized.\n        x: array of shape (78,) representing circle centers and radii.\n           x[:52] are the x and y coordinates of the circle centers.\n           x[52:] are the radii of the circles.\n        \"\"\"\n        centers = x[:52].reshape(26, 2)\n        radii = x[52:]\n\n        # Constraint handling using penalty functions\n        penalty = 0\n\n        # 1. Circle centers within the unit square\n        for i in range(26):\n            if centers[i, 0] < radii[i] or centers[i, 0] > 1 - radii[i]:\n                penalty += 100  # Increased penalty\n            if centers[i, 1] < radii[i] or centers[i, 1] > 1 - radii[i]:\n                penalty += 100  # Increased penalty\n\n        # 2. No overlapping circles\n        for i in range(26):\n            for j in range(i + 1, 26):\n                distance = np.linalg.norm(centers[i] - centers[j])\n                if distance < radii[i] + radii[j]:\n                    penalty += 100 * (radii[i] + radii[j] - distance)  # Increased penalty and scaled by violation\n\n        # 3. Radii must be non-negative\n        for i in range(26):\n            if radii[i] < 0:\n                penalty += 100 * abs(radii[i])  # Increased penalty and scaled by violation\n\n        # Calculate the sum of radii and apply the penalty\n        sum_radii = np.sum(radii)\n        return sum_radii - penalty\n\n\n    # Initial guess for the circle centers and radii\n    x0 = np.random.rand(78)\n    x0[52:] = x0[52:] * 0.1  # Initialize radii to smaller values\n\n    # Define the bounds for the parameters\n    bounds = [[0, 1]] * 52 + [[0, 0.5]] * 26  # Radii between 0 and 0.5\n    bounds = np.array(bounds).T.tolist()\n\n    # CMA-ES optimization\n    options = {\n        'bounds': bounds,\n        'popsize': 20,\n        'maxiter': 5000,\n        'tolx': 1e-6,\n        'tolfun': 1e-6,\n        'verb_disp': 0 # Suppress output\n    }\n    es = cma.CMAEvolutionStrategy(x0, 0.2, options)\n\n    while not es.stop():\n        solutions = es.ask()\n        fitness_values = [-fitness(x) for x in solutions]  # CMA-ES minimizes, so negate fitness\n        es.tell(solutions, fitness_values)\n        #es.disp()  # Suppress output\n        #es.logger.plot() # Suppress output\n\n    # Get the best solution\n    best_x = es.result.xbest\n    best_centers = best_x[:52].reshape(26, 2)\n    best_radii = best_x[52:]\n    best_sum_radii = np.sum(best_radii)\n\n    return best_centers, best_radii, best_sum_radii\n\n\ndef run_packing():\n    return construct_packing()\n\nif __name__ == '__main__':\n    centers, radii, sum_radii = run_packing()\n    print(\"Sum of radii:\", sum_radii)\n    print(\"Centers:\\n\", centers)\n    print(\"Radii:\\n\", radii)\n```",
  "reasoning": "",
  "timestamp": "2026-01-14T13:21:11.079874",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 344,
        "candidates_token_count": 923,
        "thoughts_token_count": 0
      },
      "response_text_len": 2890
    }
  }
}