{
  "trial_id": "trial_5_2",
  "generation": 5,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy import optimize\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) where:\n    - centers: np.array shape (26, 2)\n    - radii: np.array shape (26,)\n    - sum_radii: float\n    \"\"\"\n\n    def fitness(x):\n        centers = x[:52].reshape(26, 2)\n        radii = x[52:]\n        sum_radii = np.sum(radii)\n\n        # Constraint violations penalty\n        penalty = 0.0\n\n        # 1. Circles inside the square\n        for i in range(26):\n            penalty += max(0, radii[i] - centers[i, 0]) * 100\n            penalty += max(0, radii[i] - (1 - centers[i, 0])) * 100\n            penalty += max(0, radii[i] - centers[i, 1]) * 100\n            penalty += max(0, radii[i] - (1 - centers[i, 1])) * 100\n\n        # 2. No overlapping circles\n        for i in range(26):\n            for j in range(i + 1, 26):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                penalty += max(0, overlap) * 100\n\n        return -sum_radii - penalty  # Minimize negative sum of radii + penalties\n\n    # Bounds: centers [0,1], radii [0, 0.5] (max radius to fit in square)\n    bounds = [(0, 1)] * 52 + [(0, 0.5)] * 26\n\n    # Initial guess (random)\n    initial_guess = np.random.rand(78)\n    \n    # Differential Evolution\n    result = optimize.differential_evolution(\n        fitness,\n        bounds,\n        maxiter=1000,  # Increased iterations\n        popsize=15,   # Adjusted population size\n        mutation=(0.5, 1), # Adjusted mutation range\n        recombination=0.7,\n        tol=0.0001,\n        polish=False,\n        disp=False\n    )\n\n    x = result.x\n    centers = x[:52].reshape(26, 2)\n    radii = x[52:]\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 90.01648879051208,
    "error": "Timeout after 90s"
  },
  "prompt": "\nImplement a circle packing algorithm using differential evolution optimization.\n\nPack 26 circles into a unit square [0,1]x[0,1] to maximize the sum of their radii:\n- All circles must be entirely inside the unit square\n- No two circles may overlap\n- All radii must be non-negative\n\nUse differential evolution with these enhancements:\n1. Specialized encoding for circle centers and radii\n2. Custom mutation strategies for both position and radius\n3. Adaptive parameters that change during optimization\n4. Repair operators that fix constraint violations\n5. Multiple populations with migration between them\n\nReturn a solution with this structure:\n```python\nimport numpy as np\nfrom scipy import optimize\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) where:\n    - centers: np.array shape (26, 2)\n    - radii: np.array shape (26,)\n    - sum_radii: float\n    \"\"\"\n    # Implement differential evolution approach\n    \ndef run_packing():\n    return construct_packing()\n```\n",
  "response": "```python\nimport numpy as np\nfrom scipy import optimize\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) where:\n    - centers: np.array shape (26, 2)\n    - radii: np.array shape (26,)\n    - sum_radii: float\n    \"\"\"\n\n    def fitness(x):\n        centers = x[:52].reshape(26, 2)\n        radii = x[52:]\n        sum_radii = np.sum(radii)\n\n        # Constraint violations penalty\n        penalty = 0.0\n\n        # 1. Circles inside the square\n        for i in range(26):\n            penalty += max(0, radii[i] - centers[i, 0]) * 100\n            penalty += max(0, radii[i] - (1 - centers[i, 0])) * 100\n            penalty += max(0, radii[i] - centers[i, 1]) * 100\n            penalty += max(0, radii[i] - (1 - centers[i, 1])) * 100\n\n        # 2. No overlapping circles\n        for i in range(26):\n            for j in range(i + 1, 26):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                penalty += max(0, overlap) * 100\n\n        return -sum_radii - penalty  # Minimize negative sum of radii + penalties\n\n    # Bounds: centers [0,1], radii [0, 0.5] (max radius to fit in square)\n    bounds = [(0, 1)] * 52 + [(0, 0.5)] * 26\n\n    # Initial guess (random)\n    initial_guess = np.random.rand(78)\n    \n    # Differential Evolution\n    result = optimize.differential_evolution(\n        fitness,\n        bounds,\n        maxiter=1000,  # Increased iterations\n        popsize=15,   # Adjusted population size\n        mutation=(0.5, 1), # Adjusted mutation range\n        recombination=0.7,\n        tol=0.0001,\n        polish=False,\n        disp=False\n    )\n\n    x = result.x\n    centers = x[:52].reshape(26, 2)\n    radii = x[52:]\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-14T12:33:04.255980",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 452,
        "candidates_token_count": 619,
        "thoughts_token_count": 0
      },
      "response_text_len": 1836
    }
  }
}