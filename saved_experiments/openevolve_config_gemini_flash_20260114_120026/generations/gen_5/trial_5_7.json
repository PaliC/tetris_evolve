{
  "trial_id": "trial_5_7",
  "generation": 5,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) where:\n    - centers: np.array shape (26, 2)\n    - radii: np.array shape (26,)\n    - sum_radii: float\n    \"\"\"\n    # PSO parameters\n    n_particles = 50\n    n_iterations = 100\n    inertia_max = 0.9\n    inertia_min = 0.4\n    c1 = 2.0\n    c2 = 2.0\n    neighborhood_size = 5  # Adjust as needed\n\n    # Problem definition\n    n_circles = 26\n    dimension = n_circles * 3  # x, y, radius for each circle\n\n    # Initialize particles\n    particles = np.random.rand(n_particles, dimension)\n    velocities = np.random.rand(n_particles, dimension) * 0.1  # Smaller initial velocities\n    personal_best_positions = particles.copy()\n    personal_best_fitness = np.zeros(n_particles)\n    global_best_position = None\n    global_best_fitness = -np.inf\n\n    def fitness(particle):\n        \"\"\"Calculates the fitness of a particle, considering constraints.\"\"\"\n        centers = particle[:n_circles * 2].reshape(n_circles, 2)\n        radii = particle[n_circles * 2:]\n        radii = np.clip(radii, 0, 1)  # Ensure radii are non-negative and not too large\n\n        # Constraint handling (penalties)\n        penalty = 0\n\n        # Circle containment constraint\n        for i in range(n_circles):\n            if centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or \\\n               centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1:\n                penalty += 100  # Large penalty for violating containment\n\n        # Circle overlap constraint\n        distances = cdist(centers, centers)\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                if distances[i, j] < radii[i] + radii[j]:\n                    penalty += 100  # Large penalty for overlap\n\n        # Evaluate the radii\n        sum_radii = np.sum(radii)\n\n        return sum_radii - penalty\n\n    # Initialize personal best fitness\n    for i in range(n_particles):\n        personal_best_fitness[i] = fitness(particles[i])\n\n    # Main PSO loop\n    for iteration in range(n_iterations):\n        # Adaptive inertia weight\n        inertia = inertia_max - (inertia_max - inertia_min) * iteration / n_iterations\n\n        for i in range(n_particles):\n            # Update velocity\n            r1 = np.random.rand(dimension)\n            r2 = np.random.rand(dimension)\n\n            # Neighborhood best (using ring topology)\n            neighborhood_indices = np.arange(i - neighborhood_size // 2, i + neighborhood_size // 2 + 1) % n_particles\n            neighborhood_fitnesses = personal_best_fitness[neighborhood_indices]\n            best_neighbor_index = neighborhood_indices[np.argmax(neighborhood_fitnesses)]\n            neighborhood_best_position = personal_best_positions[best_neighbor_index]\n\n            velocities[i] = (inertia * velocities[i] +\n                             c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                             c2 * r2 * (neighborhood_best_position - particles[i]))\n\n            # Update position\n            particles[i] = particles[i] + velocities[i]\n\n            # Bound position (0 to 1 for centers, and adjust radii to fit)\n            centers = particles[i][:n_circles * 2].reshape(n_circles, 2)\n            radii = particles[i][n_circles * 2:]\n\n            # Containment constraint handling (clipping)\n            for j in range(n_circles):\n                centers[j, 0] = np.clip(centers[j, 0], 0, 1)\n                centers[j, 1] = np.clip(centers[j, 1], 0, 1)\n\n                # Radius clipping based on center position\n                max_radius_x = min(centers[j, 0], 1 - centers[j, 0])\n                max_radius_y = min(centers[j, 1], 1 - centers[j, 1])\n                max_radius = min(max_radius_x, max_radius_y)\n                radii[j] = np.clip(radii[j], 0, max_radius)\n\n            particles[i, :n_circles * 2] = centers.flatten()\n            particles[i, n_circles * 2:] = radii\n\n            # Evaluate fitness\n            current_fitness = fitness(particles[i])\n\n            # Update personal best\n            if current_fitness > personal_best_fitness[i]:\n                personal_best_fitness[i] = current_fitness\n                personal_best_positions[i] = particles[i].copy()\n\n                # Update global best\n                if current_fitness > global_best_fitness:\n                    global_best_fitness = current_fitness\n                    global_best_position = particles[i].copy()\n\n    # Extract results from global best\n    centers = global_best_position[:n_circles * 2].reshape(n_circles, 2)\n    radii = global_best_position[n_circles * 2:]\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 0.5309646072719435,
    "eval_time": 1.2369821071624756,
    "error": null
  },
  "prompt": "\nImplement a Particle Swarm Optimization (PSO) approach for circle packing.\n\nPack 26 circles into a unit square [0,1]x[0,1] to maximize the sum of their radii:\n- All circles must be entirely inside the unit square\n- No two circles may overlap\n- All radii must be non-negative\n\nCreate a PSO implementation that:\n1. Uses an effective particle representation for circles\n2. Implements adaptive inertia and acceleration coefficients\n3. Includes specialized position and velocity update rules\n4. Incorporates constraint handling through penalties or repair\n5. Uses neighborhood topologies to balance exploration and exploitation\n\nReturn a solution with this structure:\n```python\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) where:\n    - centers: np.array shape (26, 2)\n    - radii: np.array shape (26,)\n    - sum_radii: float\n    \"\"\"\n    # Implement your PSO approach\n    \ndef run_packing():\n    return construct_packing()\n```\n",
  "response": "```python\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) where:\n    - centers: np.array shape (26, 2)\n    - radii: np.array shape (26,)\n    - sum_radii: float\n    \"\"\"\n    # PSO parameters\n    n_particles = 50\n    n_iterations = 100\n    inertia_max = 0.9\n    inertia_min = 0.4\n    c1 = 2.0\n    c2 = 2.0\n    neighborhood_size = 5  # Adjust as needed\n\n    # Problem definition\n    n_circles = 26\n    dimension = n_circles * 3  # x, y, radius for each circle\n\n    # Initialize particles\n    particles = np.random.rand(n_particles, dimension)\n    velocities = np.random.rand(n_particles, dimension) * 0.1  # Smaller initial velocities\n    personal_best_positions = particles.copy()\n    personal_best_fitness = np.zeros(n_particles)\n    global_best_position = None\n    global_best_fitness = -np.inf\n\n    def fitness(particle):\n        \"\"\"Calculates the fitness of a particle, considering constraints.\"\"\"\n        centers = particle[:n_circles * 2].reshape(n_circles, 2)\n        radii = particle[n_circles * 2:]\n        radii = np.clip(radii, 0, 1)  # Ensure radii are non-negative and not too large\n\n        # Constraint handling (penalties)\n        penalty = 0\n\n        # Circle containment constraint\n        for i in range(n_circles):\n            if centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or \\\n               centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1:\n                penalty += 100  # Large penalty for violating containment\n\n        # Circle overlap constraint\n        distances = cdist(centers, centers)\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                if distances[i, j] < radii[i] + radii[j]:\n                    penalty += 100  # Large penalty for overlap\n\n        # Evaluate the radii\n        sum_radii = np.sum(radii)\n\n        return sum_radii - penalty\n\n    # Initialize personal best fitness\n    for i in range(n_particles):\n        personal_best_fitness[i] = fitness(particles[i])\n\n    # Main PSO loop\n    for iteration in range(n_iterations):\n        # Adaptive inertia weight\n        inertia = inertia_max - (inertia_max - inertia_min) * iteration / n_iterations\n\n        for i in range(n_particles):\n            # Update velocity\n            r1 = np.random.rand(dimension)\n            r2 = np.random.rand(dimension)\n\n            # Neighborhood best (using ring topology)\n            neighborhood_indices = np.arange(i - neighborhood_size // 2, i + neighborhood_size // 2 + 1) % n_particles\n            neighborhood_fitnesses = personal_best_fitness[neighborhood_indices]\n            best_neighbor_index = neighborhood_indices[np.argmax(neighborhood_fitnesses)]\n            neighborhood_best_position = personal_best_positions[best_neighbor_index]\n\n            velocities[i] = (inertia * velocities[i] +\n                             c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                             c2 * r2 * (neighborhood_best_position - particles[i]))\n\n            # Update position\n            particles[i] = particles[i] + velocities[i]\n\n            # Bound position (0 to 1 for centers, and adjust radii to fit)\n            centers = particles[i][:n_circles * 2].reshape(n_circles, 2)\n            radii = particles[i][n_circles * 2:]\n\n            # Containment constraint handling (clipping)\n            for j in range(n_circles):\n                centers[j, 0] = np.clip(centers[j, 0], 0, 1)\n                centers[j, 1] = np.clip(centers[j, 1], 0, 1)\n\n                # Radius clipping based on center position\n                max_radius_x = min(centers[j, 0], 1 - centers[j, 0])\n                max_radius_y = min(centers[j, 1], 1 - centers[j, 1])\n                max_radius = min(max_radius_x, max_radius_y)\n                radii[j] = np.clip(radii[j], 0, max_radius)\n\n            particles[i, :n_circles * 2] = centers.flatten()\n            particles[i, n_circles * 2:] = radii\n\n            # Evaluate fitness\n            current_fitness = fitness(particles[i])\n\n            # Update personal best\n            if current_fitness > personal_best_fitness[i]:\n                personal_best_fitness[i] = current_fitness\n                personal_best_positions[i] = particles[i].copy()\n\n                # Update global best\n                if current_fitness > global_best_fitness:\n                    global_best_fitness = current_fitness\n                    global_best_position = particles[i].copy()\n\n    # Extract results from global best\n    centers = global_best_position[:n_circles * 2].reshape(n_circles, 2)\n    radii = global_best_position[n_circles * 2:]\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-14T12:31:38.535513",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 454,
        "candidates_token_count": 1383,
        "thoughts_token_count": 0
      },
      "response_text_len": 4791
    }
  }
}