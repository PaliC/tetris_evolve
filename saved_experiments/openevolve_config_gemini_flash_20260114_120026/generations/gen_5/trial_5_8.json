{
  "trial_id": "trial_5_8",
  "generation": 5,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy import optimize\nfrom scipy.spatial.distance import pdist, squareform\nimport time\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) where:\n    - centers: np.array shape (26, 2)\n    - radii: np.array shape (26,)\n    - sum_radii: float\n    \"\"\"\n    n_circles = 26\n    \n    # Objective function: negative sum of radii (we minimize)\n    def objective(x):\n        radii = x[n_circles*2:].copy()\n        return -np.sum(radii)\n    \n    # Constraint functions\n    def constraint_no_overlap(x):\n        centers = x[:n_circles*2].reshape(n_circles, 2)\n        radii = x[n_circles*2:]\n        \n        # Calculate pairwise distances between centers\n        distances = squareform(pdist(centers))\n        \n        # Calculate minimum allowed distances (sum of radii)\n        min_distances = np.add.outer(radii, radii)\n        \n        # Set diagonal to large value to ignore self-comparisons\n        np.fill_diagonal(distances, 999)\n        \n        # Return differences (must be >= 0)\n        return (distances - min_distances).flatten()\n    \n    def constraint_in_bounds(x):\n        centers = x[:n_circles*2].reshape(n_circles, 2)\n        radii = x[n_circles*2:]\n        \n        # Circles must be entirely within the unit square\n        constraints = []\n        constraints.append(centers[:, 0] - radii)  # Left boundary\n        constraints.append(centers[:, 1] - radii)  # Bottom boundary\n        constraints.append(1 - centers[:, 0] - radii)  # Right boundary\n        constraints.append(1 - centers[:, 1] - radii)  # Top boundary\n        \n        return np.concatenate(constraints)\n    \n    # Combine all constraints\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_no_overlap},\n        {'type': 'ineq', 'fun': constraint_in_bounds}\n    ]\n    \n    # Bounds for optimization variables\n    bounds = [(0, 1) for _ in range(n_circles*2)]  # Center coordinates in [0,1]\n    bounds += [(0, 0.5) for _ in range(n_circles)]  # Radii in [0, 0.5]\n    \n    # Custom step-taking for basin-hopping\n    class CustomTakeStep:\n        def __init__(self, stepsize=0.05):\n            self.stepsize = stepsize\n            self.counter = 0\n            \n        def __call__(self, x):\n            self.counter += 1\n            \n            # Decide if we perturb positions or radii or both\n            mode = np.random.choice(['positions', 'radii', 'both', 'swap'], \n                                    p=[0.4, 0.3, 0.2, 0.1])\n            \n            # Make a copy to modify\n            x_new = x.copy()\n            \n            # Get current centers and radii\n            centers = x[:n_circles*2].reshape(n_circles, 2)\n            radii = x[n_circles*2:]\n            \n            if mode in ['positions', 'both']:\n                # Select random circles to move (1 to 5 circles)\n                n_to_move = np.random.randint(1, 6)\n                indices = np.random.choice(n_circles, n_to_move, replace=False)\n                \n                # Move selected circles\n                for idx in indices:\n                    # Adaptive step size based on radius\n                    adaptive_step = self.stepsize * (1 + 5 * (0.5 - radii[idx]))\n                    delta = np.random.uniform(-adaptive_step, adaptive_step, 2)\n                    centers[idx] += delta\n                    \n                    # Ensure centers stay in bounds\n                    centers[idx] = np.clip(centers[idx], 0, 1)\n                \n                # Update x_new with new centers\n                x_new[:n_circles*2] = centers.flatten()\n            \n            if mode in ['radii', 'both']:\n                # Select random circles to adjust radii (1 to 3 circles)\n                n_to_adjust = np.random.randint(1, 4)\n                indices = np.random.choice(n_circles, n_to_adjust, replace=False)\n                \n                # Adjust selected radii\n                for idx in indices:\n                    # Smaller step for radii\n                    delta = np.random.uniform(-self.stepsize/2, self.stepsize/2)\n                    radii[idx] += delta\n                    \n                    # Ensure radii stay in bounds\n                    radii[idx] = np.clip(radii[idx], 0.001, 0.5)\n                \n                # Update x_new with new radii\n                x_new[n_circles*2:] = radii\n            \n            if mode == 'swap':\n                # Swap positions of two random circles\n                if n_circles >= 2:\n                    idx1, idx2 = np.random.choice(n_circles, 2, replace=False)\n                    centers[[idx1, idx2]] = centers[[idx2, idx1]]\n                    x_new[:n_circles*2] = centers.flatten()\n            \n            # Adaptively adjust step size\n            if self.counter % 100 == 0:\n                self.stepsize = max(0.01, self.stepsize * (0.9 + 0.2 * np.random.random()))\n                \n            return x_new\n    \n    # Custom accept test with adaptive temperature\n    class CustomAccept:\n        def __init__(self, initial_temp=1.0):\n            self.temp = initial_temp\n            self.counter = 0\n            self.accepts = 0\n            self.target_rate = 0.4  # Target acceptance rate\n            \n        def __call__(self, f_new, f_old, x_new, x_old):\n            self.counter += 1\n            \n            # Standard Metropolis criterion with current temperature\n            delta_f = f_new - f_old\n            metropolis = np.exp(-delta_f / self.temp)\n            accepted = (delta_f < 0) or (np.random.random() < metropolis)\n            \n            if accepted:\n                self.accepts += 1\n            \n            # Adjust temperature every 50 steps\n            if self.counter % 50 == 0:\n                current_rate = self.accepts / 50\n                \n                # Adjust temperature to approach target acceptance rate\n                if current_rate < self.target_rate:\n                    self.temp *= 1.1  # Increase temperature if accepting too few\n                else:\n                    self.temp *= 0.9  # Decrease temperature if accepting too many\n                \n                # Reset counters\n                self.accepts = 0\n                self.counter = 0\n                \n                # Periodically lower target rate to focus more on exploitation\n                if self.counter % 500 == 0:\n                    self.target_rate = max(0.1, self.target_rate * 0.95)\n            \n            return accepted\n    \n    # Function to create an intelligent initial guess\n    def create_initial_guess():\n        # Start with a hexagonal packing pattern\n        centers = []\n        spacing = 0.2  # Initial spacing between centers\n        \n        # Create a grid with hexagonal pattern\n        rows, cols = 6, 6\n        for i in range(rows):\n            for j in range(cols):\n                x = spacing * (j + 0.5 * (i % 2))\n                y = spacing * i * np.sqrt(3) / 2\n                \n                # Scale to fit in unit square and add some randomness\n                x = 0.1 + 0.8 * x / (spacing * cols)\n                y = 0.1 + 0.8 * y / (spacing * rows * np.sqrt(3) / 2)\n                \n                centers.append([x, y])\n        \n        # Select first n_circles centers\n        centers = np.array(centers[:n_circles])\n        \n        # Add small random perturbations\n        centers += np.random.uniform(-0.03, 0.03, centers.shape)\n        centers = np.clip(centers, 0.05, 0.95)\n        \n        # Initialize all radii to the same small value\n        radii = np.ones(n_circles) * 0.05\n        \n        # Combine centers and radii into a single array\n        return np.concatenate([centers.flatten(), radii])\n    \n    # Function to perform local optimization\n    def local_minimizer(x):\n        result = optimize.minimize(\n            objective, \n            x, \n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 200, 'ftol': 1e-6}\n        )\n        return result.x\n    \n    # Multi-start basin hopping with different initial configurations\n    best_x = None\n    best_score = float('inf')\n    \n    # Try different initialization strategies\n    for init_strategy in range(5):\n        if init_strategy == 0:\n            # Hexagonal-based initialization\n            x0 = create_initial_guess()\n        elif init_strategy == 1:\n            # Random initialization with bias toward corners\n            centers = np.random.beta(0.5, 0.5, (n_circles, 2))\n            radii = np.random.uniform(0.01, 0.1, n_circles)\n            x0 = np.concatenate([centers.flatten(), radii])\n        elif init_strategy == 2:\n            # Start with circles of different sizes\n            centers = np.random.uniform(0.1, 0.9, (n_circles, 2))\n            # Make a few larger circles and many smaller ones\n            radii = np.zeros(n_circles)\n            radii[:5] = np.random.uniform(0.08, 0.15, 5)\n            radii[5:] = np.random.uniform(0.02, 0.06, n_circles-5)\n            x0 = np.concatenate([centers.flatten(), radii])\n        elif init_strategy == 3:\n            # Concentric rings\n            centers = np.zeros((n_circles, 2))\n            radii = np.zeros(n_circles)\n            \n            # Central circle\n            centers[0] = [0.5, 0.5]\n            radii[0] = 0.12\n            \n            # First ring (8 circles)\n            angles = np.linspace(0, 2*np.pi, 9)[:-1]\n            ring_radius = 0.3\n            for i in range(8):\n                centers[i+1] = [0.5 + ring_radius * np.cos(angles[i]), \n                                0.5 + ring_radius * np.sin(angles[i])]\n                radii[i+1] = 0.08\n            \n            # Second ring (remaining circles)\n            angles = np.linspace(0, 2*np.pi, n_circles-9+1)[:-1]\n            ring_radius = 0.6\n            for i in range(n_circles-9):\n                centers[i+9] = [0.5 + ring_radius * np.cos(angles[i]), \n                                0.5 + ring_radius * np.sin(angles[i])]\n                radii[i+9] = 0.06\n            \n            # Add small random perturbations\n            centers += np.random.uniform(-0.02, 0.02, centers.shape)\n            centers = np.clip(centers, 0.05, 0.95)\n            \n            x0 = np.concatenate([centers.flatten(), radii])\n        else:\n            # Grid-based initialization\n            n_per_side = int(np.ceil(np.sqrt(n_circles)))\n            spacing = 1.0 / (n_per_side + 1)\n            \n            centers = []\n            for i in range(n_per_side):\n                for j in range(n_per_side):\n                    if len(centers) < n_circles:\n                        x = spacing * (j + 1)\n                        y = spacing * (i + 1)\n                        centers.append([x, y])\n            \n            centers = np.array(centers)\n            centers += np.random.uniform(-spacing/4, spacing/4, centers.shape)\n            centers = np.clip(centers, 0.05, 0.95)\n            \n            radii = np.ones(n_circles) * 0.05\n            x0 = np.concatenate([centers.flatten(), radii])\n        \n        # Ensure initial guess is feasible by running local optimization\n        x0 = local_minimizer(x0)\n        \n        # Run basin-hopping with the current initialization\n        custom_step = CustomTakeStep(stepsize=0.05)\n        custom_accept = CustomAccept(initial_temp=0.5)\n        \n        result = optimize.basinhopping(\n            objective,\n            x0,\n            niter=150,\n            T=1.0,\n            stepsize=0.05,\n            minimizer_kwargs={\n                'method': 'SLSQP',\n                'bounds': bounds,\n                'constraints': constraints,\n                'options': {'maxiter': 200}\n            },\n            take_step=custom_step,\n            accept_test=custom_accept,\n            interval=20,  # Adjust step size every 20 iterations\n            disp=False\n        )\n        \n        # Check if this is the best result so far\n        if result.fun < best_score:\n            best_score = result.fun\n            best_x = result.x\n    \n    # Extract final centers and radii\n    centers = best_x[:n_circles*2].reshape(n_circles, 2)\n    radii = best_x[n_circles*2:]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.633035228845132,
    "eval_time": 45.06658101081848,
    "error": null
  },
  "prompt": "\nImplement an advanced basin-hopping optimization for circle packing.\n\nPack 26 circles into a unit square [0,1]x[0,1] to maximize the sum of their radii:\n- All circles must be entirely inside the unit square\n- No two circles may overlap\n- All radii must be non-negative\n\nCreate a sophisticated basin-hopping implementation:\n1. Design intelligent initialization for starting positions and radii\n2. Implement custom step-taking strategies for effective exploration\n3. Create specialized local minimization procedures\n4. Use adaptive temperature scheduling for acceptance criterion\n5. Add restart mechanisms to escape poor local optima\n\nReturn a solution with this structure:\n```python\nimport numpy as np\nfrom scipy import optimize\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) where:\n    - centers: np.array shape (26, 2)\n    - radii: np.array shape (26,)\n    - sum_radii: float\n    \"\"\"\n    # Implement your basin-hopping approach\n    \ndef run_packing():\n    return construct_packing()\n```\n",
  "response": "```python\nimport numpy as np\nfrom scipy import optimize\nfrom scipy.spatial.distance import pdist, squareform\nimport time\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) where:\n    - centers: np.array shape (26, 2)\n    - radii: np.array shape (26,)\n    - sum_radii: float\n    \"\"\"\n    n_circles = 26\n    \n    # Objective function: negative sum of radii (we minimize)\n    def objective(x):\n        radii = x[n_circles*2:].copy()\n        return -np.sum(radii)\n    \n    # Constraint functions\n    def constraint_no_overlap(x):\n        centers = x[:n_circles*2].reshape(n_circles, 2)\n        radii = x[n_circles*2:]\n        \n        # Calculate pairwise distances between centers\n        distances = squareform(pdist(centers))\n        \n        # Calculate minimum allowed distances (sum of radii)\n        min_distances = np.add.outer(radii, radii)\n        \n        # Set diagonal to large value to ignore self-comparisons\n        np.fill_diagonal(distances, 999)\n        \n        # Return differences (must be >= 0)\n        return (distances - min_distances).flatten()\n    \n    def constraint_in_bounds(x):\n        centers = x[:n_circles*2].reshape(n_circles, 2)\n        radii = x[n_circles*2:]\n        \n        # Circles must be entirely within the unit square\n        constraints = []\n        constraints.append(centers[:, 0] - radii)  # Left boundary\n        constraints.append(centers[:, 1] - radii)  # Bottom boundary\n        constraints.append(1 - centers[:, 0] - radii)  # Right boundary\n        constraints.append(1 - centers[:, 1] - radii)  # Top boundary\n        \n        return np.concatenate(constraints)\n    \n    # Combine all constraints\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_no_overlap},\n        {'type': 'ineq', 'fun': constraint_in_bounds}\n    ]\n    \n    # Bounds for optimization variables\n    bounds = [(0, 1) for _ in range(n_circles*2)]  # Center coordinates in [0,1]\n    bounds += [(0, 0.5) for _ in range(n_circles)]  # Radii in [0, 0.5]\n    \n    # Custom step-taking for basin-hopping\n    class CustomTakeStep:\n        def __init__(self, stepsize=0.05):\n            self.stepsize = stepsize\n            self.counter = 0\n            \n        def __call__(self, x):\n            self.counter += 1\n            \n            # Decide if we perturb positions or radii or both\n            mode = np.random.choice(['positions', 'radii', 'both', 'swap'], \n                                    p=[0.4, 0.3, 0.2, 0.1])\n            \n            # Make a copy to modify\n            x_new = x.copy()\n            \n            # Get current centers and radii\n            centers = x[:n_circles*2].reshape(n_circles, 2)\n            radii = x[n_circles*2:]\n            \n            if mode in ['positions', 'both']:\n                # Select random circles to move (1 to 5 circles)\n                n_to_move = np.random.randint(1, 6)\n                indices = np.random.choice(n_circles, n_to_move, replace=False)\n                \n                # Move selected circles\n                for idx in indices:\n                    # Adaptive step size based on radius\n                    adaptive_step = self.stepsize * (1 + 5 * (0.5 - radii[idx]))\n                    delta = np.random.uniform(-adaptive_step, adaptive_step, 2)\n                    centers[idx] += delta\n                    \n                    # Ensure centers stay in bounds\n                    centers[idx] = np.clip(centers[idx], 0, 1)\n                \n                # Update x_new with new centers\n                x_new[:n_circles*2] = centers.flatten()\n            \n            if mode in ['radii', 'both']:\n                # Select random circles to adjust radii (1 to 3 circles)\n                n_to_adjust = np.random.randint(1, 4)\n                indices = np.random.choice(n_circles, n_to_adjust, replace=False)\n                \n                # Adjust selected radii\n                for idx in indices:\n                    # Smaller step for radii\n                    delta = np.random.uniform(-self.stepsize/2, self.stepsize/2)\n                    radii[idx] += delta\n                    \n                    # Ensure radii stay in bounds\n                    radii[idx] = np.clip(radii[idx], 0.001, 0.5)\n                \n                # Update x_new with new radii\n                x_new[n_circles*2:] = radii\n            \n            if mode == 'swap':\n                # Swap positions of two random circles\n                if n_circles >= 2:\n                    idx1, idx2 = np.random.choice(n_circles, 2, replace=False)\n                    centers[[idx1, idx2]] = centers[[idx2, idx1]]\n                    x_new[:n_circles*2] = centers.flatten()\n            \n            # Adaptively adjust step size\n            if self.counter % 100 == 0:\n                self.stepsize = max(0.01, self.stepsize * (0.9 + 0.2 * np.random.random()))\n                \n            return x_new\n    \n    # Custom accept test with adaptive temperature\n    class CustomAccept:\n        def __init__(self, initial_temp=1.0):\n            self.temp = initial_temp\n            self.counter = 0\n            self.accepts = 0\n            self.target_rate = 0.4  # Target acceptance rate\n            \n        def __call__(self, f_new, f_old, x_new, x_old):\n            self.counter += 1\n            \n            # Standard Metropolis criterion with current temperature\n            delta_f = f_new - f_old\n            metropolis = np.exp(-delta_f / self.temp)\n            accepted = (delta_f < 0) or (np.random.random() < metropolis)\n            \n            if accepted:\n                self.accepts += 1\n            \n            # Adjust temperature every 50 steps\n            if self.counter % 50 == 0:\n                current_rate = self.accepts / 50\n                \n                # Adjust temperature to approach target acceptance rate\n                if current_rate < self.target_rate:\n                    self.temp *= 1.1  # Increase temperature if accepting too few\n                else:\n                    self.temp *= 0.9  # Decrease temperature if accepting too many\n                \n                # Reset counters\n                self.accepts = 0\n                self.counter = 0\n                \n                # Periodically lower target rate to focus more on exploitation\n                if self.counter % 500 == 0:\n                    self.target_rate = max(0.1, self.target_rate * 0.95)\n            \n            return accepted\n    \n    # Function to create an intelligent initial guess\n    def create_initial_guess():\n        # Start with a hexagonal packing pattern\n        centers = []\n        spacing = 0.2  # Initial spacing between centers\n        \n        # Create a grid with hexagonal pattern\n        rows, cols = 6, 6\n        for i in range(rows):\n            for j in range(cols):\n                x = spacing * (j + 0.5 * (i % 2))\n                y = spacing * i * np.sqrt(3) / 2\n                \n                # Scale to fit in unit square and add some randomness\n                x = 0.1 + 0.8 * x / (spacing * cols)\n                y = 0.1 + 0.8 * y / (spacing * rows * np.sqrt(3) / 2)\n                \n                centers.append([x, y])\n        \n        # Select first n_circles centers\n        centers = np.array(centers[:n_circles])\n        \n        # Add small random perturbations\n        centers += np.random.uniform(-0.03, 0.03, centers.shape)\n        centers = np.clip(centers, 0.05, 0.95)\n        \n        # Initialize all radii to the same small value\n        radii = np.ones(n_circles) * 0.05\n        \n        # Combine centers and radii into a single array\n        return np.concatenate([centers.flatten(), radii])\n    \n    # Function to perform local optimization\n    def local_minimizer(x):\n        result = optimize.minimize(\n            objective, \n            x, \n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 200, 'ftol': 1e-6}\n        )\n        return result.x\n    \n    # Multi-start basin hopping with different initial configurations\n    best_x = None\n    best_score = float('inf')\n    \n    # Try different initialization strategies\n    for init_strategy in range(5):\n        if init_strategy == 0:\n            # Hexagonal-based initialization\n            x0 = create_initial_guess()\n        elif init_strategy == 1:\n            # Random initialization with bias toward corners\n            centers = np.random.beta(0.5, 0.5, (n_circles, 2))\n            radii = np.random.uniform(0.01, 0.1, n_circles)\n            x0 = np.concatenate([centers.flatten(), radii])\n        elif init_strategy == 2:\n            # Start with circles of different sizes\n            centers = np.random.uniform(0.1, 0.9, (n_circles, 2))\n            # Make a few larger circles and many smaller ones\n            radii = np.zeros(n_circles)\n            radii[:5] = np.random.uniform(0.08, 0.15, 5)\n            radii[5:] = np.random.uniform(0.02, 0.06, n_circles-5)\n            x0 = np.concatenate([centers.flatten(), radii])\n        elif init_strategy == 3:\n            # Concentric rings\n            centers = np.zeros((n_circles, 2))\n            radii = np.zeros(n_circles)\n            \n            # Central circle\n            centers[0] = [0.5, 0.5]\n            radii[0] = 0.12\n            \n            # First ring (8 circles)\n            angles = np.linspace(0, 2*np.pi, 9)[:-1]\n            ring_radius = 0.3\n            for i in range(8):\n                centers[i+1] = [0.5 + ring_radius * np.cos(angles[i]), \n                                0.5 + ring_radius * np.sin(angles[i])]\n                radii[i+1] = 0.08\n            \n            # Second ring (remaining circles)\n            angles = np.linspace(0, 2*np.pi, n_circles-9+1)[:-1]\n            ring_radius = 0.6\n            for i in range(n_circles-9):\n                centers[i+9] = [0.5 + ring_radius * np.cos(angles[i]), \n                                0.5 + ring_radius * np.sin(angles[i])]\n                radii[i+9] = 0.06\n            \n            # Add small random perturbations\n            centers += np.random.uniform(-0.02, 0.02, centers.shape)\n            centers = np.clip(centers, 0.05, 0.95)\n            \n            x0 = np.concatenate([centers.flatten(), radii])\n        else:\n            # Grid-based initialization\n            n_per_side = int(np.ceil(np.sqrt(n_circles)))\n            spacing = 1.0 / (n_per_side + 1)\n            \n            centers = []\n            for i in range(n_per_side):\n                for j in range(n_per_side):\n                    if len(centers) < n_circles:\n                        x = spacing * (j + 1)\n                        y = spacing * (i + 1)\n                        centers.append([x, y])\n            \n            centers = np.array(centers)\n            centers += np.random.uniform(-spacing/4, spacing/4, centers.shape)\n            centers = np.clip(centers, 0.05, 0.95)\n            \n            radii = np.ones(n_circles) * 0.05\n            x0 = np.concatenate([centers.flatten(), radii])\n        \n        # Ensure initial guess is feasible by running local optimization\n        x0 = local_minimizer(x0)\n        \n        # Run basin-hopping with the current initialization\n        custom_step = CustomTakeStep(stepsize=0.05)\n        custom_accept = CustomAccept(initial_temp=0.5)\n        \n        result = optimize.basinhopping(\n            objective,\n            x0,\n            niter=150,\n            T=1.0,\n            stepsize=0.05,\n            minimizer_kwargs={\n                'method': 'SLSQP',\n                'bounds': bounds,\n                'constraints': constraints,\n                'options': {'maxiter': 200}\n            },\n            take_step=custom_step,\n            accept_test=custom_accept,\n            interval=20,  # Adjust step size every 20 iterations\n            disp=False\n        )\n        \n        # Check if this is the best result so far\n        if result.fun < best_score:\n            best_score = result.fun\n            best_x = result.x\n    \n    # Extract final centers and radii\n    centers = best_x[:n_circles*2].reshape(n_circles, 2)\n    radii = best_x[n_circles*2:]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-14T12:33:00.318264",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-3.7-sonnet",
    "temperature": 0.7
  }
}