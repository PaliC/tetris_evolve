{
  "trial_id": "trial_5_5",
  "generation": 5,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy import optimize\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) where:\n    - centers: np.array shape (26, 2)\n    - radii: np.array shape (26,)\n    - sum_radii: float\n    \"\"\"\n    n_circles = 26\n    \n    # Initialize circle positions and radii\n    def initialize_circles():\n        # Start with a hexagonal packing pattern\n        rows = int(np.ceil(np.sqrt(n_circles)))\n        cols = int(np.ceil(n_circles / rows))\n        \n        # Initial spacing between centers\n        spacing_x = 1.0 / (cols + 1)\n        spacing_y = 1.0 / (rows + 1)\n        \n        centers = []\n        for i in range(rows):\n            for j in range(cols):\n                if len(centers) < n_circles:\n                    # Offset even rows for better packing\n                    offset = spacing_x / 2 if i % 2 == 1 else 0\n                    centers.append([(j + 1) * spacing_x + offset, (i + 1) * spacing_y])\n        \n        centers = np.array(centers)\n        \n        # Initial radii - start with equal sizes\n        initial_radius = min(spacing_x, spacing_y) / 2.2\n        radii = np.ones(n_circles) * initial_radius\n        \n        return centers, radii\n    \n    # Penalty function for constraints\n    def penalty(x):\n        centers = x[:n_circles*2].reshape(n_circles, 2)\n        radii = x[n_circles*2:]\n        \n        # Objective: negative sum of radii (we minimize)\n        obj = -np.sum(radii)\n        \n        # Penalties\n        penalty = 0.0\n        penalty_weight = 1000.0\n        \n        # Boundary constraints\n        for i in range(n_circles):\n            cx, cy = centers[i]\n            r = radii[i]\n            \n            # Left boundary\n            if cx - r < 0:\n                penalty += penalty_weight * (r - cx)**2\n            \n            # Right boundary\n            if cx + r > 1:\n                penalty += penalty_weight * (cx + r - 1)**2\n            \n            # Bottom boundary\n            if cy - r < 0:\n                penalty += penalty_weight * (r - cy)**2\n            \n            # Top boundary\n            if cy + r > 1:\n                penalty += penalty_weight * (cy + r - 1)**2\n            \n            # Non-negative radii\n            if r < 0:\n                penalty += penalty_weight * r**2\n        \n        # Non-overlap constraints\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist:\n                    penalty += penalty_weight * (min_dist - dist)**2\n        \n        return obj + penalty\n    \n    # Multi-resolution optimization approach\n    def multi_resolution_optimize():\n        centers, radii = initialize_circles()\n        x = np.concatenate([centers.flatten(), radii])\n        \n        # Progressive optimization with increasing penalty weights\n        penalty_scales = [0.1, 1.0, 10.0, 100.0, 1000.0]\n        results = []\n        \n        for scale in penalty_scales:\n            def scaled_penalty(x):\n                centers = x[:n_circles*2].reshape(n_circles, 2)\n                radii = x[n_circles*2:]\n                \n                # Objective: negative sum of radii (we minimize)\n                obj = -np.sum(radii)\n                \n                # Penalties\n                penalty = 0.0\n                penalty_weight = scale\n                \n                # Boundary constraints\n                for i in range(n_circles):\n                    cx, cy = centers[i]\n                    r = radii[i]\n                    \n                    # Left boundary\n                    if cx - r < 0:\n                        penalty += penalty_weight * (r - cx)**2\n                    \n                    # Right boundary\n                    if cx + r > 1:\n                        penalty += penalty_weight * (cx + r - 1)**2\n                    \n                    # Bottom boundary\n                    if cy - r < 0:\n                        penalty += penalty_weight * (r - cy)**2\n                    \n                    # Top boundary\n                    if cy + r > 1:\n                        penalty += penalty_weight * (cy + r - 1)**2\n                    \n                    # Non-negative radii\n                    if r < 0:\n                        penalty += penalty_weight * r**2\n                \n                # Non-overlap constraints\n                for i in range(n_circles):\n                    for j in range(i+1, n_circles):\n                        dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                        min_dist = radii[i] + radii[j]\n                        \n                        if dist < min_dist:\n                            penalty += penalty_weight * (min_dist - dist)**2\n                \n                return obj + penalty\n            \n            # Optimize with L-BFGS-B\n            result = optimize.minimize(\n                scaled_penalty, \n                x, \n                method='L-BFGS-B',\n                options={'maxiter': 1000, 'disp': False}\n            )\n            \n            x = result.x\n            results.append(result)\n        \n        # Try different optimizers for final refinement\n        optimizers = ['L-BFGS-B', 'SLSQP', 'TNC']\n        for opt_method in optimizers:\n            result = optimize.minimize(\n                penalty, \n                x, \n                method=opt_method,\n                options={'maxiter': 2000, 'disp': False}\n            )\n            x = result.x\n            results.append(result)\n        \n        # Extract final results\n        centers = x[:n_circles*2].reshape(n_circles, 2)\n        radii = x[n_circles*2:]\n        \n        # Fix any constraint violations\n        centers, radii = fix_constraints(centers, radii)\n        \n        return centers, radii\n    \n    # Fix constraint violations\n    def fix_constraints(centers, radii):\n        # Ensure all circles are within bounds\n        for i in range(n_circles):\n            cx, cy = centers[i]\n            r = radii[i]\n            \n            # Fix boundary violations\n            centers[i, 0] = np.clip(cx, r, 1-r)\n            centers[i, 1] = np.clip(cy, r, 1-r)\n            \n            # Ensure non-negative radii\n            radii[i] = max(0, r)\n        \n        # Fix overlap violations by iteratively shrinking radii\n        max_iterations = 100\n        for _ in range(max_iterations):\n            overlap = False\n            \n            for i in range(n_circles):\n                for j in range(i+1, n_circles):\n                    dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                    min_dist = radii[i] + radii[j]\n                    \n                    if dist < min_dist:\n                        overlap = True\n                        # Shrink both radii proportionally\n                        ratio = dist / min_dist if min_dist > 0 else 0\n                        radii[i] *= 0.99 * ratio\n                        radii[j] *= 0.99 * ratio\n            \n            if not overlap:\n                break\n        \n        return centers, radii\n    \n    # Run optimization with multiple random initializations\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    num_attempts = 5\n    for _ in range(num_attempts):\n        centers, radii = multi_resolution_optimize()\n        sum_radii = np.sum(radii)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    # Perform final constraint check and fix\n    best_centers, best_radii = fix_constraints(best_centers, best_radii)\n    best_sum = np.sum(best_radii)\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 90.00843787193298,
    "error": "Timeout after 90s"
  },
  "prompt": "\nCreate a gradient-based optimization algorithm for circle packing.\n\nPack 26 circles into a unit square [0,1]x[0,1] to maximize the sum of their radii:\n- All circles must be entirely inside the unit square\n- No two circles may overlap\n- All radii must be non-negative\n\nDesign a sophisticated gradient-based approach:\n1. Use a differentiable penalty function for constraints\n2. Design an effective initialization strategy for centers and radii\n3. Implement adaptive learning rates for gradient updates\n4. Use momentum and adaptive step sizes to avoid local optima\n5. Add a multi-resolution approach that progressively refines the solution\n\nReturn a solution with this structure:\n```python\nimport numpy as np\nfrom scipy import optimize\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) where:\n    - centers: np.array shape (26, 2)\n    - radii: np.array shape (26,)\n    - sum_radii: float\n    \"\"\"\n    # Implement your gradient-based approach\n    \ndef run_packing():\n    return construct_packing()\n```\n",
  "response": "```python\nimport numpy as np\nfrom scipy import optimize\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) where:\n    - centers: np.array shape (26, 2)\n    - radii: np.array shape (26,)\n    - sum_radii: float\n    \"\"\"\n    n_circles = 26\n    \n    # Initialize circle positions and radii\n    def initialize_circles():\n        # Start with a hexagonal packing pattern\n        rows = int(np.ceil(np.sqrt(n_circles)))\n        cols = int(np.ceil(n_circles / rows))\n        \n        # Initial spacing between centers\n        spacing_x = 1.0 / (cols + 1)\n        spacing_y = 1.0 / (rows + 1)\n        \n        centers = []\n        for i in range(rows):\n            for j in range(cols):\n                if len(centers) < n_circles:\n                    # Offset even rows for better packing\n                    offset = spacing_x / 2 if i % 2 == 1 else 0\n                    centers.append([(j + 1) * spacing_x + offset, (i + 1) * spacing_y])\n        \n        centers = np.array(centers)\n        \n        # Initial radii - start with equal sizes\n        initial_radius = min(spacing_x, spacing_y) / 2.2\n        radii = np.ones(n_circles) * initial_radius\n        \n        return centers, radii\n    \n    # Penalty function for constraints\n    def penalty(x):\n        centers = x[:n_circles*2].reshape(n_circles, 2)\n        radii = x[n_circles*2:]\n        \n        # Objective: negative sum of radii (we minimize)\n        obj = -np.sum(radii)\n        \n        # Penalties\n        penalty = 0.0\n        penalty_weight = 1000.0\n        \n        # Boundary constraints\n        for i in range(n_circles):\n            cx, cy = centers[i]\n            r = radii[i]\n            \n            # Left boundary\n            if cx - r < 0:\n                penalty += penalty_weight * (r - cx)**2\n            \n            # Right boundary\n            if cx + r > 1:\n                penalty += penalty_weight * (cx + r - 1)**2\n            \n            # Bottom boundary\n            if cy - r < 0:\n                penalty += penalty_weight * (r - cy)**2\n            \n            # Top boundary\n            if cy + r > 1:\n                penalty += penalty_weight * (cy + r - 1)**2\n            \n            # Non-negative radii\n            if r < 0:\n                penalty += penalty_weight * r**2\n        \n        # Non-overlap constraints\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist:\n                    penalty += penalty_weight * (min_dist - dist)**2\n        \n        return obj + penalty\n    \n    # Multi-resolution optimization approach\n    def multi_resolution_optimize():\n        centers, radii = initialize_circles()\n        x = np.concatenate([centers.flatten(), radii])\n        \n        # Progressive optimization with increasing penalty weights\n        penalty_scales = [0.1, 1.0, 10.0, 100.0, 1000.0]\n        results = []\n        \n        for scale in penalty_scales:\n            def scaled_penalty(x):\n                centers = x[:n_circles*2].reshape(n_circles, 2)\n                radii = x[n_circles*2:]\n                \n                # Objective: negative sum of radii (we minimize)\n                obj = -np.sum(radii)\n                \n                # Penalties\n                penalty = 0.0\n                penalty_weight = scale\n                \n                # Boundary constraints\n                for i in range(n_circles):\n                    cx, cy = centers[i]\n                    r = radii[i]\n                    \n                    # Left boundary\n                    if cx - r < 0:\n                        penalty += penalty_weight * (r - cx)**2\n                    \n                    # Right boundary\n                    if cx + r > 1:\n                        penalty += penalty_weight * (cx + r - 1)**2\n                    \n                    # Bottom boundary\n                    if cy - r < 0:\n                        penalty += penalty_weight * (r - cy)**2\n                    \n                    # Top boundary\n                    if cy + r > 1:\n                        penalty += penalty_weight * (cy + r - 1)**2\n                    \n                    # Non-negative radii\n                    if r < 0:\n                        penalty += penalty_weight * r**2\n                \n                # Non-overlap constraints\n                for i in range(n_circles):\n                    for j in range(i+1, n_circles):\n                        dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                        min_dist = radii[i] + radii[j]\n                        \n                        if dist < min_dist:\n                            penalty += penalty_weight * (min_dist - dist)**2\n                \n                return obj + penalty\n            \n            # Optimize with L-BFGS-B\n            result = optimize.minimize(\n                scaled_penalty, \n                x, \n                method='L-BFGS-B',\n                options={'maxiter': 1000, 'disp': False}\n            )\n            \n            x = result.x\n            results.append(result)\n        \n        # Try different optimizers for final refinement\n        optimizers = ['L-BFGS-B', 'SLSQP', 'TNC']\n        for opt_method in optimizers:\n            result = optimize.minimize(\n                penalty, \n                x, \n                method=opt_method,\n                options={'maxiter': 2000, 'disp': False}\n            )\n            x = result.x\n            results.append(result)\n        \n        # Extract final results\n        centers = x[:n_circles*2].reshape(n_circles, 2)\n        radii = x[n_circles*2:]\n        \n        # Fix any constraint violations\n        centers, radii = fix_constraints(centers, radii)\n        \n        return centers, radii\n    \n    # Fix constraint violations\n    def fix_constraints(centers, radii):\n        # Ensure all circles are within bounds\n        for i in range(n_circles):\n            cx, cy = centers[i]\n            r = radii[i]\n            \n            # Fix boundary violations\n            centers[i, 0] = np.clip(cx, r, 1-r)\n            centers[i, 1] = np.clip(cy, r, 1-r)\n            \n            # Ensure non-negative radii\n            radii[i] = max(0, r)\n        \n        # Fix overlap violations by iteratively shrinking radii\n        max_iterations = 100\n        for _ in range(max_iterations):\n            overlap = False\n            \n            for i in range(n_circles):\n                for j in range(i+1, n_circles):\n                    dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                    min_dist = radii[i] + radii[j]\n                    \n                    if dist < min_dist:\n                        overlap = True\n                        # Shrink both radii proportionally\n                        ratio = dist / min_dist if min_dist > 0 else 0\n                        radii[i] *= 0.99 * ratio\n                        radii[j] *= 0.99 * ratio\n            \n            if not overlap:\n                break\n        \n        return centers, radii\n    \n    # Run optimization with multiple random initializations\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    num_attempts = 5\n    for _ in range(num_attempts):\n        centers, radii = multi_resolution_optimize()\n        sum_radii = np.sum(radii)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    # Perform final constraint check and fix\n    best_centers, best_radii = fix_constraints(best_centers, best_radii)\n    best_sum = np.sum(best_radii)\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-14T12:33:25.538662",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-3.7-sonnet",
    "temperature": 0.7
  }
}