{
  "trial_id": "trial_4_7",
  "generation": 4,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Uses Particle Swarm Optimization (PSO) to pack 26 circles into a unit square [0,1] x [0,1]\n    to maximize the sum of their radii.\n    \"\"\"\n\n    # PSO parameters\n    n_particles = 50\n    n_iterations = 100\n    inertia_max = 0.9\n    inertia_min = 0.4\n    c1 = 2.0  # Cognitive coefficient\n    c2 = 2.0  # Social coefficient\n    neighborhood_size = 5  # Size of the neighborhood for the local best\n\n    # Problem parameters\n    n_circles = 26\n\n    # Initialize particles\n    particles = np.zeros((n_particles, n_circles * 3))  # (x, y, r) for each circle\n    velocities = np.zeros((n_particles, n_circles * 3))\n\n    for i in range(n_particles):\n        for j in range(n_circles):\n            particles[i, j * 3:j * 3 + 2] = np.random.rand(2)  # Random center positions\n            particles[i, j * 3 + 2] = np.random.rand() * 0.1   # Random radius (start small)\n\n    # Initialize personal best positions and fitnesses\n    personal_best_positions = particles.copy()\n    personal_best_fitnesses = np.zeros(n_particles)\n    for i in range(n_particles):\n        personal_best_fitnesses[i] = fitness(particles[i], n_circles)\n\n    # Initialize global best position and fitness\n    global_best_position = particles[np.argmax(personal_best_fitnesses)].copy()\n    global_best_fitness = np.max(personal_best_fitnesses)\n\n    # PSO iterations\n    for iteration in range(n_iterations):\n        # Adaptive inertia weight\n        inertia = inertia_max - (inertia_max - inertia_min) * iteration / n_iterations\n\n        for i in range(n_particles):\n            # Calculate fitness for the current particle\n            current_fitness = fitness(particles[i], n_circles)\n\n            # Update personal best\n            if current_fitness > personal_best_fitnesses[i]:\n                personal_best_fitnesses[i] = current_fitness\n                personal_best_positions[i] = particles[i].copy()\n\n            # Determine neighborhood best\n            distances = np.linalg.norm(particles - particles[i], axis=1)\n            neighborhood_indices = np.argsort(distances)[:neighborhood_size]\n            neighborhood_best_index = neighborhood_indices[np.argmax(personal_best_fitnesses[neighborhood_indices])]\n            neighborhood_best_position = personal_best_positions[neighborhood_best_index]\n\n\n            # Update velocity\n            velocities[i] = (inertia * velocities[i]\n                             + c1 * np.random.rand() * (personal_best_positions[i] - particles[i])\n                             + c2 * np.random.rand() * (neighborhood_best_position - particles[i]))\n\n            # Update particle position\n            particles[i] += velocities[i]\n\n            # Boundary handling and radius clamping\n            for j in range(n_circles):\n                x = particles[i, j * 3]\n                y = particles[i, j * 3 + 1]\n                r = particles[i, j * 3 + 2]\n\n                # Clamp centers to [0, 1]\n                particles[i, j * 3] = np.clip(x, 0, 1)\n                particles[i, j * 3 + 1] = np.clip(y, 0, 1)\n\n                # Radius clamping based on boundaries\n                max_radius_x = min(x, 1 - x)\n                max_radius_y = min(y, 1 - y)\n                particles[i, j * 3 + 2] = np.clip(r, 0, min(max_radius_x, max_radius_y))\n\n\n        # Update global best\n        if np.max(personal_best_fitnesses) > global_best_fitness:\n            global_best_fitness = np.max(personal_best_fitnesses)\n            global_best_position = personal_best_positions[np.argmax(personal_best_fitnesses)].copy()\n\n    # Local search refinement (optional)\n    global_best_position = refine_solution(global_best_position, n_circles)\n    global_best_fitness = fitness(global_best_position, n_circles)\n\n    # Extract results\n    centers = global_best_position.reshape(n_circles, 3)[:, :2]\n    radii = global_best_position.reshape(n_circles, 3)[:, 2]\n    sum_radii = global_best_fitness\n\n    return centers, radii, sum_radii\n\n\ndef fitness(particle, n_circles):\n    \"\"\"\n    Fitness function: sum of radii, penalized for overlaps and out-of-bounds circles.\n    \"\"\"\n    centers = particle.reshape(n_circles, 3)[:, :2]\n    radii = particle.reshape(n_circles, 3)[:, 2]\n    sum_radii = np.sum(radii)\n\n    # Penalty for circles outside the unit square\n    penalty_out_of_bounds = 0\n    for i in range(n_circles):\n        x, y = centers[i]\n        r = radii[i]\n        if not (0 <= x - r and x + r <= 1 and 0 <= y - r and y + r <= 1):\n            penalty_out_of_bounds += 100  # Increased penalty\n\n    # Penalty for overlapping circles\n    distances = cdist(centers, centers)\n    penalty_overlap = 0\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            if distances[i, j] < radii[i] + radii[j]:\n                penalty_overlap += 100 # Increased penalty\n\n    return sum_radii - penalty_out_of_bounds - penalty_overlap\n\n\ndef refine_solution(solution, n_circles, iterations=10):\n    \"\"\"\n    Refines a solution using a simple gradient descent approach.\n    \"\"\"\n    learning_rate = 0.01\n    refined_solution = solution.copy()\n\n    for _ in range(iterations):\n        for i in range(n_circles * 3):  # Iterate through each parameter (x, y, r)\n            # Calculate the gradient (approximate with finite difference)\n            original_value = refined_solution[i]\n            refined_solution[i] += learning_rate\n            fitness_plus = fitness(refined_solution, n_circles)\n            refined_solution[i] -= 2 * learning_rate\n            fitness_minus = fitness(refined_solution, n_circles)\n            refined_solution[i] = original_value  # Reset to original value\n\n            gradient = (fitness_plus - fitness_minus) / (2 * learning_rate)\n\n            # Update the parameter based on the gradient\n            refined_solution[i] += learning_rate * gradient\n\n            # Boundary handling and radius clamping\n            if i % 3 == 0:  # x coordinate\n                refined_solution[i] = np.clip(refined_solution[i], 0, 1)\n            elif i % 3 == 1:  # y coordinate\n                refined_solution[i] = np.clip(refined_solution[i], 0, 1)\n            else:  # radius\n                circle_index = i // 3\n                x = refined_solution[circle_index * 3]\n                y = refined_solution[circle_index * 3 + 1]\n                max_radius_x = min(x, 1 - x)\n                max_radius_y = min(y, 1 - y)\n                refined_solution[i] = np.clip(refined_solution[i], 0, min(max_radius_x, max_radius_y))\n\n    return refined_solution\n\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 0.0,
    "eval_time": 1.3307039737701416,
    "error": null
  },
  "prompt": "Develop a particle swarm optimization (PSO) approach for circle packing.\n\nThe problem: Pack 26 circles into a unit square [0,1]x[0,1] to maximize the sum of radii.\n- All circles must be inside the unit square\n- No overlapping circles\n- All radii must be non-negative\n\nKey features to implement:\n1. Use PSO with specialized particle representation for circle packing\n2. Implement boundary handling strategies compatible with PSO\n3. Use adaptive inertia and acceleration parameters\n4. Implement neighborhood topologies that work well for this problem\n5. Use a specialized fitness function with effective constraint handling\n6. Consider various initialization strategies for the swarm\n7. Implement local search refinement of the global best solution\n\nReturn a function that uses particle swarm optimization for efficient circle packing.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Uses Particle Swarm Optimization (PSO) to pack 26 circles into a unit square [0,1] x [0,1]\n    to maximize the sum of their radii.\n    \"\"\"\n\n    # PSO parameters\n    n_particles = 50\n    n_iterations = 100\n    inertia_max = 0.9\n    inertia_min = 0.4\n    c1 = 2.0  # Cognitive coefficient\n    c2 = 2.0  # Social coefficient\n    neighborhood_size = 5  # Size of the neighborhood for the local best\n\n    # Problem parameters\n    n_circles = 26\n\n    # Initialize particles\n    particles = np.zeros((n_particles, n_circles * 3))  # (x, y, r) for each circle\n    velocities = np.zeros((n_particles, n_circles * 3))\n\n    for i in range(n_particles):\n        for j in range(n_circles):\n            particles[i, j * 3:j * 3 + 2] = np.random.rand(2)  # Random center positions\n            particles[i, j * 3 + 2] = np.random.rand() * 0.1   # Random radius (start small)\n\n    # Initialize personal best positions and fitnesses\n    personal_best_positions = particles.copy()\n    personal_best_fitnesses = np.zeros(n_particles)\n    for i in range(n_particles):\n        personal_best_fitnesses[i] = fitness(particles[i], n_circles)\n\n    # Initialize global best position and fitness\n    global_best_position = particles[np.argmax(personal_best_fitnesses)].copy()\n    global_best_fitness = np.max(personal_best_fitnesses)\n\n    # PSO iterations\n    for iteration in range(n_iterations):\n        # Adaptive inertia weight\n        inertia = inertia_max - (inertia_max - inertia_min) * iteration / n_iterations\n\n        for i in range(n_particles):\n            # Calculate fitness for the current particle\n            current_fitness = fitness(particles[i], n_circles)\n\n            # Update personal best\n            if current_fitness > personal_best_fitnesses[i]:\n                personal_best_fitnesses[i] = current_fitness\n                personal_best_positions[i] = particles[i].copy()\n\n            # Determine neighborhood best\n            distances = np.linalg.norm(particles - particles[i], axis=1)\n            neighborhood_indices = np.argsort(distances)[:neighborhood_size]\n            neighborhood_best_index = neighborhood_indices[np.argmax(personal_best_fitnesses[neighborhood_indices])]\n            neighborhood_best_position = personal_best_positions[neighborhood_best_index]\n\n\n            # Update velocity\n            velocities[i] = (inertia * velocities[i]\n                             + c1 * np.random.rand() * (personal_best_positions[i] - particles[i])\n                             + c2 * np.random.rand() * (neighborhood_best_position - particles[i]))\n\n            # Update particle position\n            particles[i] += velocities[i]\n\n            # Boundary handling and radius clamping\n            for j in range(n_circles):\n                x = particles[i, j * 3]\n                y = particles[i, j * 3 + 1]\n                r = particles[i, j * 3 + 2]\n\n                # Clamp centers to [0, 1]\n                particles[i, j * 3] = np.clip(x, 0, 1)\n                particles[i, j * 3 + 1] = np.clip(y, 0, 1)\n\n                # Radius clamping based on boundaries\n                max_radius_x = min(x, 1 - x)\n                max_radius_y = min(y, 1 - y)\n                particles[i, j * 3 + 2] = np.clip(r, 0, min(max_radius_x, max_radius_y))\n\n\n        # Update global best\n        if np.max(personal_best_fitnesses) > global_best_fitness:\n            global_best_fitness = np.max(personal_best_fitnesses)\n            global_best_position = personal_best_positions[np.argmax(personal_best_fitnesses)].copy()\n\n    # Local search refinement (optional)\n    global_best_position = refine_solution(global_best_position, n_circles)\n    global_best_fitness = fitness(global_best_position, n_circles)\n\n    # Extract results\n    centers = global_best_position.reshape(n_circles, 3)[:, :2]\n    radii = global_best_position.reshape(n_circles, 3)[:, 2]\n    sum_radii = global_best_fitness\n\n    return centers, radii, sum_radii\n\n\ndef fitness(particle, n_circles):\n    \"\"\"\n    Fitness function: sum of radii, penalized for overlaps and out-of-bounds circles.\n    \"\"\"\n    centers = particle.reshape(n_circles, 3)[:, :2]\n    radii = particle.reshape(n_circles, 3)[:, 2]\n    sum_radii = np.sum(radii)\n\n    # Penalty for circles outside the unit square\n    penalty_out_of_bounds = 0\n    for i in range(n_circles):\n        x, y = centers[i]\n        r = radii[i]\n        if not (0 <= x - r and x + r <= 1 and 0 <= y - r and y + r <= 1):\n            penalty_out_of_bounds += 100  # Increased penalty\n\n    # Penalty for overlapping circles\n    distances = cdist(centers, centers)\n    penalty_overlap = 0\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            if distances[i, j] < radii[i] + radii[j]:\n                penalty_overlap += 100 # Increased penalty\n\n    return sum_radii - penalty_out_of_bounds - penalty_overlap\n\n\ndef refine_solution(solution, n_circles, iterations=10):\n    \"\"\"\n    Refines a solution using a simple gradient descent approach.\n    \"\"\"\n    learning_rate = 0.01\n    refined_solution = solution.copy()\n\n    for _ in range(iterations):\n        for i in range(n_circles * 3):  # Iterate through each parameter (x, y, r)\n            # Calculate the gradient (approximate with finite difference)\n            original_value = refined_solution[i]\n            refined_solution[i] += learning_rate\n            fitness_plus = fitness(refined_solution, n_circles)\n            refined_solution[i] -= 2 * learning_rate\n            fitness_minus = fitness(refined_solution, n_circles)\n            refined_solution[i] = original_value  # Reset to original value\n\n            gradient = (fitness_plus - fitness_minus) / (2 * learning_rate)\n\n            # Update the parameter based on the gradient\n            refined_solution[i] += learning_rate * gradient\n\n            # Boundary handling and radius clamping\n            if i % 3 == 0:  # x coordinate\n                refined_solution[i] = np.clip(refined_solution[i], 0, 1)\n            elif i % 3 == 1:  # y coordinate\n                refined_solution[i] = np.clip(refined_solution[i], 0, 1)\n            else:  # radius\n                circle_index = i // 3\n                x = refined_solution[circle_index * 3]\n                y = refined_solution[circle_index * 3 + 1]\n                max_radius_x = min(x, 1 - x)\n                max_radius_y = min(y, 1 - y)\n                refined_solution[i] = np.clip(refined_solution[i], 0, min(max_radius_x, max_radius_y))\n\n    return refined_solution\n\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-14T12:26:55.397489",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 386,
        "candidates_token_count": 1917,
        "thoughts_token_count": 0
      },
      "response_text_len": 6635
    }
  }
}