{
  "trial_id": "trial_4_6",
  "generation": 4,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    # Advanced vector-based force model for circle packing\n    \n    # Initialize parameters\n    n_circles = 26\n    max_iterations = 5000\n    initial_temperature = 0.1\n    cooling_rate = 0.9995\n    damping = 0.8\n    \n    # Initialize circle positions with Halton sequence for better distribution\n    def halton(index, base):\n        result = 0\n        f = 1\n        while index > 0:\n            f = f / base\n            result = result + f * (index % base)\n            index = index // base\n        return result\n    \n    centers = np.array([[halton(i+1, 2), halton(i+1, 3)] for i in range(n_circles)])\n    centers = centers * 0.8 + 0.1  # Scale to fit within [0.1, 0.9]\u00b2\n    \n    # Initialize with small equal radii\n    radii = np.ones(n_circles) * 0.03\n    \n    # Initialize velocities\n    velocities = np.zeros((n_circles, 2))\n    \n    # Initialize force parameters\n    repulsion_strength = 0.1\n    attraction_strength = 0.01\n    boundary_strength = 0.2\n    growth_rate = 0.0005\n    \n    # Multi-phase strategy\n    phases = [\n        # Phase 1: High repulsion, low growth - establish positions\n        {\"iterations\": 1000, \"repulsion\": 0.15, \"attraction\": 0.005, \"boundary\": 0.3, \"growth\": 0.0002, \"temp\": 0.08},\n        # Phase 2: Balanced forces - stabilize\n        {\"iterations\": 1000, \"repulsion\": 0.1, \"attraction\": 0.01, \"boundary\": 0.2, \"growth\": 0.0005, \"temp\": 0.05},\n        # Phase 3: Low repulsion, higher growth - maximize sizes\n        {\"iterations\": 1000, \"repulsion\": 0.08, \"attraction\": 0.015, \"boundary\": 0.15, \"growth\": 0.001, \"temp\": 0.03},\n        # Phase 4: Fine-tuning\n        {\"iterations\": 1000, \"repulsion\": 0.05, \"attraction\": 0.02, \"boundary\": 0.1, \"growth\": 0.0015, \"temp\": 0.01},\n        # Phase 5: Final adjustments\n        {\"iterations\": 1000, \"repulsion\": 0.03, \"attraction\": 0.025, \"boundary\": 0.05, \"growth\": 0.002, \"temp\": 0.005}\n    ]\n    \n    best_radii = radii.copy()\n    best_centers = centers.copy()\n    best_sum = np.sum(radii)\n    \n    temperature = initial_temperature\n    \n    # Main optimization loop\n    iteration = 0\n    phase_idx = 0\n    \n    while iteration < max_iterations and phase_idx < len(phases):\n        phase = phases[phase_idx]\n        \n        if iteration % phase[\"iterations\"] == 0 and phase_idx < len(phases) - 1:\n            phase_idx += 1\n            phase = phases[phase_idx]\n            repulsion_strength = phase[\"repulsion\"]\n            attraction_strength = phase[\"attraction\"]\n            boundary_strength = phase[\"boundary\"]\n            growth_rate = phase[\"growth\"]\n            temperature = phase[\"temp\"]\n        \n        # Calculate pairwise distances between circle centers\n        distances = squareform(pdist(centers))\n        np.fill_diagonal(distances, np.inf)  # Avoid self-interactions\n        \n        # Calculate minimum required distances (sum of radii pairs)\n        required_distances = np.add.outer(radii, radii)\n        \n        # Calculate overlap amounts\n        overlaps = required_distances - distances\n        overlaps[overlaps < 0] = 0  # Only consider actual overlaps\n        \n        # Calculate unit direction vectors between all pairs of circles\n        directions = np.zeros((n_circles, n_circles, 2))\n        for i in range(n_circles):\n            for j in range(n_circles):\n                if i != j:\n                    direction = centers[j] - centers[i]\n                    norm = np.linalg.norm(direction)\n                    if norm > 1e-10:  # Avoid division by zero\n                        directions[i, j] = direction / norm\n        \n        # Initialize forces\n        forces = np.zeros((n_circles, 2))\n        \n        # Repulsive forces from overlapping circles\n        for i in range(n_circles):\n            for j in range(n_circles):\n                if i != j and overlaps[i, j] > 0:\n                    forces[i] -= directions[i, j] * overlaps[i, j] * repulsion_strength\n        \n        # Attractive forces for nearby circles (helps with stability)\n        for i in range(n_circles):\n            for j in range(n_circles):\n                if i != j and distances[i, j] < 0.3 and overlaps[i, j] == 0:\n                    forces[i] += directions[i, j] * attraction_strength * (1.0 / (distances[i, j] + 0.01))\n        \n        # Boundary forces to keep circles inside the unit square\n        for i in range(n_circles):\n            # Left boundary\n            dist_to_left = centers[i, 0] - radii[i]\n            if dist_to_left < 0:\n                forces[i, 0] += boundary_strength * abs(dist_to_left)\n            \n            # Right boundary\n            dist_to_right = 1 - (centers[i, 0] + radii[i])\n            if dist_to_right < 0:\n                forces[i, 0] -= boundary_strength * abs(dist_to_right)\n            \n            # Bottom boundary\n            dist_to_bottom = centers[i, 1] - radii[i]\n            if dist_to_bottom < 0:\n                forces[i, 1] += boundary_strength * abs(dist_to_bottom)\n            \n            # Top boundary\n            dist_to_top = 1 - (centers[i, 1] + radii[i])\n            if dist_to_top < 0:\n                forces[i, 1] -= boundary_strength * abs(dist_to_top)\n        \n        # Add random perturbation based on temperature\n        forces += np.random.normal(0, temperature, forces.shape)\n        \n        # Update velocities with damping\n        velocities = velocities * damping + forces\n        \n        # Update positions\n        centers += velocities\n        \n        # Check if any circle is stable (low velocity and no overlaps)\n        is_stable = np.all(np.linalg.norm(velocities, axis=1) < 0.001)\n        no_overlaps = np.all(overlaps == 0)\n        \n        # If stable and no overlaps, try growing circles\n        if is_stable and no_overlaps:\n            # Calculate the distance to the nearest boundary or circle for each circle\n            min_distances = np.ones(n_circles) * np.inf\n            \n            # Distance to other circles\n            for i in range(n_circles):\n                for j in range(n_circles):\n                    if i != j:\n                        min_distances[i] = min(min_distances[i], distances[i, j] - radii[j])\n            \n            # Distance to boundaries\n            for i in range(n_circles):\n                min_distances[i] = min(min_distances[i], \n                                      centers[i, 0],                # Distance to left\n                                      centers[i, 1],                # Distance to bottom\n                                      1 - centers[i, 0],            # Distance to right\n                                      1 - centers[i, 1])            # Distance to top\n            \n            # Grow radii proportionally to available space\n            growth_factors = min_distances - radii\n            growth_factors = np.clip(growth_factors, 0, growth_rate)\n            radii += growth_factors\n        \n        # Check if this is the best solution so far\n        current_sum = np.sum(radii)\n        if current_sum > best_sum and no_overlaps and np.all(\n                (centers[:, 0] - radii >= 0) & \n                (centers[:, 0] + radii <= 1) & \n                (centers[:, 1] - radii >= 0) & \n                (centers[:, 1] + radii <= 1)):\n            best_sum = current_sum\n            best_radii = radii.copy()\n            best_centers = centers.copy()\n        \n        # Cool down the temperature\n        temperature *= cooling_rate\n        iteration += 1\n    \n    # Final refinement: try to grow each circle individually\n    for i in range(n_circles):\n        # Calculate the distance to the nearest boundary or circle\n        min_distance = np.inf\n        \n        # Distance to other circles\n        for j in range(n_circles):\n            if i != j:\n                dist = np.linalg.norm(best_centers[i] - best_centers[j]) - best_radii[j]\n                min_distance = min(min_distance, dist)\n        \n        # Distance to boundaries\n        min_distance = min(min_distance, \n                          best_centers[i, 0],                # Distance to left\n                          best_centers[i, 1],                # Distance to bottom\n                          1 - best_centers[i, 0],            # Distance to right\n                          1 - best_centers[i, 1])            # Distance to top\n        \n        # Grow the circle to touch the nearest constraint\n        best_radii[i] = min(best_radii[i] + min_distance, best_radii[i] * 1.1)\n    \n    return best_centers, best_radii, np.sum(best_radii)\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 0.8580000000000001,
    "eval_time": 6.056284189224243,
    "error": null
  },
  "prompt": "Implement an advanced vector-based force model for circle packing simulation.\n\nThe problem: Pack 26 circles into a unit square [0,1]x[0,1] to maximize the sum of radii.\n- All circles must be inside the unit square\n- No overlapping circles\n- All radii must be non-negative\n\nKey features to implement:\n1. Use sophisticated vector forces between circles and boundaries\n2. Implement multiple force types (repulsion, attraction, boundary forces)\n3. Use adaptive force parameters that change during simulation\n4. Implement a smart circle growth strategy during stable periods\n5. Use momentum and damping to improve convergence\n6. Include temperature-like parameters to control exploration vs. exploitation\n7. Implement a multi-resolution approach that refines the simulation over time\n\nReturn a function that uses advanced vector-based forces for efficient circle packing.\n",
  "response": "I'll implement an advanced vector-based force model for packing 26 circles into a unit square. This approach uses sophisticated physics-based simulation with multiple force types, adaptive parameters, and strategic growth strategies.\n\n```python\nimport numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    # Advanced vector-based force model for circle packing\n    \n    # Initialize parameters\n    n_circles = 26\n    max_iterations = 5000\n    initial_temperature = 0.1\n    cooling_rate = 0.9995\n    damping = 0.8\n    \n    # Initialize circle positions with Halton sequence for better distribution\n    def halton(index, base):\n        result = 0\n        f = 1\n        while index > 0:\n            f = f / base\n            result = result + f * (index % base)\n            index = index // base\n        return result\n    \n    centers = np.array([[halton(i+1, 2), halton(i+1, 3)] for i in range(n_circles)])\n    centers = centers * 0.8 + 0.1  # Scale to fit within [0.1, 0.9]\u00b2\n    \n    # Initialize with small equal radii\n    radii = np.ones(n_circles) * 0.03\n    \n    # Initialize velocities\n    velocities = np.zeros((n_circles, 2))\n    \n    # Initialize force parameters\n    repulsion_strength = 0.1\n    attraction_strength = 0.01\n    boundary_strength = 0.2\n    growth_rate = 0.0005\n    \n    # Multi-phase strategy\n    phases = [\n        # Phase 1: High repulsion, low growth - establish positions\n        {\"iterations\": 1000, \"repulsion\": 0.15, \"attraction\": 0.005, \"boundary\": 0.3, \"growth\": 0.0002, \"temp\": 0.08},\n        # Phase 2: Balanced forces - stabilize\n        {\"iterations\": 1000, \"repulsion\": 0.1, \"attraction\": 0.01, \"boundary\": 0.2, \"growth\": 0.0005, \"temp\": 0.05},\n        # Phase 3: Low repulsion, higher growth - maximize sizes\n        {\"iterations\": 1000, \"repulsion\": 0.08, \"attraction\": 0.015, \"boundary\": 0.15, \"growth\": 0.001, \"temp\": 0.03},\n        # Phase 4: Fine-tuning\n        {\"iterations\": 1000, \"repulsion\": 0.05, \"attraction\": 0.02, \"boundary\": 0.1, \"growth\": 0.0015, \"temp\": 0.01},\n        # Phase 5: Final adjustments\n        {\"iterations\": 1000, \"repulsion\": 0.03, \"attraction\": 0.025, \"boundary\": 0.05, \"growth\": 0.002, \"temp\": 0.005}\n    ]\n    \n    best_radii = radii.copy()\n    best_centers = centers.copy()\n    best_sum = np.sum(radii)\n    \n    temperature = initial_temperature\n    \n    # Main optimization loop\n    iteration = 0\n    phase_idx = 0\n    \n    while iteration < max_iterations and phase_idx < len(phases):\n        phase = phases[phase_idx]\n        \n        if iteration % phase[\"iterations\"] == 0 and phase_idx < len(phases) - 1:\n            phase_idx += 1\n            phase = phases[phase_idx]\n            repulsion_strength = phase[\"repulsion\"]\n            attraction_strength = phase[\"attraction\"]\n            boundary_strength = phase[\"boundary\"]\n            growth_rate = phase[\"growth\"]\n            temperature = phase[\"temp\"]\n        \n        # Calculate pairwise distances between circle centers\n        distances = squareform(pdist(centers))\n        np.fill_diagonal(distances, np.inf)  # Avoid self-interactions\n        \n        # Calculate minimum required distances (sum of radii pairs)\n        required_distances = np.add.outer(radii, radii)\n        \n        # Calculate overlap amounts\n        overlaps = required_distances - distances\n        overlaps[overlaps < 0] = 0  # Only consider actual overlaps\n        \n        # Calculate unit direction vectors between all pairs of circles\n        directions = np.zeros((n_circles, n_circles, 2))\n        for i in range(n_circles):\n            for j in range(n_circles):\n                if i != j:\n                    direction = centers[j] - centers[i]\n                    norm = np.linalg.norm(direction)\n                    if norm > 1e-10:  # Avoid division by zero\n                        directions[i, j] = direction / norm\n        \n        # Initialize forces\n        forces = np.zeros((n_circles, 2))\n        \n        # Repulsive forces from overlapping circles\n        for i in range(n_circles):\n            for j in range(n_circles):\n                if i != j and overlaps[i, j] > 0:\n                    forces[i] -= directions[i, j] * overlaps[i, j] * repulsion_strength\n        \n        # Attractive forces for nearby circles (helps with stability)\n        for i in range(n_circles):\n            for j in range(n_circles):\n                if i != j and distances[i, j] < 0.3 and overlaps[i, j] == 0:\n                    forces[i] += directions[i, j] * attraction_strength * (1.0 / (distances[i, j] + 0.01))\n        \n        # Boundary forces to keep circles inside the unit square\n        for i in range(n_circles):\n            # Left boundary\n            dist_to_left = centers[i, 0] - radii[i]\n            if dist_to_left < 0:\n                forces[i, 0] += boundary_strength * abs(dist_to_left)\n            \n            # Right boundary\n            dist_to_right = 1 - (centers[i, 0] + radii[i])\n            if dist_to_right < 0:\n                forces[i, 0] -= boundary_strength * abs(dist_to_right)\n            \n            # Bottom boundary\n            dist_to_bottom = centers[i, 1] - radii[i]\n            if dist_to_bottom < 0:\n                forces[i, 1] += boundary_strength * abs(dist_to_bottom)\n            \n            # Top boundary\n            dist_to_top = 1 - (centers[i, 1] + radii[i])\n            if dist_to_top < 0:\n                forces[i, 1] -= boundary_strength * abs(dist_to_top)\n        \n        # Add random perturbation based on temperature\n        forces += np.random.normal(0, temperature, forces.shape)\n        \n        # Update velocities with damping\n        velocities = velocities * damping + forces\n        \n        # Update positions\n        centers += velocities\n        \n        # Check if any circle is stable (low velocity and no overlaps)\n        is_stable = np.all(np.linalg.norm(velocities, axis=1) < 0.001)\n        no_overlaps = np.all(overlaps == 0)\n        \n        # If stable and no overlaps, try growing circles\n        if is_stable and no_overlaps:\n            # Calculate the distance to the nearest boundary or circle for each circle\n            min_distances = np.ones(n_circles) * np.inf\n            \n            # Distance to other circles\n            for i in range(n_circles):\n                for j in range(n_circles):\n                    if i != j:\n                        min_distances[i] = min(min_distances[i], distances[i, j] - radii[j])\n            \n            # Distance to boundaries\n            for i in range(n_circles):\n                min_distances[i] = min(min_distances[i], \n                                      centers[i, 0],                # Distance to left\n                                      centers[i, 1],                # Distance to bottom\n                                      1 - centers[i, 0],            # Distance to right\n                                      1 - centers[i, 1])            # Distance to top\n            \n            # Grow radii proportionally to available space\n            growth_factors = min_distances - radii\n            growth_factors = np.clip(growth_factors, 0, growth_rate)\n            radii += growth_factors\n        \n        # Check if this is the best solution so far\n        current_sum = np.sum(radii)\n        if current_sum > best_sum and no_overlaps and np.all(\n                (centers[:, 0] - radii >= 0) & \n                (centers[:, 0] + radii <= 1) & \n                (centers[:, 1] - radii >= 0) & \n                (centers[:, 1] + radii <= 1)):\n            best_sum = current_sum\n            best_radii = radii.copy()\n            best_centers = centers.copy()\n        \n        # Cool down the temperature\n        temperature *= cooling_rate\n        iteration += 1\n    \n    # Final refinement: try to grow each circle individually\n    for i in range(n_circles):\n        # Calculate the distance to the nearest boundary or circle\n        min_distance = np.inf\n        \n        # Distance to other circles\n        for j in range(n_circles):\n            if i != j:\n                dist = np.linalg.norm(best_centers[i] - best_centers[j]) - best_radii[j]\n                min_distance = min(min_distance, dist)\n        \n        # Distance to boundaries\n        min_distance = min(min_distance, \n                          best_centers[i, 0],                # Distance to left\n                          best_centers[i, 1],                # Distance to bottom\n                          1 - best_centers[i, 0],            # Distance to right\n                          1 - best_centers[i, 1])            # Distance to top\n        \n        # Grow the circle to touch the nearest constraint\n        best_radii[i] = min(best_radii[i] + min_distance, best_radii[i] * 1.1)\n    \n    return best_centers, best_radii, np.sum(best_radii)\n\ndef run_packing():\n    return construct_packing()\n```\n\nThis implementation includes:\n\n1. **Multi-phase optimization strategy** with different force parameters for each phase\n2. **Advanced force model** with:\n   - Repulsion forces between overlapping circles\n   - Attraction forces for nearby circles to improve packing density\n   - Boundary forces to keep circles inside the unit square\n   - Temperature-based random perturbations for exploration\n\n3. **Adaptive parameters** that change throughout the simulation\n4. **Momentum and damping** to improve convergence\n5. **Smart growth strategy** that grows circles proportionally to available space\n6. **Halton sequence** for initial placement to improve distribution\n7. **Final refinement phase** that tries to grow each circle individually\n\nThe algorithm balances exploration and exploitation through its temperature parameter and uses physics-inspired forces to efficiently pack the circles while maximizing the sum of their radii.",
  "reasoning": "I'll implement an advanced vector-based force model for packing 26 circles into a unit square. This approach uses sophisticated physics-based simulation with multiple force types, adaptive parameters, and strategic growth strategies.\n\nThis implementation includes:\n\n1. **Multi-phase optimization strategy** with different force parameters for each phase\n2. **Advanced force model** with:\n   - Repulsion forces between overlapping circles\n   - Attraction forces for nearby circles to improve packing density\n   - Boundary forces to keep circles inside the unit square\n   - Temperature-based random perturbations for exploration\n\n3. **Adaptive parameters** that change throughout the simulation\n4. **Momentum and damping** to improve convergence\n5. **Smart growth strategy** that grows circles proportionally to available space\n6. **Halton sequence** for initial placement to improve distribution\n7. **Final refinement phase** that tries to grow each circle individually\n\nThe algorithm balances exploration and exploitation through its temperature parameter and uses physics-inspired forces to efficiently pack the circles while maximizing the sum of their radii.",
  "timestamp": "2026-01-14T12:27:24.694848",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-3.7-sonnet",
    "temperature": 0.7
  }
}