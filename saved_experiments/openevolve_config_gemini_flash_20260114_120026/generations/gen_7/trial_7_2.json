{
  "trial_id": "trial_7_2",
  "generation": 7,
  "parent_id": "trial_5_8",
  "code": "import numpy as np\nfrom scipy.optimize import basinhopping, differential_evolution\nfrom scipy.spatial import distance_matrix\n\ndef construct_packing():\n    def physics_simulation(centers, radii, iterations=1000, repulsion_strength=0.01, attraction_strength=0.0001, dt=0.1):\n        for _ in range(iterations):\n            forces = np.zeros_like(centers)\n            \n            # Repulsive forces between circles\n            for i in range(26):\n                for j in range(i + 1, 26):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    overlap = radii[i] + radii[j] - dist\n                    if overlap > 0:\n                        direction = (centers[i] - centers[j]) / dist\n                        forces[i] += repulsion_strength * overlap * direction\n                        forces[j] -= repulsion_strength * overlap * direction\n\n            # Attractive forces to the center\n            forces += -attraction_strength * (centers - 0.5)\n            \n            # Update positions\n            centers += dt * forces\n\n            # Reflect off walls\n            for i in range(26):\n                if centers[i, 0] - radii[i] < 0:\n                    centers[i, 0] = radii[i]\n                if centers[i, 0] + radii[i] > 1:\n                    centers[i, 0] = 1 - radii[i]\n                if centers[i, 1] - radii[i] < 0:\n                    centers[i, 1] = radii[i]\n                if centers[i, 1] + radii[i] > 1:\n                    centers[i, 1] = 1 - radii[i]\n                    \n        return centers\n\n    def initial_radii_heuristic(centers):\n        radii = np.zeros(26)\n        for i in range(26):\n            min_dist = float('inf')\n            # Distance to walls\n            min_dist = min(min_dist, centers[i, 0])\n            min_dist = min(min_dist, 1 - centers[i, 0])\n            min_dist = min(min_dist, centers[i, 1])\n            min_dist = min(min_dist, 1 - centers[i, 1])\n\n            # Distance to other circles\n            for j in range(26):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    min_dist = min(min_dist, (dist - radii[j])/2) # Ensure no overlap\n            radii[i] = min_dist\n        return radii\n    \n    def objective_function(x):\n        centers = x[:52].reshape(26, 2)\n        radii = x[52:]\n        \n        # Constraint violation penalty\n        penalty = 0\n        \n        # Ensure circles are within the unit square\n        for i in range(26):\n            if radii[i] <= 0:\n                penalty += 1000  # Large penalty for negative radii\n            if centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1:\n                penalty += 1000\n\n        # Ensure no overlapping circles\n        distances = distance_matrix(centers, centers)\n        for i in range(26):\n            for j in range(i + 1, 26):\n                if distances[i, j] < radii[i] + radii[j]:\n                    penalty += 1000 * (radii[i] + radii[j] - distances[i, j])\n\n        return -np.sum(radii) + penalty  # Maximize sum of radii, minimize penalty\n\n    def random_step(x):\n        # Perturb centers and radii\n        centers = x[:52].reshape(26, 2)\n        radii = x[52:]\n        \n        # Randomly select a circle and perturb its position\n        circle_index = np.random.randint(26)\n        centers[circle_index] += np.random.uniform(-0.01, 0.01, size=2)\n        \n        # Randomly select a radius and perturb its value\n        radius_index = np.random.randint(26)\n        radii[radius_index] += np.random.uniform(-0.005, 0.005)\n\n        x[:52] = centers.flatten()\n        x[52:] = radii\n        return x\n\n    def physics_step(x):\n        centers = x[:52].reshape(26, 2)\n        radii = x[52:]\n\n        # Perform a few iterations of the physics simulation\n        centers = physics_simulation(centers, radii, iterations=50, repulsion_strength=0.01, attraction_strength=0.0001)\n\n        # Recalculate radii based on the new positions\n        radii = initial_radii_heuristic(centers)\n\n        x[:52] = centers.flatten()\n        x[52:] = radii\n        return x\n\n    class MyTakeStep:\n        def __init__(self, stepsize=0.05):\n            self.stepsize = stepsize\n            self.rng = np.random.default_rng()\n\n        def __call__(self, x):\n            s = self.stepsize\n            \n            if np.random.rand() < 0.2: # 20% chance to take physics step\n                x = physics_step(x)\n            else: # 80% chance to take random step\n                x = random_step(x)\n\n            return x\n\n    # 1. Initial Configuration (Random)\n    initial_centers = np.random.rand(26, 2)\n    initial_radii = initial_radii_heuristic(initial_centers)\n\n    # 2. Physics Simulation for Initial Optimization\n    initial_centers = physics_simulation(initial_centers, initial_radii, iterations=500)\n    initial_radii = initial_radii_heuristic(initial_centers)\n    \n    x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n\n    # Bounds for the optimizer\n    bounds = [(0, 1)] * 52 + [(0, 0.5)] * 26\n\n    # 3. Basin Hopping Optimization\n    mytakestep = MyTakeStep()\n    minimizer_kwargs = {\"method\": \"L-BFGS-B\", \"bounds\": bounds} # , \"options\": {'maxiter': 50}\n    ret = basinhopping(objective_function, x0, niter=200, minimizer_kwargs=minimizer_kwargs, take_step=mytakestep) #, stepsize=0.01\n\n    # Extract Results\n    final_centers = ret.x[:52].reshape(26, 2)\n    final_radii = ret.x[52:]\n    sum_radii = np.sum(final_radii)\n    \n    return final_centers, final_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 1.093932429900211,
    "eval_time": 29.819514989852905,
    "error": null
  },
  "prompt": "Develop a hybrid approach for the circle packing problem that combines physics-based simulation with mathematical optimization.\n\nYour solution should:\n1. Begin with a physics-based simulation that uses:\n   - Repulsive forces between circles\n   - Attractive forces to the center of the square\n   - Dynamic radius adjustment based on available space\n2. Use the physics simulation to generate a promising initial configuration\n3. Feed this configuration into a basin-hopping or differential evolution optimizer\n4. Implement specialized step functions that occasionally use physics-based perturbations\n5. Include robust constraint handling for both the physics and optimization phases\n\nYour goal is to maximize the sum of radii for 26 circles in a unit square.\n\nUse insights from these successful approaches:\n1. Physics-based approach from trial_0_2 (score: 2.6121943848600018)\n2. Optimization approach from trial_trial_5_8 (score: 2.633035228845132)\n        ",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import basinhopping, differential_evolution\nfrom scipy.spatial import distance_matrix\n\ndef construct_packing():\n    def physics_simulation(centers, radii, iterations=1000, repulsion_strength=0.01, attraction_strength=0.0001, dt=0.1):\n        for _ in range(iterations):\n            forces = np.zeros_like(centers)\n            \n            # Repulsive forces between circles\n            for i in range(26):\n                for j in range(i + 1, 26):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    overlap = radii[i] + radii[j] - dist\n                    if overlap > 0:\n                        direction = (centers[i] - centers[j]) / dist\n                        forces[i] += repulsion_strength * overlap * direction\n                        forces[j] -= repulsion_strength * overlap * direction\n\n            # Attractive forces to the center\n            forces += -attraction_strength * (centers - 0.5)\n            \n            # Update positions\n            centers += dt * forces\n\n            # Reflect off walls\n            for i in range(26):\n                if centers[i, 0] - radii[i] < 0:\n                    centers[i, 0] = radii[i]\n                if centers[i, 0] + radii[i] > 1:\n                    centers[i, 0] = 1 - radii[i]\n                if centers[i, 1] - radii[i] < 0:\n                    centers[i, 1] = radii[i]\n                if centers[i, 1] + radii[i] > 1:\n                    centers[i, 1] = 1 - radii[i]\n                    \n        return centers\n\n    def initial_radii_heuristic(centers):\n        radii = np.zeros(26)\n        for i in range(26):\n            min_dist = float('inf')\n            # Distance to walls\n            min_dist = min(min_dist, centers[i, 0])\n            min_dist = min(min_dist, 1 - centers[i, 0])\n            min_dist = min(min_dist, centers[i, 1])\n            min_dist = min(min_dist, 1 - centers[i, 1])\n\n            # Distance to other circles\n            for j in range(26):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    min_dist = min(min_dist, (dist - radii[j])/2) # Ensure no overlap\n            radii[i] = min_dist\n        return radii\n    \n    def objective_function(x):\n        centers = x[:52].reshape(26, 2)\n        radii = x[52:]\n        \n        # Constraint violation penalty\n        penalty = 0\n        \n        # Ensure circles are within the unit square\n        for i in range(26):\n            if radii[i] <= 0:\n                penalty += 1000  # Large penalty for negative radii\n            if centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1:\n                penalty += 1000\n\n        # Ensure no overlapping circles\n        distances = distance_matrix(centers, centers)\n        for i in range(26):\n            for j in range(i + 1, 26):\n                if distances[i, j] < radii[i] + radii[j]:\n                    penalty += 1000 * (radii[i] + radii[j] - distances[i, j])\n\n        return -np.sum(radii) + penalty  # Maximize sum of radii, minimize penalty\n\n    def random_step(x):\n        # Perturb centers and radii\n        centers = x[:52].reshape(26, 2)\n        radii = x[52:]\n        \n        # Randomly select a circle and perturb its position\n        circle_index = np.random.randint(26)\n        centers[circle_index] += np.random.uniform(-0.01, 0.01, size=2)\n        \n        # Randomly select a radius and perturb its value\n        radius_index = np.random.randint(26)\n        radii[radius_index] += np.random.uniform(-0.005, 0.005)\n\n        x[:52] = centers.flatten()\n        x[52:] = radii\n        return x\n\n    def physics_step(x):\n        centers = x[:52].reshape(26, 2)\n        radii = x[52:]\n\n        # Perform a few iterations of the physics simulation\n        centers = physics_simulation(centers, radii, iterations=50, repulsion_strength=0.01, attraction_strength=0.0001)\n\n        # Recalculate radii based on the new positions\n        radii = initial_radii_heuristic(centers)\n\n        x[:52] = centers.flatten()\n        x[52:] = radii\n        return x\n\n    class MyTakeStep:\n        def __init__(self, stepsize=0.05):\n            self.stepsize = stepsize\n            self.rng = np.random.default_rng()\n\n        def __call__(self, x):\n            s = self.stepsize\n            \n            if np.random.rand() < 0.2: # 20% chance to take physics step\n                x = physics_step(x)\n            else: # 80% chance to take random step\n                x = random_step(x)\n\n            return x\n\n    # 1. Initial Configuration (Random)\n    initial_centers = np.random.rand(26, 2)\n    initial_radii = initial_radii_heuristic(initial_centers)\n\n    # 2. Physics Simulation for Initial Optimization\n    initial_centers = physics_simulation(initial_centers, initial_radii, iterations=500)\n    initial_radii = initial_radii_heuristic(initial_centers)\n    \n    x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n\n    # Bounds for the optimizer\n    bounds = [(0, 1)] * 52 + [(0, 0.5)] * 26\n\n    # 3. Basin Hopping Optimization\n    mytakestep = MyTakeStep()\n    minimizer_kwargs = {\"method\": \"L-BFGS-B\", \"bounds\": bounds} # , \"options\": {'maxiter': 50}\n    ret = basinhopping(objective_function, x0, niter=200, minimizer_kwargs=minimizer_kwargs, take_step=mytakestep) #, stepsize=0.01\n\n    # Extract Results\n    final_centers = ret.x[:52].reshape(26, 2)\n    final_radii = ret.x[52:]\n    sum_radii = np.sum(final_radii)\n    \n    return final_centers, final_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-14T12:43:41.607273",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 443,
        "candidates_token_count": 1731,
        "thoughts_token_count": 0
      },
      "response_text_len": 5654
    }
  }
}