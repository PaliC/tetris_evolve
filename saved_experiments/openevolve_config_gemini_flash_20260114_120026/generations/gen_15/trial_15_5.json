{
  "trial_id": "trial_15_5",
  "generation": 15,
  "parent_id": null,
  "code": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\ndef is_valid(centers, radii):\n    \"\"\"Checks if a configuration is valid (no overlaps, inside the unit square).\"\"\"\n    n = len(centers)\n    for i in range(n):\n        if not (0 <= centers[i][0] - radii[i] and centers[i][0] + radii[i] <= 1 and\n                0 <= centers[i][1] - radii[i] and centers[i][1] + radii[i] <= 1):\n            return False\n        for j in range(i + 1, n):\n            distance = np.linalg.norm(centers[i] - centers[j])\n            if distance < radii[i] + radii[j]:\n                return False\n    return True\n\ndef calculate_sum_radii(radii):\n    \"\"\"Calculates the sum of radii.\"\"\"\n    return np.sum(radii)\n\ndef initialize_population(pop_size, num_circles):\n    \"\"\"Initializes a population of circle configurations.\"\"\"\n    population = []\n    for _ in range(pop_size):\n        centers = np.random.rand(num_circles, 2)\n        radii = np.random.rand(num_circles) * 0.1  # Initial radii capped at 0.1\n        population.append((centers, radii))\n    return population\n\ndef evaluate_population(population):\n    \"\"\"Evaluates the fitness of each individual in the population.\"\"\"\n    fitness_scores = []\n    for centers, radii in population:\n        if is_valid(centers, radii):\n            fitness_scores.append(calculate_sum_radii(radii))\n        else:\n            fitness_scores.append(0)  # Assign low fitness to invalid solutions\n    return fitness_scores\n\ndef selection(population, fitness_scores, num_parents):\n    \"\"\"Selects the best individuals as parents for the next generation.\"\"\"\n    # Tournament selection\n    selected_indices = []\n    for _ in range(num_parents):\n        indices = random.sample(range(len(population)), 5)  # Tournament size = 5\n        winner_index = max(indices, key=lambda i: fitness_scores[i])\n        selected_indices.append(winner_index)\n    parents = [population[i] for i in selected_indices]\n    return parents\n\ndef crossover(parent1, parent2, crossover_rate=0.8):\n    \"\"\"Performs crossover to create new offspring.\"\"\"\n    if random.random() > crossover_rate:\n        return parent1, parent2\n\n    centers1, radii1 = parent1\n    centers2, radii2 = parent2\n    num_circles = len(centers1)\n\n    new_centers1 = centers1.copy()\n    new_centers2 = centers2.copy()\n    new_radii1 = radii1.copy()\n    new_radii2 = radii2.copy()\n\n    # Uniform crossover\n    for i in range(num_circles):\n        if random.random() < 0.5:\n            new_centers1[i] = centers2[i].copy()\n            new_centers2[i] = centers1[i].copy()\n            new_radii1[i] = radii2[i]\n            new_radii2[i] = radii1[i]\n\n    return (new_centers1, new_radii1), (new_centers2, new_radii2)\n\ndef mutate(individual, mutation_rate=0.1, step_size=0.01):\n    \"\"\"Mutates an individual by adjusting circle positions and radii.\"\"\"\n    centers, radii = individual\n    num_circles = len(centers)\n\n    new_centers = centers.copy()\n    new_radii = radii.copy()\n\n    for i in range(num_circles):\n        if random.random() < mutation_rate:\n            # Adjust position\n            new_centers[i] += np.random.normal(0, step_size, 2)\n        if random.random() < mutation_rate:\n            # Adjust radius\n            new_radii[i] += np.random.normal(0, step_size * 0.1) # smaller step for radii\n            new_radii[i] = max(0, new_radii[i])  # Ensure radius is non-negative\n\n    return new_centers, new_radii\n\ndef repair_solution(centers, radii):\n    \"\"\"Repairs an invalid solution by adjusting circle positions and radii.\"\"\"\n    n = len(centers)\n    for i in range(n):\n        # Ensure circles are within the unit square\n        radii[i] = min(radii[i], centers[i][0], 1 - centers[i][0], centers[i][1], 1 - centers[i][1])\n        centers[i][0] = np.clip(centers[i][0], radii[i], 1 - radii[i])\n        centers[i][1] = np.clip(centers[i][1], radii[i], 1 - radii[i])\n\n    # Resolve overlaps using a simple repulsive force approach\n    for _ in range(100): # Iterate to resolve overlaps\n        overlap_found = False\n        for i in range(n):\n            for j in range(i + 1, n):\n                distance = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - distance\n                if overlap > 0:\n                    overlap_found = True\n                    # Move circles away from each other\n                    direction = (centers[j] - centers[i])\n                    if np.linalg.norm(direction) == 0:\n                        direction = np.array([1,0]) # avoid division by zero\n                    direction = direction / np.linalg.norm(direction)\n                    centers[i] -= direction * overlap * 0.5\n                    centers[j] += direction * overlap * 0.5\n\n                    # keep within bounds\n                    radii[i] = min(radii[i], centers[i][0], 1 - centers[i][0], centers[i][1], 1 - centers[i][1])\n                    centers[i][0] = np.clip(centers[i][0], radii[i], 1 - radii[i])\n                    centers[i][1] = np.clip(centers[i][1], radii[i], 1 - radii[i])\n                    radii[j] = min(radii[j], centers[j][0], 1 - centers[j][0], centers[j][1], 1 - centers[j][1])\n                    centers[j][0] = np.clip(centers[j][0], radii[j], 1 - radii[j])\n                    centers[j][1] = np.clip(centers[j][1], radii[j], 1 - radii[j])\n\n\n        if not overlap_found:\n            break\n    return centers, radii\n\ndef local_refinement(centers, radii):\n    \"\"\"Refines the solution using local optimization.\"\"\"\n    def objective_function(x):\n        # x contains flattened centers and radii\n        centers = x[:2*len(radii)].reshape(-1, 2)\n        radii = x[2*len(radii):]\n\n        # Penalize invalid solutions heavily\n        if not is_valid(centers, radii):\n            return -1e9\n\n        return np.sum(radii)  # Maximize sum of radii\n\n    # Flatten centers and radii into a single vector\n    x0 = np.concatenate([centers.flatten(), radii])\n\n    # Define bounds for the optimization\n    bounds = []\n    for i in range(len(radii)):\n        bounds.append((0, 1))  # x coordinate\n        bounds.append((0, 1))  # y coordinate\n    for i in range(len(radii)):\n        bounds.append((0, 0.5)) #radius\n\n    # Perform the optimization\n    result = minimize(lambda x: -objective_function(x), x0, method='L-BFGS-B', bounds=bounds)\n\n    # Extract the optimized centers and radii\n    optimized_centers = result.x[:2*len(radii)].reshape(-1, 2)\n    optimized_radii = result.x[2*len(radii):]\n\n    return optimized_centers, optimized_radii\n\ndef construct_packing():\n    \"\"\"Constructs a circle packing using a genetic algorithm.\"\"\"\n    num_circles = 26\n    pop_size = 50\n    num_generations = 100\n    num_parents = pop_size // 2\n\n    # Initialize the population\n    population = initialize_population(pop_size, num_circles)\n\n    # Evolve the population\n    for generation in range(num_generations):\n        # Evaluate the population\n        fitness_scores = evaluate_population(population)\n\n        # Select parents\n        parents = selection(population, fitness_scores, num_parents)\n\n        # Create the next generation\n        offspring = []\n        for i in range(0, len(parents), 2):\n            parent1 = parents[i]\n            parent2 = parents[i+1] if i+1 < len(parents) else parents[i]\n            child1, child2 = crossover(parent1, parent2)\n            offspring.append(child1)\n            offspring.append(child2)\n\n        # Mutate the offspring\n        mutated_offspring = []\n        for individual in offspring:\n            centers, radii = mutate(individual)\n            centers, radii = repair_solution(centers, radii)\n            mutated_offspring.append((centers, radii))\n\n        # Combine parents and offspring to form the new population\n        population = parents + mutated_offspring\n        fitness_scores = evaluate_population(population)\n        best_index = np.argmax(fitness_scores)\n        best_individual = population[best_index]\n\n        # Keep only the best individuals\n        sorted_indices = np.argsort(fitness_scores)[::-1]\n        population = [population[i] for i in sorted_indices[:pop_size]]\n\n        # Print the best fitness score in each generation\n        print(f\"Generation {generation}: Best fitness = {fitness_scores[sorted_indices[0]]}\")\n\n    # After the genetic algorithm, perform local refinement on the best solution\n    best_centers, best_radii = population[0]\n    best_centers, best_radii = local_refinement(best_centers, best_radii)\n    best_centers, best_radii = repair_solution(best_centers, best_radii) #repair once more after local refinement\n\n    # Return the best solution\n    sum_radii = calculate_sum_radii(best_radii)\n    return best_centers, best_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 16.32743191719055,
    "error": "UnboundLocalError: cannot access local variable 'radii' where it is not associated with a value"
  },
  "prompt": "Create a genetic algorithm or evolutionary strategy for the circle packing problem (26 circles in unit square).\n\nYour implementation should:\n1. Define a chromosome representation for circle configurations\n   - Encode circle positions and radii efficiently\n2. Implement selection mechanisms that favor higher sums of radii\n3. Design specialized crossover operations that:\n   - Preserve good sub-structures from both parents\n   - Avoid creating invalid offspring (overlapping circles)\n4. Create mutation operators that:\n   - Adjust circle positions with adaptive step sizes\n   - Modify radii according to available space\n5. Include a repair mechanism to fix invalid solutions\n6. Implement a diversity-preserving mechanism\n\nOptimize the evolutionary parameters throughout the process and include a local refinement step.\n\nReturn the centers, radii, and sum of radii using the required format.\n",
  "response": "```python\nimport numpy as np\nimport random\nfrom scipy.optimize import minimize\n\ndef is_valid(centers, radii):\n    \"\"\"Checks if a configuration is valid (no overlaps, inside the unit square).\"\"\"\n    n = len(centers)\n    for i in range(n):\n        if not (0 <= centers[i][0] - radii[i] and centers[i][0] + radii[i] <= 1 and\n                0 <= centers[i][1] - radii[i] and centers[i][1] + radii[i] <= 1):\n            return False\n        for j in range(i + 1, n):\n            distance = np.linalg.norm(centers[i] - centers[j])\n            if distance < radii[i] + radii[j]:\n                return False\n    return True\n\ndef calculate_sum_radii(radii):\n    \"\"\"Calculates the sum of radii.\"\"\"\n    return np.sum(radii)\n\ndef initialize_population(pop_size, num_circles):\n    \"\"\"Initializes a population of circle configurations.\"\"\"\n    population = []\n    for _ in range(pop_size):\n        centers = np.random.rand(num_circles, 2)\n        radii = np.random.rand(num_circles) * 0.1  # Initial radii capped at 0.1\n        population.append((centers, radii))\n    return population\n\ndef evaluate_population(population):\n    \"\"\"Evaluates the fitness of each individual in the population.\"\"\"\n    fitness_scores = []\n    for centers, radii in population:\n        if is_valid(centers, radii):\n            fitness_scores.append(calculate_sum_radii(radii))\n        else:\n            fitness_scores.append(0)  # Assign low fitness to invalid solutions\n    return fitness_scores\n\ndef selection(population, fitness_scores, num_parents):\n    \"\"\"Selects the best individuals as parents for the next generation.\"\"\"\n    # Tournament selection\n    selected_indices = []\n    for _ in range(num_parents):\n        indices = random.sample(range(len(population)), 5)  # Tournament size = 5\n        winner_index = max(indices, key=lambda i: fitness_scores[i])\n        selected_indices.append(winner_index)\n    parents = [population[i] for i in selected_indices]\n    return parents\n\ndef crossover(parent1, parent2, crossover_rate=0.8):\n    \"\"\"Performs crossover to create new offspring.\"\"\"\n    if random.random() > crossover_rate:\n        return parent1, parent2\n\n    centers1, radii1 = parent1\n    centers2, radii2 = parent2\n    num_circles = len(centers1)\n\n    new_centers1 = centers1.copy()\n    new_centers2 = centers2.copy()\n    new_radii1 = radii1.copy()\n    new_radii2 = radii2.copy()\n\n    # Uniform crossover\n    for i in range(num_circles):\n        if random.random() < 0.5:\n            new_centers1[i] = centers2[i].copy()\n            new_centers2[i] = centers1[i].copy()\n            new_radii1[i] = radii2[i]\n            new_radii2[i] = radii1[i]\n\n    return (new_centers1, new_radii1), (new_centers2, new_radii2)\n\ndef mutate(individual, mutation_rate=0.1, step_size=0.01):\n    \"\"\"Mutates an individual by adjusting circle positions and radii.\"\"\"\n    centers, radii = individual\n    num_circles = len(centers)\n\n    new_centers = centers.copy()\n    new_radii = radii.copy()\n\n    for i in range(num_circles):\n        if random.random() < mutation_rate:\n            # Adjust position\n            new_centers[i] += np.random.normal(0, step_size, 2)\n        if random.random() < mutation_rate:\n            # Adjust radius\n            new_radii[i] += np.random.normal(0, step_size * 0.1) # smaller step for radii\n            new_radii[i] = max(0, new_radii[i])  # Ensure radius is non-negative\n\n    return new_centers, new_radii\n\ndef repair_solution(centers, radii):\n    \"\"\"Repairs an invalid solution by adjusting circle positions and radii.\"\"\"\n    n = len(centers)\n    for i in range(n):\n        # Ensure circles are within the unit square\n        radii[i] = min(radii[i], centers[i][0], 1 - centers[i][0], centers[i][1], 1 - centers[i][1])\n        centers[i][0] = np.clip(centers[i][0], radii[i], 1 - radii[i])\n        centers[i][1] = np.clip(centers[i][1], radii[i], 1 - radii[i])\n\n    # Resolve overlaps using a simple repulsive force approach\n    for _ in range(100): # Iterate to resolve overlaps\n        overlap_found = False\n        for i in range(n):\n            for j in range(i + 1, n):\n                distance = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - distance\n                if overlap > 0:\n                    overlap_found = True\n                    # Move circles away from each other\n                    direction = (centers[j] - centers[i])\n                    if np.linalg.norm(direction) == 0:\n                        direction = np.array([1,0]) # avoid division by zero\n                    direction = direction / np.linalg.norm(direction)\n                    centers[i] -= direction * overlap * 0.5\n                    centers[j] += direction * overlap * 0.5\n\n                    # keep within bounds\n                    radii[i] = min(radii[i], centers[i][0], 1 - centers[i][0], centers[i][1], 1 - centers[i][1])\n                    centers[i][0] = np.clip(centers[i][0], radii[i], 1 - radii[i])\n                    centers[i][1] = np.clip(centers[i][1], radii[i], 1 - radii[i])\n                    radii[j] = min(radii[j], centers[j][0], 1 - centers[j][0], centers[j][1], 1 - centers[j][1])\n                    centers[j][0] = np.clip(centers[j][0], radii[j], 1 - radii[j])\n                    centers[j][1] = np.clip(centers[j][1], radii[j], 1 - radii[j])\n\n\n        if not overlap_found:\n            break\n    return centers, radii\n\ndef local_refinement(centers, radii):\n    \"\"\"Refines the solution using local optimization.\"\"\"\n    def objective_function(x):\n        # x contains flattened centers and radii\n        centers = x[:2*len(radii)].reshape(-1, 2)\n        radii = x[2*len(radii):]\n\n        # Penalize invalid solutions heavily\n        if not is_valid(centers, radii):\n            return -1e9\n\n        return np.sum(radii)  # Maximize sum of radii\n\n    # Flatten centers and radii into a single vector\n    x0 = np.concatenate([centers.flatten(), radii])\n\n    # Define bounds for the optimization\n    bounds = []\n    for i in range(len(radii)):\n        bounds.append((0, 1))  # x coordinate\n        bounds.append((0, 1))  # y coordinate\n    for i in range(len(radii)):\n        bounds.append((0, 0.5)) #radius\n\n    # Perform the optimization\n    result = minimize(lambda x: -objective_function(x), x0, method='L-BFGS-B', bounds=bounds)\n\n    # Extract the optimized centers and radii\n    optimized_centers = result.x[:2*len(radii)].reshape(-1, 2)\n    optimized_radii = result.x[2*len(radii):]\n\n    return optimized_centers, optimized_radii\n\ndef construct_packing():\n    \"\"\"Constructs a circle packing using a genetic algorithm.\"\"\"\n    num_circles = 26\n    pop_size = 50\n    num_generations = 100\n    num_parents = pop_size // 2\n\n    # Initialize the population\n    population = initialize_population(pop_size, num_circles)\n\n    # Evolve the population\n    for generation in range(num_generations):\n        # Evaluate the population\n        fitness_scores = evaluate_population(population)\n\n        # Select parents\n        parents = selection(population, fitness_scores, num_parents)\n\n        # Create the next generation\n        offspring = []\n        for i in range(0, len(parents), 2):\n            parent1 = parents[i]\n            parent2 = parents[i+1] if i+1 < len(parents) else parents[i]\n            child1, child2 = crossover(parent1, parent2)\n            offspring.append(child1)\n            offspring.append(child2)\n\n        # Mutate the offspring\n        mutated_offspring = []\n        for individual in offspring:\n            centers, radii = mutate(individual)\n            centers, radii = repair_solution(centers, radii)\n            mutated_offspring.append((centers, radii))\n\n        # Combine parents and offspring to form the new population\n        population = parents + mutated_offspring\n        fitness_scores = evaluate_population(population)\n        best_index = np.argmax(fitness_scores)\n        best_individual = population[best_index]\n\n        # Keep only the best individuals\n        sorted_indices = np.argsort(fitness_scores)[::-1]\n        population = [population[i] for i in sorted_indices[:pop_size]]\n\n        # Print the best fitness score in each generation\n        print(f\"Generation {generation}: Best fitness = {fitness_scores[sorted_indices[0]]}\")\n\n    # After the genetic algorithm, perform local refinement on the best solution\n    best_centers, best_radii = population[0]\n    best_centers, best_radii = local_refinement(best_centers, best_radii)\n    best_centers, best_radii = repair_solution(best_centers, best_radii) #repair once more after local refinement\n\n    # Return the best solution\n    sum_radii = calculate_sum_radii(best_radii)\n    return best_centers, best_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-14T13:26:44.761350",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 386,
        "candidates_token_count": 2520,
        "thoughts_token_count": 0
      },
      "response_text_len": 8737
    }
  }
}