{
  "trial_id": "trial_15_7",
  "generation": 15,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial import Voronoi\n\ndef construct_packing():\n    def initial_centers_radii(n=26):\n        \"\"\"Generates an initial configuration based on a hybrid pattern.\"\"\"\n        centers = []\n        radii = []\n\n        # Core hexagonal lattice (adjust parameters as needed)\n        num_rings = 3  # Number of rings around the center\n        center_x, center_y = 0.5, 0.5\n        radius_spacing = 0.15  # Radial distance between rings\n\n        for i in range(num_rings):\n            if i == 0:\n                centers.append([center_x, center_y])\n                radii.append(0.0)  # Initial radius, will be optimized later\n            else:\n                num_circles = 6 * i\n                for j in range(num_circles):\n                    angle = 2 * np.pi * j / num_circles\n                    x = center_x + i * radius_spacing * np.cos(angle)\n                    y = center_y + i * radius_spacing * np.sin(angle)\n                    centers.append([x, y])\n                    radii.append(0.0) # Initial radius, will be optimized later\n        \n        # Add more points randomly if needed\n        remaining = n - len(centers)\n        if remaining > 0:\n            for _ in range(remaining):\n                x = np.random.uniform(0, 1)\n                y = np.random.uniform(0, 1)\n                centers.append([x, y])\n                radii.append(0.0)\n\n        centers = np.array(centers[:n])\n        radii = np.array(radii[:n])\n        \n        return centers, radii\n\n    def check_constraints(centers, radii):\n        \"\"\"Checks if the constraints are satisfied.\"\"\"\n        n = len(centers)\n        for i in range(n):\n            # Check if inside the square\n            if not (0 <= centers[i, 0] - radii[i] and centers[i, 0] + radii[i] <= 1 and\n                    0 <= centers[i, 1] - radii[i] and centers[i, 1] + radii[i] <= 1):\n                return False\n            # Check for overlaps\n            for j in range(i):\n                distance = np.linalg.norm(centers[i] - centers[j])\n                if distance < radii[i] + radii[j]:\n                    return False\n        return True\n\n    def objective_function(x, n):\n        \"\"\"Objective function to maximize the sum of radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n\n        if not check_constraints(centers, radii):\n             return -1e9  # Return a large negative value if constraints are violated\n\n        return np.sum(radii)\n\n    def optimize_radii(centers, radii):\n        \"\"\"Optimizes radii based on Voronoi cell areas.\"\"\"\n        vor = Voronoi(centers)\n        new_radii = []\n        for i, region_index in enumerate(vor.point_region):\n            if region_index == -1: # Handle unbounded regions\n                new_radii.append(0.01) # Small default value\n                continue\n\n            region = vor.regions[region_index]\n            if not all(v >= 0 for v in region):\n                new_radii.append(0.01) # Small default value if unbounded\n                continue\n                \n            vertices = vor.vertices[region]\n            area = 0.0\n            for j in range(len(vertices)):\n                v1 = vertices[j]\n                v2 = vertices[(j + 1) % len(vertices)]\n                area += 0.5 * (v1[0] * v2[1] - v2[0] * v1[1])\n            \n            area = abs(area)\n            new_radii.append(np.sqrt(area)/5) # Scale the radius based on area\n        \n        return np.array(new_radii)\n    \n    def penalty_function(x, n, penalty_factor=1000.0):\n        \"\"\"Penalty function to enforce constraints.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        penalty = 0.0\n\n        # Boundary penalty\n        for i in range(n):\n            penalty += max(0, radii[i] - centers[i, 0]) * penalty_factor\n            penalty += max(0, radii[i] - (1 - centers[i, 0])) * penalty_factor\n            penalty += max(0, radii[i] - centers[i, 1]) * penalty_factor\n            penalty += max(0, radii[i] - (1 - centers[i, 1])) * penalty_factor\n\n        # Overlap penalty\n        for i in range(n):\n            for j in range(i):\n                distance = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - distance\n                penalty += max(0, overlap) * penalty_factor\n\n        return penalty\n    \n    def combined_objective(x, n):\n        \"\"\"Combines the objective and penalty functions.\"\"\"\n        return -objective_function(x, n) + penalty_function(x, n)\n\n    # Initialization\n    n = 26\n    centers, radii = initial_centers_radii(n)\n    \n    # Optimization Loop\n    for iteration in range(5): # Adjust number of iterations as needed\n        # Optimize Radii based on Voronoi Cells\n        radii = optimize_radii(centers, radii)\n        \n        # Global Optimization with penalty method\n        x0 = np.concatenate([centers.flatten(), radii])\n        bounds = [(0, 1)] * (2 * n) + [(0.001, 0.5)] * n  # Radius bounds (adjust as needed)\n\n        result = minimize(\n            combined_objective,\n            x0,\n            args=(n,),\n            method='L-BFGS-B', # or 'SLSQP'\n            bounds=bounds,\n            options={'maxiter': 500, 'ftol': 1e-5}  # Adjust options as needed\n        )\n\n        x_optimal = result.x\n        centers = x_optimal[:2*n].reshape(n, 2)\n        radii = x_optimal[2*n:]\n\n    # Final Check\n    if not check_constraints(centers, radii):\n        print(\"Warning: Constraints not fully satisfied.\")\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 0.7426118628200797,
    "eval_time": 4.583538770675659,
    "error": null
  },
  "prompt": "Create a pattern-based approach for circle packing with optimization refinement.\n\nYour solution should:\n1. Generate initial configurations based on known optimal packing patterns:\n   - Triangular/hexagonal lattice (optimal for infinite packing)\n   - Shell-based configurations (concentric rings)\n   - Hybrid patterns that handle the square boundary effectively\n2. Implement a customized optimization algorithm:\n   - Preserve the global pattern structure\n   - Allow local adjustments to handle boundary effects\n   - Gradually increase radii while maintaining feasibility\n3. Use specialized algorithms for radius assignment:\n   - Assign radii based on local Voronoi cell areas\n   - Implement contact graph optimization\n   - Balance radius sizes to maximize total sum\n\nImplement the required function format and ensure all constraints are satisfied.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial import Voronoi\n\ndef construct_packing():\n    def initial_centers_radii(n=26):\n        \"\"\"Generates an initial configuration based on a hybrid pattern.\"\"\"\n        centers = []\n        radii = []\n\n        # Core hexagonal lattice (adjust parameters as needed)\n        num_rings = 3  # Number of rings around the center\n        center_x, center_y = 0.5, 0.5\n        radius_spacing = 0.15  # Radial distance between rings\n\n        for i in range(num_rings):\n            if i == 0:\n                centers.append([center_x, center_y])\n                radii.append(0.0)  # Initial radius, will be optimized later\n            else:\n                num_circles = 6 * i\n                for j in range(num_circles):\n                    angle = 2 * np.pi * j / num_circles\n                    x = center_x + i * radius_spacing * np.cos(angle)\n                    y = center_y + i * radius_spacing * np.sin(angle)\n                    centers.append([x, y])\n                    radii.append(0.0) # Initial radius, will be optimized later\n        \n        # Add more points randomly if needed\n        remaining = n - len(centers)\n        if remaining > 0:\n            for _ in range(remaining):\n                x = np.random.uniform(0, 1)\n                y = np.random.uniform(0, 1)\n                centers.append([x, y])\n                radii.append(0.0)\n\n        centers = np.array(centers[:n])\n        radii = np.array(radii[:n])\n        \n        return centers, radii\n\n    def check_constraints(centers, radii):\n        \"\"\"Checks if the constraints are satisfied.\"\"\"\n        n = len(centers)\n        for i in range(n):\n            # Check if inside the square\n            if not (0 <= centers[i, 0] - radii[i] and centers[i, 0] + radii[i] <= 1 and\n                    0 <= centers[i, 1] - radii[i] and centers[i, 1] + radii[i] <= 1):\n                return False\n            # Check for overlaps\n            for j in range(i):\n                distance = np.linalg.norm(centers[i] - centers[j])\n                if distance < radii[i] + radii[j]:\n                    return False\n        return True\n\n    def objective_function(x, n):\n        \"\"\"Objective function to maximize the sum of radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n\n        if not check_constraints(centers, radii):\n             return -1e9  # Return a large negative value if constraints are violated\n\n        return np.sum(radii)\n\n    def optimize_radii(centers, radii):\n        \"\"\"Optimizes radii based on Voronoi cell areas.\"\"\"\n        vor = Voronoi(centers)\n        new_radii = []\n        for i, region_index in enumerate(vor.point_region):\n            if region_index == -1: # Handle unbounded regions\n                new_radii.append(0.01) # Small default value\n                continue\n\n            region = vor.regions[region_index]\n            if not all(v >= 0 for v in region):\n                new_radii.append(0.01) # Small default value if unbounded\n                continue\n                \n            vertices = vor.vertices[region]\n            area = 0.0\n            for j in range(len(vertices)):\n                v1 = vertices[j]\n                v2 = vertices[(j + 1) % len(vertices)]\n                area += 0.5 * (v1[0] * v2[1] - v2[0] * v1[1])\n            \n            area = abs(area)\n            new_radii.append(np.sqrt(area)/5) # Scale the radius based on area\n        \n        return np.array(new_radii)\n    \n    def penalty_function(x, n, penalty_factor=1000.0):\n        \"\"\"Penalty function to enforce constraints.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        penalty = 0.0\n\n        # Boundary penalty\n        for i in range(n):\n            penalty += max(0, radii[i] - centers[i, 0]) * penalty_factor\n            penalty += max(0, radii[i] - (1 - centers[i, 0])) * penalty_factor\n            penalty += max(0, radii[i] - centers[i, 1]) * penalty_factor\n            penalty += max(0, radii[i] - (1 - centers[i, 1])) * penalty_factor\n\n        # Overlap penalty\n        for i in range(n):\n            for j in range(i):\n                distance = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - distance\n                penalty += max(0, overlap) * penalty_factor\n\n        return penalty\n    \n    def combined_objective(x, n):\n        \"\"\"Combines the objective and penalty functions.\"\"\"\n        return -objective_function(x, n) + penalty_function(x, n)\n\n    # Initialization\n    n = 26\n    centers, radii = initial_centers_radii(n)\n    \n    # Optimization Loop\n    for iteration in range(5): # Adjust number of iterations as needed\n        # Optimize Radii based on Voronoi Cells\n        radii = optimize_radii(centers, radii)\n        \n        # Global Optimization with penalty method\n        x0 = np.concatenate([centers.flatten(), radii])\n        bounds = [(0, 1)] * (2 * n) + [(0.001, 0.5)] * n  # Radius bounds (adjust as needed)\n\n        result = minimize(\n            combined_objective,\n            x0,\n            args=(n,),\n            method='L-BFGS-B', # or 'SLSQP'\n            bounds=bounds,\n            options={'maxiter': 500, 'ftol': 1e-5}  # Adjust options as needed\n        )\n\n        x_optimal = result.x\n        centers = x_optimal[:2*n].reshape(n, 2)\n        radii = x_optimal[2*n:]\n\n    # Final Check\n    if not check_constraints(centers, radii):\n        print(\"Warning: Constraints not fully satisfied.\")\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-14T13:26:28.741227",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 378,
        "candidates_token_count": 1604,
        "thoughts_token_count": 0
      },
      "response_text_len": 5624
    }
  }
}