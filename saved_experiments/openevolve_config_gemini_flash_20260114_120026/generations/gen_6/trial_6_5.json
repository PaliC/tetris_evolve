{
  "trial_id": "trial_6_5",
  "generation": 6,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    def is_valid(centers, radii):\n        \"\"\"Check if the packing is valid.\"\"\"\n        n = len(centers)\n        for i in range(n):\n            # Check if circle is inside the unit square\n            if not (0 <= centers[i][0] - radii[i] and centers[i][0] + radii[i] <= 1 and\n                    0 <= centers[i][1] - radii[i] and centers[i][1] + radii[i] <= 1):\n                return False\n            # Check for overlaps with other circles\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j]:\n                    return False\n        return True\n\n    def fitness(chromosome):\n        \"\"\"Fitness function: sum of radii with penalty for invalid packings.\"\"\"\n        centers = chromosome[:52].reshape(26, 2)\n        radii = chromosome[52:]\n        \n        sum_radii = np.sum(radii)\n        \n        if not is_valid(centers, radii):\n            return -1  # Large penalty for invalid packings\n        \n        return sum_radii\n\n    def create_individual():\n        \"\"\"Create a random individual (chromosome).\"\"\"\n        centers = np.random.rand(26, 2)\n        radii = np.random.rand(26) * 0.03  # Initialize with smaller radii\n        return np.concatenate([centers.flatten(), radii])\n\n    def crossover(parent1, parent2):\n        \"\"\"Crossover operation: combines parts of two parent chromosomes.\"\"\"\n        alpha = np.random.rand()\n        child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n\n    def mutate(chromosome, mutation_rate=0.01):\n        \"\"\"Mutation operation: introduces random changes to the chromosome.\"\"\"\n        mutation_mask = np.random.rand(len(chromosome)) < mutation_rate\n        chromosome[mutation_mask] = np.random.rand(np.sum(mutation_mask))\n        return chromosome\n\n    def tournament_selection(population, k=3):\n        \"\"\"Tournament selection: selects the best individual from a random subset.\"\"\"\n        candidates = np.random.choice(len(population), k, replace=False)\n        winner = max(candidates, key=lambda i: fitness(population[i]))\n        return population[winner]\n    \n    def local_search(chromosome, bounds):\n        \"\"\"Apply local search to improve the chromosome.\"\"\"\n        def objective(x):\n            centers = x[:52].reshape(26, 2)\n            radii = x[52:]\n            \n            if not is_valid(centers, radii):\n                return -1e10\n            \n            return -np.sum(radii)  # Minimize negative sum of radii\n\n        result = minimize(objective, chromosome, method='L-BFGS-B', bounds=bounds)\n        return result.x\n\n    # Genetic Algorithm parameters\n    population_size = 50\n    num_generations = 100\n    mutation_rate = 0.01\n    elite_size = 5\n\n    # Initialize population\n    population = [create_individual() for _ in range(population_size)]\n    \n    # Define bounds for local search\n    bounds = [(0, 1) for _ in range(52)] + [(0, 0.5) for _ in range(26)]\n\n    # Run Genetic Algorithm\n    for generation in range(num_generations):\n        # Evaluate fitness of each individual\n        fitness_scores = [fitness(chromosome) for chromosome in population]\n\n        # Select elite individuals\n        elite_indices = np.argsort(fitness_scores)[-elite_size:]\n        elite = [population[i] for i in elite_indices]\n\n        # Create new population\n        new_population = elite.copy()\n        while len(new_population) < population_size:\n            # Selection\n            parent1 = tournament_selection(population)\n            parent2 = tournament_selection(population)\n\n            # Crossover\n            child = crossover(parent1, parent2)\n\n            # Mutation\n            child = mutate(child, mutation_rate)\n\n            new_population.append(child)\n\n        population = new_population\n        \n        # Apply local search to the best individual\n        best_index = np.argmax([fitness(chromosome) for chromosome in population])\n        population[best_index] = local_search(population[best_index], bounds)\n\n        # Print best fitness in each generation\n        best_fitness = fitness(population[best_index])\n        print(f\"Generation {generation + 1}: Best Fitness = {best_fitness}\")\n\n    # Return the best packing\n    best_chromosome = population[np.argmax([fitness(chromosome) for chromosome in population])]\n    centers = best_chromosome[:52].reshape(26, 2)\n    radii = best_chromosome[52:]\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 0.5877761790121816,
    "eval_time": 12.095873832702637,
    "error": null
  },
  "prompt": "Implement a genetic algorithm for circle packing with 26 circles.\n\nCurrent best score: 2.633035228845132\nTarget to beat: 2.6359850561146603\n\nYour genetic algorithm should:\n1. Encode solutions as chromosomes representing circle positions and sizes\n2. Use crossover operations that preserve good circle configurations\n3. Implement mutation operations that adjust circle positions and radii\n4. Define fitness based on the sum of radii with penalties for constraint violations\n5. Use tournament selection to maintain diversity\n6. Implement elitism to preserve the best solutions\n7. Apply local search to the best individuals in each generation\n\nReturn the packing with centers, radii, and the sum of radii.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    def is_valid(centers, radii):\n        \"\"\"Check if the packing is valid.\"\"\"\n        n = len(centers)\n        for i in range(n):\n            # Check if circle is inside the unit square\n            if not (0 <= centers[i][0] - radii[i] and centers[i][0] + radii[i] <= 1 and\n                    0 <= centers[i][1] - radii[i] and centers[i][1] + radii[i] <= 1):\n                return False\n            # Check for overlaps with other circles\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j]:\n                    return False\n        return True\n\n    def fitness(chromosome):\n        \"\"\"Fitness function: sum of radii with penalty for invalid packings.\"\"\"\n        centers = chromosome[:52].reshape(26, 2)\n        radii = chromosome[52:]\n        \n        sum_radii = np.sum(radii)\n        \n        if not is_valid(centers, radii):\n            return -1  # Large penalty for invalid packings\n        \n        return sum_radii\n\n    def create_individual():\n        \"\"\"Create a random individual (chromosome).\"\"\"\n        centers = np.random.rand(26, 2)\n        radii = np.random.rand(26) * 0.03  # Initialize with smaller radii\n        return np.concatenate([centers.flatten(), radii])\n\n    def crossover(parent1, parent2):\n        \"\"\"Crossover operation: combines parts of two parent chromosomes.\"\"\"\n        alpha = np.random.rand()\n        child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n\n    def mutate(chromosome, mutation_rate=0.01):\n        \"\"\"Mutation operation: introduces random changes to the chromosome.\"\"\"\n        mutation_mask = np.random.rand(len(chromosome)) < mutation_rate\n        chromosome[mutation_mask] = np.random.rand(np.sum(mutation_mask))\n        return chromosome\n\n    def tournament_selection(population, k=3):\n        \"\"\"Tournament selection: selects the best individual from a random subset.\"\"\"\n        candidates = np.random.choice(len(population), k, replace=False)\n        winner = max(candidates, key=lambda i: fitness(population[i]))\n        return population[winner]\n    \n    def local_search(chromosome, bounds):\n        \"\"\"Apply local search to improve the chromosome.\"\"\"\n        def objective(x):\n            centers = x[:52].reshape(26, 2)\n            radii = x[52:]\n            \n            if not is_valid(centers, radii):\n                return -1e10\n            \n            return -np.sum(radii)  # Minimize negative sum of radii\n\n        result = minimize(objective, chromosome, method='L-BFGS-B', bounds=bounds)\n        return result.x\n\n    # Genetic Algorithm parameters\n    population_size = 50\n    num_generations = 100\n    mutation_rate = 0.01\n    elite_size = 5\n\n    # Initialize population\n    population = [create_individual() for _ in range(population_size)]\n    \n    # Define bounds for local search\n    bounds = [(0, 1) for _ in range(52)] + [(0, 0.5) for _ in range(26)]\n\n    # Run Genetic Algorithm\n    for generation in range(num_generations):\n        # Evaluate fitness of each individual\n        fitness_scores = [fitness(chromosome) for chromosome in population]\n\n        # Select elite individuals\n        elite_indices = np.argsort(fitness_scores)[-elite_size:]\n        elite = [population[i] for i in elite_indices]\n\n        # Create new population\n        new_population = elite.copy()\n        while len(new_population) < population_size:\n            # Selection\n            parent1 = tournament_selection(population)\n            parent2 = tournament_selection(population)\n\n            # Crossover\n            child = crossover(parent1, parent2)\n\n            # Mutation\n            child = mutate(child, mutation_rate)\n\n            new_population.append(child)\n\n        population = new_population\n        \n        # Apply local search to the best individual\n        best_index = np.argmax([fitness(chromosome) for chromosome in population])\n        population[best_index] = local_search(population[best_index], bounds)\n\n        # Print best fitness in each generation\n        best_fitness = fitness(population[best_index])\n        print(f\"Generation {generation + 1}: Best Fitness = {best_fitness}\")\n\n    # Return the best packing\n    best_chromosome = population[np.argmax([fitness(chromosome) for chromosome in population])]\n    centers = best_chromosome[:52].reshape(26, 2)\n    radii = best_chromosome[52:]\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-14T12:37:58.021504",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 386,
        "candidates_token_count": 1209,
        "thoughts_token_count": 0
      },
      "response_text_len": 4604
    }
  }
}