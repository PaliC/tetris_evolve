{
  "trial_id": "trial_1_7",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    # PSO parameters\n    num_circles = 26\n    num_particles = 50\n    num_dimensions = 3 * num_circles  # x, y, radius for each circle\n    max_iterations = 1000\n    \n    # PSO coefficients\n    w = 0.7  # Inertia weight\n    c1 = 1.5  # Cognitive parameter\n    c2 = 1.5  # Social parameter\n    \n    # Initialize particles with random positions and velocities\n    positions = np.random.rand(num_particles, num_dimensions)\n    velocities = np.random.uniform(-0.1, 0.1, (num_particles, num_dimensions))\n    \n    # Initialize personal best and global best\n    personal_best_positions = positions.copy()\n    personal_best_scores = np.zeros(num_particles)\n    \n    # Calculate initial fitness for each particle\n    for i in range(num_particles):\n        personal_best_scores[i] = fitness_function(positions[i], num_circles)\n    \n    global_best_index = np.argmax(personal_best_scores)\n    global_best_position = personal_best_positions[global_best_index].copy()\n    global_best_score = personal_best_scores[global_best_index]\n    \n    # PSO main loop\n    for iteration in range(max_iterations):\n        for i in range(num_particles):\n            # Update velocities\n            r1, r2 = np.random.rand(2)\n            cognitive_velocity = c1 * r1 * (personal_best_positions[i] - positions[i])\n            social_velocity = c2 * r2 * (global_best_position - positions[i])\n            velocities[i] = w * velocities[i] + cognitive_velocity + social_velocity\n            \n            # Clamp velocities to prevent explosion\n            velocities[i] = np.clip(velocities[i], -0.1, 0.1)\n            \n            # Update positions\n            positions[i] += velocities[i]\n            \n            # Apply constraints (keep circles inside unit square)\n            for j in range(num_circles):\n                x_idx, y_idx, r_idx = j*3, j*3+1, j*3+2\n                # Ensure radius is non-negative\n                positions[i, r_idx] = max(0, positions[i, r_idx])\n                \n                # Ensure circle is inside unit square\n                if positions[i, x_idx] - positions[i, r_idx] < 0:\n                    positions[i, x_idx] = positions[i, r_idx]\n                elif positions[i, x_idx] + positions[i, r_idx] > 1:\n                    positions[i, x_idx] = 1 - positions[i, r_idx]\n                \n                if positions[i, y_idx] - positions[i, r_idx] < 0:\n                    positions[i, y_idx] = positions[i, r_idx]\n                elif positions[i, y_idx] + positions[i, r_idx] > 1:\n                    positions[i, y_idx] = 1 - positions[i, r_idx]\n            \n            # Calculate new fitness\n            score = fitness_function(positions[i], num_circles)\n            \n            # Update personal best\n            if score > personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i].copy()\n                \n                # Update global best\n                if score > global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i].copy()\n        \n        # Optional: Decrease inertia weight over time\n        w = max(0.4, w * 0.99)\n        \n        # Early stopping if no improvement for a while\n        if iteration % 50 == 0:\n            # Apply local search to the global best\n            improved_position = local_search(global_best_position, num_circles)\n            improved_score = fitness_function(improved_position, num_circles)\n            \n            if improved_score > global_best_score:\n                global_best_score = improved_score\n                global_best_position = improved_position.copy()\n    \n    # Final local search refinement\n    global_best_position = local_search(global_best_position, num_circles)\n    \n    # Extract centers and radii from the best solution\n    centers = np.zeros((num_circles, 2))\n    radii = np.zeros(num_circles)\n    \n    for i in range(num_circles):\n        centers[i, 0] = global_best_position[i*3]\n        centers[i, 1] = global_best_position[i*3+1]\n        radii[i] = global_best_position[i*3+2]\n    \n    # Sort by radius (largest first) for better visualization\n    sort_indices = np.argsort(-radii)\n    centers = centers[sort_indices]\n    radii = radii[sort_indices]\n    \n    return centers, radii, np.sum(radii)\n\ndef fitness_function(particle, num_circles):\n    \"\"\"Calculate fitness (sum of radii) with penalty for constraint violations\"\"\"\n    centers = np.zeros((num_circles, 2))\n    radii = np.zeros(num_circles)\n    \n    for i in range(num_circles):\n        centers[i, 0] = particle[i*3]\n        centers[i, 1] = particle[i*3+1]\n        radii[i] = particle[i*3+2]\n    \n    # Check for circle overlaps\n    distances = squareform(pdist(centers))\n    np.fill_diagonal(distances, np.inf)  # Ignore self-distances\n    \n    # Calculate sum of radii\n    sum_radii = np.sum(radii)\n    \n    # Apply penalty for overlapping circles\n    penalty = 0\n    for i in range(num_circles):\n        for j in range(i+1, num_circles):\n            min_distance = radii[i] + radii[j]\n            if distances[i, j] < min_distance:\n                penalty += min_distance - distances[i, j]\n    \n    # Apply penalty for circles outside the unit square\n    boundary_penalty = 0\n    for i in range(num_circles):\n        if centers[i, 0] - radii[i] < 0:\n            boundary_penalty += abs(centers[i, 0] - radii[i])\n        if centers[i, 0] + radii[i] > 1:\n            boundary_penalty += centers[i, 0] + radii[i] - 1\n        if centers[i, 1] - radii[i] < 0:\n            boundary_penalty += abs(centers[i, 1] - radii[i])\n        if centers[i, 1] + radii[i] > 1:\n            boundary_penalty += centers[i, 1] + radii[i] - 1\n    \n    # Return fitness with penalties\n    return sum_radii - 10 * (penalty + boundary_penalty)\n\ndef local_search(particle, num_circles):\n    \"\"\"Apply local search to improve the solution\"\"\"\n    best_particle = particle.copy()\n    best_score = fitness_function(best_particle, num_circles)\n    \n    # Try small adjustments to each circle\n    for i in range(num_circles):\n        x_idx, y_idx, r_idx = i*3, i*3+1, i*3+2\n        \n        # Try adjusting position\n        for dim in [x_idx, y_idx]:\n            for delta in [-0.01, 0.01]:\n                new_particle = best_particle.copy()\n                new_particle[dim] += delta\n                score = fitness_function(new_particle, num_circles)\n                if score > best_score:\n                    best_particle = new_particle\n                    best_score = score\n        \n        # Try adjusting radius\n        for delta in [-0.005, 0.005]:\n            new_particle = best_particle.copy()\n            new_particle[r_idx] += delta\n            score = fitness_function(new_particle, num_circles)\n            if score > best_score:\n                best_particle = new_particle\n                best_score = score\n    \n    return best_particle\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 1.0332113601058355,
    "eval_time": 7.274100065231323,
    "error": null
  },
  "prompt": "Create a circle packing algorithm using Particle Swarm Optimization (PSO).\n\nImplement a PSO algorithm to find optimal positions and radii for 26 circles in a unit square:\n\n1. Define particles as potential configurations of 26 circles\n2. Use a fitness function that maximizes the sum of radii\n3. Handle constraints to ensure circles don't overlap and stay within bounds\n4. Update particle positions and velocities based on:\n   - Each particle's best position\n   - Global best position\n   - Inertia, cognitive, and social parameters\n\nYou can implement PSO from scratch or use a library like pyswarms if available.\n\nThe code format should be:\n```python\nimport numpy as np\n\ndef construct_packing():\n    # PSO implementation\n    # ...\n    return centers, radii, sum(radii)\n\ndef run_packing():\n    return construct_packing()\n```\n\nAim to maximize the sum of radii while satisfying all constraints.\n",
  "response": "I'll implement a Particle Swarm Optimization (PSO) algorithm to find an optimal packing of 26 circles in a unit square. This approach will search the solution space by updating particle positions based on both individual and swarm knowledge.\n\n```python\nimport numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    # PSO parameters\n    num_circles = 26\n    num_particles = 50\n    num_dimensions = 3 * num_circles  # x, y, radius for each circle\n    max_iterations = 1000\n    \n    # PSO coefficients\n    w = 0.7  # Inertia weight\n    c1 = 1.5  # Cognitive parameter\n    c2 = 1.5  # Social parameter\n    \n    # Initialize particles with random positions and velocities\n    positions = np.random.rand(num_particles, num_dimensions)\n    velocities = np.random.uniform(-0.1, 0.1, (num_particles, num_dimensions))\n    \n    # Initialize personal best and global best\n    personal_best_positions = positions.copy()\n    personal_best_scores = np.zeros(num_particles)\n    \n    # Calculate initial fitness for each particle\n    for i in range(num_particles):\n        personal_best_scores[i] = fitness_function(positions[i], num_circles)\n    \n    global_best_index = np.argmax(personal_best_scores)\n    global_best_position = personal_best_positions[global_best_index].copy()\n    global_best_score = personal_best_scores[global_best_index]\n    \n    # PSO main loop\n    for iteration in range(max_iterations):\n        for i in range(num_particles):\n            # Update velocities\n            r1, r2 = np.random.rand(2)\n            cognitive_velocity = c1 * r1 * (personal_best_positions[i] - positions[i])\n            social_velocity = c2 * r2 * (global_best_position - positions[i])\n            velocities[i] = w * velocities[i] + cognitive_velocity + social_velocity\n            \n            # Clamp velocities to prevent explosion\n            velocities[i] = np.clip(velocities[i], -0.1, 0.1)\n            \n            # Update positions\n            positions[i] += velocities[i]\n            \n            # Apply constraints (keep circles inside unit square)\n            for j in range(num_circles):\n                x_idx, y_idx, r_idx = j*3, j*3+1, j*3+2\n                # Ensure radius is non-negative\n                positions[i, r_idx] = max(0, positions[i, r_idx])\n                \n                # Ensure circle is inside unit square\n                if positions[i, x_idx] - positions[i, r_idx] < 0:\n                    positions[i, x_idx] = positions[i, r_idx]\n                elif positions[i, x_idx] + positions[i, r_idx] > 1:\n                    positions[i, x_idx] = 1 - positions[i, r_idx]\n                \n                if positions[i, y_idx] - positions[i, r_idx] < 0:\n                    positions[i, y_idx] = positions[i, r_idx]\n                elif positions[i, y_idx] + positions[i, r_idx] > 1:\n                    positions[i, y_idx] = 1 - positions[i, r_idx]\n            \n            # Calculate new fitness\n            score = fitness_function(positions[i], num_circles)\n            \n            # Update personal best\n            if score > personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i].copy()\n                \n                # Update global best\n                if score > global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i].copy()\n        \n        # Optional: Decrease inertia weight over time\n        w = max(0.4, w * 0.99)\n        \n        # Early stopping if no improvement for a while\n        if iteration % 50 == 0:\n            # Apply local search to the global best\n            improved_position = local_search(global_best_position, num_circles)\n            improved_score = fitness_function(improved_position, num_circles)\n            \n            if improved_score > global_best_score:\n                global_best_score = improved_score\n                global_best_position = improved_position.copy()\n    \n    # Final local search refinement\n    global_best_position = local_search(global_best_position, num_circles)\n    \n    # Extract centers and radii from the best solution\n    centers = np.zeros((num_circles, 2))\n    radii = np.zeros(num_circles)\n    \n    for i in range(num_circles):\n        centers[i, 0] = global_best_position[i*3]\n        centers[i, 1] = global_best_position[i*3+1]\n        radii[i] = global_best_position[i*3+2]\n    \n    # Sort by radius (largest first) for better visualization\n    sort_indices = np.argsort(-radii)\n    centers = centers[sort_indices]\n    radii = radii[sort_indices]\n    \n    return centers, radii, np.sum(radii)\n\ndef fitness_function(particle, num_circles):\n    \"\"\"Calculate fitness (sum of radii) with penalty for constraint violations\"\"\"\n    centers = np.zeros((num_circles, 2))\n    radii = np.zeros(num_circles)\n    \n    for i in range(num_circles):\n        centers[i, 0] = particle[i*3]\n        centers[i, 1] = particle[i*3+1]\n        radii[i] = particle[i*3+2]\n    \n    # Check for circle overlaps\n    distances = squareform(pdist(centers))\n    np.fill_diagonal(distances, np.inf)  # Ignore self-distances\n    \n    # Calculate sum of radii\n    sum_radii = np.sum(radii)\n    \n    # Apply penalty for overlapping circles\n    penalty = 0\n    for i in range(num_circles):\n        for j in range(i+1, num_circles):\n            min_distance = radii[i] + radii[j]\n            if distances[i, j] < min_distance:\n                penalty += min_distance - distances[i, j]\n    \n    # Apply penalty for circles outside the unit square\n    boundary_penalty = 0\n    for i in range(num_circles):\n        if centers[i, 0] - radii[i] < 0:\n            boundary_penalty += abs(centers[i, 0] - radii[i])\n        if centers[i, 0] + radii[i] > 1:\n            boundary_penalty += centers[i, 0] + radii[i] - 1\n        if centers[i, 1] - radii[i] < 0:\n            boundary_penalty += abs(centers[i, 1] - radii[i])\n        if centers[i, 1] + radii[i] > 1:\n            boundary_penalty += centers[i, 1] + radii[i] - 1\n    \n    # Return fitness with penalties\n    return sum_radii - 10 * (penalty + boundary_penalty)\n\ndef local_search(particle, num_circles):\n    \"\"\"Apply local search to improve the solution\"\"\"\n    best_particle = particle.copy()\n    best_score = fitness_function(best_particle, num_circles)\n    \n    # Try small adjustments to each circle\n    for i in range(num_circles):\n        x_idx, y_idx, r_idx = i*3, i*3+1, i*3+2\n        \n        # Try adjusting position\n        for dim in [x_idx, y_idx]:\n            for delta in [-0.01, 0.01]:\n                new_particle = best_particle.copy()\n                new_particle[dim] += delta\n                score = fitness_function(new_particle, num_circles)\n                if score > best_score:\n                    best_particle = new_particle\n                    best_score = score\n        \n        # Try adjusting radius\n        for delta in [-0.005, 0.005]:\n            new_particle = best_particle.copy()\n            new_particle[r_idx] += delta\n            score = fitness_function(new_particle, num_circles)\n            if score > best_score:\n                best_particle = new_particle\n                best_score = score\n    \n    return best_particle\n\ndef run_packing():\n    return construct_packing()\n```\n\nThis implementation:\n\n1. Uses Particle Swarm Optimization with cognitive and social components to search the solution space\n2. Represents each particle as a vector containing x-position, y-position, and radius for each circle\n3. Implements a fitness function that maximizes the sum of radii while penalizing constraint violations\n4. Applies boundary constraints to keep circles within the unit square\n5. Performs local search periodically to refine the best solution\n6. Returns the centers, radii, and sum of radii for the best packing found\n\nThe algorithm balances exploration and exploitation through its parameters and includes local search to fine-tune solutions. The fitness function penalizes overlaps and boundary violations, guiding the optimization toward feasible solutions with large radii.",
  "reasoning": "I'll implement a Particle Swarm Optimization (PSO) algorithm to find an optimal packing of 26 circles in a unit square. This approach will search the solution space by updating particle positions based on both individual and swarm knowledge.\n\nThis implementation:\n\n1. Uses Particle Swarm Optimization with cognitive and social components to search the solution space\n2. Represents each particle as a vector containing x-position, y-position, and radius for each circle\n3. Implements a fitness function that maximizes the sum of radii while penalizing constraint violations\n4. Applies boundary constraints to keep circles within the unit square\n5. Performs local search periodically to refine the best solution\n6. Returns the centers, radii, and sum of radii for the best packing found\n\nThe algorithm balances exploration and exploitation through its parameters and includes local search to fine-tune solutions. The fitness function penalizes overlaps and boundary violations, guiding the optimization toward feasible solutions with large radii.",
  "timestamp": "2026-01-14T12:14:17.556725",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-3.7-sonnet",
    "temperature": 0.7
  }
}