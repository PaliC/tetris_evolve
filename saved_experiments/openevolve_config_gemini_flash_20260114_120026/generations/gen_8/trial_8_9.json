{
  "trial_id": "trial_8_9",
  "generation": 8,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, basinhopping\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    n_circles = 26\n\n    def objective(x):\n        radii = x[:n_circles]\n        centers = x[n_circles:].reshape((n_circles, 2))\n        return -np.sum(radii)\n\n    def constraints_factory(min_radius, box_padding_factor, overlap_factor):\n        def constraints(x):\n            radii = x[:n_circles]\n            centers = x[n_circles:].reshape((n_circles, 2))\n\n            # Circle inside the box\n            box_constraints = np.concatenate([\n                centers[:, 0] - radii * box_padding_factor,  # x_i - r_i >= 0\n                1 - centers[:, 0] - radii * box_padding_factor,  # 1 - x_i - r_i >= 0\n                centers[:, 1] - radii * box_padding_factor,  # y_i - r_i >= 0\n                1 - centers[:, 1] - radii * box_padding_factor,  # 1 - y_i - r_i >= 0\n            ])\n\n            # Non-overlapping circles\n            distances = pdist(centers)\n            distances_matrix = squareform(distances)\n            radii_matrix = np.add.outer(radii, radii)\n            overlap_constraints = distances_matrix[np.triu_indices_from(distances_matrix, k=1)] - radii_matrix[np.triu_indices_from(radii_matrix, k=1)] * overlap_factor\n\n            # Minimum radius constraint\n            min_radius_constraints = radii - min_radius\n\n            return np.concatenate([box_constraints, overlap_constraints, min_radius_constraints])\n        return constraints\n\n    def create_bounds(n_circles):\n        radii_bounds = [(0.001, 0.5) for _ in range(n_circles)]  # Enforce minimum radius for numerical stability and avoid zero radii initially\n        center_x_bounds = [(0, 1) for _ in range(n_circles)]\n        center_y_bounds = [(0, 1) for _ in range(n_circles)]\n        bounds = radii_bounds + center_x_bounds + center_y_bounds\n        return bounds\n\n    def solve(initial_guess, constraints, bounds, niter=10):\n        constraint = {'type': 'ineq', 'fun': constraints}\n\n        minimizer_kwargs = {\"method\": \"SLSQP\", \"constraints\": constraint, \"bounds\": bounds}\n        ret = basinhopping(objective, initial_guess, minimizer_kwargs=minimizer_kwargs, niter=niter, disp=False)  #disp=True for debugging\n        return ret\n\n    # Initialization strategies\n    def initialize_random(n_circles):\n        radii = np.random.rand(n_circles) * 0.1 + 0.01\n        centers = np.random.rand(n_circles, 2) * 0.9 + 0.05\n        return np.concatenate([radii, centers.flatten()])\n\n    def initialize_grid(n_circles):\n        grid_size = int(np.ceil(np.sqrt(n_circles)))\n        radii = np.array([0.05] * n_circles)\n        centers = np.zeros((n_circles, 2))\n        for i in range(n_circles):\n            row = i // grid_size\n            col = i % grid_size\n            centers[i] = [(col + 0.5) / grid_size, (row + 0.5) / grid_size]\n        return np.concatenate([radii, centers.flatten()])\n\n    # Optimization parameters (adaptive)\n    initial_min_radius = 0.001\n    initial_box_padding_factor = 1.0\n    initial_overlap_factor = 1.0\n    n_iterations_stage1 = 10\n    n_iterations_stage2 = 15\n    n_iterations_stage3 = 20\n\n    # Stage 1: Relaxed constraints\n    constraints = constraints_factory(initial_min_radius, initial_box_padding_factor, initial_overlap_factor)\n    bounds = create_bounds(n_circles)\n    initial_guess_random = initialize_random(n_circles)\n    initial_guess_grid = initialize_grid(n_circles)\n    result_random = solve(initial_guess_random, constraints, bounds, niter=n_iterations_stage1)\n    result_grid = solve(initial_guess_grid, constraints, bounds, niter=n_iterations_stage1)\n    if result_random.fun < result_grid.fun:\n        x = result_random.x\n    else:\n        x = result_grid.x\n\n    # Stage 2: Tighten constraints slightly\n    constraints = constraints_factory(initial_min_radius * 0.5, initial_box_padding_factor * 0.9, initial_overlap_factor * 0.9)\n    bounds = create_bounds(n_circles)\n    x = solve(x, constraints, bounds, niter=n_iterations_stage2).x\n\n    # Stage 3: Final tightening\n    constraints = constraints_factory(0.0, 1.0, 1.0) #Min radius is 0 to allow for more optimal solutions\n    radii_bounds = [(0.0, 0.5) for _ in range(n_circles)]  # Enforce minimum radius for numerical stability and avoid zero radii initially\n    center_x_bounds = [(0, 1) for _ in range(n_circles)]\n    center_y_bounds = [(0, 1) for _ in range(n_circles)]\n    bounds = radii_bounds + center_x_bounds + center_y_bounds\n    x = solve(x, constraints, bounds, niter=n_iterations_stage3).x\n\n    # Extract results\n    radii = x[:n_circles]\n    centers = x[n_circles:].reshape((n_circles, 2))\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.6207033438942715,
    "eval_time": 18.086839199066162,
    "error": null
  },
  "prompt": "Implement a circle packing algorithm using constraint satisfaction with progressive relaxation.\n\nCreate a solution that:\n1. Starts with a tight constraint formulation\n2. Gradually relaxes constraints during optimization to escape local optima\n3. Re-tightens constraints to ensure final feasibility\n4. Uses basin-hopping or another global optimization method\n5. Implements multiple initialization strategies\n6. Has adaptive parameters throughout the optimization\n\nThe goal is to pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii while ensuring:\n- All circles must be entirely inside the unit square\n- No two circles may overlap\n- All radii must be non-negative",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    n_circles = 26\n\n    def objective(x):\n        radii = x[:n_circles]\n        centers = x[n_circles:].reshape((n_circles, 2))\n        return -np.sum(radii)\n\n    def constraints_factory(min_radius, box_padding_factor, overlap_factor):\n        def constraints(x):\n            radii = x[:n_circles]\n            centers = x[n_circles:].reshape((n_circles, 2))\n\n            # Circle inside the box\n            box_constraints = np.concatenate([\n                centers[:, 0] - radii * box_padding_factor,  # x_i - r_i >= 0\n                1 - centers[:, 0] - radii * box_padding_factor,  # 1 - x_i - r_i >= 0\n                centers[:, 1] - radii * box_padding_factor,  # y_i - r_i >= 0\n                1 - centers[:, 1] - radii * box_padding_factor,  # 1 - y_i - r_i >= 0\n            ])\n\n            # Non-overlapping circles\n            distances = pdist(centers)\n            distances_matrix = squareform(distances)\n            radii_matrix = np.add.outer(radii, radii)\n            overlap_constraints = distances_matrix[np.triu_indices_from(distances_matrix, k=1)] - radii_matrix[np.triu_indices_from(radii_matrix, k=1)] * overlap_factor\n\n            # Minimum radius constraint\n            min_radius_constraints = radii - min_radius\n\n            return np.concatenate([box_constraints, overlap_constraints, min_radius_constraints])\n        return constraints\n\n    def create_bounds(n_circles):\n        radii_bounds = [(0.001, 0.5) for _ in range(n_circles)]  # Enforce minimum radius for numerical stability and avoid zero radii initially\n        center_x_bounds = [(0, 1) for _ in range(n_circles)]\n        center_y_bounds = [(0, 1) for _ in range(n_circles)]\n        bounds = radii_bounds + center_x_bounds + center_y_bounds\n        return bounds\n\n    def solve(initial_guess, constraints, bounds, niter=10):\n        constraint = {'type': 'ineq', 'fun': constraints}\n\n        minimizer_kwargs = {\"method\": \"SLSQP\", \"constraints\": constraint, \"bounds\": bounds}\n        ret = basinhopping(objective, initial_guess, minimizer_kwargs=minimizer_kwargs, niter=niter, disp=False)  #disp=True for debugging\n        return ret\n\n    # Initialization strategies\n    def initialize_random(n_circles):\n        radii = np.random.rand(n_circles) * 0.1 + 0.01\n        centers = np.random.rand(n_circles, 2) * 0.9 + 0.05\n        return np.concatenate([radii, centers.flatten()])\n\n    def initialize_grid(n_circles):\n        grid_size = int(np.ceil(np.sqrt(n_circles)))\n        radii = np.array([0.05] * n_circles)\n        centers = np.zeros((n_circles, 2))\n        for i in range(n_circles):\n            row = i // grid_size\n            col = i % grid_size\n            centers[i] = [(col + 0.5) / grid_size, (row + 0.5) / grid_size]\n        return np.concatenate([radii, centers.flatten()])\n\n    # Optimization parameters (adaptive)\n    initial_min_radius = 0.001\n    initial_box_padding_factor = 1.0\n    initial_overlap_factor = 1.0\n    n_iterations_stage1 = 10\n    n_iterations_stage2 = 15\n    n_iterations_stage3 = 20\n\n    # Stage 1: Relaxed constraints\n    constraints = constraints_factory(initial_min_radius, initial_box_padding_factor, initial_overlap_factor)\n    bounds = create_bounds(n_circles)\n    initial_guess_random = initialize_random(n_circles)\n    initial_guess_grid = initialize_grid(n_circles)\n    result_random = solve(initial_guess_random, constraints, bounds, niter=n_iterations_stage1)\n    result_grid = solve(initial_guess_grid, constraints, bounds, niter=n_iterations_stage1)\n    if result_random.fun < result_grid.fun:\n        x = result_random.x\n    else:\n        x = result_grid.x\n\n    # Stage 2: Tighten constraints slightly\n    constraints = constraints_factory(initial_min_radius * 0.5, initial_box_padding_factor * 0.9, initial_overlap_factor * 0.9)\n    bounds = create_bounds(n_circles)\n    x = solve(x, constraints, bounds, niter=n_iterations_stage2).x\n\n    # Stage 3: Final tightening\n    constraints = constraints_factory(0.0, 1.0, 1.0) #Min radius is 0 to allow for more optimal solutions\n    radii_bounds = [(0.0, 0.5) for _ in range(n_circles)]  # Enforce minimum radius for numerical stability and avoid zero radii initially\n    center_x_bounds = [(0, 1) for _ in range(n_circles)]\n    center_y_bounds = [(0, 1) for _ in range(n_circles)]\n    bounds = radii_bounds + center_x_bounds + center_y_bounds\n    x = solve(x, constraints, bounds, niter=n_iterations_stage3).x\n\n    # Extract results\n    radii = x[:n_circles]\n    centers = x[n_circles:].reshape((n_circles, 2))\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-14T12:49:12.586818",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 362,
        "candidates_token_count": 1483,
        "thoughts_token_count": 0
      },
      "response_text_len": 4777
    }
  }
}