{
  "trial_id": "trial_8_7",
  "generation": 8,
  "parent_id": null,
  "code": "import numpy as np\nimport random\nimport math\n\ndef construct_packing():\n    n_circles = 26\n    centers = np.random.rand(n_circles, 2)\n    radii = np.random.rand(n_circles) * 0.05  # Initial radii\n    \n    def dist(c1, c2):\n        return np.linalg.norm(c1 - c2)\n\n    def is_valid(centers, radii, i):\n        for j in range(len(centers)):\n            if i != j:\n                if dist(centers[i], centers[j]) < radii[i] + radii[j] - 1e-9:  #Added tolerance to prevent oscillations\n                    return False\n        if not (0 <= centers[i][0] - radii[i] and centers[i][0] + radii[i] <= 1 and\n                0 <= centers[i][1] - radii[i] and centers[i][1] + radii[i] <= 1):\n            return False\n        return True\n\n    def total_energy(centers, radii):\n        energy = 0\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                d = dist(centers[i], centers[j])\n                overlap = radii[i] + radii[j] - d\n                if overlap > 0:\n                    energy += overlap * 1000  # Repulsion energy\n            \n            # Boundary energy\n            energy += max(0, radii[i] - centers[i][0]) * 1000\n            energy += max(0, radii[i] - (1 - centers[i][0])) * 1000\n            energy += max(0, radii[i] - centers[i][1]) * 1000\n            energy += max(0, radii[i] - (1 - centers[i][1])) * 1000\n        return energy\n\n    # Physics Simulation\n    temperature = 1.0\n    cooling_rate = 0.995\n    growth_rate = 1.0001 # Increase radius slowly\n    \n    for iteration in range(10000):\n        if iteration % 1000 == 0:\n            print(f\"Iteration: {iteration}, Temperature: {temperature}, Sum Radii: {np.sum(radii)}\")\n\n        for i in range(n_circles):\n            # Try to increase radius\n            old_radii = radii.copy()\n            radii[i] *= growth_rate\n            if not is_valid(centers, radii, i):\n                radii = old_radii # Revert\n\n            # Move circles based on forces\n            old_centers = centers.copy()\n            force_x = 0\n            force_y = 0\n\n            #Repulsion from other circles\n            for j in range(n_circles):\n                if i != j:\n                    d = dist(centers[i], centers[j])\n                    if d < radii[i] + radii[j]:\n                        overlap = radii[i] + radii[j] - d\n                        direction = (centers[i] - centers[j]) / d\n                        force_x += direction[0] * overlap * 100\n                        force_y += direction[1] * overlap * 100\n            \n            #Attraction to center\n            force_x += (0.5 - centers[i][0]) * 0.1\n            force_y += (0.5 - centers[i][1]) * 0.1\n\n            centers[i][0] += force_x * temperature\n            centers[i][1] += force_y * temperature\n            \n            # Boundary handling: Reflect circles off walls\n            if centers[i][0] < radii[i]:\n              centers[i][0] = radii[i]\n            if centers[i][0] > 1 - radii[i]:\n              centers[i][0] = 1 - radii[i]\n            if centers[i][1] < radii[i]:\n              centers[i][1] = radii[i]\n            if centers[i][1] > 1 - radii[i]:\n              centers[i][1] = 1 - radii[i]\n\n            if not is_valid(centers, radii, i):\n                centers = old_centers\n                \n\n        temperature *= cooling_rate\n\n    sum_radii = np.sum(radii)\n    print(f\"Final Sum Radii: {sum_radii}\")\n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 0.7424113513053308,
    "eval_time": 16.313658237457275,
    "error": null
  },
  "prompt": "Implement an enhanced physics-based circle packing algorithm with careful parameter tuning.\n\nCreate a physics simulation that:\n1. Models circles with repulsive forces to prevent overlap\n2. Uses attractive forces toward empty spaces\n3. Gradually increases circle sizes while maintaining constraints\n4. Implements a cooling schedule to stabilize the configuration\n5. Uses multiple initialization strategies\n6. Has robust boundary handling\n\nThe goal is to pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii while ensuring:\n- All circles must be entirely inside the unit square\n- No two circles may overlap\n- All radii must be non-negative",
  "response": "```python\nimport numpy as np\nimport random\nimport math\n\ndef construct_packing():\n    n_circles = 26\n    centers = np.random.rand(n_circles, 2)\n    radii = np.random.rand(n_circles) * 0.05  # Initial radii\n    \n    def dist(c1, c2):\n        return np.linalg.norm(c1 - c2)\n\n    def is_valid(centers, radii, i):\n        for j in range(len(centers)):\n            if i != j:\n                if dist(centers[i], centers[j]) < radii[i] + radii[j] - 1e-9:  #Added tolerance to prevent oscillations\n                    return False\n        if not (0 <= centers[i][0] - radii[i] and centers[i][0] + radii[i] <= 1 and\n                0 <= centers[i][1] - radii[i] and centers[i][1] + radii[i] <= 1):\n            return False\n        return True\n\n    def total_energy(centers, radii):\n        energy = 0\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                d = dist(centers[i], centers[j])\n                overlap = radii[i] + radii[j] - d\n                if overlap > 0:\n                    energy += overlap * 1000  # Repulsion energy\n            \n            # Boundary energy\n            energy += max(0, radii[i] - centers[i][0]) * 1000\n            energy += max(0, radii[i] - (1 - centers[i][0])) * 1000\n            energy += max(0, radii[i] - centers[i][1]) * 1000\n            energy += max(0, radii[i] - (1 - centers[i][1])) * 1000\n        return energy\n\n    # Physics Simulation\n    temperature = 1.0\n    cooling_rate = 0.995\n    growth_rate = 1.0001 # Increase radius slowly\n    \n    for iteration in range(10000):\n        if iteration % 1000 == 0:\n            print(f\"Iteration: {iteration}, Temperature: {temperature}, Sum Radii: {np.sum(radii)}\")\n\n        for i in range(n_circles):\n            # Try to increase radius\n            old_radii = radii.copy()\n            radii[i] *= growth_rate\n            if not is_valid(centers, radii, i):\n                radii = old_radii # Revert\n\n            # Move circles based on forces\n            old_centers = centers.copy()\n            force_x = 0\n            force_y = 0\n\n            #Repulsion from other circles\n            for j in range(n_circles):\n                if i != j:\n                    d = dist(centers[i], centers[j])\n                    if d < radii[i] + radii[j]:\n                        overlap = radii[i] + radii[j] - d\n                        direction = (centers[i] - centers[j]) / d\n                        force_x += direction[0] * overlap * 100\n                        force_y += direction[1] * overlap * 100\n            \n            #Attraction to center\n            force_x += (0.5 - centers[i][0]) * 0.1\n            force_y += (0.5 - centers[i][1]) * 0.1\n\n            centers[i][0] += force_x * temperature\n            centers[i][1] += force_y * temperature\n            \n            # Boundary handling: Reflect circles off walls\n            if centers[i][0] < radii[i]:\n              centers[i][0] = radii[i]\n            if centers[i][0] > 1 - radii[i]:\n              centers[i][0] = 1 - radii[i]\n            if centers[i][1] < radii[i]:\n              centers[i][1] = radii[i]\n            if centers[i][1] > 1 - radii[i]:\n              centers[i][1] = 1 - radii[i]\n\n            if not is_valid(centers, radii, i):\n                centers = old_centers\n                \n\n        temperature *= cooling_rate\n\n    sum_radii = np.sum(radii)\n    print(f\"Final Sum Radii: {sum_radii}\")\n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-14T12:49:07.733986",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 359,
        "candidates_token_count": 1075,
        "thoughts_token_count": 0
      },
      "response_text_len": 3491
    }
  }
}