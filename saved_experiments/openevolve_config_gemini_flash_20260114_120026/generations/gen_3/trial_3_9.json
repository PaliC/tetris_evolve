{
  "trial_id": "trial_3_9",
  "generation": 3,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n_circles = 26\n\n    def initial_placement(n):\n        # Heuristic for placing circles\n        rows = int(np.floor(np.sqrt(n)))\n        cols = int(np.ceil(n / rows))\n        centers = []\n        for i in range(rows):\n            for j in range(cols):\n                if len(centers) < n:\n                    x = (j + 0.5) / cols\n                    y = (i + 0.5) / rows\n                    centers.append([x, y])\n        return np.array(centers)\n\n    centers = initial_placement(n_circles)\n    initial_radius = 0.04  # Adjusted initial radius\n    radii = np.full(n_circles, initial_radius)\n\n    def calculate_distances(centers):\n        distances = np.zeros((n_circles, n_circles))\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                distances[i, j] = np.linalg.norm(centers[i] - centers[j])\n                distances[j, i] = distances[i, j]\n        return distances\n\n    def objective_function(x):\n        radii = x[:n_circles]\n        centers_flat = x[n_circles:]\n        centers = centers_flat.reshape((n_circles, 2))\n        return -np.sum(radii)\n\n    def constraint_overlap(x):\n        radii = x[:n_circles]\n        centers_flat = x[n_circles:]\n        centers = centers_flat.reshape((n_circles, 2))\n        distances = calculate_distances(centers)\n        return distances - np.add.outer(radii, radii)\n\n    def constraint_within_bounds(x):\n        radii = x[:n_circles]\n        centers_flat = x[n_circles:]\n        centers = centers_flat.reshape((n_circles, 2))\n        min_x = centers[:, 0] - radii\n        max_x = centers[:, 0] + radii\n        min_y = centers[:, 1] - radii\n        max_y = centers[:, 1] + radii\n        return np.concatenate([min_x, 1 - max_x, min_y, 1 - max_y])\n\n    # Phase 1: Optimize positions with fixed radii\n    def objective_function_phase1(x):\n        centers = x.reshape((n_circles, 2))\n        return -np.sum(radii)  # Dummy objective, just for positioning\n\n    def constraint_overlap_phase1(x):\n        centers = x.reshape((n_circles, 2))\n        distances = calculate_distances(centers)\n        return distances - np.add.outer(radii, radii)\n\n    def constraint_within_bounds_phase1(x):\n        centers = x.reshape((n_circles, 2))\n        min_x = centers[:, 0] - radii\n        max_x = centers[:, 0] + radii\n        min_y = centers[:, 1] - radii\n        max_y = centers[:, 1] + radii\n        return np.concatenate([min_x, 1 - max_x, min_y, 1 - max_y])\n\n    constraints_phase1 = ({'type': 'ineq', 'fun': constraint_overlap_phase1[np.triu_indices(n_circles, 1)].ravel()},  # Flatten upper triangle\n                           {'type': 'ineq', 'fun': constraint_within_bounds_phase1})\n\n    initial_centers_flat = centers.flatten()\n    result_phase1 = minimize(objective_function_phase1, initial_centers_flat,\n                              constraints=constraints_phase1, method='SLSQP',\n                              options={'maxiter': 100})\n\n    centers = result_phase1.x.reshape((n_circles, 2))\n\n    # Phase 2: Introduce radius variations while maintaining positions\n    def objective_function_phase2(x):\n        radii = x\n        return -np.sum(radii)\n\n    def constraint_overlap_phase2(x):\n        radii = x\n        distances = calculate_distances(centers)\n        return distances - np.add.outer(radii, radii)\n\n    def constraint_within_bounds_phase2(x):\n        radii = x\n        min_x = centers[:, 0] - radii\n        max_x = centers[:, 0] + radii\n        min_y = centers[:, 1] - radii\n        max_y = centers[:, 1] + radii\n        return np.concatenate([min_x, 1 - max_x, min_y, 1 - max_y])\n\n    constraints_phase2 = ({'type': 'ineq', 'fun': constraint_overlap_phase2[np.triu_indices(n_circles, 1)].ravel()},\n                           {'type': 'ineq', 'fun': constraint_within_bounds_phase2})\n\n    bounds_radii = [(0.001, 0.2) for _ in range(n_circles)]  # Radius bounds\n\n    result_phase2 = minimize(objective_function_phase2, radii,\n                              constraints=constraints_phase2, method='SLSQP',\n                              bounds=bounds_radii, options={'maxiter': 100})\n    radii = result_phase2.x\n\n    # Phase 3: Jointly optimize positions and radii\n    constraints = ({'type': 'ineq', 'fun': constraint_overlap[np.triu_indices(n_circles, 1)].ravel()},\n                   {'type': 'ineq', 'fun': constraint_within_bounds})\n\n    initial_x = np.concatenate([radii, centers.flatten()])\n\n    result = minimize(objective_function, initial_x, constraints=constraints,\n                      method='SLSQP', bounds=bounds_radii + [(0, 1) for _ in range(2 * n_circles)],\n                      options={'maxiter': 150})\n\n    radii = result.x[:n_circles]\n    centers = result.x[n_circles:].reshape((n_circles, 2))\n\n    # Phase 4: Fine-tuning\n    constraints = ({'type': 'ineq', 'fun': constraint_overlap[np.triu_indices(n_circles, 1)].ravel()},\n                   {'type': 'ineq', 'fun': constraint_within_bounds})\n\n    initial_x = np.concatenate([radii, centers.flatten()])\n\n    result = minimize(objective_function, initial_x, constraints=constraints,\n                      method='SLSQP', bounds=bounds_radii + [(0, 1) for _ in range(2 * n_circles)],\n                      options={'maxiter': 1000, 'ftol': 1e-7})  # Increased iterations and tighter tolerance\n\n    radii = result.x[:n_circles]\n    centers = result.x[n_circles:].reshape((n_circles, 2))\n    \n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 0.22911787033081055,
    "error": "TypeError: 'function' object is not subscriptable"
  },
  "prompt": "Implement an adaptive radius optimization technique for circle packing:\n\n1. Begin with equal-sized circles placed in a structured pattern\n2. Implement a multi-phase optimization:\n   - Phase 1: Optimize positions with fixed equal radii\n   - Phase 2: Gradually introduce radius variations while maintaining positions\n   - Phase 3: Jointly optimize positions and radii with emphasis on maximizing sum\n   - Phase 4: Apply fine-tuning with tight constraint handling\n   \n3. Use adaptive parameters that adjust based on:\n   - Current packing density\n   - Available space in different regions\n   - Convergence rate of the optimization\n   \n4. Implement robust constraint handling throughout all phases\n\nThe goal is to pack 26 circles into a unit square [0,1]x[0,1] to maximize the sum of their radii, ensuring no overlaps and all circles remain within the square.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n_circles = 26\n\n    def initial_placement(n):\n        # Heuristic for placing circles\n        rows = int(np.floor(np.sqrt(n)))\n        cols = int(np.ceil(n / rows))\n        centers = []\n        for i in range(rows):\n            for j in range(cols):\n                if len(centers) < n:\n                    x = (j + 0.5) / cols\n                    y = (i + 0.5) / rows\n                    centers.append([x, y])\n        return np.array(centers)\n\n    centers = initial_placement(n_circles)\n    initial_radius = 0.04  # Adjusted initial radius\n    radii = np.full(n_circles, initial_radius)\n\n    def calculate_distances(centers):\n        distances = np.zeros((n_circles, n_circles))\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                distances[i, j] = np.linalg.norm(centers[i] - centers[j])\n                distances[j, i] = distances[i, j]\n        return distances\n\n    def objective_function(x):\n        radii = x[:n_circles]\n        centers_flat = x[n_circles:]\n        centers = centers_flat.reshape((n_circles, 2))\n        return -np.sum(radii)\n\n    def constraint_overlap(x):\n        radii = x[:n_circles]\n        centers_flat = x[n_circles:]\n        centers = centers_flat.reshape((n_circles, 2))\n        distances = calculate_distances(centers)\n        return distances - np.add.outer(radii, radii)\n\n    def constraint_within_bounds(x):\n        radii = x[:n_circles]\n        centers_flat = x[n_circles:]\n        centers = centers_flat.reshape((n_circles, 2))\n        min_x = centers[:, 0] - radii\n        max_x = centers[:, 0] + radii\n        min_y = centers[:, 1] - radii\n        max_y = centers[:, 1] + radii\n        return np.concatenate([min_x, 1 - max_x, min_y, 1 - max_y])\n\n    # Phase 1: Optimize positions with fixed radii\n    def objective_function_phase1(x):\n        centers = x.reshape((n_circles, 2))\n        return -np.sum(radii)  # Dummy objective, just for positioning\n\n    def constraint_overlap_phase1(x):\n        centers = x.reshape((n_circles, 2))\n        distances = calculate_distances(centers)\n        return distances - np.add.outer(radii, radii)\n\n    def constraint_within_bounds_phase1(x):\n        centers = x.reshape((n_circles, 2))\n        min_x = centers[:, 0] - radii\n        max_x = centers[:, 0] + radii\n        min_y = centers[:, 1] - radii\n        max_y = centers[:, 1] + radii\n        return np.concatenate([min_x, 1 - max_x, min_y, 1 - max_y])\n\n    constraints_phase1 = ({'type': 'ineq', 'fun': constraint_overlap_phase1[np.triu_indices(n_circles, 1)].ravel()},  # Flatten upper triangle\n                           {'type': 'ineq', 'fun': constraint_within_bounds_phase1})\n\n    initial_centers_flat = centers.flatten()\n    result_phase1 = minimize(objective_function_phase1, initial_centers_flat,\n                              constraints=constraints_phase1, method='SLSQP',\n                              options={'maxiter': 100})\n\n    centers = result_phase1.x.reshape((n_circles, 2))\n\n    # Phase 2: Introduce radius variations while maintaining positions\n    def objective_function_phase2(x):\n        radii = x\n        return -np.sum(radii)\n\n    def constraint_overlap_phase2(x):\n        radii = x\n        distances = calculate_distances(centers)\n        return distances - np.add.outer(radii, radii)\n\n    def constraint_within_bounds_phase2(x):\n        radii = x\n        min_x = centers[:, 0] - radii\n        max_x = centers[:, 0] + radii\n        min_y = centers[:, 1] - radii\n        max_y = centers[:, 1] + radii\n        return np.concatenate([min_x, 1 - max_x, min_y, 1 - max_y])\n\n    constraints_phase2 = ({'type': 'ineq', 'fun': constraint_overlap_phase2[np.triu_indices(n_circles, 1)].ravel()},\n                           {'type': 'ineq', 'fun': constraint_within_bounds_phase2})\n\n    bounds_radii = [(0.001, 0.2) for _ in range(n_circles)]  # Radius bounds\n\n    result_phase2 = minimize(objective_function_phase2, radii,\n                              constraints=constraints_phase2, method='SLSQP',\n                              bounds=bounds_radii, options={'maxiter': 100})\n    radii = result_phase2.x\n\n    # Phase 3: Jointly optimize positions and radii\n    constraints = ({'type': 'ineq', 'fun': constraint_overlap[np.triu_indices(n_circles, 1)].ravel()},\n                   {'type': 'ineq', 'fun': constraint_within_bounds})\n\n    initial_x = np.concatenate([radii, centers.flatten()])\n\n    result = minimize(objective_function, initial_x, constraints=constraints,\n                      method='SLSQP', bounds=bounds_radii + [(0, 1) for _ in range(2 * n_circles)],\n                      options={'maxiter': 150})\n\n    radii = result.x[:n_circles]\n    centers = result.x[n_circles:].reshape((n_circles, 2))\n\n    # Phase 4: Fine-tuning\n    constraints = ({'type': 'ineq', 'fun': constraint_overlap[np.triu_indices(n_circles, 1)].ravel()},\n                   {'type': 'ineq', 'fun': constraint_within_bounds})\n\n    initial_x = np.concatenate([radii, centers.flatten()])\n\n    result = minimize(objective_function, initial_x, constraints=constraints,\n                      method='SLSQP', bounds=bounds_radii + [(0, 1) for _ in range(2 * n_circles)],\n                      options={'maxiter': 1000, 'ftol': 1e-7})  # Increased iterations and tighter tolerance\n\n    radii = result.x[:n_circles]\n    centers = result.x[n_circles:].reshape((n_circles, 2))\n    \n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-14T12:23:11.519974",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 405,
        "candidates_token_count": 1691,
        "thoughts_token_count": 0
      },
      "response_text_len": 5573
    }
  }
}