{
  "trial_id": "trial_2_3",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\ndef construct_packing():\n    n_circles = 26\n    n_params = 2 * n_circles + n_circles  # x, y coordinates + radii\n\n    def objective(params):\n        centers = params[:2 * n_circles].reshape(n_circles, 2)\n        radii = params[2 * n_circles:]\n        sum_radii = np.sum(radii)\n        return -sum_radii  # Maximize sum_radii\n\n    def constraint(params):\n        centers = params[:2 * n_circles].reshape(n_circles, 2)\n        radii = params[2 * n_circles:]\n        \n        # 1. Circle centers within bounds [radius, 1-radius] for x and y\n        inside_bounds = np.all((centers >= radii[:, None]) & (centers <= (1 - radii[:, None])))\n        if not inside_bounds:\n            return -1e10 # High penalty\n\n        # 2. No overlapping circles\n        overlap_penalty = 0\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                distance = np.linalg.norm(centers[i] - centers[j])\n                min_distance = radii[i] + radii[j]\n                if distance < min_distance:\n                    overlap_penalty += (min_distance - distance) * 100  # Penalty increases with overlap\n        \n        return -overlap_penalty\n\n    def bounds_function(iteration):\n        # Adaptive mutation and crossover parameters\n        mutation_factor = 0.5 + 0.2 * np.sin(iteration / 50) # Example adaptation\n        crossover_rate = 0.7 + 0.2 * np.cos(iteration / 50)\n\n        return mutation_factor, crossover_rate\n    \n    def callback(xk, convergence):\n        global best_sum_radii\n        current_radii = xk[2*n_circles:]\n        sum_radii = np.sum(current_radii)\n        if sum_radii > best_sum_radii:\n            best_sum_radii = sum_radii\n            print(f\"Iteration: {result.nit}, Best Sum Radii: {best_sum_radii}\")\n\n    # Bounds: x, y in [0, 1], radii in [0, 0.5]  (max radius to fit in square)\n    bounds = [(0, 1)] * (2 * n_circles) + [(0.01, 0.4)] * n_circles\n\n    # Custom initialization\n    def init_population(rng, npop):\n        initial_population = np.zeros((npop, n_params))\n        for i in range(npop):\n            # Initialize centers somewhat uniformly\n            centers = rng.random((n_circles, 2)) * 0.8 + 0.1  # Spread within [0.1, 0.9]\n            \n            # Initialize radii with some variation but avoid zero\n            radii = rng.random(n_circles) * 0.2 + 0.02  # Radii mostly between 0.02 and 0.22\n\n            initial_population[i, :2 * n_circles] = centers.flatten()\n            initial_population[i, 2 * n_circles:] = radii\n        return initial_population\n    \n    global best_sum_radii\n    best_sum_radii = 0\n\n    result = differential_evolution(\n        objective,\n        bounds,\n        constraints=constraint,\n        popsize=15,\n        mutation=(0.5, 1),\n        recombination=0.7,\n        strategy='best1bin',\n        tol=0.0001,\n        maxiter=1000,\n        callback=callback,\n        init=init_population,\n        seed=42,\n        workers=-1\n    )\n\n    centers = result.x[:2 * n_circles].reshape(n_circles, 2)\n    radii = result.x[2 * n_circles:]\n    sum_radii = -result.fun\n\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 0.2745988368988037,
    "error": "TypeError: float() argument must be a string or a real number, not 'function'"
  },
  "prompt": "Create a circle packing solution using differential evolution with adaptive parameters.\n\nCurrent best score: 2.6121943848600018\n\nCreate a solution that:\n1. Uses scipy.optimize.differential_evolution\n2. Implements adaptive mutation and crossover parameters\n3. Handles constraints effectively through penalty functions\n4. Uses a custom initialization strategy (not purely random)\n5. Optimizes both positions and radii in a single pass\n\nThe objective is to pack 26 circles in a unit square to maximize the sum of radii.\nReturn centers, radii, and sum_radii in the required format.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import differential_evolution\n\ndef construct_packing():\n    n_circles = 26\n    n_params = 2 * n_circles + n_circles  # x, y coordinates + radii\n\n    def objective(params):\n        centers = params[:2 * n_circles].reshape(n_circles, 2)\n        radii = params[2 * n_circles:]\n        sum_radii = np.sum(radii)\n        return -sum_radii  # Maximize sum_radii\n\n    def constraint(params):\n        centers = params[:2 * n_circles].reshape(n_circles, 2)\n        radii = params[2 * n_circles:]\n        \n        # 1. Circle centers within bounds [radius, 1-radius] for x and y\n        inside_bounds = np.all((centers >= radii[:, None]) & (centers <= (1 - radii[:, None])))\n        if not inside_bounds:\n            return -1e10 # High penalty\n\n        # 2. No overlapping circles\n        overlap_penalty = 0\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                distance = np.linalg.norm(centers[i] - centers[j])\n                min_distance = radii[i] + radii[j]\n                if distance < min_distance:\n                    overlap_penalty += (min_distance - distance) * 100  # Penalty increases with overlap\n        \n        return -overlap_penalty\n\n    def bounds_function(iteration):\n        # Adaptive mutation and crossover parameters\n        mutation_factor = 0.5 + 0.2 * np.sin(iteration / 50) # Example adaptation\n        crossover_rate = 0.7 + 0.2 * np.cos(iteration / 50)\n\n        return mutation_factor, crossover_rate\n    \n    def callback(xk, convergence):\n        global best_sum_radii\n        current_radii = xk[2*n_circles:]\n        sum_radii = np.sum(current_radii)\n        if sum_radii > best_sum_radii:\n            best_sum_radii = sum_radii\n            print(f\"Iteration: {result.nit}, Best Sum Radii: {best_sum_radii}\")\n\n    # Bounds: x, y in [0, 1], radii in [0, 0.5]  (max radius to fit in square)\n    bounds = [(0, 1)] * (2 * n_circles) + [(0.01, 0.4)] * n_circles\n\n    # Custom initialization\n    def init_population(rng, npop):\n        initial_population = np.zeros((npop, n_params))\n        for i in range(npop):\n            # Initialize centers somewhat uniformly\n            centers = rng.random((n_circles, 2)) * 0.8 + 0.1  # Spread within [0.1, 0.9]\n            \n            # Initialize radii with some variation but avoid zero\n            radii = rng.random(n_circles) * 0.2 + 0.02  # Radii mostly between 0.02 and 0.22\n\n            initial_population[i, :2 * n_circles] = centers.flatten()\n            initial_population[i, 2 * n_circles:] = radii\n        return initial_population\n    \n    global best_sum_radii\n    best_sum_radii = 0\n\n    result = differential_evolution(\n        objective,\n        bounds,\n        constraints=constraint,\n        popsize=15,\n        mutation=(0.5, 1),\n        recombination=0.7,\n        strategy='best1bin',\n        tol=0.0001,\n        maxiter=1000,\n        callback=callback,\n        init=init_population,\n        seed=42,\n        workers=-1\n    )\n\n    centers = result.x[:2 * n_circles].reshape(n_circles, 2)\n    radii = result.x[2 * n_circles:]\n    sum_radii = -result.fun\n\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-14T12:18:08.919896",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 355,
        "candidates_token_count": 1006,
        "thoughts_token_count": 0
      },
      "response_text_len": 3226
    }
  }
}