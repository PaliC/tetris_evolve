{
  "trial_id": "trial_0_1",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.spatial import distance_matrix\n\ndef construct_packing():\n    \"\"\"\n    Pack 26 circles into a unit square to maximize the sum of radii.\n    Returns:\n        centers: np.array shape (26, 2) - coordinates of circle centers\n        radii: np.array shape (26,) - radii of circles\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n_circles = 26\n    \n    # Initialize with a greedy approach\n    centers, radii = initialize_packing(n_circles)\n    \n    # Apply simulated annealing to optimize\n    centers, radii = simulated_annealing(centers, radii)\n    \n    # Final optimization with gradient-based approach\n    centers, radii = local_optimization(centers, radii)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef initialize_packing(n_circles):\n    \"\"\"Initialize circle packing with a grid-based approach\"\"\"\n    # Start with a grid layout\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    centers = []\n    \n    for i in range(grid_size):\n        for j in range(grid_size):\n            if len(centers) < n_circles:\n                centers.append([\n                    (i + 0.5) / grid_size + np.random.uniform(-0.01, 0.01),\n                    (j + 0.5) / grid_size + np.random.uniform(-0.01, 0.01)\n                ])\n    \n    centers = np.array(centers)\n    \n    # Initialize radii based on distance to nearest neighbor\n    radii = calculate_max_radii(centers)\n    \n    return centers, radii\n\ndef calculate_max_radii(centers):\n    \"\"\"Calculate maximum possible radii for given centers\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    # Distance to boundaries\n    boundary_dist = np.minimum.reduce([\n        centers[:, 0],                # Distance to left\n        centers[:, 1],                # Distance to bottom\n        1.0 - centers[:, 0],          # Distance to right\n        1.0 - centers[:, 1]           # Distance to top\n    ])\n    \n    # Distance to other circles\n    dist_matrix = distance_matrix(centers, centers)\n    np.fill_diagonal(dist_matrix, np.inf)  # Ignore self-distance\n    min_neighbor_dist = np.min(dist_matrix, axis=1) / 2.0\n    \n    # Maximum radius is minimum of boundary distance and half the distance to nearest neighbor\n    radii = np.minimum(boundary_dist, min_neighbor_dist)\n    \n    return radii\n\ndef simulated_annealing(centers, radii):\n    \"\"\"Optimize circle packing using simulated annealing\"\"\"\n    n_circles = len(centers)\n    \n    # Parameters\n    temp_init = 0.1\n    temp_final = 0.00001\n    alpha = 0.99  # Cooling rate\n    iterations_per_temp = 100\n    \n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    current_centers = centers.copy()\n    current_radii = radii.copy()\n    current_sum = best_sum\n    \n    temp = temp_init\n    \n    while temp > temp_final:\n        for _ in range(iterations_per_temp):\n            # Create a candidate solution by perturbing a random circle\n            candidate_centers = current_centers.copy()\n            \n            # Choose a random circle to move\n            idx = np.random.randint(0, n_circles)\n            \n            # Perturb its position - more at high temperatures, less at low temperatures\n            scale = 0.1 * temp / temp_init\n            candidate_centers[idx, 0] += np.random.uniform(-scale, scale)\n            candidate_centers[idx, 1] += np.random.uniform(-scale, scale)\n            \n            # Keep within bounds\n            candidate_centers[idx, 0] = np.clip(candidate_centers[idx, 0], 0, 1)\n            candidate_centers[idx, 1] = np.clip(candidate_centers[idx, 1], 0, 1)\n            \n            # Calculate new radii and sum\n            candidate_radii = calculate_max_radii(candidate_centers)\n            candidate_sum = np.sum(candidate_radii)\n            \n            # Accept or reject the candidate solution\n            delta = candidate_sum - current_sum\n            if delta > 0 or np.random.random() < np.exp(delta / temp):\n                current_centers = candidate_centers\n                current_radii = candidate_radii\n                current_sum = candidate_sum\n                \n                # Update best solution if improved\n                if current_sum > best_sum:\n                    best_centers = current_centers.copy()\n                    best_radii = current_radii.copy()\n                    best_sum = current_sum\n        \n        # Cool down\n        temp *= alpha\n    \n    return best_centers, best_radii\n\ndef local_optimization(centers, radii):\n    \"\"\"Fine-tune the solution with local optimization\"\"\"\n    n_circles = len(centers)\n    learning_rate = 0.001\n    iterations = 1000\n    \n    current_centers = centers.copy()\n    best_sum = np.sum(radii)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    \n    for _ in range(iterations):\n        # Try to improve each circle's position\n        for i in range(n_circles):\n            # Try 4 directions (up, down, left, right)\n            for direction in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                candidate_centers = current_centers.copy()\n                candidate_centers[i, 0] += direction[0] * learning_rate\n                candidate_centers[i, 1] += direction[1] * learning_rate\n                \n                # Keep within bounds\n                if (candidate_centers[i, 0] < 0 or candidate_centers[i, 0] > 1 or\n                    candidate_centers[i, 1] < 0 or candidate_centers[i, 1] > 1):\n                    continue\n                \n                candidate_radii = calculate_max_radii(candidate_centers)\n                candidate_sum = np.sum(candidate_radii)\n                \n                if candidate_sum > best_sum:\n                    best_sum = candidate_sum\n                    best_centers = candidate_centers.copy()\n                    best_radii = candidate_radii.copy()\n                    current_centers = candidate_centers.copy()\n        \n        # Reduce learning rate over time\n        learning_rate *= 0.995\n    \n    return best_centers, best_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.425798774499636,
    "eval_time": 5.094144105911255,
    "error": null
  },
  "prompt": "\nCreate an algorithm for packing 26 circles in a unit square [0,1]\u00d7[0,1] to maximize the sum of their radii.\nUse simulated annealing or another global optimization technique to find an optimal configuration.\nYour solution should handle the constraints:\n- All circles must be entirely inside the unit square\n- No two circles may overlap\n- All radii must be non-negative\nReturn (centers, radii, sum_radii) as specified in the function signature.\n",
  "response": "I'll create an algorithm using simulated annealing to optimize the packing of 26 circles in a unit square. This approach will allow us to explore the solution space efficiently while avoiding local optima.\n\n```python\nimport numpy as np\nfrom scipy.spatial import distance_matrix\n\ndef construct_packing():\n    \"\"\"\n    Pack 26 circles into a unit square to maximize the sum of radii.\n    Returns:\n        centers: np.array shape (26, 2) - coordinates of circle centers\n        radii: np.array shape (26,) - radii of circles\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n_circles = 26\n    \n    # Initialize with a greedy approach\n    centers, radii = initialize_packing(n_circles)\n    \n    # Apply simulated annealing to optimize\n    centers, radii = simulated_annealing(centers, radii)\n    \n    # Final optimization with gradient-based approach\n    centers, radii = local_optimization(centers, radii)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef initialize_packing(n_circles):\n    \"\"\"Initialize circle packing with a grid-based approach\"\"\"\n    # Start with a grid layout\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    centers = []\n    \n    for i in range(grid_size):\n        for j in range(grid_size):\n            if len(centers) < n_circles:\n                centers.append([\n                    (i + 0.5) / grid_size + np.random.uniform(-0.01, 0.01),\n                    (j + 0.5) / grid_size + np.random.uniform(-0.01, 0.01)\n                ])\n    \n    centers = np.array(centers)\n    \n    # Initialize radii based on distance to nearest neighbor\n    radii = calculate_max_radii(centers)\n    \n    return centers, radii\n\ndef calculate_max_radii(centers):\n    \"\"\"Calculate maximum possible radii for given centers\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    # Distance to boundaries\n    boundary_dist = np.minimum.reduce([\n        centers[:, 0],                # Distance to left\n        centers[:, 1],                # Distance to bottom\n        1.0 - centers[:, 0],          # Distance to right\n        1.0 - centers[:, 1]           # Distance to top\n    ])\n    \n    # Distance to other circles\n    dist_matrix = distance_matrix(centers, centers)\n    np.fill_diagonal(dist_matrix, np.inf)  # Ignore self-distance\n    min_neighbor_dist = np.min(dist_matrix, axis=1) / 2.0\n    \n    # Maximum radius is minimum of boundary distance and half the distance to nearest neighbor\n    radii = np.minimum(boundary_dist, min_neighbor_dist)\n    \n    return radii\n\ndef simulated_annealing(centers, radii):\n    \"\"\"Optimize circle packing using simulated annealing\"\"\"\n    n_circles = len(centers)\n    \n    # Parameters\n    temp_init = 0.1\n    temp_final = 0.00001\n    alpha = 0.99  # Cooling rate\n    iterations_per_temp = 100\n    \n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    current_centers = centers.copy()\n    current_radii = radii.copy()\n    current_sum = best_sum\n    \n    temp = temp_init\n    \n    while temp > temp_final:\n        for _ in range(iterations_per_temp):\n            # Create a candidate solution by perturbing a random circle\n            candidate_centers = current_centers.copy()\n            \n            # Choose a random circle to move\n            idx = np.random.randint(0, n_circles)\n            \n            # Perturb its position - more at high temperatures, less at low temperatures\n            scale = 0.1 * temp / temp_init\n            candidate_centers[idx, 0] += np.random.uniform(-scale, scale)\n            candidate_centers[idx, 1] += np.random.uniform(-scale, scale)\n            \n            # Keep within bounds\n            candidate_centers[idx, 0] = np.clip(candidate_centers[idx, 0], 0, 1)\n            candidate_centers[idx, 1] = np.clip(candidate_centers[idx, 1], 0, 1)\n            \n            # Calculate new radii and sum\n            candidate_radii = calculate_max_radii(candidate_centers)\n            candidate_sum = np.sum(candidate_radii)\n            \n            # Accept or reject the candidate solution\n            delta = candidate_sum - current_sum\n            if delta > 0 or np.random.random() < np.exp(delta / temp):\n                current_centers = candidate_centers\n                current_radii = candidate_radii\n                current_sum = candidate_sum\n                \n                # Update best solution if improved\n                if current_sum > best_sum:\n                    best_centers = current_centers.copy()\n                    best_radii = current_radii.copy()\n                    best_sum = current_sum\n        \n        # Cool down\n        temp *= alpha\n    \n    return best_centers, best_radii\n\ndef local_optimization(centers, radii):\n    \"\"\"Fine-tune the solution with local optimization\"\"\"\n    n_circles = len(centers)\n    learning_rate = 0.001\n    iterations = 1000\n    \n    current_centers = centers.copy()\n    best_sum = np.sum(radii)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    \n    for _ in range(iterations):\n        # Try to improve each circle's position\n        for i in range(n_circles):\n            # Try 4 directions (up, down, left, right)\n            for direction in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                candidate_centers = current_centers.copy()\n                candidate_centers[i, 0] += direction[0] * learning_rate\n                candidate_centers[i, 1] += direction[1] * learning_rate\n                \n                # Keep within bounds\n                if (candidate_centers[i, 0] < 0 or candidate_centers[i, 0] > 1 or\n                    candidate_centers[i, 1] < 0 or candidate_centers[i, 1] > 1):\n                    continue\n                \n                candidate_radii = calculate_max_radii(candidate_centers)\n                candidate_sum = np.sum(candidate_radii)\n                \n                if candidate_sum > best_sum:\n                    best_sum = candidate_sum\n                    best_centers = candidate_centers.copy()\n                    best_radii = candidate_radii.copy()\n                    current_centers = candidate_centers.copy()\n        \n        # Reduce learning rate over time\n        learning_rate *= 0.995\n    \n    return best_centers, best_radii\n\ndef run_packing():\n    return construct_packing()\n```\n\nThis solution implements:\n\n1. **Initialization**: Starting with a grid-based layout with small perturbations to avoid symmetry issues.\n\n2. **Simulated Annealing**: The core optimization technique that allows exploring the solution space by:\n   - Perturbing circle positions with temperature-dependent magnitudes\n   - Accepting improvements and occasionally accepting worse solutions based on temperature\n   - Gradually reducing temperature to converge on a good solution\n\n3. **Local Optimization**: Fine-tuning the solution with small adjustments to improve the total sum of radii.\n\n4. **Radius Calculation**: Computing the maximum possible radii for each configuration while respecting the constraints.\n\nThe approach balances exploration of the solution space with exploitation of promising regions, which is crucial for this type of packing problem where many local optima exist.",
  "reasoning": "I'll create an algorithm using simulated annealing to optimize the packing of 26 circles in a unit square. This approach will allow us to explore the solution space efficiently while avoiding local optima.\n\nThis solution implements:\n\n1. **Initialization**: Starting with a grid-based layout with small perturbations to avoid symmetry issues.\n\n2. **Simulated Annealing**: The core optimization technique that allows exploring the solution space by:\n   - Perturbing circle positions with temperature-dependent magnitudes\n   - Accepting improvements and occasionally accepting worse solutions based on temperature\n   - Gradually reducing temperature to converge on a good solution\n\n3. **Local Optimization**: Fine-tuning the solution with small adjustments to improve the total sum of radii.\n\n4. **Radius Calculation**: Computing the maximum possible radii for each configuration while respecting the constraints.\n\nThe approach balances exploration of the solution space with exploitation of promising regions, which is crucial for this type of packing problem where many local optima exist.",
  "timestamp": "2026-01-14T12:03:15.884900",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-3.7-sonnet",
    "temperature": 0.7
  }
}