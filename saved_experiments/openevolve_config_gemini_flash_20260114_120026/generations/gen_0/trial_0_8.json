{
  "trial_id": "trial_0_8",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef compute_fitness(centers, radii):\n    \"\"\"Computes the fitness of a circle packing configuration.\"\"\"\n    sum_radii = np.sum(radii)\n    \n    # Constraint violations penalty\n    penalty = 0.0\n\n    # Circle centers inside the unit square\n    for i in range(len(centers)):\n        if not (0 <= centers[i, 0] <= 1 and 0 <= centers[i, 1] <= 1):\n            penalty += 100  # Large penalty for being outside the bounds\n\n    # Circle radii non-negative\n    for r in radii:\n        if r < 0:\n            penalty += 100\n\n    # Circles entirely inside the unit square\n    for i in range(len(centers)):\n        if not (0 <= centers[i, 0] - radii[i] and centers[i, 0] + radii[i] <= 1 and 0 <= centers[i, 1] - radii[i] and centers[i, 1] + radii[i] <= 1):\n            penalty += 100\n\n    # No overlapping circles\n    for i in range(len(centers)):\n        for j in range(i + 1, len(centers)):\n            distance = np.linalg.norm(centers[i] - centers[j])\n            if distance < radii[i] + radii[j]:\n                penalty += 100 * (radii[i] + radii[j] - distance)\n\n    return sum_radii - penalty\n\ndef initialize_population(population_size, num_circles):\n    \"\"\"Initializes a population of circle packing configurations.\"\"\"\n    population = []\n    for _ in range(population_size):\n        centers = np.random.rand(num_circles, 2)\n        radii = np.random.rand(num_circles) * 0.1  # Initialize with smaller radii\n        population.append((centers, radii))\n    return population\n\ndef crossover(parent1, parent2):\n    \"\"\"Performs crossover between two parent configurations.\"\"\"\n    centers1, radii1 = parent1\n    centers2, radii2 = parent2\n\n    # Randomly choose a crossover point for centers and radii\n    crossover_point_centers = np.random.randint(1, len(centers1))\n    crossover_point_radii = np.random.randint(1, len(radii1))\n\n    # Create offspring by combining the genetic material of the parents\n    offspring_centers = np.concatenate((centers1[:crossover_point_centers], centers2[crossover_point_centers:]))\n    offspring_radii = np.concatenate((radii1[:crossover_point_radii], radii2[crossover_point_radii:]))\n\n    return offspring_centers, offspring_radii\n\ndef mutate(centers, radii, mutation_rate=0.05):\n    \"\"\"Applies mutation to a circle packing configuration.\"\"\"\n    for i in range(len(centers)):\n        if np.random.rand() < mutation_rate:\n            centers[i] += np.random.normal(0, 0.01, 2)  # Mutate center position\n\n        if np.random.rand() < mutation_rate:\n            radii[i] += np.random.normal(0, 0.005)  # Mutate radius\n    return centers, radii\n\ndef optimize_individual(centers, radii):\n    \"\"\"Optimizes an individual using local optimization.\"\"\"\n    def objective(x):\n        centers_flat = x[:2 * len(centers)].reshape(len(centers), 2)\n        radii_flat = x[2 * len(centers):]\n        return -compute_fitness(centers_flat, radii_flat)\n\n    x0 = np.concatenate([centers.flatten(), radii])\n    bounds = [(0, 1)] * (2 * len(centers)) + [(0, 0.5)] * len(radii)\n    result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds)\n\n    optimized_centers = result.x[:2 * len(centers)].reshape(len(centers), 2)\n    optimized_radii = result.x[2 * len(centers):]\n    return optimized_centers, optimized_radii\n\ndef genetic_algorithm(population_size=50, num_generations=100, num_circles=26):\n    \"\"\"Performs a genetic algorithm to optimize circle packing.\"\"\"\n    population = initialize_population(population_size, num_circles)\n\n    for generation in range(num_generations):\n        # Evaluate the fitness of each individual in the population\n        fitness_scores = [compute_fitness(centers, radii) for centers, radii in population]\n\n        # Select the best individuals for reproduction (tournament selection)\n        selected_indices = np.random.choice(len(population), size=population_size, p=np.array(fitness_scores) / np.sum(fitness_scores))\n        selected_population = [population[i] for i in selected_indices]\n\n        # Create the next generation through crossover and mutation\n        new_population = []\n        for i in range(0, population_size, 2):\n            parent1 = selected_population[i]\n            parent2 = selected_population[i + 1] if i + 1 < population_size else selected_population[i]\n            \n            offspring_centers, offspring_radii = crossover(parent1, parent2)\n            offspring_centers, offspring_radii = mutate(offspring_centers, offspring_radii)\n            \n            # Local optimization\n            offspring_centers, offspring_radii = optimize_individual(offspring_centers, offspring_radii)\n            new_population.append((offspring_centers, offspring_radii))\n\n        population = new_population\n\n        # Print the best fitness score in the current generation\n        best_fitness = np.max([compute_fitness(centers, radii) for centers, radii in population])\n        print(f\"Generation {generation + 1}: Best Fitness = {best_fitness}\")\n\n    # Return the best individual from the final population\n    best_index = np.argmax([compute_fitness(centers, radii) for centers, radii in population])\n    best_centers, best_radii = population[best_index]\n    best_sum_radii = np.sum(best_radii)\n    return best_centers, best_radii, best_sum_radii\n\ndef construct_packing():\n    \"\"\"Constructs a circle packing configuration using a genetic algorithm.\"\"\"\n    centers, radii, sum_radii = genetic_algorithm()\n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Runs the circle packing algorithm and returns the results.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 90.01051902770996,
    "error": "Timeout after 90s"
  },
  "prompt": "\nCreate an algorithm for packing 26 circles in a unit square [0,1]\u00d7[0,1] to maximize the sum of their radii.\nUse a genetic algorithm or evolutionary approach to evolve good configurations over generations.\nYour solution should handle the constraints:\n- All circles must be entirely inside the unit square\n- No two circles may overlap\n- All radii must be non-negative\nReturn (centers, radii, sum_radii) as specified in the function signature.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef compute_fitness(centers, radii):\n    \"\"\"Computes the fitness of a circle packing configuration.\"\"\"\n    sum_radii = np.sum(radii)\n    \n    # Constraint violations penalty\n    penalty = 0.0\n\n    # Circle centers inside the unit square\n    for i in range(len(centers)):\n        if not (0 <= centers[i, 0] <= 1 and 0 <= centers[i, 1] <= 1):\n            penalty += 100  # Large penalty for being outside the bounds\n\n    # Circle radii non-negative\n    for r in radii:\n        if r < 0:\n            penalty += 100\n\n    # Circles entirely inside the unit square\n    for i in range(len(centers)):\n        if not (0 <= centers[i, 0] - radii[i] and centers[i, 0] + radii[i] <= 1 and 0 <= centers[i, 1] - radii[i] and centers[i, 1] + radii[i] <= 1):\n            penalty += 100\n\n    # No overlapping circles\n    for i in range(len(centers)):\n        for j in range(i + 1, len(centers)):\n            distance = np.linalg.norm(centers[i] - centers[j])\n            if distance < radii[i] + radii[j]:\n                penalty += 100 * (radii[i] + radii[j] - distance)\n\n    return sum_radii - penalty\n\ndef initialize_population(population_size, num_circles):\n    \"\"\"Initializes a population of circle packing configurations.\"\"\"\n    population = []\n    for _ in range(population_size):\n        centers = np.random.rand(num_circles, 2)\n        radii = np.random.rand(num_circles) * 0.1  # Initialize with smaller radii\n        population.append((centers, radii))\n    return population\n\ndef crossover(parent1, parent2):\n    \"\"\"Performs crossover between two parent configurations.\"\"\"\n    centers1, radii1 = parent1\n    centers2, radii2 = parent2\n\n    # Randomly choose a crossover point for centers and radii\n    crossover_point_centers = np.random.randint(1, len(centers1))\n    crossover_point_radii = np.random.randint(1, len(radii1))\n\n    # Create offspring by combining the genetic material of the parents\n    offspring_centers = np.concatenate((centers1[:crossover_point_centers], centers2[crossover_point_centers:]))\n    offspring_radii = np.concatenate((radii1[:crossover_point_radii], radii2[crossover_point_radii:]))\n\n    return offspring_centers, offspring_radii\n\ndef mutate(centers, radii, mutation_rate=0.05):\n    \"\"\"Applies mutation to a circle packing configuration.\"\"\"\n    for i in range(len(centers)):\n        if np.random.rand() < mutation_rate:\n            centers[i] += np.random.normal(0, 0.01, 2)  # Mutate center position\n\n        if np.random.rand() < mutation_rate:\n            radii[i] += np.random.normal(0, 0.005)  # Mutate radius\n    return centers, radii\n\ndef optimize_individual(centers, radii):\n    \"\"\"Optimizes an individual using local optimization.\"\"\"\n    def objective(x):\n        centers_flat = x[:2 * len(centers)].reshape(len(centers), 2)\n        radii_flat = x[2 * len(centers):]\n        return -compute_fitness(centers_flat, radii_flat)\n\n    x0 = np.concatenate([centers.flatten(), radii])\n    bounds = [(0, 1)] * (2 * len(centers)) + [(0, 0.5)] * len(radii)\n    result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds)\n\n    optimized_centers = result.x[:2 * len(centers)].reshape(len(centers), 2)\n    optimized_radii = result.x[2 * len(centers):]\n    return optimized_centers, optimized_radii\n\ndef genetic_algorithm(population_size=50, num_generations=100, num_circles=26):\n    \"\"\"Performs a genetic algorithm to optimize circle packing.\"\"\"\n    population = initialize_population(population_size, num_circles)\n\n    for generation in range(num_generations):\n        # Evaluate the fitness of each individual in the population\n        fitness_scores = [compute_fitness(centers, radii) for centers, radii in population]\n\n        # Select the best individuals for reproduction (tournament selection)\n        selected_indices = np.random.choice(len(population), size=population_size, p=np.array(fitness_scores) / np.sum(fitness_scores))\n        selected_population = [population[i] for i in selected_indices]\n\n        # Create the next generation through crossover and mutation\n        new_population = []\n        for i in range(0, population_size, 2):\n            parent1 = selected_population[i]\n            parent2 = selected_population[i + 1] if i + 1 < population_size else selected_population[i]\n            \n            offspring_centers, offspring_radii = crossover(parent1, parent2)\n            offspring_centers, offspring_radii = mutate(offspring_centers, offspring_radii)\n            \n            # Local optimization\n            offspring_centers, offspring_radii = optimize_individual(offspring_centers, offspring_radii)\n            new_population.append((offspring_centers, offspring_radii))\n\n        population = new_population\n\n        # Print the best fitness score in the current generation\n        best_fitness = np.max([compute_fitness(centers, radii) for centers, radii in population])\n        print(f\"Generation {generation + 1}: Best Fitness = {best_fitness}\")\n\n    # Return the best individual from the final population\n    best_index = np.argmax([compute_fitness(centers, radii) for centers, radii in population])\n    best_centers, best_radii = population[best_index]\n    best_sum_radii = np.sum(best_radii)\n    return best_centers, best_radii, best_sum_radii\n\ndef construct_packing():\n    \"\"\"Constructs a circle packing configuration using a genetic algorithm.\"\"\"\n    centers, radii, sum_radii = genetic_algorithm()\n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Runs the circle packing algorithm and returns the results.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-14T12:04:26.037312",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 323,
        "candidates_token_count": 1569,
        "thoughts_token_count": 0
      },
      "response_text_len": 5598
    }
  }
}