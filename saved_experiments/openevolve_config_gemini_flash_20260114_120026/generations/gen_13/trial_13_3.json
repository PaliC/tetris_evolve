{
  "trial_id": "trial_13_3",
  "generation": 13,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import differential_evolution, basinhopping\nfrom scipy.spatial import distance_matrix\nimport random\n\ndef construct_packing():\n    def is_valid(centers, radii):\n        \"\"\"Check if the packing is valid (no overlaps, within bounds).\"\"\"\n        for i in range(len(centers)):\n            if not (0 <= centers[i][0] - radii[i] and centers[i][0] + radii[i] <= 1 and\n                    0 <= centers[i][1] - radii[i] and centers[i][1] + radii[i] <= 1):\n                return False\n            for j in range(i + 1, len(centers)):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j]:\n                    return False\n        return True\n\n    def objective_function(x):\n        \"\"\"Objective function to minimize (negative sum of radii).\"\"\"\n        centers = x[:52].reshape(26, 2)\n        radii = x[52:]\n        if not is_valid(centers, radii):\n            return 0.0  # Return a very bad score if invalid\n        return -np.sum(radii)\n\n    def random_step(x):\n        \"\"\"Custom step function for basin-hopping.\"\"\"\n        centers = x[:52].reshape(26, 2)\n        radii = x[52:]\n        \n        # Adjust a random center\n        i = random.randint(0, 25)\n        centers[i] += np.random.uniform(-0.01, 0.01, 2)\n        \n        # Adjust a random radius\n        j = random.randint(0, 25)\n        radii[j] += np.random.uniform(-0.005, 0.005)\n        radii[radii < 0] = 0  # Keep radii non-negative\n\n        x[:52] = centers.flatten()\n        x[52:] = radii\n\n        return x\n\n    def adaptive_radii(centers):\n        \"\"\"Assign radii based on local density.\"\"\"\n        radii = np.zeros(26)\n        for i in range(26):\n            distances = np.linalg.norm(centers - centers[i], axis=1)\n            distances[i] = np.inf  # Exclude self-distance\n            min_dist = np.min(distances)\n            radii[i] = min_dist / 2.0  # Half the distance to nearest neighbor\n            radii[i] = min(radii[i], centers[i][0], 1 - centers[i][0], centers[i][1], 1 - centers[i][1])\n            radii[i] *= 0.9 # Reduce radius slightly to avoid clashes\n        return radii\n\n    # 1. Physics-based Initialization\n    centers = np.random.rand(26, 2)\n    radii = np.full(26, 0.05) # Initial radii\n    \n    # Simulate repulsive forces for a few iterations\n    for _ in range(50):\n        forces = np.zeros_like(centers)\n        for i in range(26):\n            for j in range(i + 1, 26):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    direction = (centers[i] - centers[j]) / dist\n                    forces[i] += direction * overlap * 0.5\n                    forces[j] -= direction * overlap * 0.5\n        centers += forces * 0.01 # Move centers based on forces\n        centers = np.clip(centers, 0, 1) # Keep within bounds\n    \n    radii = adaptive_radii(centers)\n\n    # 2. Differential Evolution\n    bounds = [(0, 1)] * 52 + [(0.001, 0.5)] * 26  # Bounds for centers and radii\n    initial_guess = np.concatenate([centers.flatten(), radii])\n    \n    de_result = differential_evolution(objective_function, bounds, \n                                        popsize=15, \n                                        mutation=(0.5, 1), \n                                        recombination=0.7, \n                                        seed=42,\n                                        init = 'latinhypercube',\n                                        maxiter=50)\n    \n    centers = de_result.x[:52].reshape(26, 2)\n    radii = de_result.x[52:]\n    radii[radii < 0] = 0\n\n    # 3. Basin-Hopping\n    bh_result = basinhopping(objective_function, de_result.x, \n                             niter=50, \n                             take_step=random_step, \n                             T=0.5, # Temperature parameter\n                             stepsize=0.05)\n    \n    centers = bh_result.x[:52].reshape(26, 2)\n    radii = bh_result.x[52:]\n    radii[radii < 0] = 0\n    \n    # Final check for validity\n    if not is_valid(centers, radii):\n        print(\"Warning: Final packing is invalid. Returning best valid packing found.\")\n        # If the final result is invalid, return the result from differential evolution.\n        centers = de_result.x[:52].reshape(26, 2)\n        radii = de_result.x[52:]\n        radii[radii < 0] = 0\n        if not is_valid(centers, radii):\n          print(\"Differential evolution result is also invalid. Returning random valid packing\")\n          centers = np.random.rand(26, 2)\n          radii = adaptive_radii(centers)\n          while not is_valid(centers, radii):\n            centers = np.random.rand(26, 2)\n            radii = adaptive_radii(centers)\n          \n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 1.0001303495843887,
    "eval_time": 0.36357712745666504,
    "error": null
  },
  "prompt": "\n        Create a hybrid optimization algorithm for the circle packing problem: fitting 26 non-overlapping circles in a unit square to maximize the sum of radii.\n        \n        The current best solution has score 2.634292402075199. Your approach should combine methods:\n        \n        1. Start with a physics-based initialization (repulsive forces)\n        2. Apply differential evolution to find promising regions\n        3. Use basin-hopping with custom step function for final optimization\n        4. Implement adaptive radius assignment based on local density\n        \n        Key requirements:\n        - Efficient constraint handling to maintain no overlaps\n        - Dynamic adjustment of optimization parameters\n        - Multiple initializations with different strategies\n        - Return tuple (centers, radii, sum_radii)\n        \n        This hybrid approach should leverage the strengths of multiple optimization techniques.\n        ",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import differential_evolution, basinhopping\nfrom scipy.spatial import distance_matrix\nimport random\n\ndef construct_packing():\n    def is_valid(centers, radii):\n        \"\"\"Check if the packing is valid (no overlaps, within bounds).\"\"\"\n        for i in range(len(centers)):\n            if not (0 <= centers[i][0] - radii[i] and centers[i][0] + radii[i] <= 1 and\n                    0 <= centers[i][1] - radii[i] and centers[i][1] + radii[i] <= 1):\n                return False\n            for j in range(i + 1, len(centers)):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j]:\n                    return False\n        return True\n\n    def objective_function(x):\n        \"\"\"Objective function to minimize (negative sum of radii).\"\"\"\n        centers = x[:52].reshape(26, 2)\n        radii = x[52:]\n        if not is_valid(centers, radii):\n            return 0.0  # Return a very bad score if invalid\n        return -np.sum(radii)\n\n    def random_step(x):\n        \"\"\"Custom step function for basin-hopping.\"\"\"\n        centers = x[:52].reshape(26, 2)\n        radii = x[52:]\n        \n        # Adjust a random center\n        i = random.randint(0, 25)\n        centers[i] += np.random.uniform(-0.01, 0.01, 2)\n        \n        # Adjust a random radius\n        j = random.randint(0, 25)\n        radii[j] += np.random.uniform(-0.005, 0.005)\n        radii[radii < 0] = 0  # Keep radii non-negative\n\n        x[:52] = centers.flatten()\n        x[52:] = radii\n\n        return x\n\n    def adaptive_radii(centers):\n        \"\"\"Assign radii based on local density.\"\"\"\n        radii = np.zeros(26)\n        for i in range(26):\n            distances = np.linalg.norm(centers - centers[i], axis=1)\n            distances[i] = np.inf  # Exclude self-distance\n            min_dist = np.min(distances)\n            radii[i] = min_dist / 2.0  # Half the distance to nearest neighbor\n            radii[i] = min(radii[i], centers[i][0], 1 - centers[i][0], centers[i][1], 1 - centers[i][1])\n            radii[i] *= 0.9 # Reduce radius slightly to avoid clashes\n        return radii\n\n    # 1. Physics-based Initialization\n    centers = np.random.rand(26, 2)\n    radii = np.full(26, 0.05) # Initial radii\n    \n    # Simulate repulsive forces for a few iterations\n    for _ in range(50):\n        forces = np.zeros_like(centers)\n        for i in range(26):\n            for j in range(i + 1, 26):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    direction = (centers[i] - centers[j]) / dist\n                    forces[i] += direction * overlap * 0.5\n                    forces[j] -= direction * overlap * 0.5\n        centers += forces * 0.01 # Move centers based on forces\n        centers = np.clip(centers, 0, 1) # Keep within bounds\n    \n    radii = adaptive_radii(centers)\n\n    # 2. Differential Evolution\n    bounds = [(0, 1)] * 52 + [(0.001, 0.5)] * 26  # Bounds for centers and radii\n    initial_guess = np.concatenate([centers.flatten(), radii])\n    \n    de_result = differential_evolution(objective_function, bounds, \n                                        popsize=15, \n                                        mutation=(0.5, 1), \n                                        recombination=0.7, \n                                        seed=42,\n                                        init = 'latinhypercube',\n                                        maxiter=50)\n    \n    centers = de_result.x[:52].reshape(26, 2)\n    radii = de_result.x[52:]\n    radii[radii < 0] = 0\n\n    # 3. Basin-Hopping\n    bh_result = basinhopping(objective_function, de_result.x, \n                             niter=50, \n                             take_step=random_step, \n                             T=0.5, # Temperature parameter\n                             stepsize=0.05)\n    \n    centers = bh_result.x[:52].reshape(26, 2)\n    radii = bh_result.x[52:]\n    radii[radii < 0] = 0\n    \n    # Final check for validity\n    if not is_valid(centers, radii):\n        print(\"Warning: Final packing is invalid. Returning best valid packing found.\")\n        # If the final result is invalid, return the result from differential evolution.\n        centers = de_result.x[:52].reshape(26, 2)\n        radii = de_result.x[52:]\n        radii[radii < 0] = 0\n        if not is_valid(centers, radii):\n          print(\"Differential evolution result is also invalid. Returning random valid packing\")\n          centers = np.random.rand(26, 2)\n          radii = adaptive_radii(centers)\n          while not is_valid(centers, radii):\n            centers = np.random.rand(26, 2)\n            radii = adaptive_radii(centers)\n          \n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-14T13:16:46.165072",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 410,
        "candidates_token_count": 1472,
        "thoughts_token_count": 0
      },
      "response_text_len": 4897
    }
  }
}