{
  "trial_id": "trial_16_7",
  "generation": 16,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    def objective(x):\n        radii = x[:26]\n        centers = x[26:].reshape(26, 2)\n        return -np.sum(radii)\n\n    def constraint_overlap(x):\n        radii = x[:26]\n        centers = x[26:].reshape(26, 2)\n        n = len(radii)\n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - radii[i] - radii[j])\n        return np.array(constraints)\n\n    def constraint_bounds(x):\n        radii = x[:26]\n        centers = x[26:].reshape(26, 2)\n        constraints = []\n        for i in range(26):\n            constraints.append(centers[i, 0] - radii[i])\n            constraints.append(1 - centers[i, 0] - radii[i])\n            constraints.append(centers[i, 1] - radii[i])\n            constraints.append(1 - centers[i, 1] - radii[i])\n        return np.array(constraints)\n    \n    def generate_hexagonal_pattern():\n        n = 26\n        rows = 6\n        cols = 5\n        centers_x = np.linspace(0.1, 0.9, cols)\n        centers_y = np.linspace(0.1, 0.9, rows)\n        centers = np.array([[x,y] for y in centers_y for x in centers_x])[:n]\n        radii = np.ones(n) * 0.05\n        return centers, radii\n    \n    def generate_circular_pattern():\n        n = 26\n        radius = 0.4\n        center_x = 0.5\n        center_y = 0.5\n        angles = np.linspace(0, 2*np.pi, n, endpoint=False)\n        centers_x = center_x + radius * np.cos(angles)\n        centers_y = center_y + radius * np.sin(angles)\n        centers = np.column_stack((centers_x, centers_y))\n        radii = np.ones(n) * 0.04\n        return centers, radii\n\n    def optimize_pattern(centers, radii):\n        x0 = np.concatenate([radii, centers.flatten()])\n        bounds_radii = [(0.001, 0.4) for _ in range(26)]\n        bounds_centers = [(0, 1) for _ in range(26 * 2)]\n        bounds = bounds_radii + bounds_centers\n        \n        constraints = ({'type': 'ineq', 'fun': constraint_overlap},\n                       {'type': 'ineq', 'fun': constraint_bounds})\n        \n        result = minimize(objective, x0, method='SLSQP', bounds=bounds, constraints=constraints, options={'maxiter': 200})\n        \n        optimized_radii = result.x[:26]\n        optimized_centers = result.x[26:].reshape(26, 2)\n        return optimized_centers, optimized_radii, -result.fun\n\n    # Multi-pattern strategy\n    patterns = [generate_hexagonal_pattern(), generate_circular_pattern()]\n    best_sum_radii = 0\n    best_centers = None\n    best_radii = None\n    \n    for centers, radii in patterns:\n        # Perturbation mechanism\n        for _ in range(3):\n            perturbed_centers = centers + np.random.normal(0, 0.01, centers.shape)\n            perturbed_radii = radii + np.random.normal(0, 0.005, radii.shape)\n            perturbed_radii = np.clip(perturbed_radii, 0.001, 0.4)  # Ensure radii stay within bounds\n\n            optimized_centers, optimized_radii, sum_radii = optimize_pattern(perturbed_centers, perturbed_radii)\n            \n            if sum_radii > best_sum_radii:\n                best_sum_radii = sum_radii\n                best_centers = optimized_centers\n                best_radii = optimized_radii\n\n    # Final optimization phase\n    final_centers, final_radii, final_sum_radii = optimize_pattern(best_centers, best_radii)\n\n    return final_centers, final_radii, final_sum_radii\n\ndef run_packing():\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.625909832028471,
    "eval_time": 2.371932029724121,
    "error": null
  },
  "prompt": "\nYou are solving the circle packing problem: pack 26 circles in a unit square to maximize the sum of radii.\n\nI'd like you to implement a pattern-based approach combined with optimization.\n\nCreate a solution that:\n1. Starts with a predefined pattern layout (e.g., hexagonal, circular, or fractal)\n2. Sets initial circle positions based on the pattern but with variable radii\n3. Optimizes the positions and radii using a constrained optimization approach\n4. Implements a multi-pattern strategy that tries multiple patterns and selects the best\n5. Uses a perturbation mechanism to explore variations of each pattern\n6. Applies a final optimization phase to refine the solution\n\nImplement your complete solution using this pattern-based approach, focusing on maximizing the sum of radii while ensuring circles don't overlap and stay within bounds.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    def objective(x):\n        radii = x[:26]\n        centers = x[26:].reshape(26, 2)\n        return -np.sum(radii)\n\n    def constraint_overlap(x):\n        radii = x[:26]\n        centers = x[26:].reshape(26, 2)\n        n = len(radii)\n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - radii[i] - radii[j])\n        return np.array(constraints)\n\n    def constraint_bounds(x):\n        radii = x[:26]\n        centers = x[26:].reshape(26, 2)\n        constraints = []\n        for i in range(26):\n            constraints.append(centers[i, 0] - radii[i])\n            constraints.append(1 - centers[i, 0] - radii[i])\n            constraints.append(centers[i, 1] - radii[i])\n            constraints.append(1 - centers[i, 1] - radii[i])\n        return np.array(constraints)\n    \n    def generate_hexagonal_pattern():\n        n = 26\n        rows = 6\n        cols = 5\n        centers_x = np.linspace(0.1, 0.9, cols)\n        centers_y = np.linspace(0.1, 0.9, rows)\n        centers = np.array([[x,y] for y in centers_y for x in centers_x])[:n]\n        radii = np.ones(n) * 0.05\n        return centers, radii\n    \n    def generate_circular_pattern():\n        n = 26\n        radius = 0.4\n        center_x = 0.5\n        center_y = 0.5\n        angles = np.linspace(0, 2*np.pi, n, endpoint=False)\n        centers_x = center_x + radius * np.cos(angles)\n        centers_y = center_y + radius * np.sin(angles)\n        centers = np.column_stack((centers_x, centers_y))\n        radii = np.ones(n) * 0.04\n        return centers, radii\n\n    def optimize_pattern(centers, radii):\n        x0 = np.concatenate([radii, centers.flatten()])\n        bounds_radii = [(0.001, 0.4) for _ in range(26)]\n        bounds_centers = [(0, 1) for _ in range(26 * 2)]\n        bounds = bounds_radii + bounds_centers\n        \n        constraints = ({'type': 'ineq', 'fun': constraint_overlap},\n                       {'type': 'ineq', 'fun': constraint_bounds})\n        \n        result = minimize(objective, x0, method='SLSQP', bounds=bounds, constraints=constraints, options={'maxiter': 200})\n        \n        optimized_radii = result.x[:26]\n        optimized_centers = result.x[26:].reshape(26, 2)\n        return optimized_centers, optimized_radii, -result.fun\n\n    # Multi-pattern strategy\n    patterns = [generate_hexagonal_pattern(), generate_circular_pattern()]\n    best_sum_radii = 0\n    best_centers = None\n    best_radii = None\n    \n    for centers, radii in patterns:\n        # Perturbation mechanism\n        for _ in range(3):\n            perturbed_centers = centers + np.random.normal(0, 0.01, centers.shape)\n            perturbed_radii = radii + np.random.normal(0, 0.005, radii.shape)\n            perturbed_radii = np.clip(perturbed_radii, 0.001, 0.4)  # Ensure radii stay within bounds\n\n            optimized_centers, optimized_radii, sum_radii = optimize_pattern(perturbed_centers, perturbed_radii)\n            \n            if sum_radii > best_sum_radii:\n                best_sum_radii = sum_radii\n                best_centers = optimized_centers\n                best_radii = optimized_radii\n\n    # Final optimization phase\n    final_centers, final_radii, final_sum_radii = optimize_pattern(best_centers, best_radii)\n\n    return final_centers, final_radii, final_sum_radii\n\ndef run_packing():\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n```",
  "reasoning": "",
  "timestamp": "2026-01-14T13:30:01.300543",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 393,
        "candidates_token_count": 1139,
        "thoughts_token_count": 0
      },
      "response_text_len": 3586
    }
  }
}