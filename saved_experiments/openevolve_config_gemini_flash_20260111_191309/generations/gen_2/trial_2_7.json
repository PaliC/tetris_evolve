{
  "trial_id": "trial_2_7",
  "generation": 2,
  "parent_id": "trial_1_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial import distance\n\ndef poisson_disk_sample(width, height, radius, k=30):\n    \"\"\"\n    Generate points using Poisson Disk Sampling.\n\n    Args:\n        width: Width of the rectangular region.\n        height: Height of the rectangular region.\n        radius: Minimum distance between points.\n        k: Number of attempts to place a new point before rejection.\n\n    Returns:\n        A list of (x, y) coordinates.\n    \"\"\"\n    grid_width = radius / np.sqrt(2)\n    grid = np.zeros((int(np.ceil(width / grid_width)), int(np.ceil(height / grid_width))), dtype=int)\n    points = []\n    active_list = []\n\n    # Initialize\n    x = np.random.uniform(0, width)\n    y = np.random.uniform(0, height)\n    points.append((x, y))\n    active_list.append((x, y))\n    grid_x = int(x / grid_width)\n    grid_y = int(y / grid_width)\n    grid[grid_x, grid_y] = 1\n\n    while active_list:\n        # Choose a random point from the active list\n        idx = np.random.randint(len(active_list))\n        x, y = active_list[idx]\n\n        found = False\n        for _ in range(k):\n            # Generate a random point around the chosen point\n            angle = np.random.uniform(0, 2 * np.pi)\n            new_radius = np.random.uniform(radius, 2 * radius)\n            new_x = x + new_radius * np.cos(angle)\n            new_y = y + new_radius * np.sin(angle)\n\n            # Check if the new point is within the bounds\n            if 0 <= new_x <= width and 0 <= new_y <= height:\n                new_grid_x = int(new_x / grid_width)\n                new_grid_y = int(new_y / grid_width)\n\n                # Check if the new point is too close to existing points\n                valid = True\n                for i in range(max(0, new_grid_x - 2), min(grid.shape[0], new_grid_x + 3)):\n                    for j in range(max(0, new_grid_y - 2), min(grid.shape[1], new_grid_y + 3)):\n                        if grid[i, j] == 1:\n                            px = i * grid_width + grid_width / 2\n                            py = j * grid_width + grid_width / 2\n                            if distance.euclidean((new_x, new_y), (px, py)) < radius:\n                                valid = False\n                                break\n                    if not valid:\n                        break\n\n                if valid:\n                    points.append((new_x, new_y))\n                    active_list.append((new_x, new_y))\n                    grid[new_grid_x, new_grid_y] = 1\n                    found = True\n                    break\n\n        if not found:\n            active_list.pop(idx)\n\n    return np.array(points)\n\n\ndef construct_packing():\n    n_circles = 26\n    \n    # Poisson Disk Sampling for initial centers\n    initial_centers = poisson_disk_sample(1, 1, 0.07, k=30)  # Adjust radius as needed\n    if len(initial_centers) < n_circles:\n        # If PDS doesn't generate enough points, fall back to random initialization\n        initial_centers = np.random.rand(n_circles, 2)\n    else:\n        initial_centers = initial_centers[:n_circles]  # Take the first n_circles points\n    \n    initial_radii = np.full(n_circles, 0.01) # Initial radii\n\n    def objective(x):\n        radii = x[-n_circles:]\n        return -np.sum(radii)\n\n    def constraint_overlap(x):\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[-n_circles:]\n        dists = distance.cdist(centers, centers)\n        for i in range(n_circles):\n            dists[i, i] = np.inf  # Avoid self-comparison\n        return dists - radii[:, None] - radii[None, :]\n\n    def constraint_boundary(x):\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[-n_circles:]\n        x_coords = centers[:, 0]\n        y_coords = centers[:, 1]\n        return np.concatenate([x_coords - radii,\n                               1 - x_coords - radii,\n                               y_coords - radii,\n                               1 - y_coords - radii])\n\n    # Bounds and constraints\n    bounds_centers = [(0, 1)] * (2 * n_circles)\n    bounds_radii = [(0, 1)] * n_circles\n    bounds = bounds_centers + bounds_radii\n\n    constraints = ({'type': 'ineq', 'fun': lambda x: constraint_overlap(x).min()},\n                   {'type': 'ineq', 'fun': lambda x: constraint_boundary(x).min()})\n\n    # Initial guess\n    x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n\n    # Multi-start optimization\n    n_starts = 5\n    best_sum_radii = -np.inf\n    best_centers = None\n    best_radii = None\n\n    for _ in range(n_starts):\n        # Perturb initial guess slightly\n        x0_perturbed = x0 + np.random.normal(0, 0.01, size=len(x0))\n        \n        # Ensure centers stay within bounds\n        x0_perturbed[:2*n_circles] = np.clip(x0_perturbed[:2*n_circles], 0, 1)\n        \n        # Ensure radii are non-negative\n        x0_perturbed[-n_circles:] = np.maximum(x0_perturbed[-n_circles:], 0.001)\n\n        result = minimize(objective, x0_perturbed, method='SLSQP', bounds=bounds, constraints=constraints, options={'maxiter': 200})\n\n        if -result.fun > best_sum_radii and result.success:\n            best_sum_radii = -result.fun\n            best_centers = result.x[:2*n_circles].reshape(n_circles, 2)\n            best_radii = result.x[-n_circles:]\n\n    return best_centers, best_radii, best_sum_radii\n\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 1.3385639190673828,
    "error": "Invalid centers shape: (), expected (26, 2)"
  },
  "prompt": "Pack 26 circles. Use a multi-start SLSQP approach, but improve the initialization: instead of random centers, initialize centers using a Poisson Disk Sampling method to ensure they are well-distributed from the start. Then optimize sum(radii) with strict non-overlap and boundary constraints.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial import distance\n\ndef poisson_disk_sample(width, height, radius, k=30):\n    \"\"\"\n    Generate points using Poisson Disk Sampling.\n\n    Args:\n        width: Width of the rectangular region.\n        height: Height of the rectangular region.\n        radius: Minimum distance between points.\n        k: Number of attempts to place a new point before rejection.\n\n    Returns:\n        A list of (x, y) coordinates.\n    \"\"\"\n    grid_width = radius / np.sqrt(2)\n    grid = np.zeros((int(np.ceil(width / grid_width)), int(np.ceil(height / grid_width))), dtype=int)\n    points = []\n    active_list = []\n\n    # Initialize\n    x = np.random.uniform(0, width)\n    y = np.random.uniform(0, height)\n    points.append((x, y))\n    active_list.append((x, y))\n    grid_x = int(x / grid_width)\n    grid_y = int(y / grid_width)\n    grid[grid_x, grid_y] = 1\n\n    while active_list:\n        # Choose a random point from the active list\n        idx = np.random.randint(len(active_list))\n        x, y = active_list[idx]\n\n        found = False\n        for _ in range(k):\n            # Generate a random point around the chosen point\n            angle = np.random.uniform(0, 2 * np.pi)\n            new_radius = np.random.uniform(radius, 2 * radius)\n            new_x = x + new_radius * np.cos(angle)\n            new_y = y + new_radius * np.sin(angle)\n\n            # Check if the new point is within the bounds\n            if 0 <= new_x <= width and 0 <= new_y <= height:\n                new_grid_x = int(new_x / grid_width)\n                new_grid_y = int(new_y / grid_width)\n\n                # Check if the new point is too close to existing points\n                valid = True\n                for i in range(max(0, new_grid_x - 2), min(grid.shape[0], new_grid_x + 3)):\n                    for j in range(max(0, new_grid_y - 2), min(grid.shape[1], new_grid_y + 3)):\n                        if grid[i, j] == 1:\n                            px = i * grid_width + grid_width / 2\n                            py = j * grid_width + grid_width / 2\n                            if distance.euclidean((new_x, new_y), (px, py)) < radius:\n                                valid = False\n                                break\n                    if not valid:\n                        break\n\n                if valid:\n                    points.append((new_x, new_y))\n                    active_list.append((new_x, new_y))\n                    grid[new_grid_x, new_grid_y] = 1\n                    found = True\n                    break\n\n        if not found:\n            active_list.pop(idx)\n\n    return np.array(points)\n\n\ndef construct_packing():\n    n_circles = 26\n    \n    # Poisson Disk Sampling for initial centers\n    initial_centers = poisson_disk_sample(1, 1, 0.07, k=30)  # Adjust radius as needed\n    if len(initial_centers) < n_circles:\n        # If PDS doesn't generate enough points, fall back to random initialization\n        initial_centers = np.random.rand(n_circles, 2)\n    else:\n        initial_centers = initial_centers[:n_circles]  # Take the first n_circles points\n    \n    initial_radii = np.full(n_circles, 0.01) # Initial radii\n\n    def objective(x):\n        radii = x[-n_circles:]\n        return -np.sum(radii)\n\n    def constraint_overlap(x):\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[-n_circles:]\n        dists = distance.cdist(centers, centers)\n        for i in range(n_circles):\n            dists[i, i] = np.inf  # Avoid self-comparison\n        return dists - radii[:, None] - radii[None, :]\n\n    def constraint_boundary(x):\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[-n_circles:]\n        x_coords = centers[:, 0]\n        y_coords = centers[:, 1]\n        return np.concatenate([x_coords - radii,\n                               1 - x_coords - radii,\n                               y_coords - radii,\n                               1 - y_coords - radii])\n\n    # Bounds and constraints\n    bounds_centers = [(0, 1)] * (2 * n_circles)\n    bounds_radii = [(0, 1)] * n_circles\n    bounds = bounds_centers + bounds_radii\n\n    constraints = ({'type': 'ineq', 'fun': lambda x: constraint_overlap(x).min()},\n                   {'type': 'ineq', 'fun': lambda x: constraint_boundary(x).min()})\n\n    # Initial guess\n    x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n\n    # Multi-start optimization\n    n_starts = 5\n    best_sum_radii = -np.inf\n    best_centers = None\n    best_radii = None\n\n    for _ in range(n_starts):\n        # Perturb initial guess slightly\n        x0_perturbed = x0 + np.random.normal(0, 0.01, size=len(x0))\n        \n        # Ensure centers stay within bounds\n        x0_perturbed[:2*n_circles] = np.clip(x0_perturbed[:2*n_circles], 0, 1)\n        \n        # Ensure radii are non-negative\n        x0_perturbed[-n_circles:] = np.maximum(x0_perturbed[-n_circles:], 0.001)\n\n        result = minimize(objective, x0_perturbed, method='SLSQP', bounds=bounds, constraints=constraints, options={'maxiter': 200})\n\n        if -result.fun > best_sum_radii and result.success:\n            best_sum_radii = -result.fun\n            best_centers = result.x[:2*n_circles].reshape(n_circles, 2)\n            best_radii = result.x[-n_circles:]\n\n    return best_centers, best_radii, best_sum_radii\n\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-11T19:22:08.458596",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.4,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 280,
        "candidates_token_count": 1609,
        "thoughts_token_count": 0
      },
      "response_text_len": 5389
    }
  }
}