{
  "trial_id": "trial_11_7",
  "generation": 11,
  "parent_id": "trial_5_2",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, basinhopping, linprog\nfrom scipy.stats import qmc\nimport multiprocessing as mp\n\ndef construct_packing():\n    n_circles = 26\n    centers = np.zeros((n_circles, 2))\n    radii = np.zeros(n_circles)\n\n    def calculate_max_radius(center, existing_centers, existing_radii):\n        \"\"\"Calculates the maximum possible radius for a circle at the given center,\n        without overlapping existing circles or exceeding the boundaries of the unit square.\n        \"\"\"\n        min_dist_to_existing = np.inf\n        for i in range(len(existing_centers)):\n            dist = np.linalg.norm(center - existing_centers[i])\n            min_dist_to_existing = min(min_dist_to_existing, dist - existing_radii[i])\n\n        dist_to_boundary = min(center[0], center[1], 1 - center[0], 1 - center[1])\n\n        return min(min_dist_to_existing, dist_to_boundary)\n\n    # Greedy placement with Sobol sequence\n    num_samples = 4096\n    sampler = qmc.Sobol(d=2, scramble=False)\n    sample = sampler.random(n=num_samples)\n\n    for i in range(n_circles):\n        best_center = None\n        best_radius = -1\n\n        for j in range(num_samples):\n            center = sample[j]\n            radius = calculate_max_radius(center, centers[:i], radii[:i])\n\n            if radius > best_radius:\n                best_radius = radius\n                best_center = center\n\n        centers[i] = best_center\n        radii[i] = best_radius\n\n    # Parallel Tempering Basin Hopping\n    def objective(centers_opt):\n        \"\"\"Objective function to minimize the negative sum of radii, solving LP for radii.\"\"\"\n        # Solve LP for radii given centers\n        c = -np.ones(n_circles)  # Maximize sum of radii\n        A_ub = np.zeros((n_circles * (n_circles - 1) // 2 + 4 * n_circles, n_circles))\n        b_ub = np.zeros(n_circles * (n_circles - 1) // 2 + 4 * n_circles)\n        k = 0\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                A_ub[k, i] = 1\n                A_ub[k, j] = 1\n                b_ub[k] = np.linalg.norm(centers_opt[i] - centers_opt[j])\n                k += 1\n        for i in range(n_circles):\n            A_ub[k, i] = 1\n            b_ub[k] = centers_opt[i, 0]\n            k += 1\n            A_ub[k, i] = 1\n            b_ub[k] = centers_opt[i, 1]\n            k += 1\n            A_ub[k, i] = 1\n            b_ub[k] = 1 - centers_opt[i, 0]\n            k += 1\n            A_ub[k, i] = 1\n            b_ub[k] = 1 - centers_opt[i, 1]\n            k += 1\n\n        bounds = [(0, 0.15)] * n_circles  # Radii bounded by 0.15\n        result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n        if result.success:\n            radii_opt = result.x\n            return -np.sum(radii_opt), radii_opt\n        else:\n            return np.inf, None  # Return a high cost if LP fails\n\n    def parallel_tempering_step(centers, stepsize):\n        \"\"\"Performs a single step of Basin Hopping with a given stepsize.\"\"\"\n        centers_new = centers + np.random.normal(0, stepsize, size=centers.shape)\n        centers_new = np.clip(centers_new, 0, 1)  # Keep centers within [0, 1]\n\n        energy_current, radii_current = objective(centers)\n        energy_new, radii_new = objective(centers_new)\n\n        if energy_new < energy_current:\n            return centers_new, radii_new, energy_new\n        else:\n            acceptance_probability = np.exp(-(energy_new - energy_current))\n            if np.random.rand() < acceptance_probability:\n                return centers_new, radii_new, energy_new\n            else:\n                return centers, radii_current, energy_current\n\n    def run_chain(centers_initial, stepsize, iterations):\n        \"\"\"Runs a single parallel tempering chain.\"\"\"\n        centers = centers_initial.copy()\n        best_centers = centers.copy()\n        best_energy, radii = objective(centers)\n        best_radii = radii\n        \n        for _ in range(iterations):\n            centers, radii, energy = parallel_tempering_step(centers, stepsize)\n            if energy < best_energy:\n                best_energy = energy\n                best_centers = centers.copy()\n                best_radii = radii\n        return best_centers, best_radii, best_energy\n\n    # Parallel Tempering setup\n    num_chains = 4\n    stepsizes = [0.1, 0.05, 0.01, 0.002]\n    iterations = 250\n    centers_initial = centers.copy()\n    \n    # Run chains in parallel\n    with mp.Pool(processes=num_chains) as pool:\n        results = pool.starmap(run_chain, [(centers_initial, stepsize, iterations) for stepsize in stepsizes])\n\n    # Select the best result\n    best_energy = np.inf\n    best_centers = None\n    best_radii = None\n    for centers_opt, radii_opt, energy in results:\n        if energy < best_energy:\n            best_energy = energy\n            best_centers = centers_opt\n            best_radii = radii_opt\n\n    sum_radii = np.sum(best_radii)\n    return best_centers, best_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 1.7399840354919434,
    "error": "PicklingError: Can't pickle local object <function construct_packing.<locals>.run_chain at 0x10ce5fab0>"
  },
  "prompt": "Refine trial_5_2 using 'Parallel Tempering' Basin Hopping:\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nfrom scipy.stats import qmc\n\ndef construct_packing():\n    n_circles = 26\n    centers = np.zeros((n_circles, 2))\n    radii = np.zeros(n_circles)\n\n    def calculate_max_radius(center, existing_centers, existing_radii):\n        \"\"\"Calculates the maximum possible radius for a circle at the given center,\n        without overlapping existing circles or exceeding the boundaries of the unit square.\n        \"\"\"\n        min_dist_to_existing = np.inf\n        for i in range(len(existing_centers)):\n            dist = np.linalg.norm(center - existing_centers[i])\n            min_dist_to_existing = min(min_dist_to_existing, dist - existing_radii[i])\n\n        dist_to_boundary = min(center[0], center[1], 1 - center[0], 1 - center[1])\n\n        return min(min_dist_to_existing, dist_to_boundary)\n\n    # Greedy placement with Sobol sequence\n    num_samples = 4096\n    sampler = qmc.Sobol(d=2, scramble=False)\n    sample = sampler.random(n=num_samples)\n\n    for i in range(n_circles):\n        best_center = None\n        best_radius = -1\n\n        for j in range(num_samples):\n            center = sample[j]\n            radius = calculate_max_radius(center, centers[:i], radii[:i])\n\n            if radius > best_radius:\n                best_radius = radius\n                best_center = center\n\n        centers[i] = best_center\n        radii[i] = best_radius\n\n    # Global optimization using Basin Hopping\n    def objective(x):\n        \"\"\"Objective function to minimize the negative sum of radii.\"\"\"\n        radii_opt = x[2 * n_circles:]\n        return -np.sum(radii_opt)\n\n    def constraint_overlap(x):\n        \"\"\"Constraint to prevent circle overlaps.\"\"\"\n        centers_opt = x[:2 * n_circles].reshape((n_circles, 2))\n        radii_opt = x[2 * n_circles:]\n        constraints = []\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers_opt[i] - centers_opt[j])\n                constraints.append(dist - radii_opt[i] - radii_opt[j])\n        return np.array(constraints)\n\n    def constraint_boundary(x):\n        \"\"\"Constraint to keep circles within the unit square.\"\"\"\n        centers_opt = x[:2 * n_circles].reshape((n_circles, 2))\n        radii_opt = x[2 * n_circles:]\n        constraints = []\n        for i in range(n_circles):\n            constraints.append(centers_opt[i, 0] - radii_opt[i])\n            constraints.append(centers_opt[i, 1] - radii_opt[i])\n            constraints.append(1 - centers_opt[i, 0] - radii_opt[i])\n            constraints.append(1 - centers_opt[i, 1] - radii_opt[i])\n        return np.array(constraints)\n\n    # Initial guess\n    x0 = np.concatenate([centers.flatten(), radii])\n\n    # Bounds for centers and radii\n    bounds = [(0, 1)] * (2 * n_circles) + [(0, 0.15)] * n_circles  # Radii bounded by 0.15\n\n    # Constraints\n    constraints = ({'type': 'ineq', 'fun': constraint_overlap},\n                   {'type': 'ineq', 'fun': constraint_boundary})\n\n    # Optimization using Basin Hopping\n    minimizer_kwargs = {\"method\": \"SLSQP\", \"bounds\": bounds, \"constraints\": constraints, 'options': {'maxiter': 500}}\n    result = basinhopping(objective, x0, minimizer_kwargs=minimizer_kwargs, niter=250, stepsize=0.05)\n\n    # Extract optimized values\n    centers_opt = result.x[:2 * n_circles].reshape((n_circles, 2))\n    radii_opt = result.x[2 * n_circles:]\n\n    sum_radii = np.sum(radii_opt)\n    return centers_opt, radii_opt, sum_radii\n\ndef run_packing():\n    return construct_packing()\nRun 4 parallel chains at different temperatures (step sizes: 0.1, 0.05, 0.01, 0.002). Periodically swap configurations between chains. Use Sobol initialization and solve the LP for radii in every evaluation.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping, linprog\nfrom scipy.stats import qmc\nimport multiprocessing as mp\n\ndef construct_packing():\n    n_circles = 26\n    centers = np.zeros((n_circles, 2))\n    radii = np.zeros(n_circles)\n\n    def calculate_max_radius(center, existing_centers, existing_radii):\n        \"\"\"Calculates the maximum possible radius for a circle at the given center,\n        without overlapping existing circles or exceeding the boundaries of the unit square.\n        \"\"\"\n        min_dist_to_existing = np.inf\n        for i in range(len(existing_centers)):\n            dist = np.linalg.norm(center - existing_centers[i])\n            min_dist_to_existing = min(min_dist_to_existing, dist - existing_radii[i])\n\n        dist_to_boundary = min(center[0], center[1], 1 - center[0], 1 - center[1])\n\n        return min(min_dist_to_existing, dist_to_boundary)\n\n    # Greedy placement with Sobol sequence\n    num_samples = 4096\n    sampler = qmc.Sobol(d=2, scramble=False)\n    sample = sampler.random(n=num_samples)\n\n    for i in range(n_circles):\n        best_center = None\n        best_radius = -1\n\n        for j in range(num_samples):\n            center = sample[j]\n            radius = calculate_max_radius(center, centers[:i], radii[:i])\n\n            if radius > best_radius:\n                best_radius = radius\n                best_center = center\n\n        centers[i] = best_center\n        radii[i] = best_radius\n\n    # Parallel Tempering Basin Hopping\n    def objective(centers_opt):\n        \"\"\"Objective function to minimize the negative sum of radii, solving LP for radii.\"\"\"\n        # Solve LP for radii given centers\n        c = -np.ones(n_circles)  # Maximize sum of radii\n        A_ub = np.zeros((n_circles * (n_circles - 1) // 2 + 4 * n_circles, n_circles))\n        b_ub = np.zeros(n_circles * (n_circles - 1) // 2 + 4 * n_circles)\n        k = 0\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                A_ub[k, i] = 1\n                A_ub[k, j] = 1\n                b_ub[k] = np.linalg.norm(centers_opt[i] - centers_opt[j])\n                k += 1\n        for i in range(n_circles):\n            A_ub[k, i] = 1\n            b_ub[k] = centers_opt[i, 0]\n            k += 1\n            A_ub[k, i] = 1\n            b_ub[k] = centers_opt[i, 1]\n            k += 1\n            A_ub[k, i] = 1\n            b_ub[k] = 1 - centers_opt[i, 0]\n            k += 1\n            A_ub[k, i] = 1\n            b_ub[k] = 1 - centers_opt[i, 1]\n            k += 1\n\n        bounds = [(0, 0.15)] * n_circles  # Radii bounded by 0.15\n        result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n        if result.success:\n            radii_opt = result.x\n            return -np.sum(radii_opt), radii_opt\n        else:\n            return np.inf, None  # Return a high cost if LP fails\n\n    def parallel_tempering_step(centers, stepsize):\n        \"\"\"Performs a single step of Basin Hopping with a given stepsize.\"\"\"\n        centers_new = centers + np.random.normal(0, stepsize, size=centers.shape)\n        centers_new = np.clip(centers_new, 0, 1)  # Keep centers within [0, 1]\n\n        energy_current, radii_current = objective(centers)\n        energy_new, radii_new = objective(centers_new)\n\n        if energy_new < energy_current:\n            return centers_new, radii_new, energy_new\n        else:\n            acceptance_probability = np.exp(-(energy_new - energy_current))\n            if np.random.rand() < acceptance_probability:\n                return centers_new, radii_new, energy_new\n            else:\n                return centers, radii_current, energy_current\n\n    def run_chain(centers_initial, stepsize, iterations):\n        \"\"\"Runs a single parallel tempering chain.\"\"\"\n        centers = centers_initial.copy()\n        best_centers = centers.copy()\n        best_energy, radii = objective(centers)\n        best_radii = radii\n        \n        for _ in range(iterations):\n            centers, radii, energy = parallel_tempering_step(centers, stepsize)\n            if energy < best_energy:\n                best_energy = energy\n                best_centers = centers.copy()\n                best_radii = radii\n        return best_centers, best_radii, best_energy\n\n    # Parallel Tempering setup\n    num_chains = 4\n    stepsizes = [0.1, 0.05, 0.01, 0.002]\n    iterations = 250\n    centers_initial = centers.copy()\n    \n    # Run chains in parallel\n    with mp.Pool(processes=num_chains) as pool:\n        results = pool.starmap(run_chain, [(centers_initial, stepsize, iterations) for stepsize in stepsizes])\n\n    # Select the best result\n    best_energy = np.inf\n    best_centers = None\n    best_radii = None\n    for centers_opt, radii_opt, energy in results:\n        if energy < best_energy:\n            best_energy = energy\n            best_centers = centers_opt\n            best_radii = radii_opt\n\n    sum_radii = np.sum(best_radii)\n    return best_centers, best_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-11T19:43:34.818559",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.4,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 1361,
        "candidates_token_count": 1528,
        "thoughts_token_count": 0
      },
      "response_text_len": 5027
    }
  }
}