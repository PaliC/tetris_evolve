{
  "trial_id": "trial_12_6",
  "generation": 12,
  "parent_id": "trial_5_2",
  "code": "import numpy as np\nfrom scipy.optimize import differential_evolution\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    \"\"\"\n\n    def calculate_fitness(centers_flat):\n        \"\"\"\n        Calculates the fitness of a given arrangement of circle centers by solving a linear program\n        to determine the optimal radii that maximize their sum, subject to the constraints of\n        non-overlapping circles and containment within the unit square.\n\n        Args:\n            centers_flat (np.ndarray): A flattened array containing the x and y coordinates of the\n                                        centers of the 26 circles.  Shape (52,).\n\n        Returns:\n            float: The negative of the sum of the optimal radii, penalized for any constraint violations.\n                   The negative sign is used because differential_evolution minimizes the objective function.\n        \"\"\"\n        centers = centers_flat.reshape(26, 2)\n\n        # Define the objective function: maximize the sum of radii\n        # Since linprog minimizes, we use negative coefficients\n        c = np.array([-1] * 26)\n\n        # Define the constraints\n        # 1. Non-overlapping circles: distance between centers >= sum of radii\n        A_ub = []\n        b_ub = []\n        for i in range(26):\n            for j in range(i + 1, 26):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                row = np.zeros(26)\n                row[i] = 1\n                row[j] = 1\n                A_ub.append(row)\n                b_ub.append(dist)\n        A_ub = np.array(A_ub)\n        b_ub = np.array(b_ub)\n\n        # 2. Circles contained within the unit square: center + radius <= 1 and center - radius >= 0\n        A_ub_box = np.zeros((52, 26))\n        b_ub_box = np.zeros(52)\n        for i in range(26):\n            A_ub_box[2*i, i] = 1\n            b_ub_box[2*i] = 1 - centers[i, 0]\n            A_ub_box[2*i+1, i] = 1\n            b_ub_box[2*i+1] = 1 - centers[i, 1]\n\n        A_lb_box = np.zeros((52, 26))\n        b_lb_box = np.zeros(52)\n        for i in range(26):\n            A_lb_box[2*i, i] = -1\n            b_lb_box[2*i] = -centers[i, 0]\n            A_lb_box[2*i+1, i] = -1\n            b_lb_box[2*i+1] = -centers[i, 1]\n\n        A_ub = np.vstack([A_ub, A_ub_box, A_lb_box])\n        b_ub = np.concatenate([b_ub, b_ub_box, b_lb_box])\n\n        # Define bounds for radii (0 <= radius <= 1)\n        bounds = [(0, 1)] * 26\n\n        # Solve the linear program\n        try:\n            result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')  # Use highs method for better performance\n            radii = result.x\n            sum_radii = np.sum(radii)\n            penalty = 0\n        except:\n            # If linprog fails, heavily penalize the configuration\n            sum_radii = 0\n            penalty = 1e6\n\n        # Calculate penalty for constraint violations\n        constraints_violated = np.maximum(A_ub @ radii - b_ub, 0)\n        penalty += np.sum(constraints_violated) * 1e6\n\n        return -sum_radii - penalty\n\n    # Define bounds for the center coordinates (0 <= x, y <= 1)\n    bounds = [(0, 1)] * 52\n\n    # Use trial_5_2 centers as one member of the initial population\n    initial_centers = np.array([\n        [0.5000000000000000, 0.5000000000000000],\n        [0.5000000000000000, 0.1339745962155614],\n        [0.5000000000000000, 0.8660254037844386],\n        [0.1339745962155614, 0.5000000000000000],\n        [0.8660254037844386, 0.5000000000000000],\n        [0.1339745962155614, 0.1339745962155614],\n        [0.8660254037844386, 0.1339745962155614],\n        [0.1339745962155614, 0.8660254037844386],\n        [0.8660254037844386, 0.8660254037844386],\n        [0.5000000000000000, 0.3102391771540915],\n        [0.5000000000000000, 0.6897608228459085],\n        [0.3102391771540915, 0.5000000000000000],\n        [0.6897608228459085, 0.5000000000000000],\n        [0.1339745962155614, 0.3102391771540915],\n        [0.8660254037844386, 0.3102391771540915],\n        [0.1339745962155614, 0.6897608228459085],\n        [0.8660254037844386, 0.6897608228459085],\n        [0.3102391771540915, 0.1339745962155614],\n        [0.6897608228459085, 0.1339745962155614],\n        [0.3102391771540915, 0.8660254037844386],\n        [0.6897608228459085, 0.8660254037844386],\n        [0.3102391771540915, 0.3102391771540915],\n        [0.6897608228459085, 0.3102391771540915],\n        [0.3102391771540915, 0.6897608228459085],\n        [0.6897608228459085, 0.6897608228459085]\n    ])\n    initial_centers_flat = initial_centers.flatten()\n\n    # Run differential evolution\n    popsize = 50\n    initial_population = np.random.rand(popsize, 52)\n    for i in range(52):\n        initial_population[:, i] = initial_population[:, i] * (bounds[i][1] - bounds[i][0]) + bounds[i][0]\n    initial_population[0, :] = initial_centers_flat\n\n    result = differential_evolution(\n        calculate_fitness,\n        bounds,\n        popsize=popsize,\n        mutation=(0.5, 1),\n        recombination=0.7,\n        seed=42,\n        maxiter=1000,\n        tol=1e-6,\n        init=initial_population,\n        disp=False,\n        strategy='best1bin'\n    )\n\n    # Extract the optimized centers\n    optimized_centers = result.x.reshape(26, 2)\n\n    # Calculate the optimal radii for the optimized centers\n    c = np.array([-1] * 26)\n    A_ub = []\n    b_ub = []\n    for i in range(26):\n        for j in range(i + 1, 26):\n            dist = np.linalg.norm(optimized_centers[i] - optimized_centers[j])\n            row = np.zeros(26)\n            row[i] = 1\n            row[j] = 1\n            A_ub.append(row)\n            b_ub.append(dist)\n    A_ub = np.array(A_ub)\n    b_ub = np.array(b_ub)\n\n    A_ub_box = np.zeros((52, 26))\n    b_ub_box = np.zeros(52)\n    for i in range(26):\n        A_ub_box[2*i, i] = 1\n        b_ub_box[2*i] = 1 - optimized_centers[i, 0]\n        A_ub_box[2*i+1, i] = 1\n        b_ub_box[2*i+1] = 1 - optimized_centers[i, 1]\n\n    A_lb_box = np.zeros((52, 26))\n    b_lb_box = np.zeros(52)\n    for i in range(26):\n        A_lb_box[2*i, i] = -1\n        b_lb_box[2*i] = -optimized_centers[i, 0]\n        A_lb_box[2*i+1, i] = -1\n        b_lb_box[2*i+1] = -optimized_centers[i, 1]\n\n    A_ub = np.vstack([A_ub, A_ub_box, A_lb_box])\n    b_ub = np.concatenate([b_ub, b_ub_box, b_lb_box])\n\n    bounds = [(0, 1)] * 26\n    result_radii = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n    radii = result_radii.x\n    sum_radii = np.sum(radii)\n\n    return optimized_centers, radii, sum_radii\n\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 0.2618257999420166,
    "error": "ValueError: could not broadcast input array from shape (50,) into shape (52,)"
  },
  "prompt": "Pack 26 circles. Use `scipy.optimize.differential_evolution` to optimize the 52 center coordinates. For each candidate set of centers in the population, calculate the fitness by solving the Linear Programming problem for optimal radii. Use the centers from trial_5_2 as one member of the initial population. Use a large population and high penalty for infeasibility.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import differential_evolution\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    \"\"\"\n\n    def calculate_fitness(centers_flat):\n        \"\"\"\n        Calculates the fitness of a given arrangement of circle centers by solving a linear program\n        to determine the optimal radii that maximize their sum, subject to the constraints of\n        non-overlapping circles and containment within the unit square.\n\n        Args:\n            centers_flat (np.ndarray): A flattened array containing the x and y coordinates of the\n                                        centers of the 26 circles.  Shape (52,).\n\n        Returns:\n            float: The negative of the sum of the optimal radii, penalized for any constraint violations.\n                   The negative sign is used because differential_evolution minimizes the objective function.\n        \"\"\"\n        centers = centers_flat.reshape(26, 2)\n\n        # Define the objective function: maximize the sum of radii\n        # Since linprog minimizes, we use negative coefficients\n        c = np.array([-1] * 26)\n\n        # Define the constraints\n        # 1. Non-overlapping circles: distance between centers >= sum of radii\n        A_ub = []\n        b_ub = []\n        for i in range(26):\n            for j in range(i + 1, 26):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                row = np.zeros(26)\n                row[i] = 1\n                row[j] = 1\n                A_ub.append(row)\n                b_ub.append(dist)\n        A_ub = np.array(A_ub)\n        b_ub = np.array(b_ub)\n\n        # 2. Circles contained within the unit square: center + radius <= 1 and center - radius >= 0\n        A_ub_box = np.zeros((52, 26))\n        b_ub_box = np.zeros(52)\n        for i in range(26):\n            A_ub_box[2*i, i] = 1\n            b_ub_box[2*i] = 1 - centers[i, 0]\n            A_ub_box[2*i+1, i] = 1\n            b_ub_box[2*i+1] = 1 - centers[i, 1]\n\n        A_lb_box = np.zeros((52, 26))\n        b_lb_box = np.zeros(52)\n        for i in range(26):\n            A_lb_box[2*i, i] = -1\n            b_lb_box[2*i] = -centers[i, 0]\n            A_lb_box[2*i+1, i] = -1\n            b_lb_box[2*i+1] = -centers[i, 1]\n\n        A_ub = np.vstack([A_ub, A_ub_box, A_lb_box])\n        b_ub = np.concatenate([b_ub, b_ub_box, b_lb_box])\n\n        # Define bounds for radii (0 <= radius <= 1)\n        bounds = [(0, 1)] * 26\n\n        # Solve the linear program\n        try:\n            result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')  # Use highs method for better performance\n            radii = result.x\n            sum_radii = np.sum(radii)\n            penalty = 0\n        except:\n            # If linprog fails, heavily penalize the configuration\n            sum_radii = 0\n            penalty = 1e6\n\n        # Calculate penalty for constraint violations\n        constraints_violated = np.maximum(A_ub @ radii - b_ub, 0)\n        penalty += np.sum(constraints_violated) * 1e6\n\n        return -sum_radii - penalty\n\n    # Define bounds for the center coordinates (0 <= x, y <= 1)\n    bounds = [(0, 1)] * 52\n\n    # Use trial_5_2 centers as one member of the initial population\n    initial_centers = np.array([\n        [0.5000000000000000, 0.5000000000000000],\n        [0.5000000000000000, 0.1339745962155614],\n        [0.5000000000000000, 0.8660254037844386],\n        [0.1339745962155614, 0.5000000000000000],\n        [0.8660254037844386, 0.5000000000000000],\n        [0.1339745962155614, 0.1339745962155614],\n        [0.8660254037844386, 0.1339745962155614],\n        [0.1339745962155614, 0.8660254037844386],\n        [0.8660254037844386, 0.8660254037844386],\n        [0.5000000000000000, 0.3102391771540915],\n        [0.5000000000000000, 0.6897608228459085],\n        [0.3102391771540915, 0.5000000000000000],\n        [0.6897608228459085, 0.5000000000000000],\n        [0.1339745962155614, 0.3102391771540915],\n        [0.8660254037844386, 0.3102391771540915],\n        [0.1339745962155614, 0.6897608228459085],\n        [0.8660254037844386, 0.6897608228459085],\n        [0.3102391771540915, 0.1339745962155614],\n        [0.6897608228459085, 0.1339745962155614],\n        [0.3102391771540915, 0.8660254037844386],\n        [0.6897608228459085, 0.8660254037844386],\n        [0.3102391771540915, 0.3102391771540915],\n        [0.6897608228459085, 0.3102391771540915],\n        [0.3102391771540915, 0.6897608228459085],\n        [0.6897608228459085, 0.6897608228459085]\n    ])\n    initial_centers_flat = initial_centers.flatten()\n\n    # Run differential evolution\n    popsize = 50\n    initial_population = np.random.rand(popsize, 52)\n    for i in range(52):\n        initial_population[:, i] = initial_population[:, i] * (bounds[i][1] - bounds[i][0]) + bounds[i][0]\n    initial_population[0, :] = initial_centers_flat\n\n    result = differential_evolution(\n        calculate_fitness,\n        bounds,\n        popsize=popsize,\n        mutation=(0.5, 1),\n        recombination=0.7,\n        seed=42,\n        maxiter=1000,\n        tol=1e-6,\n        init=initial_population,\n        disp=False,\n        strategy='best1bin'\n    )\n\n    # Extract the optimized centers\n    optimized_centers = result.x.reshape(26, 2)\n\n    # Calculate the optimal radii for the optimized centers\n    c = np.array([-1] * 26)\n    A_ub = []\n    b_ub = []\n    for i in range(26):\n        for j in range(i + 1, 26):\n            dist = np.linalg.norm(optimized_centers[i] - optimized_centers[j])\n            row = np.zeros(26)\n            row[i] = 1\n            row[j] = 1\n            A_ub.append(row)\n            b_ub.append(dist)\n    A_ub = np.array(A_ub)\n    b_ub = np.array(b_ub)\n\n    A_ub_box = np.zeros((52, 26))\n    b_ub_box = np.zeros(52)\n    for i in range(26):\n        A_ub_box[2*i, i] = 1\n        b_ub_box[2*i] = 1 - optimized_centers[i, 0]\n        A_ub_box[2*i+1, i] = 1\n        b_ub_box[2*i+1] = 1 - optimized_centers[i, 1]\n\n    A_lb_box = np.zeros((52, 26))\n    b_lb_box = np.zeros(52)\n    for i in range(26):\n        A_lb_box[2*i, i] = -1\n        b_lb_box[2*i] = -optimized_centers[i, 0]\n        A_lb_box[2*i+1, i] = -1\n        b_lb_box[2*i+1] = -optimized_centers[i, 1]\n\n    A_ub = np.vstack([A_ub, A_ub_box, A_lb_box])\n    b_ub = np.concatenate([b_ub, b_ub_box, b_lb_box])\n\n    bounds = [(0, 1)] * 26\n    result_radii = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n    radii = result_radii.x\n    sum_radii = np.sum(radii)\n\n    return optimized_centers, radii, sum_radii\n\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-11T19:45:59.982068",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.5,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 297,
        "candidates_token_count": 2891,
        "thoughts_token_count": 0
      },
      "response_text_len": 6642
    }
  }
}