{
  "trial_id": "trial_12_9",
  "generation": 12,
  "parent_id": "trial_5_2",
  "code": "import numpy as np\nfrom scipy.optimize import linprog\nimport cma\n\ndef construct_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses CMA-ES to optimize the circle centers and Linear Programming to optimize the radii.\n    \"\"\"\n\n    def evaluate_fitness(centers):\n        \"\"\"\n        Evaluates the fitness of a given configuration of circle centers by optimizing the radii using Linear Programming.\n        \"\"\"\n        n = 26\n        # Distance matrix\n        dist = np.linalg.norm(centers[:, None, :] - centers[None, :, :], axis=2)\n\n        # LP formulation: maximize sum(r) subject to distance constraints and box constraints\n        # Objective function: minimize -sum(r)\n        c = -np.ones(n)\n\n        # Inequality constraints: A_ub @ r <= b_ub\n        # Distance constraints: r_i + r_j <= dist_ij\n        A_dist = np.zeros((n * (n - 1) // 2, n))\n        b_dist = np.zeros(n * (n - 1) // 2)\n        k = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                A_dist[k, i] = 1\n                A_dist[k, j] = 1\n                b_dist[k] = dist[i, j]\n                k += 1\n\n        # Box constraints: r_i <= centers[i, 0], r_i <= 1 - centers[i, 0], r_i <= centers[i, 1], r_i <= 1 - centers[i, 1]\n        A_box = np.zeros((4 * n, n))\n        b_box = np.zeros(4 * n)\n        for i in range(n):\n            A_box[4 * i, i] = 1\n            b_box[4 * i] = centers[i, 0]\n            A_box[4 * i + 1, i] = 1\n            b_box[4 * i + 1] = 1 - centers[i, 0]\n            A_box[4 * i + 2, i] = 1\n            b_box[4 * i + 2] = centers[i, 1]\n            A_box[4 * i + 3, i] = 1\n            b_box[4 * i + 3] = 1 - centers[i, 1]\n\n        # Combine constraints\n        A_ub = np.vstack([A_dist, A_box])\n        b_ub = np.concatenate([b_dist, b_box])\n\n        # Bounds: r_i >= 0\n        bounds = [(0, None)] * n\n\n        # Solve LP\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n        if res.success:\n            return res.fun  # Return negative sum of radii (since we are minimizing)\n        else:\n            return -1e-6  # Return a very bad value if LP fails\n\n    # Initial guess for circle centers (trial_5_2 layout)\n    initial_centers = np.array([\n        [0.5, 0.5],\n        [0.25, 0.25],\n        [0.75, 0.25],\n        [0.25, 0.75],\n        [0.75, 0.75],\n        [0.5, 0.25],\n        [0.5, 0.75],\n        [0.25, 0.5],\n        [0.75, 0.5],\n        [0.125, 0.125],\n        [0.875, 0.125],\n        [0.125, 0.875],\n        [0.875, 0.875],\n        [0.125, 0.5],\n        [0.875, 0.5],\n        [0.5, 0.125],\n        [0.5, 0.875],\n        [0.375, 0.375],\n        [0.625, 0.375],\n        [0.375, 0.625],\n        [0.625, 0.625],\n        [0.25, 0.0625],\n        [0.75, 0.0625],\n        [0.25, 0.9375],\n        [0.75, 0.9375],\n        [0.0625, 0.25]\n    ])\n\n    # Flatten the initial centers for CMA-ES\n    initial_x = initial_centers.flatten()\n\n    # Define the optimization function\n    def fitness(x):\n        centers = x.reshape(26, 2)\n        # Constraint: centers must be within [0, 1] x [0, 1]\n        if np.any(centers < 0) or np.any(centers > 1):\n            return -1e-6  # Very bad fitness if outside the box\n        return evaluate_fitness(centers)\n\n    # Run CMA-ES\n    sigma = 0.05  # Initial step size\n    es = cma.CMAEvolutionStrategy(initial_x, sigma, {'bounds': [0, 1], 'popsize': 30})\n    es.optimize(fitness)\n\n    # Get the best solution\n    best_x = es.result.xbest\n    best_centers = best_x.reshape(26, 2)\n\n    # Optimize radii for the best centers\n    n = 26\n    dist = np.linalg.norm(best_centers[:, None, :] - best_centers[None, :, :], axis=2)\n    c = -np.ones(n)\n    A_dist = np.zeros((n * (n - 1) // 2, n))\n    b_dist = np.zeros(n * (n - 1) // 2)\n    k = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_dist[k, i] = 1\n            A_dist[k, j] = 1\n            b_dist[k] = dist[i, j]\n            k += 1\n    A_box = np.zeros((4 * n, n))\n    b_box = np.zeros(4 * n)\n    for i in range(n):\n        A_box[4 * i, i] = 1\n        b_box[4 * i] = best_centers[i, 0]\n        A_box[4 * i + 1, i] = 1\n        b_box[4 * i + 1] = 1 - best_centers[i, 0]\n        A_box[4 * i + 2, i] = 1\n        b_box[4 * i + 2] = best_centers[i, 1]\n        A_box[4 * i + 3, i] = 1\n        b_box[4 * i + 3] = 1 - best_centers[i, 1]\n    A_ub = np.vstack([A_dist, A_box])\n    b_ub = np.concatenate([b_dist, b_box])\n    bounds = [(0, None)] * n\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n    if res.success:\n        best_radii = res.x\n        sum_radii = np.sum(best_radii)\n    else:\n        best_radii = np.zeros(n)\n        sum_radii = 0\n\n    return best_centers, best_radii, sum_radii\n\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 0.24403882026672363,
    "error": "ModuleNotFoundError: No module named 'cma'"
  },
  "prompt": "Pack 26 circles. Use 'CMA-ES' logic to optimize the 52 center coordinates. For each individual, evaluate fitness by solving the Linear Programming problem for radii. Use the trial_5_2 layout as the initial mean of the distribution and a small sigma for the mutation.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nimport cma\n\ndef construct_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses CMA-ES to optimize the circle centers and Linear Programming to optimize the radii.\n    \"\"\"\n\n    def evaluate_fitness(centers):\n        \"\"\"\n        Evaluates the fitness of a given configuration of circle centers by optimizing the radii using Linear Programming.\n        \"\"\"\n        n = 26\n        # Distance matrix\n        dist = np.linalg.norm(centers[:, None, :] - centers[None, :, :], axis=2)\n\n        # LP formulation: maximize sum(r) subject to distance constraints and box constraints\n        # Objective function: minimize -sum(r)\n        c = -np.ones(n)\n\n        # Inequality constraints: A_ub @ r <= b_ub\n        # Distance constraints: r_i + r_j <= dist_ij\n        A_dist = np.zeros((n * (n - 1) // 2, n))\n        b_dist = np.zeros(n * (n - 1) // 2)\n        k = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                A_dist[k, i] = 1\n                A_dist[k, j] = 1\n                b_dist[k] = dist[i, j]\n                k += 1\n\n        # Box constraints: r_i <= centers[i, 0], r_i <= 1 - centers[i, 0], r_i <= centers[i, 1], r_i <= 1 - centers[i, 1]\n        A_box = np.zeros((4 * n, n))\n        b_box = np.zeros(4 * n)\n        for i in range(n):\n            A_box[4 * i, i] = 1\n            b_box[4 * i] = centers[i, 0]\n            A_box[4 * i + 1, i] = 1\n            b_box[4 * i + 1] = 1 - centers[i, 0]\n            A_box[4 * i + 2, i] = 1\n            b_box[4 * i + 2] = centers[i, 1]\n            A_box[4 * i + 3, i] = 1\n            b_box[4 * i + 3] = 1 - centers[i, 1]\n\n        # Combine constraints\n        A_ub = np.vstack([A_dist, A_box])\n        b_ub = np.concatenate([b_dist, b_box])\n\n        # Bounds: r_i >= 0\n        bounds = [(0, None)] * n\n\n        # Solve LP\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n        if res.success:\n            return res.fun  # Return negative sum of radii (since we are minimizing)\n        else:\n            return -1e-6  # Return a very bad value if LP fails\n\n    # Initial guess for circle centers (trial_5_2 layout)\n    initial_centers = np.array([\n        [0.5, 0.5],\n        [0.25, 0.25],\n        [0.75, 0.25],\n        [0.25, 0.75],\n        [0.75, 0.75],\n        [0.5, 0.25],\n        [0.5, 0.75],\n        [0.25, 0.5],\n        [0.75, 0.5],\n        [0.125, 0.125],\n        [0.875, 0.125],\n        [0.125, 0.875],\n        [0.875, 0.875],\n        [0.125, 0.5],\n        [0.875, 0.5],\n        [0.5, 0.125],\n        [0.5, 0.875],\n        [0.375, 0.375],\n        [0.625, 0.375],\n        [0.375, 0.625],\n        [0.625, 0.625],\n        [0.25, 0.0625],\n        [0.75, 0.0625],\n        [0.25, 0.9375],\n        [0.75, 0.9375],\n        [0.0625, 0.25]\n    ])\n\n    # Flatten the initial centers for CMA-ES\n    initial_x = initial_centers.flatten()\n\n    # Define the optimization function\n    def fitness(x):\n        centers = x.reshape(26, 2)\n        # Constraint: centers must be within [0, 1] x [0, 1]\n        if np.any(centers < 0) or np.any(centers > 1):\n            return -1e-6  # Very bad fitness if outside the box\n        return evaluate_fitness(centers)\n\n    # Run CMA-ES\n    sigma = 0.05  # Initial step size\n    es = cma.CMAEvolutionStrategy(initial_x, sigma, {'bounds': [0, 1], 'popsize': 30})\n    es.optimize(fitness)\n\n    # Get the best solution\n    best_x = es.result.xbest\n    best_centers = best_x.reshape(26, 2)\n\n    # Optimize radii for the best centers\n    n = 26\n    dist = np.linalg.norm(best_centers[:, None, :] - best_centers[None, :, :], axis=2)\n    c = -np.ones(n)\n    A_dist = np.zeros((n * (n - 1) // 2, n))\n    b_dist = np.zeros(n * (n - 1) // 2)\n    k = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_dist[k, i] = 1\n            A_dist[k, j] = 1\n            b_dist[k] = dist[i, j]\n            k += 1\n    A_box = np.zeros((4 * n, n))\n    b_box = np.zeros(4 * n)\n    for i in range(n):\n        A_box[4 * i, i] = 1\n        b_box[4 * i] = best_centers[i, 0]\n        A_box[4 * i + 1, i] = 1\n        b_box[4 * i + 1] = 1 - best_centers[i, 0]\n        A_box[4 * i + 2, i] = 1\n        b_box[4 * i + 2] = best_centers[i, 1]\n        A_box[4 * i + 3, i] = 1\n        b_box[4 * i + 3] = 1 - best_centers[i, 1]\n    A_ub = np.vstack([A_dist, A_box])\n    b_ub = np.concatenate([b_dist, b_box])\n    bounds = [(0, None)] * n\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n    if res.success:\n        best_radii = res.x\n        sum_radii = np.sum(best_radii)\n    else:\n        best_radii = np.zeros(n)\n        sum_radii = 0\n\n    return best_centers, best_radii, sum_radii\n\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-11T19:45:55.868540",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.5,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 281,
        "candidates_token_count": 1941,
        "thoughts_token_count": 0
      },
      "response_text_len": 4807
    }
  }
}