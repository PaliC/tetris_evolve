{
  "trial_id": "trial_3_4",
  "generation": 3,
  "parent_id": "trial_2_1",
  "code": "import numpy as np\nfrom scipy.optimize import linprog, minimize\nimport random\nimport math\n\ndef calculate_radii(centers):\n    \"\"\"Calculates the optimal radii for given center locations using Linear Programming.\"\"\"\n    n = len(centers)\n    # Objective function: maximize sum of radii\n    c = [-1] * n\n    # Inequality constraints:\n    # 1. Circles inside the square: x_i + r_i <= 1, 1 - x_i + r_i <= 1, y_i + r_i <= 1, 1 - y_i + r_i <= 1\n    # 2. No overlaps: r_i + r_j <= distance(center_i, center_j)\n    A = []\n    b = []\n\n    # Constraint 1: Circles inside the square\n    for i in range(n):\n        A.append([0] * i + [1] + [0] * (n - i - 1))\n        b.append(1 - centers[i, 0])\n        A.append([0] * i + [1] + [0] * (n - i - 1))\n        b.append(centers[i, 0])\n        A.append([0] * i + [1] + [0] * (n - i - 1))\n        b.append(1 - centers[i, 1])\n        A.append([0] * i + [1] + [0] * (n - i - 1))\n        b.append(centers[i, 1])\n\n    # Constraint 2: No overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            distance = np.linalg.norm(centers[i] - centers[j])\n            row = [0] * n\n            row[i] = 1\n            row[j] = 1\n            A.append(row)\n            b.append(distance)\n\n    # Solve the LP\n    result = linprog(c, A_ub=A, b_ub=b, bounds=(0, None))\n\n    if result.success:\n        radii = result.x\n        sum_radii = -result.fun\n        return radii, sum_radii\n    else:\n        return None, -np.inf  # Return a very low sum_radii if LP fails\n\ndef energy(centers):\n    \"\"\"Calculates the energy of a state (center configuration).\"\"\"\n    radii, sum_radii = calculate_radii(centers)\n    return -sum_radii  # We want to maximize sum_radii, so minimize negative sum_radii\n\ndef neighbor(centers, step_size=0.01):\n    \"\"\"Generates a neighboring state by slightly perturbing the center locations.\"\"\"\n    new_centers = centers.copy()\n    for i in range(len(centers)):\n        new_centers[i, 0] += random.uniform(-step_size, step_size)\n        new_centers[i, 1] += random.uniform(-step_size, step_size)\n        # Ensure centers stay within the unit square (soft constraint)\n        new_centers[i, 0] = max(0, min(1, new_centers[i, 0]))\n        new_centers[i, 1] = max(0, min(1, new_centers[i, 1]))\n    return new_centers\n\ndef acceptance_probability(old_energy, new_energy, temperature):\n    \"\"\"Calculates the acceptance probability for a new state in Simulated Annealing.\"\"\"\n    if new_energy < old_energy:\n        return 1.0\n    else:\n        return np.exp((old_energy - new_energy) / temperature)\n\ndef simulated_annealing(initial_centers, initial_temperature=100, cooling_rate=0.99, num_iterations=10000):\n    \"\"\"Performs Simulated Annealing to optimize center locations.\"\"\"\n    current_centers = initial_centers.copy()\n    best_centers = initial_centers.copy()\n    current_energy = energy(current_centers)\n    best_energy = current_energy\n    temperature = initial_temperature\n\n    for i in range(num_iterations):\n        new_centers = neighbor(current_centers)\n        new_energy = energy(new_centers)\n\n        if acceptance_probability(current_energy, new_energy, temperature) > random.random():\n            current_centers = new_centers.copy()\n            current_energy = new_energy\n\n        if current_energy < best_energy:\n            best_centers = current_centers.copy()\n            best_energy = current_energy\n\n        temperature *= cooling_rate\n\n    return best_centers, best_energy\n\ndef polish_centers(centers):\n    \"\"\"Polishes the center locations using SLSQP optimization, keeping LP radii optimization.\"\"\"\n\n    def objective(x):\n        # Reshape x back into centers array\n        reshaped_centers = x.reshape(-1, 2)\n        # Calculate the energy (negative sum of radii) using the LP solver\n        return energy(reshaped_centers)\n\n    # Flatten the centers array for the optimizer\n    initial_x = centers.flatten()\n\n    # Define bounds to keep centers within the unit square\n    bounds = [(0, 1)] * (2 * len(centers))\n\n    # Define the constraint function\n    def constraint(x):\n        reshaped_centers = x.reshape(-1, 2)\n        radii, _ = calculate_radii(reshaped_centers)\n        if radii is None:\n            return -1  # Indicate invalid radii, to be rejected\n        return 1 # Indicate valid radii.\n\n    constraints = ({'type': 'ineq', 'fun': constraint})\n\n    # Use SLSQP to polish the centers\n    result = minimize(objective, initial_x, method='SLSQP', bounds=bounds, constraints=constraints, options={'maxiter': 500})\n\n    if result.success:\n        polished_centers = result.x.reshape(-1, 2)\n        return polished_centers, energy(polished_centers)\n    else:\n        print(\"SLSQP optimization failed:\", result.message)\n        return centers, energy(centers)  # Return original centers if optimization fails\n\ndef construct_packing():\n    \"\"\"Constructs the circle packing using Simulated Annealing and SLSQP polishing.\"\"\"\n    n = 26\n    # Initialize centers randomly\n    initial_centers = np.random.rand(n, 2)\n\n    # Run Simulated Annealing\n    best_centers, best_energy = simulated_annealing(initial_centers)\n\n    # Polish the centers using SLSQP\n    polished_centers, polished_energy = polish_centers(best_centers)\n\n    # Calculate the final radii and sum_radii\n    radii, sum_radii = calculate_radii(polished_centers)\n\n    return polished_centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.464153468908266,
    "eval_time": 25.205745220184326,
    "error": null
  },
  "prompt": "Pack 26 circles. Implement a 'Simulated Annealing on Centers' approach. The state is the 26 center positions. The energy is -1 * (sum of optimal radii for those centers, calculated via Linear Programming). Use SA to explore the center configurations, and for the final 500 steps, use SLSQP to polish the centers while keeping the LP radii optimization.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\nimport random\nimport math\n\ndef calculate_radii(centers):\n    \"\"\"Calculates the optimal radii for given center locations using Linear Programming.\"\"\"\n    n = len(centers)\n    # Objective function: maximize sum of radii\n    c = [-1] * n\n    # Inequality constraints:\n    # 1. Circles inside the square: x_i + r_i <= 1, 1 - x_i + r_i <= 1, y_i + r_i <= 1, 1 - y_i + r_i <= 1\n    # 2. No overlaps: r_i + r_j <= distance(center_i, center_j)\n    A = []\n    b = []\n\n    # Constraint 1: Circles inside the square\n    for i in range(n):\n        A.append([0] * i + [1] + [0] * (n - i - 1))\n        b.append(1 - centers[i, 0])\n        A.append([0] * i + [1] + [0] * (n - i - 1))\n        b.append(centers[i, 0])\n        A.append([0] * i + [1] + [0] * (n - i - 1))\n        b.append(1 - centers[i, 1])\n        A.append([0] * i + [1] + [0] * (n - i - 1))\n        b.append(centers[i, 1])\n\n    # Constraint 2: No overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            distance = np.linalg.norm(centers[i] - centers[j])\n            row = [0] * n\n            row[i] = 1\n            row[j] = 1\n            A.append(row)\n            b.append(distance)\n\n    # Solve the LP\n    result = linprog(c, A_ub=A, b_ub=b, bounds=(0, None))\n\n    if result.success:\n        radii = result.x\n        sum_radii = -result.fun\n        return radii, sum_radii\n    else:\n        return None, -np.inf  # Return a very low sum_radii if LP fails\n\ndef energy(centers):\n    \"\"\"Calculates the energy of a state (center configuration).\"\"\"\n    radii, sum_radii = calculate_radii(centers)\n    return -sum_radii  # We want to maximize sum_radii, so minimize negative sum_radii\n\ndef neighbor(centers, step_size=0.01):\n    \"\"\"Generates a neighboring state by slightly perturbing the center locations.\"\"\"\n    new_centers = centers.copy()\n    for i in range(len(centers)):\n        new_centers[i, 0] += random.uniform(-step_size, step_size)\n        new_centers[i, 1] += random.uniform(-step_size, step_size)\n        # Ensure centers stay within the unit square (soft constraint)\n        new_centers[i, 0] = max(0, min(1, new_centers[i, 0]))\n        new_centers[i, 1] = max(0, min(1, new_centers[i, 1]))\n    return new_centers\n\ndef acceptance_probability(old_energy, new_energy, temperature):\n    \"\"\"Calculates the acceptance probability for a new state in Simulated Annealing.\"\"\"\n    if new_energy < old_energy:\n        return 1.0\n    else:\n        return np.exp((old_energy - new_energy) / temperature)\n\ndef simulated_annealing(initial_centers, initial_temperature=100, cooling_rate=0.99, num_iterations=10000):\n    \"\"\"Performs Simulated Annealing to optimize center locations.\"\"\"\n    current_centers = initial_centers.copy()\n    best_centers = initial_centers.copy()\n    current_energy = energy(current_centers)\n    best_energy = current_energy\n    temperature = initial_temperature\n\n    for i in range(num_iterations):\n        new_centers = neighbor(current_centers)\n        new_energy = energy(new_centers)\n\n        if acceptance_probability(current_energy, new_energy, temperature) > random.random():\n            current_centers = new_centers.copy()\n            current_energy = new_energy\n\n        if current_energy < best_energy:\n            best_centers = current_centers.copy()\n            best_energy = current_energy\n\n        temperature *= cooling_rate\n\n    return best_centers, best_energy\n\ndef polish_centers(centers):\n    \"\"\"Polishes the center locations using SLSQP optimization, keeping LP radii optimization.\"\"\"\n\n    def objective(x):\n        # Reshape x back into centers array\n        reshaped_centers = x.reshape(-1, 2)\n        # Calculate the energy (negative sum of radii) using the LP solver\n        return energy(reshaped_centers)\n\n    # Flatten the centers array for the optimizer\n    initial_x = centers.flatten()\n\n    # Define bounds to keep centers within the unit square\n    bounds = [(0, 1)] * (2 * len(centers))\n\n    # Define the constraint function\n    def constraint(x):\n        reshaped_centers = x.reshape(-1, 2)\n        radii, _ = calculate_radii(reshaped_centers)\n        if radii is None:\n            return -1  # Indicate invalid radii, to be rejected\n        return 1 # Indicate valid radii.\n\n    constraints = ({'type': 'ineq', 'fun': constraint})\n\n    # Use SLSQP to polish the centers\n    result = minimize(objective, initial_x, method='SLSQP', bounds=bounds, constraints=constraints, options={'maxiter': 500})\n\n    if result.success:\n        polished_centers = result.x.reshape(-1, 2)\n        return polished_centers, energy(polished_centers)\n    else:\n        print(\"SLSQP optimization failed:\", result.message)\n        return centers, energy(centers)  # Return original centers if optimization fails\n\ndef construct_packing():\n    \"\"\"Constructs the circle packing using Simulated Annealing and SLSQP polishing.\"\"\"\n    n = 26\n    # Initialize centers randomly\n    initial_centers = np.random.rand(n, 2)\n\n    # Run Simulated Annealing\n    best_centers, best_energy = simulated_annealing(initial_centers)\n\n    # Polish the centers using SLSQP\n    polished_centers, polished_energy = polish_centers(best_centers)\n\n    # Calculate the final radii and sum_radii\n    radii, sum_radii = calculate_radii(polished_centers)\n\n    return polished_centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-11T19:23:31.325653",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.6,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 300,
        "candidates_token_count": 1608,
        "thoughts_token_count": 0
      },
      "response_text_len": 5403
    }
  }
}