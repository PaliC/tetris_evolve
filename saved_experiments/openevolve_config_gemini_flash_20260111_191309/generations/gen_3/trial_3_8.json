{
  "trial_id": "trial_3_8",
  "generation": 3,
  "parent_id": "trial_2_8",
  "code": "import numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    def fitness(centers):\n        \"\"\"\n        Calculates the fitness of a given configuration of circle centers by\n        solving a linear program to maximize the sum of radii, subject to\n        non-overlap and containment constraints.\n\n        Args:\n            centers (np.ndarray): A numpy array of shape (26, 2) representing the\n                                   x and y coordinates of the centers of the circles.\n\n        Returns:\n            float: The sum of the radii of the circles, or -np.inf if the\n                   constraints cannot be satisfied.\n        \"\"\"\n        # Constraint 1: Circles are contained within the unit square\n        A_ub = np.concatenate([np.eye(26), -np.eye(26)], axis=0)\n        b_ub = np.concatenate([1 - centers[:, 0], centers[:, 0],\n                               1 - centers[:, 1], centers[:, 1]])\n\n        # Constraint 2: Circles do not overlap\n        A_overlap = []\n        b_overlap = []\n        for i in range(26):\n            for j in range(i + 1, 26):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist == 0:\n                    return -np.inf  # Circles at the same spot\n                a = np.zeros(26)\n                a[i] = -1\n                a[j] = -1\n                A_overlap.append(a)\n                b_overlap.append(-dist)\n\n        A_ub = np.concatenate([A_ub, np.array(A_overlap)], axis=0)\n        b_ub = np.concatenate([b_ub, np.array(b_overlap)])\n\n        # Objective function: maximize the sum of radii\n        c = -np.ones(26)\n\n        # Solve the linear program\n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=(0, None), method='highs')\n            if res.success:\n                return -res.fun  # Return the sum of radii\n            else:\n                return -np.inf  # Indicate that the constraints could not be satisfied\n        except:\n            return -np.inf\n\n    def pso(n_particles, n_iterations):\n        \"\"\"\n        Performs Particle Swarm Optimization to find the optimal configuration\n        of circle centers that maximizes the sum of radii.\n\n        Args:\n            n_particles (int): The number of particles in the swarm.\n            n_iterations (int): The number of iterations to run the PSO algorithm.\n\n        Returns:\n            tuple: A tuple containing the best centers found, the corresponding radii,\n                   and the sum of the radii.\n        \"\"\"\n        # Initialize particles\n        particles = np.random.rand(n_particles, 26, 2)\n        velocities = np.random.rand(n_particles, 26, 2) * 0.1  # Initialize velocities\n\n        # Initialize personal best positions and fitnesses\n        personal_best_positions = particles.copy()\n        personal_best_fitnesses = np.array([fitness(p) for p in particles])\n\n        # Initialize global best position and fitness\n        global_best_index = np.argmax(personal_best_fitnesses)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_fitness = personal_best_fitnesses[global_best_index]\n\n        # PSO parameters\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive coefficient\n        c2 = 1.5  # Social coefficient\n\n        # Iterate\n        for i in range(n_iterations):\n            for j in range(n_particles):\n                # Update velocity\n                r1 = np.random.rand(26, 2)\n                r2 = np.random.rand(26, 2)\n                velocities[j] = (w * velocities[j] +\n                                 c1 * r1 * (personal_best_positions[j] - particles[j]) +\n                                 c2 * r2 * (global_best_position - particles[j]))\n\n                # Update position\n                particles[j] = particles[j] + velocities[j]\n                particles[j] = np.clip(particles[j], 0, 1)  # Keep particles within bounds\n\n                # Evaluate fitness\n                current_fitness = fitness(particles[j])\n\n                # Update personal best\n                if current_fitness > personal_best_fitnesses[j]:\n                    personal_best_fitnesses[j] = current_fitness\n                    personal_best_positions[j] = particles[j].copy()\n\n                    # Update global best\n                    if current_fitness > global_best_fitness:\n                        global_best_fitness = current_fitness\n                        global_best_position = particles[j].copy()\n\n        # After optimization, solve for radii based on the best centers\n        best_centers = global_best_position\n        A_ub = np.concatenate([np.eye(26), -np.eye(26)], axis=0)\n        b_ub = np.concatenate([1 - best_centers[:, 0], best_centers[:, 0],\n                               1 - best_centers[:, 1], best_centers[:, 1]])\n        A_overlap = []\n        b_overlap = []\n        for i in range(26):\n            for j in range(i + 1, 26):\n                dist = np.linalg.norm(best_centers[i] - best_centers[j])\n                a = np.zeros(26)\n                a[i] = -1\n                a[j] = -1\n                A_overlap.append(a)\n                b_overlap.append(-dist)\n        A_ub = np.concatenate([A_ub, np.array(A_overlap)], axis=0)\n        b_ub = np.concatenate([b_ub, np.array(b_overlap)])\n        c = -np.ones(26)\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=(0, None), method='highs')\n        radii = res.x\n        sum_radii = -res.fun\n\n        return best_centers, radii, sum_radii\n\n    # Run PSO\n    best_centers, radii, sum_radii = pso(n_particles=30, n_iterations=100)\n\n    return best_centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 1.772542953491211,
    "error": "ValueError: Invalid input for linprog: b_ub must be a 1-D array; b_ub must not have more than one non-singleton dimension and the number of rows in A_ub must equal the number of values in b_ub"
  },
  "prompt": "Pack 26 circles. Maximize sum(radii). Use a 'Particle Swarm Optimization' (PSO) where each particle represents the 52 coordinates of the 26 centers. For each particle position, calculate the fitness by solving the Linear Programming problem for radii. This avoids gradient issues with center-movement.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    def fitness(centers):\n        \"\"\"\n        Calculates the fitness of a given configuration of circle centers by\n        solving a linear program to maximize the sum of radii, subject to\n        non-overlap and containment constraints.\n\n        Args:\n            centers (np.ndarray): A numpy array of shape (26, 2) representing the\n                                   x and y coordinates of the centers of the circles.\n\n        Returns:\n            float: The sum of the radii of the circles, or -np.inf if the\n                   constraints cannot be satisfied.\n        \"\"\"\n        # Constraint 1: Circles are contained within the unit square\n        A_ub = np.concatenate([np.eye(26), -np.eye(26)], axis=0)\n        b_ub = np.concatenate([1 - centers[:, 0], centers[:, 0],\n                               1 - centers[:, 1], centers[:, 1]])\n\n        # Constraint 2: Circles do not overlap\n        A_overlap = []\n        b_overlap = []\n        for i in range(26):\n            for j in range(i + 1, 26):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist == 0:\n                    return -np.inf  # Circles at the same spot\n                a = np.zeros(26)\n                a[i] = -1\n                a[j] = -1\n                A_overlap.append(a)\n                b_overlap.append(-dist)\n\n        A_ub = np.concatenate([A_ub, np.array(A_overlap)], axis=0)\n        b_ub = np.concatenate([b_ub, np.array(b_overlap)])\n\n        # Objective function: maximize the sum of radii\n        c = -np.ones(26)\n\n        # Solve the linear program\n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=(0, None), method='highs')\n            if res.success:\n                return -res.fun  # Return the sum of radii\n            else:\n                return -np.inf  # Indicate that the constraints could not be satisfied\n        except:\n            return -np.inf\n\n    def pso(n_particles, n_iterations):\n        \"\"\"\n        Performs Particle Swarm Optimization to find the optimal configuration\n        of circle centers that maximizes the sum of radii.\n\n        Args:\n            n_particles (int): The number of particles in the swarm.\n            n_iterations (int): The number of iterations to run the PSO algorithm.\n\n        Returns:\n            tuple: A tuple containing the best centers found, the corresponding radii,\n                   and the sum of the radii.\n        \"\"\"\n        # Initialize particles\n        particles = np.random.rand(n_particles, 26, 2)\n        velocities = np.random.rand(n_particles, 26, 2) * 0.1  # Initialize velocities\n\n        # Initialize personal best positions and fitnesses\n        personal_best_positions = particles.copy()\n        personal_best_fitnesses = np.array([fitness(p) for p in particles])\n\n        # Initialize global best position and fitness\n        global_best_index = np.argmax(personal_best_fitnesses)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_fitness = personal_best_fitnesses[global_best_index]\n\n        # PSO parameters\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive coefficient\n        c2 = 1.5  # Social coefficient\n\n        # Iterate\n        for i in range(n_iterations):\n            for j in range(n_particles):\n                # Update velocity\n                r1 = np.random.rand(26, 2)\n                r2 = np.random.rand(26, 2)\n                velocities[j] = (w * velocities[j] +\n                                 c1 * r1 * (personal_best_positions[j] - particles[j]) +\n                                 c2 * r2 * (global_best_position - particles[j]))\n\n                # Update position\n                particles[j] = particles[j] + velocities[j]\n                particles[j] = np.clip(particles[j], 0, 1)  # Keep particles within bounds\n\n                # Evaluate fitness\n                current_fitness = fitness(particles[j])\n\n                # Update personal best\n                if current_fitness > personal_best_fitnesses[j]:\n                    personal_best_fitnesses[j] = current_fitness\n                    personal_best_positions[j] = particles[j].copy()\n\n                    # Update global best\n                    if current_fitness > global_best_fitness:\n                        global_best_fitness = current_fitness\n                        global_best_position = particles[j].copy()\n\n        # After optimization, solve for radii based on the best centers\n        best_centers = global_best_position\n        A_ub = np.concatenate([np.eye(26), -np.eye(26)], axis=0)\n        b_ub = np.concatenate([1 - best_centers[:, 0], best_centers[:, 0],\n                               1 - best_centers[:, 1], best_centers[:, 1]])\n        A_overlap = []\n        b_overlap = []\n        for i in range(26):\n            for j in range(i + 1, 26):\n                dist = np.linalg.norm(best_centers[i] - best_centers[j])\n                a = np.zeros(26)\n                a[i] = -1\n                a[j] = -1\n                A_overlap.append(a)\n                b_overlap.append(-dist)\n        A_ub = np.concatenate([A_ub, np.array(A_overlap)], axis=0)\n        b_ub = np.concatenate([b_ub, np.array(b_overlap)])\n        c = -np.ones(26)\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=(0, None), method='highs')\n        radii = res.x\n        sum_radii = -res.fun\n\n        return best_centers, radii, sum_radii\n\n    # Run PSO\n    best_centers, radii, sum_radii = pso(n_particles=30, n_iterations=100)\n\n    return best_centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-11T19:23:07.376007",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.5,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 286,
        "candidates_token_count": 1550,
        "thoughts_token_count": 0
      },
      "response_text_len": 5663
    }
  }
}