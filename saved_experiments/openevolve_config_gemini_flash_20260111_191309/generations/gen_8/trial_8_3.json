{
  "trial_id": "trial_8_3",
  "generation": 8,
  "parent_id": "trial_5_2",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\nfrom scipy.stats import qmc\n\ndef construct_packing():\n    n_circles = 26\n    best_centers = None\n    best_radii = None\n    best_sum_radii = -1\n\n    def calculate_max_radius(center, existing_centers, existing_radii):\n        \"\"\"Calculates the maximum possible radius for a circle at the given center,\n        without overlapping existing circles or exceeding the boundaries of the unit square.\n        \"\"\"\n        min_dist_to_existing = np.inf\n        for i in range(len(existing_centers)):\n            dist = np.linalg.norm(center - existing_centers[i])\n            min_dist_to_existing = min(min_dist_to_existing, dist - existing_radii[i])\n\n        dist_to_boundary = min(center[0], center[1], 1 - center[0], 1 - center[1])\n\n        return min(min_dist_to_existing, dist_to_boundary)\n\n    def objective(radii):\n        return -np.sum(radii)\n\n    def constraint_overlap(centers):\n        def overlap_constraint(radii):\n            constraints = []\n            for i in range(n_circles):\n                for j in range(i + 1, n_circles):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    constraints.append(radii[i] + radii[j] - dist)\n            return np.array(constraints)\n        return overlap_constraint\n\n    def constraint_boundary(centers):\n        def boundary_constraint(radii):\n            constraints = []\n            for i in range(n_circles):\n                constraints.append(radii[i] - centers[i, 0])\n                constraints.append(radii[i] - centers[i, 1])\n                constraints.append(radii[i] + centers[i, 0] - 1)\n                constraints.append(radii[i] + centers[i, 1] - 1)\n            return np.array(constraints)\n        return boundary_constraint\n\n    def linear_programming_polish(centers):\n        # Objective function: minimize -sum(radii)\n        c = np.ones(n_circles) * -1\n\n        # Inequality constraints: A_ub @ x <= b_ub\n        # 1. Overlap constraints: r_i + r_j <= dist(c_i, c_j)\n        # 2. Boundary constraints: r_i <= c_i_x, r_i <= c_i_y, r_i <= 1 - c_i_x, r_i <= 1 - c_i_y\n        A_ub = np.zeros((n_circles * (n_circles - 1) // 2 + 4 * n_circles, n_circles))\n        b_ub = np.zeros(n_circles * (n_circles - 1) // 2 + 4 * n_circles)\n\n        # Overlap constraints\n        k = 0\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                A_ub[k, i] = 1\n                A_ub[k, j] = 1\n                b_ub[k] = np.linalg.norm(centers[i] - centers[j])\n                k += 1\n\n        # Boundary constraints\n        for i in range(n_circles):\n            A_ub[k, i] = 1\n            b_ub[k] = centers[i, 0]\n            k += 1\n            A_ub[k, i] = 1\n            b_ub[k] = centers[i, 1]\n            k += 1\n            A_ub[k, i] = 1\n            b_ub[k] = 1 - centers[i, 0]\n            k += 1\n            A_ub[k, i] = 1\n            b_ub[k] = 1 - centers[i, 1]\n            k += 1\n\n        # Bounds: 0 <= r_i <= 1\n        bounds = [(0, 1)] * n_circles\n\n        # Solve the linear program\n        result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n        if result.success:\n            return result.x, -result.fun  # Radii and sum of radii\n        else:\n            return None, None\n\n    for run in range(20):\n        # Initialization with Sobol sequence\n        num_samples = 2000\n        sampler = qmc.Sobol(d=2, scramble=False)\n        sample = sampler.random(n=num_samples)\n        centers = np.zeros((n_circles, 2))\n        radii = np.zeros(n_circles)\n\n        for i in range(n_circles):\n            best_center = None\n            best_radius = -1\n\n            for j in range(num_samples):\n                center = sample[j]\n                radius = calculate_max_radius(center, centers[:i], radii[:i])\n\n                if radius > best_radius:\n                    best_radius = radius\n                    best_center = center\n\n            centers[i] = best_center\n            radii[i] = best_radius\n\n        # Optimization using SLSQP\n        def objective_slsqp(x):\n            return -np.sum(x[2*n_circles:])\n\n        def constraint_overlap_slsqp(x):\n            centers_opt = x[:2 * n_circles].reshape((n_circles, 2))\n            radii_opt = x[2 * n_circles:]\n            constraints = []\n            for i in range(n_circles):\n                for j in range(i + 1, n_circles):\n                    dist = np.linalg.norm(centers_opt[i] - centers_opt[j])\n                    constraints.append(dist - radii_opt[i] - radii_opt[j])\n            return np.array(constraints)\n\n        def constraint_boundary_slsqp(x):\n            centers_opt = x[:2 * n_circles].reshape((n_circles, 2))\n            radii_opt = x[2 * n_circles:]\n            constraints = []\n            for i in range(n_circles):\n                constraints.append(centers_opt[i, 0] - radii_opt[i])\n                constraints.append(centers_opt[i, 1] - radii_opt[i])\n                constraints.append(1 - centers_opt[i, 0] - radii_opt[i])\n                constraints.append(1 - centers_opt[i, 1] - radii_opt[i])\n            return np.array(constraints)\n\n        x0 = np.concatenate([centers.flatten(), radii])\n        bounds = [(0, 1)] * (2 * n_circles) + [(0, 0.15)] * n_circles\n        constraints_slsqp = ({'type': 'ineq', 'fun': constraint_overlap_slsqp},\n                       {'type': 'ineq', 'fun': constraint_boundary_slsqp})\n\n        result = minimize(objective_slsqp, x0, method='SLSQP', bounds=bounds, constraints=constraints_slsqp, options={'maxiter': 400})\n        centers_slsqp = result.x[:2 * n_circles].reshape((n_circles, 2))\n\n        # Linear Programming Polish\n        radii_lp, sum_radii_lp = linear_programming_polish(centers_slsqp)\n\n        if radii_lp is not None:\n            if sum_radii_lp > best_sum_radii:\n                best_sum_radii = sum_radii_lp\n                best_centers = centers_slsqp\n                best_radii = radii_lp\n\n    return best_centers, best_radii, best_sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.54406938575921,
    "eval_time": 23.415246963500977,
    "error": null
  },
  "prompt": "Implement a 'Multi-Start Sobol-SLSQP' approach with LP polish:\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nfrom scipy.stats import qmc\n\ndef construct_packing():\n    n_circles = 26\n    centers = np.zeros((n_circles, 2))\n    radii = np.zeros(n_circles)\n\n    def calculate_max_radius(center, existing_centers, existing_radii):\n        \"\"\"Calculates the maximum possible radius for a circle at the given center,\n        without overlapping existing circles or exceeding the boundaries of the unit square.\n        \"\"\"\n        min_dist_to_existing = np.inf\n        for i in range(len(existing_centers)):\n            dist = np.linalg.norm(center - existing_centers[i])\n            min_dist_to_existing = min(min_dist_to_existing, dist - existing_radii[i])\n\n        dist_to_boundary = min(center[0], center[1], 1 - center[0], 1 - center[1])\n\n        return min(min_dist_to_existing, dist_to_boundary)\n\n    # Greedy placement with Sobol sequence\n    num_samples = 4096\n    sampler = qmc.Sobol(d=2, scramble=False)\n    sample = sampler.random(n=num_samples)\n\n    for i in range(n_circles):\n        best_center = None\n        best_radius = -1\n\n        for j in range(num_samples):\n            center = sample[j]\n            radius = calculate_max_radius(center, centers[:i], radii[:i])\n\n            if radius > best_radius:\n                best_radius = radius\n                best_center = center\n\n        centers[i] = best_center\n        radii[i] = best_radius\n\n    # Global optimization using Basin Hopping\n    def objective(x):\n        \"\"\"Objective function to minimize the negative sum of radii.\"\"\"\n        radii_opt = x[2 * n_circles:]\n        return -np.sum(radii_opt)\n\n    def constraint_overlap(x):\n        \"\"\"Constraint to prevent circle overlaps.\"\"\"\n        centers_opt = x[:2 * n_circles].reshape((n_circles, 2))\n        radii_opt = x[2 * n_circles:]\n        constraints = []\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers_opt[i] - centers_opt[j])\n                constraints.append(dist - radii_opt[i] - radii_opt[j])\n        return np.array(constraints)\n\n    def constraint_boundary(x):\n        \"\"\"Constraint to keep circles within the unit square.\"\"\"\n        centers_opt = x[:2 * n_circles].reshape((n_circles, 2))\n        radii_opt = x[2 * n_circles:]\n        constraints = []\n        for i in range(n_circles):\n            constraints.append(centers_opt[i, 0] - radii_opt[i])\n            constraints.append(centers_opt[i, 1] - radii_opt[i])\n            constraints.append(1 - centers_opt[i, 0] - radii_opt[i])\n            constraints.append(1 - centers_opt[i, 1] - radii_opt[i])\n        return np.array(constraints)\n\n    # Initial guess\n    x0 = np.concatenate([centers.flatten(), radii])\n\n    # Bounds for centers and radii\n    bounds = [(0, 1)] * (2 * n_circles) + [(0, 0.15)] * n_circles  # Radii bounded by 0.15\n\n    # Constraints\n    constraints = ({'type': 'ineq', 'fun': constraint_overlap},\n                   {'type': 'ineq', 'fun': constraint_boundary})\n\n    # Optimization using Basin Hopping\n    minimizer_kwargs = {\"method\": \"SLSQP\", \"bounds\": bounds, \"constraints\": constraints, 'options': {'maxiter': 500}}\n    result = basinhopping(objective, x0, minimizer_kwargs=minimizer_kwargs, niter=250, stepsize=0.05)\n\n    # Extract optimized values\n    centers_opt = result.x[:2 * n_circles].reshape((n_circles, 2))\n    radii_opt = result.x[2 * n_circles:]\n\n    sum_radii = np.sum(radii_opt)\n    return centers_opt, radii_opt, sum_radii\n\ndef run_packing():\n    return construct_packing()\nPerform 20 independent runs. In each: 1. Initialize with 2000 Sobol samples. 2. Run SLSQP for 400 iterations. 3. After SLSQP, solve the LP for optimal radii. 4. Return the best result found across all 20 starts.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nfrom scipy.stats import qmc\n\ndef construct_packing():\n    n_circles = 26\n    best_centers = None\n    best_radii = None\n    best_sum_radii = -1\n\n    def calculate_max_radius(center, existing_centers, existing_radii):\n        \"\"\"Calculates the maximum possible radius for a circle at the given center,\n        without overlapping existing circles or exceeding the boundaries of the unit square.\n        \"\"\"\n        min_dist_to_existing = np.inf\n        for i in range(len(existing_centers)):\n            dist = np.linalg.norm(center - existing_centers[i])\n            min_dist_to_existing = min(min_dist_to_existing, dist - existing_radii[i])\n\n        dist_to_boundary = min(center[0], center[1], 1 - center[0], 1 - center[1])\n\n        return min(min_dist_to_existing, dist_to_boundary)\n\n    def objective(radii):\n        return -np.sum(radii)\n\n    def constraint_overlap(centers):\n        def overlap_constraint(radii):\n            constraints = []\n            for i in range(n_circles):\n                for j in range(i + 1, n_circles):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    constraints.append(radii[i] + radii[j] - dist)\n            return np.array(constraints)\n        return overlap_constraint\n\n    def constraint_boundary(centers):\n        def boundary_constraint(radii):\n            constraints = []\n            for i in range(n_circles):\n                constraints.append(radii[i] - centers[i, 0])\n                constraints.append(radii[i] - centers[i, 1])\n                constraints.append(radii[i] + centers[i, 0] - 1)\n                constraints.append(radii[i] + centers[i, 1] - 1)\n            return np.array(constraints)\n        return boundary_constraint\n\n    def linear_programming_polish(centers):\n        # Objective function: minimize -sum(radii)\n        c = np.ones(n_circles) * -1\n\n        # Inequality constraints: A_ub @ x <= b_ub\n        # 1. Overlap constraints: r_i + r_j <= dist(c_i, c_j)\n        # 2. Boundary constraints: r_i <= c_i_x, r_i <= c_i_y, r_i <= 1 - c_i_x, r_i <= 1 - c_i_y\n        A_ub = np.zeros((n_circles * (n_circles - 1) // 2 + 4 * n_circles, n_circles))\n        b_ub = np.zeros(n_circles * (n_circles - 1) // 2 + 4 * n_circles)\n\n        # Overlap constraints\n        k = 0\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                A_ub[k, i] = 1\n                A_ub[k, j] = 1\n                b_ub[k] = np.linalg.norm(centers[i] - centers[j])\n                k += 1\n\n        # Boundary constraints\n        for i in range(n_circles):\n            A_ub[k, i] = 1\n            b_ub[k] = centers[i, 0]\n            k += 1\n            A_ub[k, i] = 1\n            b_ub[k] = centers[i, 1]\n            k += 1\n            A_ub[k, i] = 1\n            b_ub[k] = 1 - centers[i, 0]\n            k += 1\n            A_ub[k, i] = 1\n            b_ub[k] = 1 - centers[i, 1]\n            k += 1\n\n        # Bounds: 0 <= r_i <= 1\n        bounds = [(0, 1)] * n_circles\n\n        # Solve the linear program\n        result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n        if result.success:\n            return result.x, -result.fun  # Radii and sum of radii\n        else:\n            return None, None\n\n    for run in range(20):\n        # Initialization with Sobol sequence\n        num_samples = 2000\n        sampler = qmc.Sobol(d=2, scramble=False)\n        sample = sampler.random(n=num_samples)\n        centers = np.zeros((n_circles, 2))\n        radii = np.zeros(n_circles)\n\n        for i in range(n_circles):\n            best_center = None\n            best_radius = -1\n\n            for j in range(num_samples):\n                center = sample[j]\n                radius = calculate_max_radius(center, centers[:i], radii[:i])\n\n                if radius > best_radius:\n                    best_radius = radius\n                    best_center = center\n\n            centers[i] = best_center\n            radii[i] = best_radius\n\n        # Optimization using SLSQP\n        def objective_slsqp(x):\n            return -np.sum(x[2*n_circles:])\n\n        def constraint_overlap_slsqp(x):\n            centers_opt = x[:2 * n_circles].reshape((n_circles, 2))\n            radii_opt = x[2 * n_circles:]\n            constraints = []\n            for i in range(n_circles):\n                for j in range(i + 1, n_circles):\n                    dist = np.linalg.norm(centers_opt[i] - centers_opt[j])\n                    constraints.append(dist - radii_opt[i] - radii_opt[j])\n            return np.array(constraints)\n\n        def constraint_boundary_slsqp(x):\n            centers_opt = x[:2 * n_circles].reshape((n_circles, 2))\n            radii_opt = x[2 * n_circles:]\n            constraints = []\n            for i in range(n_circles):\n                constraints.append(centers_opt[i, 0] - radii_opt[i])\n                constraints.append(centers_opt[i, 1] - radii_opt[i])\n                constraints.append(1 - centers_opt[i, 0] - radii_opt[i])\n                constraints.append(1 - centers_opt[i, 1] - radii_opt[i])\n            return np.array(constraints)\n\n        x0 = np.concatenate([centers.flatten(), radii])\n        bounds = [(0, 1)] * (2 * n_circles) + [(0, 0.15)] * n_circles\n        constraints_slsqp = ({'type': 'ineq', 'fun': constraint_overlap_slsqp},\n                       {'type': 'ineq', 'fun': constraint_boundary_slsqp})\n\n        result = minimize(objective_slsqp, x0, method='SLSQP', bounds=bounds, constraints=constraints_slsqp, options={'maxiter': 400})\n        centers_slsqp = result.x[:2 * n_circles].reshape((n_circles, 2))\n\n        # Linear Programming Polish\n        radii_lp, sum_radii_lp = linear_programming_polish(centers_slsqp)\n\n        if radii_lp is not None:\n            if sum_radii_lp > best_sum_radii:\n                best_sum_radii = sum_radii_lp\n                best_centers = centers_slsqp\n                best_radii = radii_lp\n\n    return best_centers, best_radii, best_sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-11T19:35:46.793298",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.4,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 1371,
        "candidates_token_count": 1898,
        "thoughts_token_count": 0
      },
      "response_text_len": 6066
    }
  }
}