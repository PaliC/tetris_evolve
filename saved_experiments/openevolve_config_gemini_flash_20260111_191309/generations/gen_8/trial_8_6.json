{
  "trial_id": "trial_8_6",
  "generation": 8,
  "parent_id": "trial_5_2",
  "code": "import numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    def fitness(centers):\n        \"\"\"\n        Calculates the fitness of a given arrangement of circle centers by\n        solving a linear program to maximize the sum of radii, subject to\n        non-overlap and containment constraints.\n\n        Args:\n            centers (np.ndarray): A (26, 2) array of circle center coordinates.\n\n        Returns:\n            float: The sum of radii achieved by the optimal solution to the LP,\n                   or -np.inf if the LP is infeasible.\n        \"\"\"\n\n        # Number of circles\n        n = 26\n\n        # Objective function: maximize sum of radii\n        c = -np.ones(n)  # Minimize -sum(radii)\n\n        # Constraints:\n        # 1. Non-overlap: r_i + r_j <= distance(center_i, center_j)\n        # 2. Containment: r_i <= center_i[0], r_i <= center_i[1],\n        #                  r_i <= 1 - center_i[0], r_i <= 1 - center_i[1]\n\n        # Non-overlap constraints\n        A_nonoverlap = []\n        b_nonoverlap = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                row = np.zeros(n)\n                row[i] = 1\n                row[j] = 1\n                A_nonoverlap.append(row)\n                b_nonoverlap.append(dist)\n\n        # Containment constraints\n        A_containment = []\n        b_containment = []\n        for i in range(n):\n            A_containment.append(np.zeros(n))\n            A_containment[-1][i] = 1\n            b_containment.append(centers[i][0])\n\n            A_containment.append(np.zeros(n))\n            A_containment[-1][i] = 1\n            b_containment.append(centers[i][1])\n\n            A_containment.append(np.zeros(n))\n            A_containment[-1][i] = 1\n            b_containment.append(1 - centers[i][0])\n\n            A_containment.append(np.zeros(n))\n            A_containment[-1][i] = 1\n            b_containment.append(1 - centers[i][1])\n\n        # Combine constraints\n        A = np.vstack([A_nonoverlap, A_containment])\n        b = np.array(b_nonoverlap + b_containment)\n\n        # Bounds: radii >= 0\n        bounds = [(0, None)] * n\n\n        # Solve the linear program\n        try:\n            res = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')  # Use highs method\n            if res.success:\n                return -res.fun  # Return the sum of radii\n            else:\n                return -np.inf  # Indicate infeasible solution\n        except:\n            return -np.inf # Also catch errors, return infeasible\n\n    def initialize_particles(num_particles, n):\n        \"\"\"Initializes particle positions and velocities.\"\"\"\n        positions = np.random.rand(num_particles, n * 2)  # Centers are in [0,1]x[0,1]\n        velocities = np.random.rand(num_particles, n * 2) * 0.1  # Small initial velocities\n        return positions, velocities\n\n    def update_velocity(velocity, position, personal_best_position, global_best_position, w=0.7, c1=1.5, c2=1.5):\n        \"\"\"Updates particle velocity based on PSO equations.\"\"\"\n        r1 = np.random.rand(*velocity.shape)\n        r2 = np.random.rand(*velocity.shape)\n        cognitive_component = c1 * r1 * (personal_best_position - position)\n        social_component = c2 * r2 * (global_best_position - position)\n        return w * velocity + cognitive_component + social_component\n\n    def update_position(position, velocity):\n        \"\"\"Updates particle position.\"\"\"\n        new_position = position + velocity\n        # Clip positions to stay within [0, 1]\n        new_position = np.clip(new_position, 0, 1)\n        return new_position\n\n    # PSO parameters\n    num_particles = 50\n    num_iterations = 200\n    n = 26  # Number of circles\n\n    # Initialize particles\n    positions, velocities = initialize_particles(num_particles, n)\n\n    # Initialize personal best positions and fitnesses\n    personal_best_positions = positions.copy()\n    personal_best_fitnesses = np.array([fitness(pos.reshape(n, 2)) for pos in positions])\n\n    # Initialize global best position and fitness\n    global_best_index = np.argmax(personal_best_fitnesses)\n    global_best_position = personal_best_positions[global_best_index].copy()\n    global_best_fitness = personal_best_fitnesses[global_best_index]\n\n    # PSO main loop\n    for iteration in range(num_iterations):\n        for i in range(num_particles):\n            # Update velocity and position\n            velocities[i] = update_velocity(velocities[i], positions[i], personal_best_positions[i], global_best_position)\n            positions[i] = update_position(positions[i], velocities[i])\n\n            # Evaluate fitness\n            current_fitness = fitness(positions[i].reshape(n, 2))\n\n            # Update personal best\n            if current_fitness > personal_best_fitnesses[i]:\n                personal_best_fitnesses[i] = current_fitness\n                personal_best_positions[i] = positions[i].copy()\n\n                # Update global best\n                if current_fitness > global_best_fitness:\n                    global_best_fitness = current_fitness\n                    global_best_position = positions[i].copy()\n\n    # Extract the best centers and calculate radii\n    best_centers = global_best_position.reshape(n, 2)\n    \n    # Solve LP one last time to get the radii\n    n = 26\n\n    # Objective function: maximize sum of radii\n    c = -np.ones(n)  # Minimize -sum(radii)\n\n    # Constraints:\n    # 1. Non-overlap: r_i + r_j <= distance(center_i, center_j)\n    # 2. Containment: r_i <= center_i[0], r_i <= center_i[1],\n    #                  r_i <= 1 - center_i[0], r_i <= 1 - center_i[1]\n\n    # Non-overlap constraints\n    A_nonoverlap = []\n    b_nonoverlap = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(best_centers[i] - best_centers[j])\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            A_nonoverlap.append(row)\n            b_nonoverlap.append(dist)\n\n    # Containment constraints\n    A_containment = []\n    b_containment = []\n    for i in range(n):\n        A_containment.append(np.zeros(n))\n        A_containment[-1][i] = 1\n        b_containment.append(best_centers[i][0])\n\n        A_containment.append(np.zeros(n))\n        A_containment[-1][i] = 1\n        b_containment.append(best_centers[i][1])\n\n        A_containment.append(np.zeros(n))\n        A_containment[-1][i] = 1\n        b_containment.append(1 - best_centers[i][0])\n\n        A_containment.append(np.zeros(n))\n        A_containment[-1][i] = 1\n        b_containment.append(1 - best_centers[i][1])\n\n    # Combine constraints\n    A = np.vstack([A_nonoverlap, A_containment])\n    b = np.array(b_nonoverlap + b_containment)\n\n    # Bounds: radii >= 0\n    bounds = [(0, None)] * n\n\n    # Solve the linear program\n    res = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')  # Use highs method\n    radii = res.x\n    sum_radii = -res.fun\n\n    return best_centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.276839624173649,
    "eval_time": 15.179943799972534,
    "error": null
  },
  "prompt": "Pack 26 circles. Use 'Particle Swarm Optimization' (PSO) where each particle is the 52-dimensional vector of centers. For each particle, calculate fitness by solving the Linear Programming problem for radii. Use 50 particles and 200 iterations. This avoids gradient issues with center movement.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    def fitness(centers):\n        \"\"\"\n        Calculates the fitness of a given arrangement of circle centers by\n        solving a linear program to maximize the sum of radii, subject to\n        non-overlap and containment constraints.\n\n        Args:\n            centers (np.ndarray): A (26, 2) array of circle center coordinates.\n\n        Returns:\n            float: The sum of radii achieved by the optimal solution to the LP,\n                   or -np.inf if the LP is infeasible.\n        \"\"\"\n\n        # Number of circles\n        n = 26\n\n        # Objective function: maximize sum of radii\n        c = -np.ones(n)  # Minimize -sum(radii)\n\n        # Constraints:\n        # 1. Non-overlap: r_i + r_j <= distance(center_i, center_j)\n        # 2. Containment: r_i <= center_i[0], r_i <= center_i[1],\n        #                  r_i <= 1 - center_i[0], r_i <= 1 - center_i[1]\n\n        # Non-overlap constraints\n        A_nonoverlap = []\n        b_nonoverlap = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                row = np.zeros(n)\n                row[i] = 1\n                row[j] = 1\n                A_nonoverlap.append(row)\n                b_nonoverlap.append(dist)\n\n        # Containment constraints\n        A_containment = []\n        b_containment = []\n        for i in range(n):\n            A_containment.append(np.zeros(n))\n            A_containment[-1][i] = 1\n            b_containment.append(centers[i][0])\n\n            A_containment.append(np.zeros(n))\n            A_containment[-1][i] = 1\n            b_containment.append(centers[i][1])\n\n            A_containment.append(np.zeros(n))\n            A_containment[-1][i] = 1\n            b_containment.append(1 - centers[i][0])\n\n            A_containment.append(np.zeros(n))\n            A_containment[-1][i] = 1\n            b_containment.append(1 - centers[i][1])\n\n        # Combine constraints\n        A = np.vstack([A_nonoverlap, A_containment])\n        b = np.array(b_nonoverlap + b_containment)\n\n        # Bounds: radii >= 0\n        bounds = [(0, None)] * n\n\n        # Solve the linear program\n        try:\n            res = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')  # Use highs method\n            if res.success:\n                return -res.fun  # Return the sum of radii\n            else:\n                return -np.inf  # Indicate infeasible solution\n        except:\n            return -np.inf # Also catch errors, return infeasible\n\n    def initialize_particles(num_particles, n):\n        \"\"\"Initializes particle positions and velocities.\"\"\"\n        positions = np.random.rand(num_particles, n * 2)  # Centers are in [0,1]x[0,1]\n        velocities = np.random.rand(num_particles, n * 2) * 0.1  # Small initial velocities\n        return positions, velocities\n\n    def update_velocity(velocity, position, personal_best_position, global_best_position, w=0.7, c1=1.5, c2=1.5):\n        \"\"\"Updates particle velocity based on PSO equations.\"\"\"\n        r1 = np.random.rand(*velocity.shape)\n        r2 = np.random.rand(*velocity.shape)\n        cognitive_component = c1 * r1 * (personal_best_position - position)\n        social_component = c2 * r2 * (global_best_position - position)\n        return w * velocity + cognitive_component + social_component\n\n    def update_position(position, velocity):\n        \"\"\"Updates particle position.\"\"\"\n        new_position = position + velocity\n        # Clip positions to stay within [0, 1]\n        new_position = np.clip(new_position, 0, 1)\n        return new_position\n\n    # PSO parameters\n    num_particles = 50\n    num_iterations = 200\n    n = 26  # Number of circles\n\n    # Initialize particles\n    positions, velocities = initialize_particles(num_particles, n)\n\n    # Initialize personal best positions and fitnesses\n    personal_best_positions = positions.copy()\n    personal_best_fitnesses = np.array([fitness(pos.reshape(n, 2)) for pos in positions])\n\n    # Initialize global best position and fitness\n    global_best_index = np.argmax(personal_best_fitnesses)\n    global_best_position = personal_best_positions[global_best_index].copy()\n    global_best_fitness = personal_best_fitnesses[global_best_index]\n\n    # PSO main loop\n    for iteration in range(num_iterations):\n        for i in range(num_particles):\n            # Update velocity and position\n            velocities[i] = update_velocity(velocities[i], positions[i], personal_best_positions[i], global_best_position)\n            positions[i] = update_position(positions[i], velocities[i])\n\n            # Evaluate fitness\n            current_fitness = fitness(positions[i].reshape(n, 2))\n\n            # Update personal best\n            if current_fitness > personal_best_fitnesses[i]:\n                personal_best_fitnesses[i] = current_fitness\n                personal_best_positions[i] = positions[i].copy()\n\n                # Update global best\n                if current_fitness > global_best_fitness:\n                    global_best_fitness = current_fitness\n                    global_best_position = positions[i].copy()\n\n    # Extract the best centers and calculate radii\n    best_centers = global_best_position.reshape(n, 2)\n    \n    # Solve LP one last time to get the radii\n    n = 26\n\n    # Objective function: maximize sum of radii\n    c = -np.ones(n)  # Minimize -sum(radii)\n\n    # Constraints:\n    # 1. Non-overlap: r_i + r_j <= distance(center_i, center_j)\n    # 2. Containment: r_i <= center_i[0], r_i <= center_i[1],\n    #                  r_i <= 1 - center_i[0], r_i <= 1 - center_i[1]\n\n    # Non-overlap constraints\n    A_nonoverlap = []\n    b_nonoverlap = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(best_centers[i] - best_centers[j])\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            A_nonoverlap.append(row)\n            b_nonoverlap.append(dist)\n\n    # Containment constraints\n    A_containment = []\n    b_containment = []\n    for i in range(n):\n        A_containment.append(np.zeros(n))\n        A_containment[-1][i] = 1\n        b_containment.append(best_centers[i][0])\n\n        A_containment.append(np.zeros(n))\n        A_containment[-1][i] = 1\n        b_containment.append(best_centers[i][1])\n\n        A_containment.append(np.zeros(n))\n        A_containment[-1][i] = 1\n        b_containment.append(1 - best_centers[i][0])\n\n        A_containment.append(np.zeros(n))\n        A_containment[-1][i] = 1\n        b_containment.append(1 - best_centers[i][1])\n\n    # Combine constraints\n    A = np.vstack([A_nonoverlap, A_containment])\n    b = np.array(b_nonoverlap + b_containment)\n\n    # Bounds: radii >= 0\n    bounds = [(0, None)] * n\n\n    # Solve the linear program\n    res = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')  # Use highs method\n    radii = res.x\n    sum_radii = -res.fun\n\n    return best_centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-11T19:35:43.503661",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.5,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 285,
        "candidates_token_count": 2109,
        "thoughts_token_count": 0
      },
      "response_text_len": 7060
    }
  }
}