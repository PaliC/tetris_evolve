{
  "trial_id": "trial_5_9",
  "generation": 5,
  "parent_id": "trial_3_0",
  "code": "import numpy as np\nfrom scipy.optimize import linprog\nimport random\n\ndef calculate_radii(centers):\n    \"\"\"Calculates the radii of the circles using linear programming.\"\"\"\n    n = len(centers)\n    A = np.zeros((n * (n - 1) // 2, n))\n    b = np.zeros(n * (n - 1) // 2)\n    k = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            A[k, i] = 1\n            A[k, j] = 1\n            b[k] = dist\n            k += 1\n\n    # Boundary constraints: x + r <= 1, y + r <= 1, x - r >= 0, y - r >= 0  =>  r <= 1-x, r <= 1-y, r <= x, r <= y\n    A_bound = np.zeros((n * 4, n))\n    b_bound = np.zeros(n * 4)\n    for i in range(n):\n        A_bound[i*4, i] = 1\n        b_bound[i*4] = 1 - centers[i, 0]\n        A_bound[i*4+1, i] = 1\n        b_bound[i*4+1] = 1 - centers[i, 1]\n        A_bound[i*4+2, i] = 1\n        b_bound[i*4+2] = centers[i, 0]\n        A_bound[i*4+3, i] = 1\n        b_bound[i*4+3] = centers[i, 1]\n\n    A = np.vstack((A, A_bound))\n    b = np.concatenate((b, b_bound))\n\n    c = -np.ones(n)  # Minimize -sum(radii)\n\n    try:\n        res = linprog(c, A_ub=A, b_ub=b, bounds=(0, None), method='highs')\n\n        if res.success:\n            return res.x, -res.fun\n        else:\n            return np.zeros(n), -np.inf  # Return 0 radii if LP fails\n    except:\n        return np.zeros(n), -np.inf # Return 0 radii if LP fails\n\ndef energy(centers):\n    \"\"\"Calculates the energy of a given configuration of centers.\"\"\"\n    radii, sum_radii = calculate_radii(centers)\n    return -sum_radii\n\ndef perturb_centers(centers, temperature):\n    \"\"\"Perturbs the centers slightly based on the temperature.\"\"\"\n    new_centers = centers.copy()\n    for i in range(len(centers)):\n        new_centers[i, 0] += np.random.normal(0, temperature * 0.01)\n        new_centers[i, 1] += np.random.normal(0, temperature * 0.01)\n        new_centers[i, 0] = np.clip(new_centers[i, 0], 0, 1)\n        new_centers[i, 1] = np.clip(new_centers[i, 1], 0, 1)\n    return new_centers\n\ndef construct_packing():\n    \"\"\"Finds a packing of 26 circles in a unit square using simulated annealing.\"\"\"\n    n = 26\n    centers = np.random.rand(n, 2)  # Initialize centers randomly\n\n    current_energy = energy(centers)\n    best_energy = current_energy\n    best_centers = centers.copy()\n\n    # Simulated Annealing parameters\n    initial_temperature = 1.0\n    cooling_rate = 0.9999\n    num_iterations = 50000\n\n    temperature = initial_temperature\n    for i in range(num_iterations):\n        new_centers = perturb_centers(centers, temperature)\n        new_energy = energy(new_centers)\n\n        # Metropolis acceptance criterion\n        if new_energy > current_energy or np.random.rand() < np.exp((new_energy - current_energy) / temperature):\n            centers = new_centers\n            current_energy = new_energy\n\n            if current_energy > best_energy:\n                best_energy = current_energy\n                best_centers = centers.copy()\n\n        temperature *= cooling_rate\n\n    radii, sum_radii = calculate_radii(best_centers)\n    return best_centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 0.7891028794059206,
    "eval_time": 71.213552236557,
    "error": null
  },
  "prompt": "Pack 26 circles. Implement a 'Simulated Annealing' approach where the state is the center positions and the energy is -sum(radii) where radii are found via LP. Use a very slow cooling schedule and 50,000 iterations to explore the configuration space of the 26 centers thoroughly.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nimport random\n\ndef calculate_radii(centers):\n    \"\"\"Calculates the radii of the circles using linear programming.\"\"\"\n    n = len(centers)\n    A = np.zeros((n * (n - 1) // 2, n))\n    b = np.zeros(n * (n - 1) // 2)\n    k = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            A[k, i] = 1\n            A[k, j] = 1\n            b[k] = dist\n            k += 1\n\n    # Boundary constraints: x + r <= 1, y + r <= 1, x - r >= 0, y - r >= 0  =>  r <= 1-x, r <= 1-y, r <= x, r <= y\n    A_bound = np.zeros((n * 4, n))\n    b_bound = np.zeros(n * 4)\n    for i in range(n):\n        A_bound[i*4, i] = 1\n        b_bound[i*4] = 1 - centers[i, 0]\n        A_bound[i*4+1, i] = 1\n        b_bound[i*4+1] = 1 - centers[i, 1]\n        A_bound[i*4+2, i] = 1\n        b_bound[i*4+2] = centers[i, 0]\n        A_bound[i*4+3, i] = 1\n        b_bound[i*4+3] = centers[i, 1]\n\n    A = np.vstack((A, A_bound))\n    b = np.concatenate((b, b_bound))\n\n    c = -np.ones(n)  # Minimize -sum(radii)\n\n    try:\n        res = linprog(c, A_ub=A, b_ub=b, bounds=(0, None), method='highs')\n\n        if res.success:\n            return res.x, -res.fun\n        else:\n            return np.zeros(n), -np.inf  # Return 0 radii if LP fails\n    except:\n        return np.zeros(n), -np.inf # Return 0 radii if LP fails\n\ndef energy(centers):\n    \"\"\"Calculates the energy of a given configuration of centers.\"\"\"\n    radii, sum_radii = calculate_radii(centers)\n    return -sum_radii\n\ndef perturb_centers(centers, temperature):\n    \"\"\"Perturbs the centers slightly based on the temperature.\"\"\"\n    new_centers = centers.copy()\n    for i in range(len(centers)):\n        new_centers[i, 0] += np.random.normal(0, temperature * 0.01)\n        new_centers[i, 1] += np.random.normal(0, temperature * 0.01)\n        new_centers[i, 0] = np.clip(new_centers[i, 0], 0, 1)\n        new_centers[i, 1] = np.clip(new_centers[i, 1], 0, 1)\n    return new_centers\n\ndef construct_packing():\n    \"\"\"Finds a packing of 26 circles in a unit square using simulated annealing.\"\"\"\n    n = 26\n    centers = np.random.rand(n, 2)  # Initialize centers randomly\n\n    current_energy = energy(centers)\n    best_energy = current_energy\n    best_centers = centers.copy()\n\n    # Simulated Annealing parameters\n    initial_temperature = 1.0\n    cooling_rate = 0.9999\n    num_iterations = 50000\n\n    temperature = initial_temperature\n    for i in range(num_iterations):\n        new_centers = perturb_centers(centers, temperature)\n        new_energy = energy(new_centers)\n\n        # Metropolis acceptance criterion\n        if new_energy > current_energy or np.random.rand() < np.exp((new_energy - current_energy) / temperature):\n            centers = new_centers\n            current_energy = new_energy\n\n            if current_energy > best_energy:\n                best_energy = current_energy\n                best_centers = centers.copy()\n\n        temperature *= cooling_rate\n\n    radii, sum_radii = calculate_radii(best_centers)\n    return best_centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-11T19:28:50.345538",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.6,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 287,
        "candidates_token_count": 1096,
        "thoughts_token_count": 0
      },
      "response_text_len": 3164
    }
  }
}