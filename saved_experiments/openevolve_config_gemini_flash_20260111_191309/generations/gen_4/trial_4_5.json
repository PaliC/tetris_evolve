{
  "trial_id": "trial_4_5",
  "generation": 4,
  "parent_id": "trial_3_0",
  "code": "import numpy as np\nfrom scipy.optimize import linprog\n\ndef calculate_radii(centers):\n    \"\"\"\n    Calculates the optimal radii for a given set of circle centers within a unit square,\n    maximizing the sum of radii while preventing overlaps.\n\n    Args:\n        centers (np.ndarray): A numpy array of shape (N, 2) representing the centers of N circles.\n\n    Returns:\n        tuple: A tuple containing:\n            - radii (np.ndarray): A numpy array of shape (N,) representing the optimal radii for each circle.\n            - sum_radii (float): The sum of the optimal radii.\n    \"\"\"\n    n = centers.shape[0]\n\n    # Objective function: maximize sum of radii\n    c = np.array([-1] * n)\n\n    # Inequality constraints:\n    # 1. Circles must be within the unit square: x_i + r_i <= 1 and -x_i + r_i <= 0, y_i + r_i <= 1 and -y_i + r_i <= 0\n    # 2. Circles must not overlap: r_i + r_j <= distance between centers i and j\n\n    A = []\n    b = []\n\n    # Constraint 1: Circles within the unit square\n    for i in range(n):\n        A.append([0] * i + [1] + [0] * (n - i - 1))  # x_i + r_i <= 1\n        b.append(1 - centers[i, 0])\n        A.append([0] * i + [1] + [0] * (n - i - 1))  # -x_i + r_i <= 0\n        b.append(centers[i, 0])\n        A.append([0] * i + [1] + [0] * (n - i - 1))  # y_i + r_i <= 1\n        b.append(1 - centers[i, 1])\n        A.append([0] * i + [1] + [0] * (n - i - 1))  # -y_i + r_i <= 0\n        b.append(centers[i, 1])\n\n    # Constraint 2: Circles do not overlap\n    for i in range(n):\n        for j in range(i + 1, n):\n            distance = np.linalg.norm(centers[i] - centers[j])\n            row = [0] * n\n            row[i] = 1\n            row[j] = 1\n            A.append(row)\n            b.append(distance)\n\n    # Solve the linear program\n    A = np.array(A)\n    b = np.array(b)\n    bounds = [(0, None)] * n  # Radii must be non-negative\n    result = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')\n\n    if result.success:\n        radii = result.x\n        sum_radii = -result.fun\n        return radii, sum_radii\n    else:\n        return np.zeros(n), -np.inf  # Return 0 radii and negative infinity sum if optimization fails\n\n\ndef fitness(centers):\n    \"\"\"\n    Calculates the fitness of a given arrangement of circle centers.\n\n    Args:\n        centers (np.ndarray): A numpy array of shape (26, 2) representing the centers of 26 circles.\n\n    Returns:\n        float: The sum of the optimal radii for the given arrangement.\n    \"\"\"\n    radii, sum_radii = calculate_radii(centers)\n    return sum_radii\n\n\ndef generate_individual():\n    \"\"\"\n    Generates a random individual representing circle centers within the unit square.\n\n    Returns:\n        np.ndarray: A numpy array of shape (26, 2) representing the centers of 26 circles.\n    \"\"\"\n    return np.random.rand(26, 2)\n\n\ndef crossover(parent1, parent2):\n    \"\"\"\n    Performs crossover between two parent individuals to create two offspring.\n\n    Args:\n        parent1 (np.ndarray): A numpy array of shape (26, 2) representing the centers of 26 circles.\n        parent2 (np.ndarray): A numpy array of shape (26, 2) representing the centers of 26 circles.\n\n    Returns:\n        tuple: A tuple containing two offspring individuals (numpy arrays of shape (26, 2)).\n    \"\"\"\n    alpha = np.random.rand()  # Random weight for crossover\n    offspring1 = alpha * parent1 + (1 - alpha) * parent2\n    offspring2 = (1 - alpha) * parent1 + alpha * parent2\n    return offspring1, offspring2\n\n\ndef mutate(individual, mutation_rate=0.01):\n    \"\"\"\n    Applies mutation to an individual.\n\n    Args:\n        individual (np.ndarray): A numpy array of shape (26, 2) representing the centers of 26 circles.\n        mutation_rate (float): The probability of mutating each gene.\n\n    Returns:\n        np.ndarray: The mutated individual.\n    \"\"\"\n    for i in range(individual.shape[0]):\n        for j in range(individual.shape[1]):\n            if np.random.rand() < mutation_rate:\n                individual[i, j] += np.random.normal(0, 0.05)  # Add small random noise\n                individual[i, j] = np.clip(individual[i, j], 0, 1)  # Clip values to [0, 1]\n    return individual\n\n\ndef genetic_algorithm(population_size=200, generations=50, mutation_rate=0.01, best_layouts=None):\n    \"\"\"\n    Implements a genetic algorithm to optimize the arrangement of circle centers.\n\n    Args:\n        population_size (int): The number of individuals in the population.\n        generations (int): The number of generations to run the algorithm.\n        mutation_rate (float): The probability of mutating each gene.\n        best_layouts (list): A list of previously found good layouts to seed the population.\n\n    Returns:\n        tuple: A tuple containing:\n            - best_centers (np.ndarray): The best arrangement of circle centers found.\n            - best_radii (np.ndarray): The optimal radii for the best arrangement.\n            - best_sum_radii (float): The sum of the optimal radii for the best arrangement.\n    \"\"\"\n\n    # Initialize population\n    population = []\n    if best_layouts:\n        population.extend(best_layouts)\n        while len(population) < population_size:\n            population.append(generate_individual())\n    else:\n        population = [generate_individual() for _ in range(population_size)]\n\n    best_centers = None\n    best_radii = None\n    best_sum_radii = -np.inf\n\n    for generation in range(generations):\n        # Evaluate fitness\n        fitness_scores = [fitness(individual) for individual in population]\n\n        # Select parents (tournament selection)\n        selected_indices = np.random.choice(population_size, size=population_size, replace=True)\n        parents = [population[i] for i in selected_indices]\n\n        # Crossover and Mutation\n        offspring = []\n        for i in range(0, population_size, 2):\n            parent1 = parents[i]\n            parent2 = parents[i + 1] if i + 1 < population_size else parents[0]  # Wrap around if odd population size\n            child1, child2 = crossover(parent1, parent2)\n            child1 = mutate(child1, mutation_rate)\n            child2 = mutate(child2, mutation_rate)\n            offspring.extend([child1, child2])\n\n        # Replace population\n        population = offspring\n\n        # Elitism: Keep the best individual from the previous generation\n        best_index = np.argmax(fitness_scores)\n        best_individual = population[best_index]\n        current_best_fitness = fitness_scores[best_index]\n        if current_best_fitness > best_sum_radii:\n            best_sum_radii = current_best_fitness\n            best_centers = population[best_index]\n            best_radii, _ = calculate_radii(best_centers)\n\n        # Print progress\n        #print(f\"Generation {generation + 1}: Best Fitness = {best_sum_radii}\")\n\n    best_radii, best_sum_radii = calculate_radii(best_centers)\n    return best_centers, best_radii, best_sum_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs a packing of 26 circles into a unit square using a genetic algorithm.\n\n    Returns:\n        tuple: A tuple containing:\n            - centers (np.ndarray): A numpy array of shape (26, 2) representing the centers of 26 circles.\n            - radii (np.ndarray): A numpy array of shape (26,) representing the radii of 26 circles.\n            - sum_radii (float): The sum of the radii.\n    \"\"\"\n\n    # Seed the genetic algorithm with potentially good layouts\n    # These layouts are placeholders and should be replaced with actual data\n    best_layouts = [np.random.rand(26, 2), np.random.rand(26, 2)]  # Replace with actual data\n    # Run the genetic algorithm\n    centers, radii, sum_radii = genetic_algorithm(population_size=200, generations=50, mutation_rate=0.01, best_layouts=best_layouts)\n\n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 1.1926869212613986,
    "eval_time": 15.040838956832886,
    "error": null
  },
  "prompt": "Pack 26 circles. Implement a 'Genetic Algorithm' where each individual is a 52-length vector of centers. The fitness function is the sum of optimal radii calculated via Linear Programming. Use a large population and focus on 'Crossover' between the best layouts found in trial_3_0 and trial_3_6.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef calculate_radii(centers):\n    \"\"\"\n    Calculates the optimal radii for a given set of circle centers within a unit square,\n    maximizing the sum of radii while preventing overlaps.\n\n    Args:\n        centers (np.ndarray): A numpy array of shape (N, 2) representing the centers of N circles.\n\n    Returns:\n        tuple: A tuple containing:\n            - radii (np.ndarray): A numpy array of shape (N,) representing the optimal radii for each circle.\n            - sum_radii (float): The sum of the optimal radii.\n    \"\"\"\n    n = centers.shape[0]\n\n    # Objective function: maximize sum of radii\n    c = np.array([-1] * n)\n\n    # Inequality constraints:\n    # 1. Circles must be within the unit square: x_i + r_i <= 1 and -x_i + r_i <= 0, y_i + r_i <= 1 and -y_i + r_i <= 0\n    # 2. Circles must not overlap: r_i + r_j <= distance between centers i and j\n\n    A = []\n    b = []\n\n    # Constraint 1: Circles within the unit square\n    for i in range(n):\n        A.append([0] * i + [1] + [0] * (n - i - 1))  # x_i + r_i <= 1\n        b.append(1 - centers[i, 0])\n        A.append([0] * i + [1] + [0] * (n - i - 1))  # -x_i + r_i <= 0\n        b.append(centers[i, 0])\n        A.append([0] * i + [1] + [0] * (n - i - 1))  # y_i + r_i <= 1\n        b.append(1 - centers[i, 1])\n        A.append([0] * i + [1] + [0] * (n - i - 1))  # -y_i + r_i <= 0\n        b.append(centers[i, 1])\n\n    # Constraint 2: Circles do not overlap\n    for i in range(n):\n        for j in range(i + 1, n):\n            distance = np.linalg.norm(centers[i] - centers[j])\n            row = [0] * n\n            row[i] = 1\n            row[j] = 1\n            A.append(row)\n            b.append(distance)\n\n    # Solve the linear program\n    A = np.array(A)\n    b = np.array(b)\n    bounds = [(0, None)] * n  # Radii must be non-negative\n    result = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')\n\n    if result.success:\n        radii = result.x\n        sum_radii = -result.fun\n        return radii, sum_radii\n    else:\n        return np.zeros(n), -np.inf  # Return 0 radii and negative infinity sum if optimization fails\n\n\ndef fitness(centers):\n    \"\"\"\n    Calculates the fitness of a given arrangement of circle centers.\n\n    Args:\n        centers (np.ndarray): A numpy array of shape (26, 2) representing the centers of 26 circles.\n\n    Returns:\n        float: The sum of the optimal radii for the given arrangement.\n    \"\"\"\n    radii, sum_radii = calculate_radii(centers)\n    return sum_radii\n\n\ndef generate_individual():\n    \"\"\"\n    Generates a random individual representing circle centers within the unit square.\n\n    Returns:\n        np.ndarray: A numpy array of shape (26, 2) representing the centers of 26 circles.\n    \"\"\"\n    return np.random.rand(26, 2)\n\n\ndef crossover(parent1, parent2):\n    \"\"\"\n    Performs crossover between two parent individuals to create two offspring.\n\n    Args:\n        parent1 (np.ndarray): A numpy array of shape (26, 2) representing the centers of 26 circles.\n        parent2 (np.ndarray): A numpy array of shape (26, 2) representing the centers of 26 circles.\n\n    Returns:\n        tuple: A tuple containing two offspring individuals (numpy arrays of shape (26, 2)).\n    \"\"\"\n    alpha = np.random.rand()  # Random weight for crossover\n    offspring1 = alpha * parent1 + (1 - alpha) * parent2\n    offspring2 = (1 - alpha) * parent1 + alpha * parent2\n    return offspring1, offspring2\n\n\ndef mutate(individual, mutation_rate=0.01):\n    \"\"\"\n    Applies mutation to an individual.\n\n    Args:\n        individual (np.ndarray): A numpy array of shape (26, 2) representing the centers of 26 circles.\n        mutation_rate (float): The probability of mutating each gene.\n\n    Returns:\n        np.ndarray: The mutated individual.\n    \"\"\"\n    for i in range(individual.shape[0]):\n        for j in range(individual.shape[1]):\n            if np.random.rand() < mutation_rate:\n                individual[i, j] += np.random.normal(0, 0.05)  # Add small random noise\n                individual[i, j] = np.clip(individual[i, j], 0, 1)  # Clip values to [0, 1]\n    return individual\n\n\ndef genetic_algorithm(population_size=200, generations=50, mutation_rate=0.01, best_layouts=None):\n    \"\"\"\n    Implements a genetic algorithm to optimize the arrangement of circle centers.\n\n    Args:\n        population_size (int): The number of individuals in the population.\n        generations (int): The number of generations to run the algorithm.\n        mutation_rate (float): The probability of mutating each gene.\n        best_layouts (list): A list of previously found good layouts to seed the population.\n\n    Returns:\n        tuple: A tuple containing:\n            - best_centers (np.ndarray): The best arrangement of circle centers found.\n            - best_radii (np.ndarray): The optimal radii for the best arrangement.\n            - best_sum_radii (float): The sum of the optimal radii for the best arrangement.\n    \"\"\"\n\n    # Initialize population\n    population = []\n    if best_layouts:\n        population.extend(best_layouts)\n        while len(population) < population_size:\n            population.append(generate_individual())\n    else:\n        population = [generate_individual() for _ in range(population_size)]\n\n    best_centers = None\n    best_radii = None\n    best_sum_radii = -np.inf\n\n    for generation in range(generations):\n        # Evaluate fitness\n        fitness_scores = [fitness(individual) for individual in population]\n\n        # Select parents (tournament selection)\n        selected_indices = np.random.choice(population_size, size=population_size, replace=True)\n        parents = [population[i] for i in selected_indices]\n\n        # Crossover and Mutation\n        offspring = []\n        for i in range(0, population_size, 2):\n            parent1 = parents[i]\n            parent2 = parents[i + 1] if i + 1 < population_size else parents[0]  # Wrap around if odd population size\n            child1, child2 = crossover(parent1, parent2)\n            child1 = mutate(child1, mutation_rate)\n            child2 = mutate(child2, mutation_rate)\n            offspring.extend([child1, child2])\n\n        # Replace population\n        population = offspring\n\n        # Elitism: Keep the best individual from the previous generation\n        best_index = np.argmax(fitness_scores)\n        best_individual = population[best_index]\n        current_best_fitness = fitness_scores[best_index]\n        if current_best_fitness > best_sum_radii:\n            best_sum_radii = current_best_fitness\n            best_centers = population[best_index]\n            best_radii, _ = calculate_radii(best_centers)\n\n        # Print progress\n        #print(f\"Generation {generation + 1}: Best Fitness = {best_sum_radii}\")\n\n    best_radii, best_sum_radii = calculate_radii(best_centers)\n    return best_centers, best_radii, best_sum_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs a packing of 26 circles into a unit square using a genetic algorithm.\n\n    Returns:\n        tuple: A tuple containing:\n            - centers (np.ndarray): A numpy array of shape (26, 2) representing the centers of 26 circles.\n            - radii (np.ndarray): A numpy array of shape (26,) representing the radii of 26 circles.\n            - sum_radii (float): The sum of the radii.\n    \"\"\"\n\n    # Seed the genetic algorithm with potentially good layouts\n    # These layouts are placeholders and should be replaced with actual data\n    best_layouts = [np.random.rand(26, 2), np.random.rand(26, 2)]  # Replace with actual data\n    # Run the genetic algorithm\n    centers, radii, sum_radii = genetic_algorithm(population_size=200, generations=50, mutation_rate=0.01, best_layouts=best_layouts)\n\n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-11T19:25:44.908989",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.6,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 289,
        "candidates_token_count": 2272,
        "thoughts_token_count": 0
      },
      "response_text_len": 7820
    }
  }
}