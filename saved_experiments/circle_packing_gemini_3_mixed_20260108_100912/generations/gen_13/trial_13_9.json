{
  "trial_id": "trial_13_9",
  "generation": 13,
  "parent_id": "trial_6_6",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    # Number of circles\n    N = 26\n    \n    # --- Constraint & Jacobian Definitions ---\n    # State vector x: [cx_0...cx_N-1, cy_0...cy_N-1, r_0...r_N-1]\n    # Indices: cx: 0..N-1, cy: N..2N-1, r: 2N..3N-1\n    \n    # Precompute pairs for overlap constraints\n    pairs = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            pairs.append((i, j))\n    num_pairs = len(pairs)\n            \n    def get_constraints():\n        # Box constraints: 4N constraints\n        # cx - r >= 0, 1 - cx - r >= 0, cy - r >= 0, 1 - cy - r >= 0\n        def box_cons(x):\n            cx = x[:N]\n            cy = x[N:2*N]\n            r = x[2*N:]\n            return np.concatenate([\n                cx - r,\n                1.0 - cx - r,\n                cy - r,\n                1.0 - cy - r\n            ])\n            \n        def box_jac(x):\n            jac = np.zeros((4*N, 3*N))\n            # Fill diagonals\n            # cx - r >= 0\n            rows = np.arange(N)\n            jac[rows, rows] = 1.0\n            jac[rows, 2*N + rows] = -1.0\n            \n            # 1 - cx - r >= 0\n            rows = np.arange(N, 2*N)\n            jac[rows, rows - N] = -1.0\n            jac[rows, 2*N + (rows - N)] = -1.0\n            \n            # cy - r >= 0\n            rows = np.arange(2*N, 3*N)\n            jac[rows, N + (rows - 2*N)] = 1.0\n            jac[rows, 2*N + (rows - 2*N)] = -1.0\n            \n            # 1 - cy - r >= 0\n            rows = np.arange(3*N, 4*N)\n            jac[rows, N + (rows - 3*N)] = -1.0\n            jac[rows, 2*N + (rows - 3*N)] = -1.0\n            return jac\n\n        # Overlap constraints: N(N-1)/2 constraints\n        # dist_sq - (ri + rj)^2 >= 0\n        def overlap_cons(x):\n            cx = x[:N]\n            cy = x[N:2*N]\n            r = x[2*N:]\n            res = np.zeros(num_pairs)\n            for k, (i, j) in enumerate(pairs):\n                d2 = (cx[i] - cx[j])**2 + (cy[i] - cy[j])**2\n                sr = r[i] + r[j]\n                res[k] = d2 - sr**2\n            return res\n            \n        def overlap_jac(x):\n            cx = x[:N]\n            cy = x[N:2*N]\n            r = x[2*N:]\n            jac = np.zeros((num_pairs, 3*N))\n            for k, (i, j) in enumerate(pairs):\n                dx = cx[i] - cx[j]\n                dy = cy[i] - cy[j]\n                sr = r[i] + r[j]\n                \n                # Derivatives w.r.t cx_i, cx_j\n                jac[k, i] = 2 * dx\n                jac[k, j] = -2 * dx\n                # Derivatives w.r.t cy_i, cy_j\n                jac[k, N + i] = 2 * dy\n                jac[k, N + j] = -2 * dy\n                # Derivatives w.r.t r_i, r_j\n                jac[k, 2*N + i] = -2 * sr\n                jac[k, 2*N + j] = -2 * sr\n            return jac\n\n        return [\n            {'type': 'ineq', 'fun': box_cons, 'jac': box_jac},\n            {'type': 'ineq', 'fun': overlap_cons, 'jac': overlap_jac}\n        ]\n\n    # Objective: Minimize negative sum of radii\n    def objective(x):\n        return -np.sum(x[2*N:])\n    \n    def objective_jac(x):\n        grad = np.zeros(3*N)\n        grad[2*N:] = -1.0\n        return grad\n\n    # --- Seed Generation ---\n    def get_seeds():\n        seeds = []\n        \n        # 1. Square Grid 5x5 + 1\n        # Create 5x5 grid\n        gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n        pts = np.vstack([gx.ravel(), gy.ravel()]).T\n        # Add 1 random point\n        pts = np.vstack([pts, np.random.rand(1, 2) * 0.8 + 0.1])\n        r = np.full(N, 0.09)\n        seeds.append(np.concatenate([pts[:,0], pts[:,1], r]))\n        \n        # 2. Hexagonal-ish packing\n        # Generate more points than needed on hex grid and pick center ones\n        hex_pts = []\n        dx = 1.0/5.5\n        dy = dx * np.sqrt(3)/2\n        for r_idx in range(7):\n            for c_idx in range(7):\n                px = c_idx * dx + (r_idx % 2) * dx * 0.5\n                py = r_idx * dy\n                if 0.1 < px < 0.9 and 0.1 < py < 0.9:\n                    hex_pts.append([px, py])\n        hex_pts = np.array(hex_pts)\n        if len(hex_pts) >= N:\n            # Pick N closest to center\n            dists = np.sum((hex_pts - 0.5)**2, axis=1)\n            idx = np.argsort(dists)\n            hex_pts = hex_pts[idx[:N]]\n            r = np.full(N, 0.09)\n            seeds.append(np.concatenate([hex_pts[:,0], hex_pts[:,1], r]))\n            \n        # 3. Random seeds\n        for _ in range(2):\n            pts = np.random.rand(N, 2) * 0.8 + 0.1\n            r = np.random.rand(N) * 0.05 + 0.05\n            seeds.append(np.concatenate([pts[:,0], pts[:,1], r]))\n            \n        return seeds\n\n    # --- Optimization Routine ---\n    cons = get_constraints()\n    bounds = [(0, 1)] * (2*N) + [(0, 0.5)] * N\n    \n    def solve(x0, max_iter=500, tol=1e-4):\n        # Enforce bounds on x0 initially\n        x0[:2*N] = np.clip(x0[:2*N], 0, 1)\n        x0[2*N:] = np.clip(x0[2*N:], 1e-4, 0.5)\n        \n        res = minimize(\n            objective, \n            x0, \n            method='SLSQP', \n            jac=objective_jac, \n            constraints=cons,\n            bounds=bounds,\n            options={'maxiter': max_iter, 'ftol': tol, 'disp': False}\n        )\n        return res\n\n    # --- Main Loop ---\n    seeds = get_seeds()\n    best_x = None\n    best_score = -np.inf\n    \n    # 1. Evaluate Seeds\n    for s in seeds:\n        res = solve(s, max_iter=100)\n        score = -res.fun\n        if score > best_score:\n            best_score = score\n            best_x = res.x\n            \n    # 2. Perturbation & Polish\n    # Run multiple perturbations of the best seed\n    num_perturbations = 20\n    \n    candidates = []\n    # Keep the current best\n    candidates.append(best_x)\n    \n    for _ in range(num_perturbations):\n        # Perturb centers\n        x_p = best_x.copy()\n        # Noise scale: enough to jump out of local minima but keep structure\n        noise = np.random.normal(0, 0.05, 2*N) \n        x_p[:2*N] += noise\n        # Perturb radii slightly (randomize sizes to encourage disparity)\n        x_p[2*N:] *= np.random.uniform(0.9, 1.1, N)\n        candidates.append(x_p)\n        \n    final_best_x = best_x\n    final_best_score = best_score\n    \n    for cand in candidates:\n        res = solve(cand, max_iter=1000, tol=1e-6)\n        score = -res.fun\n        if score > final_best_score:\n            final_best_score = score\n            final_best_x = res.x\n\n    # --- Formatting Output ---\n    x_opt = final_best_x\n    centers = np.vstack([x_opt[:N], x_opt[N:2*N]]).T\n    radii = x_opt[2*N:]\n    \n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.628069777803295,
    "eval_time": 1.8185462951660156,
    "error": null
  },
  "prompt": "Combine {CODE_TRIAL_6_6} (Constructive) and {CODE_TRIAL_11_11} (Random Polish). \n\nStrategy: **Constructive with Random Perturbations**.\n- Run the Constructive algorithm to get a good base.\n- Create 50 variations by adding small random noise (perturbation) to the centers.\n- Polish all 50 variations.\n- This explores the local basin of the constructive solution.\n\nIMPORTANT: Your response must contain exactly one Python code block starting with ```python and ending with ```. The code must define `construct_packing`.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    # Number of circles\n    N = 26\n    \n    # --- Constraint & Jacobian Definitions ---\n    # State vector x: [cx_0...cx_N-1, cy_0...cy_N-1, r_0...r_N-1]\n    # Indices: cx: 0..N-1, cy: N..2N-1, r: 2N..3N-1\n    \n    # Precompute pairs for overlap constraints\n    pairs = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            pairs.append((i, j))\n    num_pairs = len(pairs)\n            \n    def get_constraints():\n        # Box constraints: 4N constraints\n        # cx - r >= 0, 1 - cx - r >= 0, cy - r >= 0, 1 - cy - r >= 0\n        def box_cons(x):\n            cx = x[:N]\n            cy = x[N:2*N]\n            r = x[2*N:]\n            return np.concatenate([\n                cx - r,\n                1.0 - cx - r,\n                cy - r,\n                1.0 - cy - r\n            ])\n            \n        def box_jac(x):\n            jac = np.zeros((4*N, 3*N))\n            # Fill diagonals\n            # cx - r >= 0\n            rows = np.arange(N)\n            jac[rows, rows] = 1.0\n            jac[rows, 2*N + rows] = -1.0\n            \n            # 1 - cx - r >= 0\n            rows = np.arange(N, 2*N)\n            jac[rows, rows - N] = -1.0\n            jac[rows, 2*N + (rows - N)] = -1.0\n            \n            # cy - r >= 0\n            rows = np.arange(2*N, 3*N)\n            jac[rows, N + (rows - 2*N)] = 1.0\n            jac[rows, 2*N + (rows - 2*N)] = -1.0\n            \n            # 1 - cy - r >= 0\n            rows = np.arange(3*N, 4*N)\n            jac[rows, N + (rows - 3*N)] = -1.0\n            jac[rows, 2*N + (rows - 3*N)] = -1.0\n            return jac\n\n        # Overlap constraints: N(N-1)/2 constraints\n        # dist_sq - (ri + rj)^2 >= 0\n        def overlap_cons(x):\n            cx = x[:N]\n            cy = x[N:2*N]\n            r = x[2*N:]\n            res = np.zeros(num_pairs)\n            for k, (i, j) in enumerate(pairs):\n                d2 = (cx[i] - cx[j])**2 + (cy[i] - cy[j])**2\n                sr = r[i] + r[j]\n                res[k] = d2 - sr**2\n            return res\n            \n        def overlap_jac(x):\n            cx = x[:N]\n            cy = x[N:2*N]\n            r = x[2*N:]\n            jac = np.zeros((num_pairs, 3*N))\n            for k, (i, j) in enumerate(pairs):\n                dx = cx[i] - cx[j]\n                dy = cy[i] - cy[j]\n                sr = r[i] + r[j]\n                \n                # Derivatives w.r.t cx_i, cx_j\n                jac[k, i] = 2 * dx\n                jac[k, j] = -2 * dx\n                # Derivatives w.r.t cy_i, cy_j\n                jac[k, N + i] = 2 * dy\n                jac[k, N + j] = -2 * dy\n                # Derivatives w.r.t r_i, r_j\n                jac[k, 2*N + i] = -2 * sr\n                jac[k, 2*N + j] = -2 * sr\n            return jac\n\n        return [\n            {'type': 'ineq', 'fun': box_cons, 'jac': box_jac},\n            {'type': 'ineq', 'fun': overlap_cons, 'jac': overlap_jac}\n        ]\n\n    # Objective: Minimize negative sum of radii\n    def objective(x):\n        return -np.sum(x[2*N:])\n    \n    def objective_jac(x):\n        grad = np.zeros(3*N)\n        grad[2*N:] = -1.0\n        return grad\n\n    # --- Seed Generation ---\n    def get_seeds():\n        seeds = []\n        \n        # 1. Square Grid 5x5 + 1\n        # Create 5x5 grid\n        gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n        pts = np.vstack([gx.ravel(), gy.ravel()]).T\n        # Add 1 random point\n        pts = np.vstack([pts, np.random.rand(1, 2) * 0.8 + 0.1])\n        r = np.full(N, 0.09)\n        seeds.append(np.concatenate([pts[:,0], pts[:,1], r]))\n        \n        # 2. Hexagonal-ish packing\n        # Generate more points than needed on hex grid and pick center ones\n        hex_pts = []\n        dx = 1.0/5.5\n        dy = dx * np.sqrt(3)/2\n        for r_idx in range(7):\n            for c_idx in range(7):\n                px = c_idx * dx + (r_idx % 2) * dx * 0.5\n                py = r_idx * dy\n                if 0.1 < px < 0.9 and 0.1 < py < 0.9:\n                    hex_pts.append([px, py])\n        hex_pts = np.array(hex_pts)\n        if len(hex_pts) >= N:\n            # Pick N closest to center\n            dists = np.sum((hex_pts - 0.5)**2, axis=1)\n            idx = np.argsort(dists)\n            hex_pts = hex_pts[idx[:N]]\n            r = np.full(N, 0.09)\n            seeds.append(np.concatenate([hex_pts[:,0], hex_pts[:,1], r]))\n            \n        # 3. Random seeds\n        for _ in range(2):\n            pts = np.random.rand(N, 2) * 0.8 + 0.1\n            r = np.random.rand(N) * 0.05 + 0.05\n            seeds.append(np.concatenate([pts[:,0], pts[:,1], r]))\n            \n        return seeds\n\n    # --- Optimization Routine ---\n    cons = get_constraints()\n    bounds = [(0, 1)] * (2*N) + [(0, 0.5)] * N\n    \n    def solve(x0, max_iter=500, tol=1e-4):\n        # Enforce bounds on x0 initially\n        x0[:2*N] = np.clip(x0[:2*N], 0, 1)\n        x0[2*N:] = np.clip(x0[2*N:], 1e-4, 0.5)\n        \n        res = minimize(\n            objective, \n            x0, \n            method='SLSQP', \n            jac=objective_jac, \n            constraints=cons,\n            bounds=bounds,\n            options={'maxiter': max_iter, 'ftol': tol, 'disp': False}\n        )\n        return res\n\n    # --- Main Loop ---\n    seeds = get_seeds()\n    best_x = None\n    best_score = -np.inf\n    \n    # 1. Evaluate Seeds\n    for s in seeds:\n        res = solve(s, max_iter=100)\n        score = -res.fun\n        if score > best_score:\n            best_score = score\n            best_x = res.x\n            \n    # 2. Perturbation & Polish\n    # Run multiple perturbations of the best seed\n    num_perturbations = 20\n    \n    candidates = []\n    # Keep the current best\n    candidates.append(best_x)\n    \n    for _ in range(num_perturbations):\n        # Perturb centers\n        x_p = best_x.copy()\n        # Noise scale: enough to jump out of local minima but keep structure\n        noise = np.random.normal(0, 0.05, 2*N) \n        x_p[:2*N] += noise\n        # Perturb radii slightly (randomize sizes to encourage disparity)\n        x_p[2*N:] *= np.random.uniform(0.9, 1.1, N)\n        candidates.append(x_p)\n        \n    final_best_x = best_x\n    final_best_score = best_score\n    \n    for cand in candidates:\n        res = solve(cand, max_iter=1000, tol=1e-6)\n        score = -res.fun\n        if score > final_best_score:\n            final_best_score = score\n            final_best_x = res.x\n\n    # --- Formatting Output ---\n    x_opt = final_best_x\n    centers = np.vstack([x_opt[:N], x_opt[N:2*N]]).T\n    radii = x_opt[2*N:]\n    \n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T11:13:24.996484",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 351,
        "candidates_token_count": 2391,
        "thoughts_token_count": 11613
      },
      "response_text_len": 6705
    }
  }
}