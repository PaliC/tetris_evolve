{
  "trial_id": "trial_13_4",
  "generation": 13,
  "parent_id": "trial_12_3",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef construct_packing():\n    # Problem Parameters\n    N_CIRCLES = 26\n    # Ensemble settings: Generate multiple seeds, polish the best ones.\n    # Time constraints suggest keeping N_SEEDS moderate and polishing efficient.\n    N_SEEDS = 12 \n    GRID_RES = 64  # Resolution for hole finding\n    \n    # Precompute grid for hole searching\n    gx = np.linspace(0, 1, GRID_RES)\n    gy = np.linspace(0, 1, GRID_RES)\n    GX, GY = np.meshgrid(gx, gy)\n    grid_points = np.column_stack((GX.ravel(), GY.ravel()))\n    \n    # ---------------------------------------------------------\n    # Helper: Find top K largest empty circles (Holes)\n    # ---------------------------------------------------------\n    def get_top_k_holes(centers, radii, k=3):\n        # Calculate distance from every grid point to nearest obstacle\n        # 1. Distance to walls\n        d_left = grid_points[:, 0]\n        d_right = 1 - grid_points[:, 0]\n        d_bottom = grid_points[:, 1]\n        d_top = 1 - grid_points[:, 1]\n        d_walls = np.minimum(np.minimum(d_left, d_right), np.minimum(d_bottom, d_top))\n        \n        d_obstacles = d_walls\n        if len(centers) > 0:\n            # Distance to existing circles: dist(p, c) - r\n            # Vectorized calculation\n            dists = np.sqrt(np.sum((grid_points[:, None, :] - centers[None, :, :])**2, axis=2))\n            d_circles = dists - radii[None, :]\n            min_d_circles = np.min(d_circles, axis=1)\n            d_obstacles = np.minimum(d_walls, min_d_circles)\n            \n        # 2. Iteratively pick max and mask out region to find distinct local maxima\n        candidates = []\n        temp_d = d_obstacles.copy()\n        \n        for _ in range(k):\n            idx = np.argmax(temp_d)\n            val = temp_d[idx]\n            if val <= 1e-6: break # No space left\n            \n            p0 = grid_points[idx]\n            \n            # Local optimization to refine the hole position and size\n            def nlp_dist(p):\n                x, y = p\n                # Check bounds\n                if x < 0 or x > 1 or y < 0 or y > 1: return 1.0\n                dw = min(x, 1-x, y, 1-y)\n                if len(centers) == 0: return -dw\n                ds = np.sqrt(np.sum((centers - p)**2, axis=1)) - radii\n                return -min(dw, np.min(ds))\n            \n            # L-BFGS-B is fast for bound-constrained local search\n            res = minimize(nlp_dist, p0, method='L-BFGS-B', bounds=[(0,1), (0,1)])\n            cand_p = res.x\n            cand_r = -res.fun\n            \n            candidates.append((cand_p, cand_r))\n            \n            # Mask out this region in the grid to find the next distinct hole\n            # We mask an area slightly larger than the hole to force diversity\n            d_to_cand = np.sqrt(np.sum((grid_points - cand_p)**2, axis=1))\n            mask = d_to_cand < cand_r * 1.5 \n            temp_d[mask] = -1.0\n            \n        return candidates\n\n    # ---------------------------------------------------------\n    # Generator Strategy: Look-Ahead Greedy\n    # ---------------------------------------------------------\n    def generate_seed(seed_rng):\n        my_centers = np.zeros((0, 2))\n        my_radii = np.zeros(0)\n        \n        np.random.seed(seed_rng)\n        \n        for i in range(N_CIRCLES):\n            # 1. Find candidate positions\n            candidates = get_top_k_holes(my_centers, my_radii, k=4)\n            if not candidates:\n                break\n                \n            best_score = -1.0\n            best_cand = candidates[0]\n            \n            # 2. Look-Ahead Logic\n            # For early circles (where placement is critical), simulate one step ahead.\n            # Look-ahead is computationally expensive, so limit to first 12 circles.\n            if i < 12 and len(candidates) > 1:\n                for (cp, cr) in candidates:\n                    # Hypothetical placement\n                    temp_c = np.vstack([my_centers, cp]) if len(my_centers) > 0 else np.array([cp])\n                    temp_r = np.append(my_radii, cr)\n                    \n                    # Estimate size of the NEXT largest hole (using grid only for speed)\n                    d_l = grid_points[:, 0]\n                    d_r = 1 - grid_points[:, 0]\n                    d_b = grid_points[:, 1]\n                    d_t = 1 - grid_points[:, 1]\n                    dw = np.minimum(np.minimum(d_l, d_r), np.minimum(d_b, d_t))\n                    \n                    dists = np.sqrt(np.sum((grid_points[:, None, :] - temp_c[None, :, :])**2, axis=2))\n                    dc = dists - temp_r[None, :]\n                    d_obs = np.minimum(dw, np.min(dc, axis=1))\n                    \n                    next_r = np.max(d_obs)\n                    \n                    # Score combines current radius and potential next radius\n                    score = cr + 0.9 * next_r \n                    \n                    if score > best_score:\n                        best_score = score\n                        best_cand = (cp, cr)\n            else:\n                # Randomized Greedy for later stages or if look-ahead skipped\n                # Add randomness to ensure ensemble diversity\n                if i < 6 and np.random.random() < 0.25:\n                    idx = np.random.choice(min(len(candidates), 2))\n                    best_cand = candidates[idx]\n                else:\n                    best_cand = candidates[0]\n            \n            # Add chosen circle\n            if len(my_centers) == 0:\n                my_centers = np.array([best_cand[0]])\n            else:\n                my_centers = np.vstack([my_centers, best_cand[0]])\n            my_radii = np.append(my_radii, best_cand[1])\n            \n        return my_centers, my_radii\n\n    # ---------------------------------------------------------\n    # Polishing: Continuous Optimization + Linear Programming\n    # ---------------------------------------------------------\n    def optimize_configuration(centers, radii):\n        n = len(radii)\n        \n        # Phase 1: Adjust centers using non-linear optimization (Penalty Method)\n        # Variables: x, y, r for each circle\n        x0 = np.zeros(3 * n)\n        x0[0::3] = centers[:, 0]\n        x0[1::3] = centers[:, 1]\n        x0[2::3] = radii\n        \n        def loss(p):\n            cs = p.reshape((n, 3))\n            xs = cs[:, 0]\n            ys = cs[:, 1]\n            rs = cs[:, 2]\n            \n            # Maximize sum(r) => Minimize -sum(r)\n            obj = -np.sum(rs)\n            \n            # Penalty for Bounds: x-r>=0, x+r<=1, ...\n            v_xmin = np.maximum(0, rs - xs)\n            v_xmax = np.maximum(0, rs - (1 - xs))\n            v_ymin = np.maximum(0, rs - ys)\n            v_ymax = np.maximum(0, rs - (1 - ys))\n            \n            # Penalty for Overlaps: dist_ij >= r_i + r_j\n            dx = xs[:, None] - xs[None, :]\n            dy = ys[:, None] - ys[None, :]\n            d = np.sqrt(dx**2 + dy**2 + 1e-12)\n            r_sum = rs[:, None] + rs[None, :]\n            v_overlap = np.maximum(0, r_sum - d)\n            np.fill_diagonal(v_overlap, 0)\n            \n            # Total Penalty\n            penalty = np.sum(v_xmin**2) + np.sum(v_xmax**2) + np.sum(v_ymin**2) + np.sum(v_ymax**2)\n            penalty += 0.5 * np.sum(v_overlap**2)\n            \n            return obj + 100000.0 * penalty\n\n        bounds = []\n        for _ in range(n):\n            bounds.extend([(0, 1), (0, 1), (1e-6, 0.6)])\n            \n        # L-BFGS-B is robust for this penalty formulation\n        res = minimize(loss, x0, method='L-BFGS-B', bounds=bounds, options={'maxiter': 800})\n        \n        final_p = res.x.reshape((n, 3))\n        opt_centers = final_p[:, :2]\n        \n        # Phase 2: Fix centers, maximize radii exactly using Linear Programming\n        # This ensures all constraints are strictly satisfied.\n        # Maximize sum(r_i) subject to r_i + r_j <= dist_ij and bounds.\n        c_lp = -np.ones(n) # Minimize -sum(r)\n        \n        A_ub = []\n        b_ub = []\n        \n        # Pairwise constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(opt_centers[i] - opt_centers[j])\n                row = np.zeros(n)\n                row[i] = 1\n                row[j] = 1\n                A_ub.append(row)\n                b_ub.append(dist)\n        \n        # Box constraints (as variable bounds)\n        bounds_lp = []\n        for i in range(n):\n            x, y = opt_centers[i]\n            max_r_box = min(x, 1-x, y, 1-y)\n            bounds_lp.append((0, max_r_box))\n            \n        res_lp = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=bounds_lp, method='highs')\n        \n        if res_lp.success:\n            opt_radii = res_lp.x\n            return opt_centers, opt_radii, np.sum(opt_radii)\n        else:\n            # Fallback if LP fails (rare)\n            return opt_centers, final_p[:, 2], np.sum(final_p[:, 2])\n\n    # ---------------------------------------------------------\n    # Main Execution Loop\n    # ---------------------------------------------------------\n    seeds = []\n    # Generate ensemble\n    for k in range(N_SEEDS):\n        try:\n            c, r = generate_seed(k + 42)\n            score = np.sum(r)\n            seeds.append((score, c, r))\n        except:\n            continue\n            \n    # Sort by initial score\n    seeds.sort(key=lambda x: x[0], reverse=True)\n    \n    best_total = 0.0\n    best_c = np.zeros((N_CIRCLES, 2))\n    best_r = np.zeros(N_CIRCLES)\n    \n    # Polish the top candidates (Elitism)\n    top_k = min(len(seeds), 5)\n    for i in range(top_k):\n        _, c_init, r_init = seeds[i]\n        c_opt, r_opt, s_opt = optimize_configuration(c_init, r_init)\n        \n        if s_opt > best_total:\n            best_total = s_opt\n            best_c = c_opt\n            best_r = r_opt\n            \n    return best_c, best_r, best_total\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 1.8734290462307135,
    "eval_time": 8.977198839187622,
    "error": null
  },
  "prompt": "Refine {CODE_TRIAL_12_3}. \n\nStrategy: **Look-Ahead Ensemble**.\n- Instead of simple greedy seeds, use the 'Look-Ahead' strategy (from trial_10_3) to generate the seeds.\n- Generate 20 seeds using Look-Ahead with different random tie-breaking.\n- Polish all 20.\n- This combines the best constructive logic with the best global search logic.\n\nIMPORTANT: Your response must contain exactly one Python code block starting with ```python and ending with ```. The code must define `construct_packing`.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef construct_packing():\n    # Problem Parameters\n    N_CIRCLES = 26\n    # Ensemble settings: Generate multiple seeds, polish the best ones.\n    # Time constraints suggest keeping N_SEEDS moderate and polishing efficient.\n    N_SEEDS = 12 \n    GRID_RES = 64  # Resolution for hole finding\n    \n    # Precompute grid for hole searching\n    gx = np.linspace(0, 1, GRID_RES)\n    gy = np.linspace(0, 1, GRID_RES)\n    GX, GY = np.meshgrid(gx, gy)\n    grid_points = np.column_stack((GX.ravel(), GY.ravel()))\n    \n    # ---------------------------------------------------------\n    # Helper: Find top K largest empty circles (Holes)\n    # ---------------------------------------------------------\n    def get_top_k_holes(centers, radii, k=3):\n        # Calculate distance from every grid point to nearest obstacle\n        # 1. Distance to walls\n        d_left = grid_points[:, 0]\n        d_right = 1 - grid_points[:, 0]\n        d_bottom = grid_points[:, 1]\n        d_top = 1 - grid_points[:, 1]\n        d_walls = np.minimum(np.minimum(d_left, d_right), np.minimum(d_bottom, d_top))\n        \n        d_obstacles = d_walls\n        if len(centers) > 0:\n            # Distance to existing circles: dist(p, c) - r\n            # Vectorized calculation\n            dists = np.sqrt(np.sum((grid_points[:, None, :] - centers[None, :, :])**2, axis=2))\n            d_circles = dists - radii[None, :]\n            min_d_circles = np.min(d_circles, axis=1)\n            d_obstacles = np.minimum(d_walls, min_d_circles)\n            \n        # 2. Iteratively pick max and mask out region to find distinct local maxima\n        candidates = []\n        temp_d = d_obstacles.copy()\n        \n        for _ in range(k):\n            idx = np.argmax(temp_d)\n            val = temp_d[idx]\n            if val <= 1e-6: break # No space left\n            \n            p0 = grid_points[idx]\n            \n            # Local optimization to refine the hole position and size\n            def nlp_dist(p):\n                x, y = p\n                # Check bounds\n                if x < 0 or x > 1 or y < 0 or y > 1: return 1.0\n                dw = min(x, 1-x, y, 1-y)\n                if len(centers) == 0: return -dw\n                ds = np.sqrt(np.sum((centers - p)**2, axis=1)) - radii\n                return -min(dw, np.min(ds))\n            \n            # L-BFGS-B is fast for bound-constrained local search\n            res = minimize(nlp_dist, p0, method='L-BFGS-B', bounds=[(0,1), (0,1)])\n            cand_p = res.x\n            cand_r = -res.fun\n            \n            candidates.append((cand_p, cand_r))\n            \n            # Mask out this region in the grid to find the next distinct hole\n            # We mask an area slightly larger than the hole to force diversity\n            d_to_cand = np.sqrt(np.sum((grid_points - cand_p)**2, axis=1))\n            mask = d_to_cand < cand_r * 1.5 \n            temp_d[mask] = -1.0\n            \n        return candidates\n\n    # ---------------------------------------------------------\n    # Generator Strategy: Look-Ahead Greedy\n    # ---------------------------------------------------------\n    def generate_seed(seed_rng):\n        my_centers = np.zeros((0, 2))\n        my_radii = np.zeros(0)\n        \n        np.random.seed(seed_rng)\n        \n        for i in range(N_CIRCLES):\n            # 1. Find candidate positions\n            candidates = get_top_k_holes(my_centers, my_radii, k=4)\n            if not candidates:\n                break\n                \n            best_score = -1.0\n            best_cand = candidates[0]\n            \n            # 2. Look-Ahead Logic\n            # For early circles (where placement is critical), simulate one step ahead.\n            # Look-ahead is computationally expensive, so limit to first 12 circles.\n            if i < 12 and len(candidates) > 1:\n                for (cp, cr) in candidates:\n                    # Hypothetical placement\n                    temp_c = np.vstack([my_centers, cp]) if len(my_centers) > 0 else np.array([cp])\n                    temp_r = np.append(my_radii, cr)\n                    \n                    # Estimate size of the NEXT largest hole (using grid only for speed)\n                    d_l = grid_points[:, 0]\n                    d_r = 1 - grid_points[:, 0]\n                    d_b = grid_points[:, 1]\n                    d_t = 1 - grid_points[:, 1]\n                    dw = np.minimum(np.minimum(d_l, d_r), np.minimum(d_b, d_t))\n                    \n                    dists = np.sqrt(np.sum((grid_points[:, None, :] - temp_c[None, :, :])**2, axis=2))\n                    dc = dists - temp_r[None, :]\n                    d_obs = np.minimum(dw, np.min(dc, axis=1))\n                    \n                    next_r = np.max(d_obs)\n                    \n                    # Score combines current radius and potential next radius\n                    score = cr + 0.9 * next_r \n                    \n                    if score > best_score:\n                        best_score = score\n                        best_cand = (cp, cr)\n            else:\n                # Randomized Greedy for later stages or if look-ahead skipped\n                # Add randomness to ensure ensemble diversity\n                if i < 6 and np.random.random() < 0.25:\n                    idx = np.random.choice(min(len(candidates), 2))\n                    best_cand = candidates[idx]\n                else:\n                    best_cand = candidates[0]\n            \n            # Add chosen circle\n            if len(my_centers) == 0:\n                my_centers = np.array([best_cand[0]])\n            else:\n                my_centers = np.vstack([my_centers, best_cand[0]])\n            my_radii = np.append(my_radii, best_cand[1])\n            \n        return my_centers, my_radii\n\n    # ---------------------------------------------------------\n    # Polishing: Continuous Optimization + Linear Programming\n    # ---------------------------------------------------------\n    def optimize_configuration(centers, radii):\n        n = len(radii)\n        \n        # Phase 1: Adjust centers using non-linear optimization (Penalty Method)\n        # Variables: x, y, r for each circle\n        x0 = np.zeros(3 * n)\n        x0[0::3] = centers[:, 0]\n        x0[1::3] = centers[:, 1]\n        x0[2::3] = radii\n        \n        def loss(p):\n            cs = p.reshape((n, 3))\n            xs = cs[:, 0]\n            ys = cs[:, 1]\n            rs = cs[:, 2]\n            \n            # Maximize sum(r) => Minimize -sum(r)\n            obj = -np.sum(rs)\n            \n            # Penalty for Bounds: x-r>=0, x+r<=1, ...\n            v_xmin = np.maximum(0, rs - xs)\n            v_xmax = np.maximum(0, rs - (1 - xs))\n            v_ymin = np.maximum(0, rs - ys)\n            v_ymax = np.maximum(0, rs - (1 - ys))\n            \n            # Penalty for Overlaps: dist_ij >= r_i + r_j\n            dx = xs[:, None] - xs[None, :]\n            dy = ys[:, None] - ys[None, :]\n            d = np.sqrt(dx**2 + dy**2 + 1e-12)\n            r_sum = rs[:, None] + rs[None, :]\n            v_overlap = np.maximum(0, r_sum - d)\n            np.fill_diagonal(v_overlap, 0)\n            \n            # Total Penalty\n            penalty = np.sum(v_xmin**2) + np.sum(v_xmax**2) + np.sum(v_ymin**2) + np.sum(v_ymax**2)\n            penalty += 0.5 * np.sum(v_overlap**2)\n            \n            return obj + 100000.0 * penalty\n\n        bounds = []\n        for _ in range(n):\n            bounds.extend([(0, 1), (0, 1), (1e-6, 0.6)])\n            \n        # L-BFGS-B is robust for this penalty formulation\n        res = minimize(loss, x0, method='L-BFGS-B', bounds=bounds, options={'maxiter': 800})\n        \n        final_p = res.x.reshape((n, 3))\n        opt_centers = final_p[:, :2]\n        \n        # Phase 2: Fix centers, maximize radii exactly using Linear Programming\n        # This ensures all constraints are strictly satisfied.\n        # Maximize sum(r_i) subject to r_i + r_j <= dist_ij and bounds.\n        c_lp = -np.ones(n) # Minimize -sum(r)\n        \n        A_ub = []\n        b_ub = []\n        \n        # Pairwise constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(opt_centers[i] - opt_centers[j])\n                row = np.zeros(n)\n                row[i] = 1\n                row[j] = 1\n                A_ub.append(row)\n                b_ub.append(dist)\n        \n        # Box constraints (as variable bounds)\n        bounds_lp = []\n        for i in range(n):\n            x, y = opt_centers[i]\n            max_r_box = min(x, 1-x, y, 1-y)\n            bounds_lp.append((0, max_r_box))\n            \n        res_lp = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=bounds_lp, method='highs')\n        \n        if res_lp.success:\n            opt_radii = res_lp.x\n            return opt_centers, opt_radii, np.sum(opt_radii)\n        else:\n            # Fallback if LP fails (rare)\n            return opt_centers, final_p[:, 2], np.sum(final_p[:, 2])\n\n    # ---------------------------------------------------------\n    # Main Execution Loop\n    # ---------------------------------------------------------\n    seeds = []\n    # Generate ensemble\n    for k in range(N_SEEDS):\n        try:\n            c, r = generate_seed(k + 42)\n            score = np.sum(r)\n            seeds.append((score, c, r))\n        except:\n            continue\n            \n    # Sort by initial score\n    seeds.sort(key=lambda x: x[0], reverse=True)\n    \n    best_total = 0.0\n    best_c = np.zeros((N_CIRCLES, 2))\n    best_r = np.zeros(N_CIRCLES)\n    \n    # Polish the top candidates (Elitism)\n    top_k = min(len(seeds), 5)\n    for i in range(top_k):\n        _, c_init, r_init = seeds[i]\n        c_opt, r_opt, s_opt = optimize_configuration(c_init, r_init)\n        \n        if s_opt > best_total:\n            best_total = s_opt\n            best_c = c_opt\n            best_r = r_opt\n            \n    return best_c, best_r, best_total\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T11:13:35.065677",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 346,
        "candidates_token_count": 2990,
        "thoughts_token_count": 10585
      },
      "response_text_len": 10015
    }
  }
}