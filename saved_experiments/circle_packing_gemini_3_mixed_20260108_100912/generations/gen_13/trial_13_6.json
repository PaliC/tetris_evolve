{
  "trial_id": "trial_13_6",
  "generation": 13,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import dual_annealing, linprog\nfrom scipy.spatial.distance import pdist\n\ndef construct_packing():\n    N = 26\n    \n    # Precompute pair indices for vectorized operations in the objective function\n    # idx_i, idx_j correspond to the indices of pairs returned by pdist (upper triangle)\n    idx_i = []\n    idx_j = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            idx_i.append(i)\n            idx_j.append(j)\n    idx_i = np.array(idx_i)\n    idx_j = np.array(idx_j)\n\n    def objective(p):\n        \"\"\"\n        Objective function for Dual Annealing.\n        Variables p: [x_0...x_N-1, y_0...y_N-1, r_0...r_N-1]\n        We minimize: -sum(r) + penalty * violations\n        \"\"\"\n        xs = p[:N]\n        ys = p[N:2*N]\n        rs = p[2*N:]\n        \n        # 1. Boundary violations\n        # Conditions: x >= r, x <= 1-r, y >= r, y <= 1-r\n        # Penalties for: r - x > 0, x + r - 1 > 0, ...\n        v_left = np.maximum(0, rs - xs)\n        v_right = np.maximum(0, xs + rs - 1.0)\n        v_bottom = np.maximum(0, rs - ys)\n        v_top = np.maximum(0, ys + rs - 1.0)\n        \n        # Sum of squared violations\n        penalty_boundary = np.sum(v_left**2 + v_right**2 + v_bottom**2 + v_top**2)\n        \n        # 2. Overlap violations\n        # Condition: dist_ij >= r_i + r_j\n        # Penalty for: r_i + r_j - dist_ij > 0\n        coords = np.column_stack((xs, ys))\n        dists = pdist(coords)\n        r_sums = rs[idx_i] + rs[idx_j]\n        \n        v_overlap = np.maximum(0, r_sums - dists)\n        penalty_overlap = np.sum(v_overlap**2)\n        \n        # Total Objective\n        # Weight w needs to be large enough to prioritize validity\n        w = 1e6\n        return -np.sum(rs) + w * (penalty_boundary + penalty_overlap)\n\n    # Define bounds for variables\n    # x, y in [0, 1]\n    # r in [0, 0.25] (conservative upper bound)\n    bounds = [(0, 1)] * (2 * N) + [(0, 0.25)] * N\n    \n    # Initial guess: Regular grid to help the optimizer\n    x0 = np.zeros(3 * N)\n    grid_side = int(np.ceil(np.sqrt(N)))\n    for i in range(N):\n        r = i // grid_side\n        c = i % grid_side\n        x0[i] = (c + 0.5) / grid_side        # x\n        x0[N + i] = (r + 0.5) / grid_side    # y\n        x0[2 * N + i] = 0.05                 # r\n\n    # Run Dual Annealing\n    # Strategy: Global optimization to find approximate centers\n    res = dual_annealing(\n        objective, \n        bounds=bounds, \n        maxiter=1000, \n        x0=x0, \n        seed=42\n    )\n    \n    # Extract optimized centers\n    best_p = res.x\n    final_centers = np.column_stack((best_p[:N], best_p[N:2*N]))\n    \n    # Post-processing: \n    # Solve a Linear Program to maximize radii for the fixed centers found.\n    # This ensures the solution is strictly valid and optimal for the given geometry.\n    \n    # Constraints: r_i + r_j <= dist_ij\n    dists = pdist(final_centers)\n    num_pairs = len(dists)\n    \n    A_ub = np.zeros((num_pairs, N))\n    A_ub[np.arange(num_pairs), idx_i] = 1.0\n    A_ub[np.arange(num_pairs), idx_j] = 1.0\n    b_ub = dists\n    \n    # Bounds for r: 0 <= r <= distance_to_walls\n    x_c = final_centers[:, 0]\n    y_c = final_centers[:, 1]\n    d_walls = np.minimum(np.minimum(x_c, 1 - x_c), np.minimum(y_c, 1 - y_c))\n    r_bounds = [(0, d) for d in d_walls]\n    \n    # Objective: Minimize -sum(r)\n    c_obj = -np.ones(N)\n    \n    # Solve LP\n    lp_res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=r_bounds, method='interior-point')\n    \n    final_radii = lp_res.x\n    \n    if final_radii is None:\n        # Fallback in case of LP failure (rare)\n        final_radii = np.zeros(N)\n\n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.455133749818062,
    "eval_time": 13.124941110610962,
    "error": null
  },
  "prompt": "Solve circle packing (26 circles). \n\nStrategy: **Dual Annealing**.\n- Use `scipy.optimize.dual_annealing`.\n- This is a variation of simulated annealing coupled with local search.\n- Bounds: [0,1] for all centers.\n- Max iterations: 1000.\n- This is often very effective for difficult global optimization problems.\n\nIMPORTANT: Your response must contain exactly one Python code block starting with ```python and ending with ```. The code must define `construct_packing`.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import dual_annealing, linprog\nfrom scipy.spatial.distance import pdist\n\ndef construct_packing():\n    N = 26\n    \n    # Precompute pair indices for vectorized operations in the objective function\n    # idx_i, idx_j correspond to the indices of pairs returned by pdist (upper triangle)\n    idx_i = []\n    idx_j = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            idx_i.append(i)\n            idx_j.append(j)\n    idx_i = np.array(idx_i)\n    idx_j = np.array(idx_j)\n\n    def objective(p):\n        \"\"\"\n        Objective function for Dual Annealing.\n        Variables p: [x_0...x_N-1, y_0...y_N-1, r_0...r_N-1]\n        We minimize: -sum(r) + penalty * violations\n        \"\"\"\n        xs = p[:N]\n        ys = p[N:2*N]\n        rs = p[2*N:]\n        \n        # 1. Boundary violations\n        # Conditions: x >= r, x <= 1-r, y >= r, y <= 1-r\n        # Penalties for: r - x > 0, x + r - 1 > 0, ...\n        v_left = np.maximum(0, rs - xs)\n        v_right = np.maximum(0, xs + rs - 1.0)\n        v_bottom = np.maximum(0, rs - ys)\n        v_top = np.maximum(0, ys + rs - 1.0)\n        \n        # Sum of squared violations\n        penalty_boundary = np.sum(v_left**2 + v_right**2 + v_bottom**2 + v_top**2)\n        \n        # 2. Overlap violations\n        # Condition: dist_ij >= r_i + r_j\n        # Penalty for: r_i + r_j - dist_ij > 0\n        coords = np.column_stack((xs, ys))\n        dists = pdist(coords)\n        r_sums = rs[idx_i] + rs[idx_j]\n        \n        v_overlap = np.maximum(0, r_sums - dists)\n        penalty_overlap = np.sum(v_overlap**2)\n        \n        # Total Objective\n        # Weight w needs to be large enough to prioritize validity\n        w = 1e6\n        return -np.sum(rs) + w * (penalty_boundary + penalty_overlap)\n\n    # Define bounds for variables\n    # x, y in [0, 1]\n    # r in [0, 0.25] (conservative upper bound)\n    bounds = [(0, 1)] * (2 * N) + [(0, 0.25)] * N\n    \n    # Initial guess: Regular grid to help the optimizer\n    x0 = np.zeros(3 * N)\n    grid_side = int(np.ceil(np.sqrt(N)))\n    for i in range(N):\n        r = i // grid_side\n        c = i % grid_side\n        x0[i] = (c + 0.5) / grid_side        # x\n        x0[N + i] = (r + 0.5) / grid_side    # y\n        x0[2 * N + i] = 0.05                 # r\n\n    # Run Dual Annealing\n    # Strategy: Global optimization to find approximate centers\n    res = dual_annealing(\n        objective, \n        bounds=bounds, \n        maxiter=1000, \n        x0=x0, \n        seed=42\n    )\n    \n    # Extract optimized centers\n    best_p = res.x\n    final_centers = np.column_stack((best_p[:N], best_p[N:2*N]))\n    \n    # Post-processing: \n    # Solve a Linear Program to maximize radii for the fixed centers found.\n    # This ensures the solution is strictly valid and optimal for the given geometry.\n    \n    # Constraints: r_i + r_j <= dist_ij\n    dists = pdist(final_centers)\n    num_pairs = len(dists)\n    \n    A_ub = np.zeros((num_pairs, N))\n    A_ub[np.arange(num_pairs), idx_i] = 1.0\n    A_ub[np.arange(num_pairs), idx_j] = 1.0\n    b_ub = dists\n    \n    # Bounds for r: 0 <= r <= distance_to_walls\n    x_c = final_centers[:, 0]\n    y_c = final_centers[:, 1]\n    d_walls = np.minimum(np.minimum(x_c, 1 - x_c), np.minimum(y_c, 1 - y_c))\n    r_bounds = [(0, d) for d in d_walls]\n    \n    # Objective: Minimize -sum(r)\n    c_obj = -np.ones(N)\n    \n    # Solve LP\n    lp_res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=r_bounds, method='interior-point')\n    \n    final_radii = lp_res.x\n    \n    if final_radii is None:\n        # Fallback in case of LP failure (rare)\n        final_radii = np.zeros(N)\n\n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T11:12:24.029592",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 334,
        "candidates_token_count": 1366,
        "thoughts_token_count": 12258
      },
      "response_text_len": 3749
    }
  }
}