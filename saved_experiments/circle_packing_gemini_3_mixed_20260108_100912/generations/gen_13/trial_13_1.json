{
  "trial_id": "trial_13_1",
  "generation": 13,
  "parent_id": "trial_11_11",
  "code": "import numpy as np\nfrom scipy.stats import qmc\nfrom scipy.optimize import minimize, linprog\n\ndef construct_packing():\n    # Parameters\n    N = 26\n    n_samples = 512  # 2^9 samples for Sobol\n    m_sobol = 9\n    \n    # 1. Sobol Initialization\n    # We optimize 3N variables: x, y, r for each circle.\n    d = 3 * N\n    # Initialize Sobol sampler\n    sampler = qmc.Sobol(d=d, scramble=True)\n    samples = sampler.random_base2(m=m_sobol)\n    \n    # Map Sobol samples (0, 1) to initial guesses\n    # Centers x, y in [0, 1]\n    # Radii r in [0.05, 0.15] (heuristic based on N=26 optimal ~0.10)\n    X_init = samples[:, :2*N]\n    R_init = samples[:, 2*N:] * 0.10 + 0.05\n    initial_guesses = np.hstack([X_init, R_init])\n    \n    # Precompute indices for pairwise interactions\n    triu_idx = np.triu_indices(N, 1)\n    \n    # Objective function for penalty-based optimization\n    def packing_energy(w, penalty_weight):\n        # w: [x1...xN, y1...yN, r1...rN]\n        xs = w[:N]\n        ys = w[N:2*N]\n        rs = w[2*N:]\n        \n        # Boundary violations: r > x, r > 1-x, r > y, r > 1-y\n        # Equivalent to x < r, x > 1-r, etc.\n        v_left = np.maximum(0, rs - xs)\n        v_right = np.maximum(0, xs + rs - 1)\n        v_bottom = np.maximum(0, rs - ys)\n        v_top = np.maximum(0, ys + rs - 1)\n        loss_boundary = np.sum(v_left**2 + v_right**2 + v_bottom**2 + v_top**2)\n        \n        # Overlap violations: dist < r_i + r_j\n        dx = xs[triu_idx[0]] - xs[triu_idx[1]]\n        dy = ys[triu_idx[0]] - ys[triu_idx[1]]\n        d2 = dx**2 + dy**2\n        dist = np.sqrt(d2 + 1e-16)\n        \n        r_sum = rs[triu_idx[0]] + rs[triu_idx[1]]\n        v_overlap = np.maximum(0, r_sum - dist)\n        loss_overlap = np.sum(v_overlap**2)\n        \n        # Objective: Maximize sum(r) => Minimize -sum(r) + penalty\n        return -np.sum(rs) + penalty_weight * (loss_boundary + loss_overlap)\n\n    # 2. Coarse Optimization\n    # Run a quick L-BFGS-B on all samples to find promising basins\n    bounds = [(0, 1)] * (2*N) + [(0.01, 0.5)] * N\n    candidates = []\n    \n    for i in range(n_samples):\n        w0 = initial_guesses[i]\n        # Low maxiter to save time\n        res = minimize(packing_energy, w0, args=(1e3,), method='L-BFGS-B', bounds=bounds,\n                       options={'maxiter': 20, 'ftol': 1e-3})\n        candidates.append(res)\n        \n    # Sort by energy (lower is better)\n    candidates.sort(key=lambda x: x.fun)\n    \n    # 3. Refine Top Candidates & Exact Radius Calculation\n    top_k = 5\n    best_config = None\n    best_sum_radii = -np.inf\n    \n    for i in range(min(top_k, len(candidates))):\n        w_start = candidates[i].x\n        \n        # Run tighter optimization with high penalty\n        res = minimize(packing_energy, w_start, args=(1e6,), method='L-BFGS-B', bounds=bounds,\n                       options={'maxiter': 500, 'ftol': 1e-8})\n        \n        w_final = res.x\n        xc = w_final[:N]\n        yc = w_final[N:2*N]\n        \n        # 4. Linear Programming Step\n        # Given optimized centers, find the maximum possible radii\n        # Maximize sum(r) s.t. r_i + r_j <= dist_ij and r_i <= wall_dist\n        \n        dx = xc[triu_idx[0]] - xc[triu_idx[1]]\n        dy = yc[triu_idx[0]] - yc[triu_idx[1]]\n        dists = np.sqrt(dx**2 + dy**2)\n        \n        # Constraints: A_ub * r <= b_ub\n        n_pairs = len(dists)\n        A_ub = np.zeros((n_pairs, N))\n        A_ub[np.arange(n_pairs), triu_idx[0]] = 1\n        A_ub[np.arange(n_pairs), triu_idx[1]] = 1\n        b_ub = dists\n        \n        # Bounds: 0 <= r_i <= distance_to_wall\n        d_wall_x = np.minimum(xc, 1 - xc)\n        d_wall_y = np.minimum(yc, 1 - yc)\n        r_max_walls = np.maximum(0, np.minimum(d_wall_x, d_wall_y))\n        \n        lp_bounds = [(0, b) for b in r_max_walls]\n        c = -np.ones(N) # Minimize -sum(r)\n        \n        # Use 'highs' method if available (Scipy 1.6+), else default\n        try:\n            lp_res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds, method='highs')\n        except Exception:\n            lp_res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds)\n            \n        if lp_res.success:\n            r_opt = lp_res.x\n            current_sum = np.sum(r_opt)\n            if current_sum > best_sum_radii:\n                best_sum_radii = current_sum\n                best_config = (xc, yc, r_opt)\n    \n    # Fallback if optimization failed (unlikely)\n    if best_config is None:\n        w = candidates[0].x\n        xc, yc, rc = w[:N], w[N:2*N], w[2*N:]\n        return np.column_stack((xc, yc)), rc, np.sum(rc)\n        \n    xc, yc, rc = best_config\n    return np.column_stack((xc, yc)), rc, np.sum(rc)\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.2672608541179016,
    "eval_time": 26.898608207702637,
    "error": null
  },
  "prompt": "Refine {CODE_TRIAL_11_11}. \n\nStrategy: **Sobol Sequence Sampling**.\n- Replace `np.random.rand` with `scipy.stats.qmc.Sobol`.\n- Generate 512 initial points (powers of 2 are best for Sobol).\n- Sobol sequences cover the high-dimensional space more evenly than pseudo-random numbers.\n- Use `randomize=True` (scrambled Sobol).\n\nIMPORTANT: Your response must contain exactly one Python code block starting with ```python and ending with ```. The code must define `construct_packing`.",
  "response": "```python\nimport numpy as np\nfrom scipy.stats import qmc\nfrom scipy.optimize import minimize, linprog\n\ndef construct_packing():\n    # Parameters\n    N = 26\n    n_samples = 512  # 2^9 samples for Sobol\n    m_sobol = 9\n    \n    # 1. Sobol Initialization\n    # We optimize 3N variables: x, y, r for each circle.\n    d = 3 * N\n    # Initialize Sobol sampler\n    sampler = qmc.Sobol(d=d, scramble=True)\n    samples = sampler.random_base2(m=m_sobol)\n    \n    # Map Sobol samples (0, 1) to initial guesses\n    # Centers x, y in [0, 1]\n    # Radii r in [0.05, 0.15] (heuristic based on N=26 optimal ~0.10)\n    X_init = samples[:, :2*N]\n    R_init = samples[:, 2*N:] * 0.10 + 0.05\n    initial_guesses = np.hstack([X_init, R_init])\n    \n    # Precompute indices for pairwise interactions\n    triu_idx = np.triu_indices(N, 1)\n    \n    # Objective function for penalty-based optimization\n    def packing_energy(w, penalty_weight):\n        # w: [x1...xN, y1...yN, r1...rN]\n        xs = w[:N]\n        ys = w[N:2*N]\n        rs = w[2*N:]\n        \n        # Boundary violations: r > x, r > 1-x, r > y, r > 1-y\n        # Equivalent to x < r, x > 1-r, etc.\n        v_left = np.maximum(0, rs - xs)\n        v_right = np.maximum(0, xs + rs - 1)\n        v_bottom = np.maximum(0, rs - ys)\n        v_top = np.maximum(0, ys + rs - 1)\n        loss_boundary = np.sum(v_left**2 + v_right**2 + v_bottom**2 + v_top**2)\n        \n        # Overlap violations: dist < r_i + r_j\n        dx = xs[triu_idx[0]] - xs[triu_idx[1]]\n        dy = ys[triu_idx[0]] - ys[triu_idx[1]]\n        d2 = dx**2 + dy**2\n        dist = np.sqrt(d2 + 1e-16)\n        \n        r_sum = rs[triu_idx[0]] + rs[triu_idx[1]]\n        v_overlap = np.maximum(0, r_sum - dist)\n        loss_overlap = np.sum(v_overlap**2)\n        \n        # Objective: Maximize sum(r) => Minimize -sum(r) + penalty\n        return -np.sum(rs) + penalty_weight * (loss_boundary + loss_overlap)\n\n    # 2. Coarse Optimization\n    # Run a quick L-BFGS-B on all samples to find promising basins\n    bounds = [(0, 1)] * (2*N) + [(0.01, 0.5)] * N\n    candidates = []\n    \n    for i in range(n_samples):\n        w0 = initial_guesses[i]\n        # Low maxiter to save time\n        res = minimize(packing_energy, w0, args=(1e3,), method='L-BFGS-B', bounds=bounds,\n                       options={'maxiter': 20, 'ftol': 1e-3})\n        candidates.append(res)\n        \n    # Sort by energy (lower is better)\n    candidates.sort(key=lambda x: x.fun)\n    \n    # 3. Refine Top Candidates & Exact Radius Calculation\n    top_k = 5\n    best_config = None\n    best_sum_radii = -np.inf\n    \n    for i in range(min(top_k, len(candidates))):\n        w_start = candidates[i].x\n        \n        # Run tighter optimization with high penalty\n        res = minimize(packing_energy, w_start, args=(1e6,), method='L-BFGS-B', bounds=bounds,\n                       options={'maxiter': 500, 'ftol': 1e-8})\n        \n        w_final = res.x\n        xc = w_final[:N]\n        yc = w_final[N:2*N]\n        \n        # 4. Linear Programming Step\n        # Given optimized centers, find the maximum possible radii\n        # Maximize sum(r) s.t. r_i + r_j <= dist_ij and r_i <= wall_dist\n        \n        dx = xc[triu_idx[0]] - xc[triu_idx[1]]\n        dy = yc[triu_idx[0]] - yc[triu_idx[1]]\n        dists = np.sqrt(dx**2 + dy**2)\n        \n        # Constraints: A_ub * r <= b_ub\n        n_pairs = len(dists)\n        A_ub = np.zeros((n_pairs, N))\n        A_ub[np.arange(n_pairs), triu_idx[0]] = 1\n        A_ub[np.arange(n_pairs), triu_idx[1]] = 1\n        b_ub = dists\n        \n        # Bounds: 0 <= r_i <= distance_to_wall\n        d_wall_x = np.minimum(xc, 1 - xc)\n        d_wall_y = np.minimum(yc, 1 - yc)\n        r_max_walls = np.maximum(0, np.minimum(d_wall_x, d_wall_y))\n        \n        lp_bounds = [(0, b) for b in r_max_walls]\n        c = -np.ones(N) # Minimize -sum(r)\n        \n        # Use 'highs' method if available (Scipy 1.6+), else default\n        try:\n            lp_res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds, method='highs')\n        except Exception:\n            lp_res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds)\n            \n        if lp_res.success:\n            r_opt = lp_res.x\n            current_sum = np.sum(r_opt)\n            if current_sum > best_sum_radii:\n                best_sum_radii = current_sum\n                best_config = (xc, yc, r_opt)\n    \n    # Fallback if optimization failed (unlikely)\n    if best_config is None:\n        w = candidates[0].x\n        xc, yc, rc = w[:N], w[N:2*N], w[2*N:]\n        return np.column_stack((xc, yc)), rc, np.sum(rc)\n        \n    xc, yc, rc = best_config\n    return np.column_stack((xc, yc)), rc, np.sum(rc)\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T11:14:05.844941",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 354,
        "candidates_token_count": 1751,
        "thoughts_token_count": 12623
      },
      "response_text_len": 4724
    }
  }
}