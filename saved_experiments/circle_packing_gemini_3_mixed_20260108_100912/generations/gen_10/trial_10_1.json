{
  "trial_id": "trial_10_1",
  "generation": 10,
  "parent_id": "trial_9_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    N = 26\n    \n    # --- Physics Simulation Helpers ---\n    def get_forces(coords, radii, k_overlap, k_growth):\n        forces_x = np.zeros_like(coords)\n        forces_r = np.zeros_like(radii)\n        \n        # Pairwise distances\n        diff = coords[:, None, :] - coords[None, :, :] # Shape (N, N, 2)\n        dist_sq = np.sum(diff**2, axis=2)\n        dist = np.sqrt(dist_sq + 1e-12)\n        \n        # Radii sums\n        r_sum = radii[:, None] + radii[None, :]\n        \n        # Overlaps (dist < r_sum)\n        np.fill_diagonal(dist, np.inf) \n        overlaps = r_sum - dist\n        mask = overlaps > 0\n        \n        if np.any(mask):\n            # Normalized directions\n            norm_diff = diff / (dist[:, :, None] + 1e-12)\n            \n            # Force magnitude\n            f_mag = k_overlap * overlaps * mask # (N, N)\n            \n            # Sum forces on i\n            fx = np.sum(f_mag[:, :, None] * norm_diff, axis=1)\n            forces_x += fx\n            \n            # Force on radii (shrink to reduce overlap)\n            fr = np.sum(f_mag, axis=1)\n            forces_r -= fr\n            \n        # Wall Overlaps\n        # Left (x < r)\n        overlap_l = radii - coords[:, 0]\n        mask_l = overlap_l > 0\n        forces_x[mask_l, 0] += k_overlap * overlap_l[mask_l]\n        forces_r[mask_l] -= k_overlap * overlap_l[mask_l]\n        \n        # Right (x > 1-r)\n        overlap_r = coords[:, 0] + radii - 1\n        mask_r = overlap_r > 0\n        forces_x[mask_r, 0] -= k_overlap * overlap_r[mask_r]\n        forces_r[mask_r] -= k_overlap * overlap_r[mask_r]\n        \n        # Bottom (y < r)\n        overlap_b = radii - coords[:, 1]\n        mask_b = overlap_b > 0\n        forces_x[mask_b, 1] += k_overlap * overlap_b[mask_b]\n        forces_r[mask_b] -= k_overlap * overlap_b[mask_b]\n        \n        # Top (y > 1-r)\n        overlap_t = coords[:, 1] + radii - 1\n        mask_t = overlap_t > 0\n        forces_x[mask_t, 1] -= k_overlap * overlap_t[mask_t]\n        forces_r[mask_t] -= k_overlap * overlap_t[mask_t]\n        \n        # Growth Force\n        forces_r[radii > 0] += k_growth\n        \n        return forces_x, forces_r\n\n    def physics_simulate(coords, radii, steps, dt, growth_rate, k_start=1000, k_end=10000):\n        vx = np.zeros_like(coords)\n        vr = np.zeros_like(radii)\n        \n        curr_x = coords.copy()\n        curr_r = radii.copy()\n        \n        for i in range(steps):\n            progress = i / steps\n            k = k_start + (k_end - k_start) * progress\n            \n            fx, fr = get_forces(curr_x, curr_r, k, growth_rate)\n            \n            # Damping\n            vx = 0.9 * vx + fx * dt\n            vr = 0.9 * vr + fr * dt\n            \n            curr_x += vx * dt\n            curr_r += vr * dt\n            \n            curr_x = np.clip(curr_x, 0, 1)\n            curr_r = np.maximum(curr_r, 1e-5)\n            \n        return curr_x, curr_r\n\n    def find_hole(coords, radii):\n        # Sample points and find one farthest from any circle/wall\n        n_samples = 2000\n        samples = np.random.rand(n_samples, 2)\n        \n        # Dist to walls\n        d_walls = np.minimum(samples, 1 - samples).min(axis=1)\n        \n        # Dist to circles\n        diff = samples[:, None, :] - coords[None, :, :]\n        dists = np.sqrt(np.sum(diff**2, axis=2)) - radii[None, :]\n        d_circles = np.min(dists, axis=1)\n        \n        min_clearance = np.minimum(d_walls, d_circles)\n        best_idx = np.argmax(min_clearance)\n        \n        return samples[best_idx], max(1e-3, min_clearance[best_idx])\n\n    # --- Main Strategy ---\n    np.random.seed(42)\n    rng = np.random.default_rng(42)\n    \n    # 1. Initialize random\n    coords = np.random.rand(N, 2)\n    radii = np.full(N, 0.05)\n    \n    # 2. Initial Physics Packing\n    coords, radii = physics_simulate(coords, radii, steps=2000, dt=0.002, growth_rate=0.2)\n    \n    # 3. Random Hybrid Cut Cycles\n    cycles = 3\n    for c in range(cycles):\n        # Remove 8 random\n        remove_indices = rng.choice(N, 8, replace=False)\n        \n        # Remove\n        radii[remove_indices] = 0.0\n        coords[remove_indices] = -10.0\n        \n        # Relax remaining\n        coords, radii = physics_simulate(coords, radii, steps=800, dt=0.003, growth_rate=0.1)\n        \n        # Re-add one by one\n        for idx in remove_indices:\n            pos, size = find_hole(coords, radii)\n            coords[idx] = pos\n            radii[idx] = size\n            \n            # Relax briefly\n            coords, radii = physics_simulate(coords, radii, steps=400, dt=0.003, growth_rate=0.1)\n            \n        # Final relax for this cycle\n        coords, radii = physics_simulate(coords, radii, steps=800, dt=0.003, growth_rate=0.05)\n\n    # 4. Final Polish (SLSQP)\n    # Cooling phase\n    coords, radii = physics_simulate(coords, radii, steps=1000, dt=0.001, growth_rate=0.0, k_start=10000, k_end=50000)\n    \n    x0 = np.concatenate([coords.flatten(), radii])\n    \n    pairs = [(i, j) for i in range(N) for j in range(i+1, N)]\n    \n    def make_overlap_con(i, j):\n        def con(x):\n            c = x[:2*N]\n            r = x[2*N:]\n            dist_sq = (c[2*i] - c[2*j])**2 + (c[2*i+1] - c[2*j+1])**2\n            return dist_sq - (r[i] + r[j])**2\n        \n        def jac(x):\n            grad = np.zeros_like(x)\n            c = x[:2*N]\n            r = x[2*N:]\n            \n            dx = c[2*i] - c[2*j]\n            dy = c[2*i+1] - c[2*j+1]\n            r_sum = r[i] + r[j]\n            \n            grad[2*i] = 2*dx\n            grad[2*i+1] = 2*dy\n            grad[2*j] = -2*dx\n            grad[2*j+1] = -2*dy\n            grad[2*N+i] = -2*r_sum\n            grad[2*N+j] = -2*r_sum\n            return grad\n        return {'type': 'ineq', 'fun': con, 'jac': jac}\n\n    cons = []\n    for i, j in pairs:\n        cons.append(make_overlap_con(i, j))\n        \n    def make_wall_con(i, dim, side):\n        if side == -1:\n            def con(x): return x[2*i+dim] - x[2*N+i]\n            def jac(x):\n                g = np.zeros_like(x)\n                g[2*i+dim] = 1; g[2*N+i] = -1\n                return g\n        else:\n            def con(x): return 1.0 - (x[2*i+dim] + x[2*N+i])\n            def jac(x):\n                g = np.zeros_like(x)\n                g[2*i+dim] = -1; g[2*N+i] = -1\n                return g\n        return {'type': 'ineq', 'fun': con, 'jac': jac}\n\n    for i in range(N):\n        cons.append(make_wall_con(i, 0, -1))\n        cons.append(make_wall_con(i, 0, 1))\n        cons.append(make_wall_con(i, 1, -1))\n        cons.append(make_wall_con(i, 1, 1))\n\n    def objective(x):\n        return -np.sum(x[2*N:])\n    \n    def obj_jac(x):\n        g = np.zeros_like(x)\n        g[2*N:] = -1\n        return g\n\n    bounds = [(0, 1)]*(2*N) + [(0, None)]*N\n    \n    res = minimize(objective, x0, method='SLSQP', jac=obj_jac, constraints=cons, bounds=bounds, \n                   options={'maxiter': 500, 'ftol': 1e-6, 'disp': False})\n    \n    xf = res.x\n    centers = xf[:2*N].reshape(N, 2)\n    radii = xf[2*N:]\n    \n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 0.8848698139190674,
    "error": "NaN values in centers"
  },
  "prompt": "Refine the Hybrid strategy from {CODE_TRIAL_9_0}. \n\nNew Strategy: **Random Hybrid Cut**.\n- Run Physics simulation.\n- Instead of removing outer circles, remove **8 random** circles.\n- Re-add them one by one.\n- Repeat this 'remove random 8 -> re-add' cycle 3 times.\n- This allows the packing to rearrange internally, not just at the boundary.\n\nCRITICAL: You must output ONLY a single Python code block (```python ... ```). \nDO NOT write any introduction. \nDO NOT write 'Here is the code'. \nDO NOT write any explanation after. \nJust the code block.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    N = 26\n    \n    # --- Physics Simulation Helpers ---\n    def get_forces(coords, radii, k_overlap, k_growth):\n        forces_x = np.zeros_like(coords)\n        forces_r = np.zeros_like(radii)\n        \n        # Pairwise distances\n        diff = coords[:, None, :] - coords[None, :, :] # Shape (N, N, 2)\n        dist_sq = np.sum(diff**2, axis=2)\n        dist = np.sqrt(dist_sq + 1e-12)\n        \n        # Radii sums\n        r_sum = radii[:, None] + radii[None, :]\n        \n        # Overlaps (dist < r_sum)\n        np.fill_diagonal(dist, np.inf) \n        overlaps = r_sum - dist\n        mask = overlaps > 0\n        \n        if np.any(mask):\n            # Normalized directions\n            norm_diff = diff / (dist[:, :, None] + 1e-12)\n            \n            # Force magnitude\n            f_mag = k_overlap * overlaps * mask # (N, N)\n            \n            # Sum forces on i\n            fx = np.sum(f_mag[:, :, None] * norm_diff, axis=1)\n            forces_x += fx\n            \n            # Force on radii (shrink to reduce overlap)\n            fr = np.sum(f_mag, axis=1)\n            forces_r -= fr\n            \n        # Wall Overlaps\n        # Left (x < r)\n        overlap_l = radii - coords[:, 0]\n        mask_l = overlap_l > 0\n        forces_x[mask_l, 0] += k_overlap * overlap_l[mask_l]\n        forces_r[mask_l] -= k_overlap * overlap_l[mask_l]\n        \n        # Right (x > 1-r)\n        overlap_r = coords[:, 0] + radii - 1\n        mask_r = overlap_r > 0\n        forces_x[mask_r, 0] -= k_overlap * overlap_r[mask_r]\n        forces_r[mask_r] -= k_overlap * overlap_r[mask_r]\n        \n        # Bottom (y < r)\n        overlap_b = radii - coords[:, 1]\n        mask_b = overlap_b > 0\n        forces_x[mask_b, 1] += k_overlap * overlap_b[mask_b]\n        forces_r[mask_b] -= k_overlap * overlap_b[mask_b]\n        \n        # Top (y > 1-r)\n        overlap_t = coords[:, 1] + radii - 1\n        mask_t = overlap_t > 0\n        forces_x[mask_t, 1] -= k_overlap * overlap_t[mask_t]\n        forces_r[mask_t] -= k_overlap * overlap_t[mask_t]\n        \n        # Growth Force\n        forces_r[radii > 0] += k_growth\n        \n        return forces_x, forces_r\n\n    def physics_simulate(coords, radii, steps, dt, growth_rate, k_start=1000, k_end=10000):\n        vx = np.zeros_like(coords)\n        vr = np.zeros_like(radii)\n        \n        curr_x = coords.copy()\n        curr_r = radii.copy()\n        \n        for i in range(steps):\n            progress = i / steps\n            k = k_start + (k_end - k_start) * progress\n            \n            fx, fr = get_forces(curr_x, curr_r, k, growth_rate)\n            \n            # Damping\n            vx = 0.9 * vx + fx * dt\n            vr = 0.9 * vr + fr * dt\n            \n            curr_x += vx * dt\n            curr_r += vr * dt\n            \n            curr_x = np.clip(curr_x, 0, 1)\n            curr_r = np.maximum(curr_r, 1e-5)\n            \n        return curr_x, curr_r\n\n    def find_hole(coords, radii):\n        # Sample points and find one farthest from any circle/wall\n        n_samples = 2000\n        samples = np.random.rand(n_samples, 2)\n        \n        # Dist to walls\n        d_walls = np.minimum(samples, 1 - samples).min(axis=1)\n        \n        # Dist to circles\n        diff = samples[:, None, :] - coords[None, :, :]\n        dists = np.sqrt(np.sum(diff**2, axis=2)) - radii[None, :]\n        d_circles = np.min(dists, axis=1)\n        \n        min_clearance = np.minimum(d_walls, d_circles)\n        best_idx = np.argmax(min_clearance)\n        \n        return samples[best_idx], max(1e-3, min_clearance[best_idx])\n\n    # --- Main Strategy ---\n    np.random.seed(42)\n    rng = np.random.default_rng(42)\n    \n    # 1. Initialize random\n    coords = np.random.rand(N, 2)\n    radii = np.full(N, 0.05)\n    \n    # 2. Initial Physics Packing\n    coords, radii = physics_simulate(coords, radii, steps=2000, dt=0.002, growth_rate=0.2)\n    \n    # 3. Random Hybrid Cut Cycles\n    cycles = 3\n    for c in range(cycles):\n        # Remove 8 random\n        remove_indices = rng.choice(N, 8, replace=False)\n        \n        # Remove\n        radii[remove_indices] = 0.0\n        coords[remove_indices] = -10.0\n        \n        # Relax remaining\n        coords, radii = physics_simulate(coords, radii, steps=800, dt=0.003, growth_rate=0.1)\n        \n        # Re-add one by one\n        for idx in remove_indices:\n            pos, size = find_hole(coords, radii)\n            coords[idx] = pos\n            radii[idx] = size\n            \n            # Relax briefly\n            coords, radii = physics_simulate(coords, radii, steps=400, dt=0.003, growth_rate=0.1)\n            \n        # Final relax for this cycle\n        coords, radii = physics_simulate(coords, radii, steps=800, dt=0.003, growth_rate=0.05)\n\n    # 4. Final Polish (SLSQP)\n    # Cooling phase\n    coords, radii = physics_simulate(coords, radii, steps=1000, dt=0.001, growth_rate=0.0, k_start=10000, k_end=50000)\n    \n    x0 = np.concatenate([coords.flatten(), radii])\n    \n    pairs = [(i, j) for i in range(N) for j in range(i+1, N)]\n    \n    def make_overlap_con(i, j):\n        def con(x):\n            c = x[:2*N]\n            r = x[2*N:]\n            dist_sq = (c[2*i] - c[2*j])**2 + (c[2*i+1] - c[2*j+1])**2\n            return dist_sq - (r[i] + r[j])**2\n        \n        def jac(x):\n            grad = np.zeros_like(x)\n            c = x[:2*N]\n            r = x[2*N:]\n            \n            dx = c[2*i] - c[2*j]\n            dy = c[2*i+1] - c[2*j+1]\n            r_sum = r[i] + r[j]\n            \n            grad[2*i] = 2*dx\n            grad[2*i+1] = 2*dy\n            grad[2*j] = -2*dx\n            grad[2*j+1] = -2*dy\n            grad[2*N+i] = -2*r_sum\n            grad[2*N+j] = -2*r_sum\n            return grad\n        return {'type': 'ineq', 'fun': con, 'jac': jac}\n\n    cons = []\n    for i, j in pairs:\n        cons.append(make_overlap_con(i, j))\n        \n    def make_wall_con(i, dim, side):\n        if side == -1:\n            def con(x): return x[2*i+dim] - x[2*N+i]\n            def jac(x):\n                g = np.zeros_like(x)\n                g[2*i+dim] = 1; g[2*N+i] = -1\n                return g\n        else:\n            def con(x): return 1.0 - (x[2*i+dim] + x[2*N+i])\n            def jac(x):\n                g = np.zeros_like(x)\n                g[2*i+dim] = -1; g[2*N+i] = -1\n                return g\n        return {'type': 'ineq', 'fun': con, 'jac': jac}\n\n    for i in range(N):\n        cons.append(make_wall_con(i, 0, -1))\n        cons.append(make_wall_con(i, 0, 1))\n        cons.append(make_wall_con(i, 1, -1))\n        cons.append(make_wall_con(i, 1, 1))\n\n    def objective(x):\n        return -np.sum(x[2*N:])\n    \n    def obj_jac(x):\n        g = np.zeros_like(x)\n        g[2*N:] = -1\n        return g\n\n    bounds = [(0, 1)]*(2*N) + [(0, None)]*N\n    \n    res = minimize(objective, x0, method='SLSQP', jac=obj_jac, constraints=cons, bounds=bounds, \n                   options={'maxiter': 500, 'ftol': 1e-6, 'disp': False})\n    \n    xf = res.x\n    centers = xf[:2*N].reshape(N, 2)\n    radii = xf[2*N:]\n    \n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T10:59:03.318883",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 368,
        "candidates_token_count": 2598,
        "thoughts_token_count": 9760
      },
      "response_text_len": 7208
    }
  }
}