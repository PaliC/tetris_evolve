{
  "trial_id": "trial_12_1",
  "generation": 12,
  "parent_id": "trial_11_11",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\nfrom scipy.stats import qmc\n\ndef construct_packing():\n    N = 26\n    \n    # 1. Initialization using Sobol Sequence\n    # Generate 512 samples in 52-dimensional space (26 circles * 2 coords)\n    d = 2 * N\n    try:\n        sampler = qmc.Sobol(d=d, scramble=True, seed=42)\n        samples = sampler.random_base2(m=9) # 2^9 = 512\n    except AttributeError:\n        # Fallback for older scipy versions\n        samples = np.random.rand(512, d)\n        \n    # Precompute pair indices for constraints\n    pairs = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            pairs.append((i, j))\n    num_pairs = len(pairs)\n    idx_i = np.array([p[0] for p in pairs])\n    idx_j = np.array([p[1] for p in pairs])\n    \n    # LP constants for filtering\n    # Maximize sum(r) <=> Minimize -sum(r)\n    c_lp = -np.ones(N)\n    \n    # A_ub for r_i + r_j <= dist_ij\n    # r vector has N elements\n    A_ub = np.zeros((num_pairs, N))\n    for k, (i, j) in enumerate(pairs):\n        A_ub[k, i] = 1\n        A_ub[k, j] = 1\n        \n    candidates = []\n    \n    # 2. Filter samples using Linear Programming\n    # For fixed centers, find optimal radii\n    for sample in samples:\n        centers = sample.reshape((N, 2))\n        \n        # Calculate pair distances\n        p_i = centers[idx_i]\n        p_j = centers[idx_j]\n        dists = np.sqrt(np.sum((p_i - p_j)**2, axis=1))\n        \n        b_ub = dists\n        \n        # Calculate max radius based on wall boundaries\n        # r_i <= x_i, 1-x_i, y_i, 1-y_i\n        d_walls = np.minimum(centers, 1 - centers)\n        max_r = np.min(d_walls, axis=1)\n        max_r = np.maximum(max_r, 0) # Ensure non-negative\n        \n        bounds_lp = [(0, mr) for mr in max_r]\n        \n        # Solve LP\n        res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=bounds_lp, method='highs')\n        \n        if res.success:\n            score = -res.fun\n            candidates.append((score, centers, res.x))\n            \n    # Sort candidates by potential score\n    candidates.sort(key=lambda x: x[0], reverse=True)\n    \n    # 3. Polish top candidates using Non-Linear Optimization\n    top_k = 4\n    best_res = (None, None, -1.0)\n    \n    # Define optimization functions\n    def obj(p):\n        # Minimize negative sum of radii\n        return -np.sum(p[2*N:])\n    \n    def jac_obj(p):\n        g = np.zeros_like(p)\n        g[2*N:] = -1\n        return g\n    \n    def constraints(p):\n        xy = p[:2*N].reshape((N, 2))\n        r = p[2*N:]\n        \n        # Wall constraints (must be >= 0)\n        # x-r, 1-x-r, y-r, 1-y-r\n        c_left = xy[:, 0] - r\n        c_right = 1 - xy[:, 0] - r\n        c_bot = xy[:, 1] - r\n        c_top = 1 - xy[:, 1] - r\n        \n        # Pair constraints (dist^2 - (ri+rj)^2 >= 0)\n        p_i = xy[idx_i]\n        p_j = xy[idx_j]\n        diff = p_i - p_j\n        d2 = np.sum(diff**2, axis=1)\n        r_sum = r[idx_i] + r[idx_j]\n        c_pair = d2 - r_sum**2\n        \n        return np.concatenate([c_left, c_right, c_bot, c_top, c_pair])\n        \n    def jac_constraints(p):\n        xy = p[:2*N].reshape((N, 2))\n        r = p[2*N:]\n        \n        n_cons = 4*N + num_pairs\n        jac = np.zeros((n_cons, 3*N))\n        \n        rng = np.arange(N)\n        \n        # Wall Jacobians\n        # Left: x - r\n        jac[rng, 2*rng] = 1\n        jac[rng, 2*N + rng] = -1\n        \n        # Right: 1 - x - r\n        jac[N + rng, 2*rng] = -1\n        jac[N + rng, 2*N + rng] = -1\n        \n        # Bot: y - r\n        jac[2*N + rng, 2*rng + 1] = 1\n        jac[2*N + rng, 2*N + rng] = -1\n        \n        # Top: 1 - y - r\n        jac[3*N + rng, 2*rng + 1] = -1\n        jac[3*N + rng, 2*N + rng] = -1\n        \n        # Pair Jacobians\n        # c = (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2\n        p_i = xy[idx_i]\n        p_j = xy[idx_j]\n        diff = p_i - p_j\n        dx = diff[:, 0]\n        dy = diff[:, 1]\n        r_sum = r[idx_i] + r[idx_j]\n        \n        row_idx = 4*N + np.arange(num_pairs)\n        \n        # Derivatives w.r.t x_i, x_j, y_i, y_j\n        jac[row_idx, 2*idx_i] = 2 * dx\n        jac[row_idx, 2*idx_j] = -2 * dx\n        jac[row_idx, 2*idx_i + 1] = 2 * dy\n        jac[row_idx, 2*idx_j + 1] = -2 * dy\n        \n        # Derivatives w.r.t r_i, r_j\n        jac[row_idx, 2*N + idx_i] = -2 * r_sum\n        jac[row_idx, 2*N + idx_j] = -2 * r_sum\n        \n        return jac\n\n    # Run polish\n    for i in range(min(len(candidates), top_k)):\n        score_init, c_init, r_init = candidates[i]\n        p0 = np.concatenate([c_init.flatten(), r_init])\n        \n        # Bounds: x in [0,1], r in [0, 0.5]\n        bnds = [(0, 1)] * (2*N) + [(0, 0.5)] * N\n        \n        # SLSQP optimization\n        res = minimize(\n            obj, \n            p0, \n            method='SLSQP', \n            jac=jac_obj,\n            bounds=bnds,\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n            options={'maxiter': 300, 'ftol': 1e-5}\n        )\n        \n        final_score = -res.fun\n        if final_score > best_res[2]:\n            best_res = (res.x[:2*N].reshape((N, 2)), res.x[2*N:], final_score)\n            \n    return best_res\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 1.0964081287384033,
    "error": "Circles 6 and 8 overlap: distance=0.204767, required=0.204772"
  },
  "prompt": "Refine {CODE_TRIAL_11_11}. \n\nStrategy: **Sobol Sequence Initialization**.\n- Instead of `np.random.rand`, use `scipy.stats.qmc.Sobol` to generate 26 * 2 dimensional points.\n- This ensures the initial configurations cover the search space more evenly than random noise.\n- Generate 512 Sobol points (power of 2 for best balance).\n- Polish each.\n\nCRITICAL: Output ONLY a single Python code block (```python ... ```). \nNO intro text. NO explanation. NO 'Here is the code'. \nJust the code.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nfrom scipy.stats import qmc\n\ndef construct_packing():\n    N = 26\n    \n    # 1. Initialization using Sobol Sequence\n    # Generate 512 samples in 52-dimensional space (26 circles * 2 coords)\n    d = 2 * N\n    try:\n        sampler = qmc.Sobol(d=d, scramble=True, seed=42)\n        samples = sampler.random_base2(m=9) # 2^9 = 512\n    except AttributeError:\n        # Fallback for older scipy versions\n        samples = np.random.rand(512, d)\n        \n    # Precompute pair indices for constraints\n    pairs = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            pairs.append((i, j))\n    num_pairs = len(pairs)\n    idx_i = np.array([p[0] for p in pairs])\n    idx_j = np.array([p[1] for p in pairs])\n    \n    # LP constants for filtering\n    # Maximize sum(r) <=> Minimize -sum(r)\n    c_lp = -np.ones(N)\n    \n    # A_ub for r_i + r_j <= dist_ij\n    # r vector has N elements\n    A_ub = np.zeros((num_pairs, N))\n    for k, (i, j) in enumerate(pairs):\n        A_ub[k, i] = 1\n        A_ub[k, j] = 1\n        \n    candidates = []\n    \n    # 2. Filter samples using Linear Programming\n    # For fixed centers, find optimal radii\n    for sample in samples:\n        centers = sample.reshape((N, 2))\n        \n        # Calculate pair distances\n        p_i = centers[idx_i]\n        p_j = centers[idx_j]\n        dists = np.sqrt(np.sum((p_i - p_j)**2, axis=1))\n        \n        b_ub = dists\n        \n        # Calculate max radius based on wall boundaries\n        # r_i <= x_i, 1-x_i, y_i, 1-y_i\n        d_walls = np.minimum(centers, 1 - centers)\n        max_r = np.min(d_walls, axis=1)\n        max_r = np.maximum(max_r, 0) # Ensure non-negative\n        \n        bounds_lp = [(0, mr) for mr in max_r]\n        \n        # Solve LP\n        res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=bounds_lp, method='highs')\n        \n        if res.success:\n            score = -res.fun\n            candidates.append((score, centers, res.x))\n            \n    # Sort candidates by potential score\n    candidates.sort(key=lambda x: x[0], reverse=True)\n    \n    # 3. Polish top candidates using Non-Linear Optimization\n    top_k = 4\n    best_res = (None, None, -1.0)\n    \n    # Define optimization functions\n    def obj(p):\n        # Minimize negative sum of radii\n        return -np.sum(p[2*N:])\n    \n    def jac_obj(p):\n        g = np.zeros_like(p)\n        g[2*N:] = -1\n        return g\n    \n    def constraints(p):\n        xy = p[:2*N].reshape((N, 2))\n        r = p[2*N:]\n        \n        # Wall constraints (must be >= 0)\n        # x-r, 1-x-r, y-r, 1-y-r\n        c_left = xy[:, 0] - r\n        c_right = 1 - xy[:, 0] - r\n        c_bot = xy[:, 1] - r\n        c_top = 1 - xy[:, 1] - r\n        \n        # Pair constraints (dist^2 - (ri+rj)^2 >= 0)\n        p_i = xy[idx_i]\n        p_j = xy[idx_j]\n        diff = p_i - p_j\n        d2 = np.sum(diff**2, axis=1)\n        r_sum = r[idx_i] + r[idx_j]\n        c_pair = d2 - r_sum**2\n        \n        return np.concatenate([c_left, c_right, c_bot, c_top, c_pair])\n        \n    def jac_constraints(p):\n        xy = p[:2*N].reshape((N, 2))\n        r = p[2*N:]\n        \n        n_cons = 4*N + num_pairs\n        jac = np.zeros((n_cons, 3*N))\n        \n        rng = np.arange(N)\n        \n        # Wall Jacobians\n        # Left: x - r\n        jac[rng, 2*rng] = 1\n        jac[rng, 2*N + rng] = -1\n        \n        # Right: 1 - x - r\n        jac[N + rng, 2*rng] = -1\n        jac[N + rng, 2*N + rng] = -1\n        \n        # Bot: y - r\n        jac[2*N + rng, 2*rng + 1] = 1\n        jac[2*N + rng, 2*N + rng] = -1\n        \n        # Top: 1 - y - r\n        jac[3*N + rng, 2*rng + 1] = -1\n        jac[3*N + rng, 2*N + rng] = -1\n        \n        # Pair Jacobians\n        # c = (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2\n        p_i = xy[idx_i]\n        p_j = xy[idx_j]\n        diff = p_i - p_j\n        dx = diff[:, 0]\n        dy = diff[:, 1]\n        r_sum = r[idx_i] + r[idx_j]\n        \n        row_idx = 4*N + np.arange(num_pairs)\n        \n        # Derivatives w.r.t x_i, x_j, y_i, y_j\n        jac[row_idx, 2*idx_i] = 2 * dx\n        jac[row_idx, 2*idx_j] = -2 * dx\n        jac[row_idx, 2*idx_i + 1] = 2 * dy\n        jac[row_idx, 2*idx_j + 1] = -2 * dy\n        \n        # Derivatives w.r.t r_i, r_j\n        jac[row_idx, 2*N + idx_i] = -2 * r_sum\n        jac[row_idx, 2*N + idx_j] = -2 * r_sum\n        \n        return jac\n\n    # Run polish\n    for i in range(min(len(candidates), top_k)):\n        score_init, c_init, r_init = candidates[i]\n        p0 = np.concatenate([c_init.flatten(), r_init])\n        \n        # Bounds: x in [0,1], r in [0, 0.5]\n        bnds = [(0, 1)] * (2*N) + [(0, 0.5)] * N\n        \n        # SLSQP optimization\n        res = minimize(\n            obj, \n            p0, \n            method='SLSQP', \n            jac=jac_obj,\n            bounds=bnds,\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n            options={'maxiter': 300, 'ftol': 1e-5}\n        )\n        \n        final_score = -res.fun\n        if final_score > best_res[2]:\n            best_res = (res.x[:2*N].reshape((N, 2)), res.x[2*N:], final_score)\n            \n    return best_res\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T11:07:49.504280",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 361,
        "candidates_token_count": 1990,
        "thoughts_token_count": 11690
      },
      "response_text_len": 5243
    }
  }
}