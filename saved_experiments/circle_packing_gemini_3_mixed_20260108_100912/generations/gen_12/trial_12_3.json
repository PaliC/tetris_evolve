{
  "trial_id": "trial_12_3",
  "generation": 12,
  "parent_id": "trial_6_6",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    N = 26\n    n_seeds = 20\n    \n    # Precompute pairs for overlap constraints\n    pairs = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            pairs.append((i, j))\n            \n    # Helper to generate initial guess using Maximin strategy\n    def generate_seed(rng):\n        centers = []\n        # Start with one random point\n        centers.append(rng.random(2))\n        \n        # Add others maximizing distance to nearest existing center\n        for _ in range(N - 1):\n            candidates = rng.random((500, 2))\n            c_arr = np.array(centers)\n            # Vectorized distance computation\n            # (n_cand, 1, 2) - (1, n_exist, 2) -> (n_cand, n_exist, 2)\n            diff = candidates[:, np.newaxis, :] - c_arr[np.newaxis, :, :]\n            d2 = np.sum(diff**2, axis=2) # (n_cand, n_exist)\n            min_d2 = np.min(d2, axis=1) # (n_cand,)\n            best_idx = np.argmax(min_d2)\n            centers.append(candidates[best_idx])\n            \n        centers = np.array(centers)\n        # Conservative initial radii\n        radii = np.full(N, 0.01)\n        \n        x0 = np.zeros(3 * N)\n        x0[0::3] = centers[:, 0]\n        x0[1::3] = centers[:, 1]\n        x0[2::3] = radii\n        return x0\n\n    # Optimization definitions\n    def objective(x):\n        return -np.sum(x[2::3])\n\n    def obj_jac(x):\n        grad = np.zeros_like(x)\n        grad[2::3] = -1.0\n        return grad\n        \n    def overlap_fun(x):\n        X = x[0::3]\n        Y = x[1::3]\n        R = x[2::3]\n        res = []\n        for i, j in pairs:\n            d2 = (X[i] - X[j])**2 + (Y[i] - Y[j])**2\n            r_sum = R[i] + R[j]\n            res.append(d2 - r_sum**2)\n        return np.array(res)\n\n    def overlap_jac(x):\n        X = x[0::3]\n        Y = x[1::3]\n        R = x[2::3]\n        jac = np.zeros((len(pairs), 3 * N))\n        for idx, (i, j) in enumerate(pairs):\n            dx = X[i] - X[j]\n            dy = Y[i] - Y[j]\n            sr = R[i] + R[j]\n            \n            jac[idx, 3*i]     = 2 * dx\n            jac[idx, 3*i + 1] = 2 * dy\n            jac[idx, 3*i + 2] = -2 * sr\n            \n            jac[idx, 3*j]     = -2 * dx\n            jac[idx, 3*j + 1] = -2 * dy\n            jac[idx, 3*j + 2] = -2 * sr\n        return jac\n\n    # Box constraints matrix\n    n_box = 4 * N\n    A = np.zeros((n_box, 3 * N))\n    b = np.zeros(n_box)\n    for i in range(N):\n        # xi - ri >= 0\n        A[4*i, 3*i] = 1; A[4*i, 3*i+2] = -1; b[4*i] = 0\n        # -xi - ri >= -1\n        A[4*i+1, 3*i] = -1; A[4*i+1, 3*i+2] = -1; b[4*i+1] = -1\n        # yi - ri >= 0\n        A[4*i+2, 3*i+1] = 1; A[4*i+2, 3*i+2] = -1; b[4*i+2] = 0\n        # -yi - ri >= -1\n        A[4*i+3, 3*i+1] = -1; A[4*i+3, 3*i+2] = -1; b[4*i+3] = -1\n\n    linear_con = {'type': 'ineq', 'fun': lambda x: A @ x - b, 'jac': lambda x: A}\n    nonlinear_con = {'type': 'ineq', 'fun': overlap_fun, 'jac': overlap_jac}\n    constraints = [linear_con, nonlinear_con]\n    \n    bounds = [(0, 1)] * (3 * N)\n    for i in range(N):\n        bounds[3*i+2] = (0, 0.5)\n\n    rng = np.random.RandomState(42)\n    \n    best_x = None\n    best_val = -np.inf\n    \n    for _ in range(n_seeds):\n        x0 = generate_seed(rng)\n        # Use SLSQP to polish\n        res = minimize(objective, x0, method='SLSQP', jac=obj_jac, \n                       bounds=bounds, constraints=constraints, \n                       options={'maxiter': 800, 'ftol': 1e-5})\n        \n        # Check if successful or at least feasible\n        # Even if not 'success', the result might be good.\n        # We assume SLSQP satisfies constraints mostly.\n        current_val = -res.fun\n        if current_val > best_val:\n            best_val = current_val\n            best_x = res.x\n\n    # Extract result\n    centers = np.zeros((N, 2))\n    centers[:, 0] = best_x[0::3]\n    centers[:, 1] = best_x[1::3]\n    radii = best_x[2::3]\n    \n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.624374671287826,
    "eval_time": 1.3789608478546143,
    "error": null
  },
  "prompt": "Combine {CODE_TRIAL_6_6} and {CODE_TRIAL_11_11}. \n\nStrategy: **Constructive Seed Ensemble**.\n- Instead of pure random seeds, generate seeds using a *fast* version of the constructive algorithm (randomized order of insertion).\n- Generate 20 such constructive seeds.\n- Polish all of them.\n- This combines the structure of constructive with the diversity of random search.\n\nCRITICAL: Output ONLY a single Python code block (```python ... ```). \nNO intro text. NO explanation. NO 'Here is the code'. \nJust the code.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    N = 26\n    n_seeds = 20\n    \n    # Precompute pairs for overlap constraints\n    pairs = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            pairs.append((i, j))\n            \n    # Helper to generate initial guess using Maximin strategy\n    def generate_seed(rng):\n        centers = []\n        # Start with one random point\n        centers.append(rng.random(2))\n        \n        # Add others maximizing distance to nearest existing center\n        for _ in range(N - 1):\n            candidates = rng.random((500, 2))\n            c_arr = np.array(centers)\n            # Vectorized distance computation\n            # (n_cand, 1, 2) - (1, n_exist, 2) -> (n_cand, n_exist, 2)\n            diff = candidates[:, np.newaxis, :] - c_arr[np.newaxis, :, :]\n            d2 = np.sum(diff**2, axis=2) # (n_cand, n_exist)\n            min_d2 = np.min(d2, axis=1) # (n_cand,)\n            best_idx = np.argmax(min_d2)\n            centers.append(candidates[best_idx])\n            \n        centers = np.array(centers)\n        # Conservative initial radii\n        radii = np.full(N, 0.01)\n        \n        x0 = np.zeros(3 * N)\n        x0[0::3] = centers[:, 0]\n        x0[1::3] = centers[:, 1]\n        x0[2::3] = radii\n        return x0\n\n    # Optimization definitions\n    def objective(x):\n        return -np.sum(x[2::3])\n\n    def obj_jac(x):\n        grad = np.zeros_like(x)\n        grad[2::3] = -1.0\n        return grad\n        \n    def overlap_fun(x):\n        X = x[0::3]\n        Y = x[1::3]\n        R = x[2::3]\n        res = []\n        for i, j in pairs:\n            d2 = (X[i] - X[j])**2 + (Y[i] - Y[j])**2\n            r_sum = R[i] + R[j]\n            res.append(d2 - r_sum**2)\n        return np.array(res)\n\n    def overlap_jac(x):\n        X = x[0::3]\n        Y = x[1::3]\n        R = x[2::3]\n        jac = np.zeros((len(pairs), 3 * N))\n        for idx, (i, j) in enumerate(pairs):\n            dx = X[i] - X[j]\n            dy = Y[i] - Y[j]\n            sr = R[i] + R[j]\n            \n            jac[idx, 3*i]     = 2 * dx\n            jac[idx, 3*i + 1] = 2 * dy\n            jac[idx, 3*i + 2] = -2 * sr\n            \n            jac[idx, 3*j]     = -2 * dx\n            jac[idx, 3*j + 1] = -2 * dy\n            jac[idx, 3*j + 2] = -2 * sr\n        return jac\n\n    # Box constraints matrix\n    n_box = 4 * N\n    A = np.zeros((n_box, 3 * N))\n    b = np.zeros(n_box)\n    for i in range(N):\n        # xi - ri >= 0\n        A[4*i, 3*i] = 1; A[4*i, 3*i+2] = -1; b[4*i] = 0\n        # -xi - ri >= -1\n        A[4*i+1, 3*i] = -1; A[4*i+1, 3*i+2] = -1; b[4*i+1] = -1\n        # yi - ri >= 0\n        A[4*i+2, 3*i+1] = 1; A[4*i+2, 3*i+2] = -1; b[4*i+2] = 0\n        # -yi - ri >= -1\n        A[4*i+3, 3*i+1] = -1; A[4*i+3, 3*i+2] = -1; b[4*i+3] = -1\n\n    linear_con = {'type': 'ineq', 'fun': lambda x: A @ x - b, 'jac': lambda x: A}\n    nonlinear_con = {'type': 'ineq', 'fun': overlap_fun, 'jac': overlap_jac}\n    constraints = [linear_con, nonlinear_con]\n    \n    bounds = [(0, 1)] * (3 * N)\n    for i in range(N):\n        bounds[3*i+2] = (0, 0.5)\n\n    rng = np.random.RandomState(42)\n    \n    best_x = None\n    best_val = -np.inf\n    \n    for _ in range(n_seeds):\n        x0 = generate_seed(rng)\n        # Use SLSQP to polish\n        res = minimize(objective, x0, method='SLSQP', jac=obj_jac, \n                       bounds=bounds, constraints=constraints, \n                       options={'maxiter': 800, 'ftol': 1e-5})\n        \n        # Check if successful or at least feasible\n        # Even if not 'success', the result might be good.\n        # We assume SLSQP satisfies constraints mostly.\n        current_val = -res.fun\n        if current_val > best_val:\n            best_val = current_val\n            best_x = res.x\n\n    # Extract result\n    centers = np.zeros((N, 2))\n    centers[:, 0] = best_x[0::3]\n    centers[:, 1] = best_x[1::3]\n    radii = best_x[2::3]\n    \n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T11:07:39.612195",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 354,
        "candidates_token_count": 1542,
        "thoughts_token_count": 10145
      },
      "response_text_len": 4040
    }
  }
}