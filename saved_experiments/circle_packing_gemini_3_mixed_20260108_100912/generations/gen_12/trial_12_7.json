{
  "trial_id": "trial_12_7",
  "generation": 12,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.spatial import Voronoi\n\ndef construct_packing():\n    # Parameters for the packing optimization\n    N = 26\n    N_RESTARTS = 50\n    N_LLOYD_ITERS = 100\n    \n    best_res = None\n    best_score = -np.inf\n\n    # Dummy points to ensure Voronoi cells for the 26 points are finite\n    # Bounding box [-10, 20] is sufficient for [0,1] points\n    dummy_points = np.array([\n        [-10.0, -10.0], [0.5, -10.0], [10.0, -10.0],\n        [-10.0, 0.5],                 [10.0, 0.5],\n        [-10.0, 10.0],  [0.5, 10.0],  [10.0, 10.0]\n    ])\n\n    def get_clipped_centroid(verts):\n        # Sutherland-Hodgman polygon clipping against [0,1]x[0,1]\n        poly = list(verts)\n        # Planes defined by (normal, point)\n        planes = [\n            (np.array([1.0, 0.0]), np.array([0.0, 0.0])),   # x >= 0\n            (np.array([-1.0, 0.0]), np.array([1.0, 0.0])),  # x <= 1\n            (np.array([0.0, 1.0]), np.array([0.0, 0.0])),   # y >= 0\n            (np.array([0.0, -1.0]), np.array([0.0, 1.0]))   # y <= 1\n        ]\n        \n        for n, p in planes:\n            if not poly: break\n            new_poly = []\n            S = poly[-1]\n            for E in poly:\n                # Check if points are inside: dot(n, X-p) >= 0\n                sin = np.dot(n, S - p) >= -1e-12\n                ein = np.dot(n, E - p) >= -1e-12\n                \n                if ein:\n                    if not sin:\n                        # Intersection\n                        denom = np.dot(n, E - S)\n                        t = np.dot(n, p - S) / (denom if abs(denom) > 1e-12 else 1e-12)\n                        new_poly.append(S + t * (E - S))\n                    new_poly.append(E)\n                elif sin:\n                    # Intersection\n                    denom = np.dot(n, E - S)\n                    t = np.dot(n, p - S) / (denom if abs(denom) > 1e-12 else 1e-12)\n                    new_poly.append(S + t * (E - S))\n                S = E\n            poly = new_poly\n            \n        if len(poly) < 3:\n            return None\n            \n        # Compute Centroid\n        A = np.array(poly)\n        x = A[:, 0]\n        y = A[:, 1]\n        x_next = np.roll(x, -1)\n        y_next = np.roll(y, -1)\n        cross = x * y_next - x_next * y\n        area = 0.5 * np.sum(cross)\n        \n        if abs(area) < 1e-9: return None\n        \n        cx = np.sum((x + x_next) * cross) / (6.0 * area)\n        cy = np.sum((y + y_next) * cross) / (6.0 * area)\n        return np.array([cx, cy])\n\n    for _ in range(N_RESTARTS):\n        # Initialize random centers\n        points = np.random.rand(N, 2)\n        \n        # Lloyd's Relaxation\n        valid_attempt = True\n        for _ in range(N_LLOYD_ITERS):\n            all_pts = np.vstack([points, dummy_points])\n            try:\n                vor = Voronoi(all_pts)\n            except:\n                valid_attempt = False\n                break\n                \n            new_points = []\n            for i in range(N):\n                region_idx = vor.point_region[i]\n                idxs = vor.regions[region_idx]\n                \n                # Should be finite due to dummy points\n                if -1 in idxs or len(idxs) == 0:\n                    new_points.append(points[i])\n                    continue\n                    \n                verts = vor.vertices[idxs]\n                c = get_clipped_centroid(verts)\n                \n                if c is not None:\n                    c = np.clip(c, 0.0, 1.0)\n                    new_points.append(c)\n                else:\n                    new_points.append(points[i])\n            points = np.array(new_points)\n        \n        if not valid_attempt: continue\n\n        # Compute Radii (Greedy Expansion)\n        centers = points\n        radii = np.zeros(N)\n        \n        # Calculate distance matrix\n        dists = np.sqrt(np.sum((centers[:, None] - centers[None, :])**2, axis=-1))\n        np.fill_diagonal(dists, np.inf)\n        \n        # Initial radii: distance to wall or half-distance to nearest neighbor\n        for i in range(N):\n            w = min(centers[i,0], 1-centers[i,0], centers[i,1], 1-centers[i,1])\n            radii[i] = min(w, np.min(dists[i])/2.0)\n            \n        # Iterative expansion to fill gaps\n        idx_list = np.arange(N)\n        for _ in range(200):\n            np.random.shuffle(idx_list)\n            changed = False\n            for i in idx_list:\n                old_r = radii[i]\n                # Max possible radius for i given fixed others\n                # Wall constraint\n                lim = min(centers[i,0], 1-centers[i,0], centers[i,1], 1-centers[i,1])\n                # Neighbor constraints: r_i <= dist_ij - r_j\n                for j in range(N):\n                    if i == j: continue\n                    lim = min(lim, dists[i,j] - radii[j])\n                \n                lim = max(0.0, lim)\n                \n                # Update with relaxation or direct assignment\n                if abs(lim - old_r) > 1e-7:\n                    radii[i] = lim\n                    changed = True\n            if not changed: break\n            \n        score = np.sum(radii)\n        if score > best_score:\n            best_score = score\n            best_res = (centers, radii, score)\n            \n    return best_res\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.475131189691223,
    "eval_time": 6.046122074127197,
    "error": null
  },
  "prompt": "Solve circle packing (26 circles). \n\nStrategy: **Voronoi Relaxation**.\n- Start random.\n- Loop:\n  - Compute Voronoi diagram of centers.\n  - Move each center to the centroid of its Voronoi cell (Lloyd's algorithm).\n  - Adjust radii.\n  - Repeat.\n- This tends to produce hexagonal packings.\n\nCRITICAL: Output ONLY a single Python code block (```python ... ```). \nNO intro text. NO explanation. NO 'Here is the code'. \nJust the code.",
  "response": "```python\nimport numpy as np\nfrom scipy.spatial import Voronoi\n\ndef construct_packing():\n    # Parameters for the packing optimization\n    N = 26\n    N_RESTARTS = 50\n    N_LLOYD_ITERS = 100\n    \n    best_res = None\n    best_score = -np.inf\n\n    # Dummy points to ensure Voronoi cells for the 26 points are finite\n    # Bounding box [-10, 20] is sufficient for [0,1] points\n    dummy_points = np.array([\n        [-10.0, -10.0], [0.5, -10.0], [10.0, -10.0],\n        [-10.0, 0.5],                 [10.0, 0.5],\n        [-10.0, 10.0],  [0.5, 10.0],  [10.0, 10.0]\n    ])\n\n    def get_clipped_centroid(verts):\n        # Sutherland-Hodgman polygon clipping against [0,1]x[0,1]\n        poly = list(verts)\n        # Planes defined by (normal, point)\n        planes = [\n            (np.array([1.0, 0.0]), np.array([0.0, 0.0])),   # x >= 0\n            (np.array([-1.0, 0.0]), np.array([1.0, 0.0])),  # x <= 1\n            (np.array([0.0, 1.0]), np.array([0.0, 0.0])),   # y >= 0\n            (np.array([0.0, -1.0]), np.array([0.0, 1.0]))   # y <= 1\n        ]\n        \n        for n, p in planes:\n            if not poly: break\n            new_poly = []\n            S = poly[-1]\n            for E in poly:\n                # Check if points are inside: dot(n, X-p) >= 0\n                sin = np.dot(n, S - p) >= -1e-12\n                ein = np.dot(n, E - p) >= -1e-12\n                \n                if ein:\n                    if not sin:\n                        # Intersection\n                        denom = np.dot(n, E - S)\n                        t = np.dot(n, p - S) / (denom if abs(denom) > 1e-12 else 1e-12)\n                        new_poly.append(S + t * (E - S))\n                    new_poly.append(E)\n                elif sin:\n                    # Intersection\n                    denom = np.dot(n, E - S)\n                    t = np.dot(n, p - S) / (denom if abs(denom) > 1e-12 else 1e-12)\n                    new_poly.append(S + t * (E - S))\n                S = E\n            poly = new_poly\n            \n        if len(poly) < 3:\n            return None\n            \n        # Compute Centroid\n        A = np.array(poly)\n        x = A[:, 0]\n        y = A[:, 1]\n        x_next = np.roll(x, -1)\n        y_next = np.roll(y, -1)\n        cross = x * y_next - x_next * y\n        area = 0.5 * np.sum(cross)\n        \n        if abs(area) < 1e-9: return None\n        \n        cx = np.sum((x + x_next) * cross) / (6.0 * area)\n        cy = np.sum((y + y_next) * cross) / (6.0 * area)\n        return np.array([cx, cy])\n\n    for _ in range(N_RESTARTS):\n        # Initialize random centers\n        points = np.random.rand(N, 2)\n        \n        # Lloyd's Relaxation\n        valid_attempt = True\n        for _ in range(N_LLOYD_ITERS):\n            all_pts = np.vstack([points, dummy_points])\n            try:\n                vor = Voronoi(all_pts)\n            except:\n                valid_attempt = False\n                break\n                \n            new_points = []\n            for i in range(N):\n                region_idx = vor.point_region[i]\n                idxs = vor.regions[region_idx]\n                \n                # Should be finite due to dummy points\n                if -1 in idxs or len(idxs) == 0:\n                    new_points.append(points[i])\n                    continue\n                    \n                verts = vor.vertices[idxs]\n                c = get_clipped_centroid(verts)\n                \n                if c is not None:\n                    c = np.clip(c, 0.0, 1.0)\n                    new_points.append(c)\n                else:\n                    new_points.append(points[i])\n            points = np.array(new_points)\n        \n        if not valid_attempt: continue\n\n        # Compute Radii (Greedy Expansion)\n        centers = points\n        radii = np.zeros(N)\n        \n        # Calculate distance matrix\n        dists = np.sqrt(np.sum((centers[:, None] - centers[None, :])**2, axis=-1))\n        np.fill_diagonal(dists, np.inf)\n        \n        # Initial radii: distance to wall or half-distance to nearest neighbor\n        for i in range(N):\n            w = min(centers[i,0], 1-centers[i,0], centers[i,1], 1-centers[i,1])\n            radii[i] = min(w, np.min(dists[i])/2.0)\n            \n        # Iterative expansion to fill gaps\n        idx_list = np.arange(N)\n        for _ in range(200):\n            np.random.shuffle(idx_list)\n            changed = False\n            for i in idx_list:\n                old_r = radii[i]\n                # Max possible radius for i given fixed others\n                # Wall constraint\n                lim = min(centers[i,0], 1-centers[i,0], centers[i,1], 1-centers[i,1])\n                # Neighbor constraints: r_i <= dist_ij - r_j\n                for j in range(N):\n                    if i == j: continue\n                    lim = min(lim, dists[i,j] - radii[j])\n                \n                lim = max(0.0, lim)\n                \n                # Update with relaxation or direct assignment\n                if abs(lim - old_r) > 1e-7:\n                    radii[i] = lim\n                    changed = True\n            if not changed: break\n            \n        score = np.sum(radii)\n        if score > best_score:\n            best_score = score\n            best_res = (centers, radii, score)\n            \n    return best_res\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T11:05:59.118418",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 341,
        "candidates_token_count": 1695,
        "thoughts_token_count": 8989
      },
      "response_text_len": 5349
    }
  }
}