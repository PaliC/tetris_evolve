{
  "trial_id": "trial_4_6",
  "generation": 4,
  "parent_id": "trial_1_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    best_sum_r = 0\n    best_vars = None\n    \n    # Run multiple physics-based initializations to find a good starting point\n    for start_idx in range(5):\n        if start_idx == 0:\n            # 5x5 grid plus one extra circle, slightly perturbed\n            x_vals = np.linspace(0.1, 0.9, 5)\n            xx, yy = np.meshgrid(x_vals, x_vals)\n            centers = np.vstack([xx.ravel(), yy.ravel()]).T\n            centers = np.vstack([centers, [0.5, 0.5]])\n            centers += np.random.normal(0, 0.02, centers.shape)\n            radii = np.full(n, 0.05)\n        else:\n            # Random starting positions\n            centers = np.random.rand(n, 2) * 0.7 + 0.15\n            radii = np.full(n, 0.04)\n        \n        # Physics simulation: variable radius dynamics\n        for step in range(800):\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists_sq = np.sum(diffs**2, axis=2)\n            dists = np.sqrt(dists_sq + 1e-12)\n            min_dists = radii[:, np.newaxis] + radii[np.newaxis, :]\n            \n            overlap = np.maximum(0, min_dists - dists)\n            np.fill_diagonal(overlap, 0)\n            \n            # Repulsive forces between overlapping circles\n            force_dir = diffs / (dists[:, :, np.newaxis] + 1e-12)\n            forces = np.sum(overlap[:, :, np.newaxis] * force_dir, axis=1)\n            \n            # Boundary forces\n            b_min = radii[:, np.newaxis] - centers\n            b_max = centers - (1.0 - radii[:, np.newaxis])\n            forces += np.maximum(0, b_min) * 0.6\n            forces -= np.maximum(0, b_max) * 0.6\n            \n            # Update positions and radii based on local pressure\n            pressure = np.sum(overlap, axis=1)\n            centers += forces * 0.05\n            radii += 0.0006 * (0.02 - pressure)\n            radii = np.clip(radii, 0.005, 0.15)\n            centers = np.clip(centers, 0, 1)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum_r:\n            best_sum_r = current_sum\n            best_vars = np.hstack([centers, radii.reshape(-1, 1)]).flatten()\n\n    # SLSQP Refinement\n    def objective(vars):\n        # Maximize sum of radii\n        return -np.sum(vars[2::3])\n\n    def objective_jac(vars):\n        jac = np.zeros_like(vars)\n        jac[2::3] = -1.0\n        return jac\n\n    def constraints(vars):\n        v = vars.reshape(-1, 3)\n        c = v[:, :2]\n        r = v[:, 2]\n        \n        # Boundary constraints\n        b_cons = np.zeros(4 * n)\n        b_cons[0::4] = c[:, 0] - r\n        b_cons[1::4] = 1.0 - c[:, 0] - r\n        b_cons[2::4] = c[:, 1] - r\n        b_cons[3::4] = 1.0 - c[:, 1] - r\n        \n        # Overlap constraints\n        i_idx, j_idx = np.triu_indices(n, k=1)\n        dx = c[i_idx, 0] - c[j_idx, 0]\n        dy = c[i_idx, 1] - c[j_idx, 1]\n        sr = r[i_idx] + r[j_idx]\n        o_cons = dx*dx + dy*dy - sr*sr\n        \n        return np.concatenate([b_cons, o_cons])\n\n    def constraints_jac(vars):\n        v = vars.reshape(-1, 3)\n        c = v[:, :2]\n        r = v[:, 2]\n        num_o_cons = n * (n - 1) // 2\n        jac = np.zeros((4 * n + num_o_cons, 3 * n))\n        \n        # Boundary constraints Jacobian\n        for i in range(n):\n            jac[4*i, 3*i] = 1; jac[4*i, 3*i+2] = -1\n            jac[4*i+1, 3*i] = -1; jac[4*i+1, 3*i+2] = -1\n            jac[4*i+2, 3*i+1] = 1; jac[4*i+2, 3*i+2] = -1\n            jac[4*i+3, 3*i+1] = -1; jac[4*i+3, 3*i+2] = -1\n            \n        # Overlap constraints Jacobian\n        i_idx, j_idx = np.triu_indices(n, k=1)\n        dx = c[i_idx, 0] - c[j_idx, 0]\n        dy = c[i_idx, 1] - c[j_idx, 1]\n        sr = r[i_idx] + r[j_idx]\n        \n        o_row_indices = np.arange(4 * n, 4 * n + num_o_cons)\n        jac[o_row_indices, 3*i_idx] = 2 * dx\n        jac[o_row_indices, 3*i_idx+1] = 2 * dy\n        jac[o_row_indices, 3*i_idx+2] = -2 * sr\n        jac[o_row_indices, 3*j_idx] = -2 * dx\n        jac[o_row_indices, 3*j_idx+1] = -2 * dy\n        jac[o_row_indices, 3*j_idx+2] = -2 * sr\n        \n        return jac\n\n    # Run the optimizer\n    res = minimize(objective, best_vars, jac=objective_jac,\n                   constraints={'type': 'ineq', 'fun': constraints, 'jac': constraints_jac},\n                   method='SLSQP', options={'maxiter': 250},\n                   bounds=[(0, 1), (0, 1), (0, 0.5)] * n)\n    \n    final_vars = res.x.reshape(-1, 3)\n    final_centers = final_vars[:, :2]\n    final_radii = final_vars[:, 2]\n    sum_radii = -res.fun\n    \n    return final_centers, final_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.629189042164051,
    "eval_time": 0.3881199359893799,
    "error": null
  },
  "prompt": "Refine the physics approach from {CODE_TRIAL_1_0}. \n\nStrategy: **Variable Radius Dynamics**.\n- In the physics simulation, allow radii to grow *dynamically* based on local pressure.\n- If a circle has no neighbors, grow fast.\n- If it has high overlap, shrink.\n- Run for 1000 steps, then freeze and polish with SLSQP.\n\nCRITICAL INSTRUCTION:\nYour response must contain ONLY a single Python code block (```python ... ```). \nDO NOT write any introduction, explanation, or conclusion.\nJust the code.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    best_sum_r = 0\n    best_vars = None\n    \n    # Run multiple physics-based initializations to find a good starting point\n    for start_idx in range(5):\n        if start_idx == 0:\n            # 5x5 grid plus one extra circle, slightly perturbed\n            x_vals = np.linspace(0.1, 0.9, 5)\n            xx, yy = np.meshgrid(x_vals, x_vals)\n            centers = np.vstack([xx.ravel(), yy.ravel()]).T\n            centers = np.vstack([centers, [0.5, 0.5]])\n            centers += np.random.normal(0, 0.02, centers.shape)\n            radii = np.full(n, 0.05)\n        else:\n            # Random starting positions\n            centers = np.random.rand(n, 2) * 0.7 + 0.15\n            radii = np.full(n, 0.04)\n        \n        # Physics simulation: variable radius dynamics\n        for step in range(800):\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists_sq = np.sum(diffs**2, axis=2)\n            dists = np.sqrt(dists_sq + 1e-12)\n            min_dists = radii[:, np.newaxis] + radii[np.newaxis, :]\n            \n            overlap = np.maximum(0, min_dists - dists)\n            np.fill_diagonal(overlap, 0)\n            \n            # Repulsive forces between overlapping circles\n            force_dir = diffs / (dists[:, :, np.newaxis] + 1e-12)\n            forces = np.sum(overlap[:, :, np.newaxis] * force_dir, axis=1)\n            \n            # Boundary forces\n            b_min = radii[:, np.newaxis] - centers\n            b_max = centers - (1.0 - radii[:, np.newaxis])\n            forces += np.maximum(0, b_min) * 0.6\n            forces -= np.maximum(0, b_max) * 0.6\n            \n            # Update positions and radii based on local pressure\n            pressure = np.sum(overlap, axis=1)\n            centers += forces * 0.05\n            radii += 0.0006 * (0.02 - pressure)\n            radii = np.clip(radii, 0.005, 0.15)\n            centers = np.clip(centers, 0, 1)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum_r:\n            best_sum_r = current_sum\n            best_vars = np.hstack([centers, radii.reshape(-1, 1)]).flatten()\n\n    # SLSQP Refinement\n    def objective(vars):\n        # Maximize sum of radii\n        return -np.sum(vars[2::3])\n\n    def objective_jac(vars):\n        jac = np.zeros_like(vars)\n        jac[2::3] = -1.0\n        return jac\n\n    def constraints(vars):\n        v = vars.reshape(-1, 3)\n        c = v[:, :2]\n        r = v[:, 2]\n        \n        # Boundary constraints\n        b_cons = np.zeros(4 * n)\n        b_cons[0::4] = c[:, 0] - r\n        b_cons[1::4] = 1.0 - c[:, 0] - r\n        b_cons[2::4] = c[:, 1] - r\n        b_cons[3::4] = 1.0 - c[:, 1] - r\n        \n        # Overlap constraints\n        i_idx, j_idx = np.triu_indices(n, k=1)\n        dx = c[i_idx, 0] - c[j_idx, 0]\n        dy = c[i_idx, 1] - c[j_idx, 1]\n        sr = r[i_idx] + r[j_idx]\n        o_cons = dx*dx + dy*dy - sr*sr\n        \n        return np.concatenate([b_cons, o_cons])\n\n    def constraints_jac(vars):\n        v = vars.reshape(-1, 3)\n        c = v[:, :2]\n        r = v[:, 2]\n        num_o_cons = n * (n - 1) // 2\n        jac = np.zeros((4 * n + num_o_cons, 3 * n))\n        \n        # Boundary constraints Jacobian\n        for i in range(n):\n            jac[4*i, 3*i] = 1; jac[4*i, 3*i+2] = -1\n            jac[4*i+1, 3*i] = -1; jac[4*i+1, 3*i+2] = -1\n            jac[4*i+2, 3*i+1] = 1; jac[4*i+2, 3*i+2] = -1\n            jac[4*i+3, 3*i+1] = -1; jac[4*i+3, 3*i+2] = -1\n            \n        # Overlap constraints Jacobian\n        i_idx, j_idx = np.triu_indices(n, k=1)\n        dx = c[i_idx, 0] - c[j_idx, 0]\n        dy = c[i_idx, 1] - c[j_idx, 1]\n        sr = r[i_idx] + r[j_idx]\n        \n        o_row_indices = np.arange(4 * n, 4 * n + num_o_cons)\n        jac[o_row_indices, 3*i_idx] = 2 * dx\n        jac[o_row_indices, 3*i_idx+1] = 2 * dy\n        jac[o_row_indices, 3*i_idx+2] = -2 * sr\n        jac[o_row_indices, 3*j_idx] = -2 * dx\n        jac[o_row_indices, 3*j_idx+1] = -2 * dy\n        jac[o_row_indices, 3*j_idx+2] = -2 * sr\n        \n        return jac\n\n    # Run the optimizer\n    res = minimize(objective, best_vars, jac=objective_jac,\n                   constraints={'type': 'ineq', 'fun': constraints, 'jac': constraints_jac},\n                   method='SLSQP', options={'maxiter': 250},\n                   bounds=[(0, 1), (0, 1), (0, 0.5)] * n)\n    \n    final_vars = res.x.reshape(-1, 3)\n    final_centers = final_vars[:, :2]\n    final_radii = final_vars[:, 2]\n    sum_radii = -res.fun\n    \n    return final_centers, final_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T10:30:50.553988",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 349,
        "candidates_token_count": 1757,
        "thoughts_token_count": 14535
      },
      "response_text_len": 4687
    }
  }
}