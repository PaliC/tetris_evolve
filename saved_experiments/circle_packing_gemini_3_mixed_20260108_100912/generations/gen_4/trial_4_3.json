{
  "trial_id": "trial_4_3",
  "generation": 4,
  "parent_id": "trial_3_3",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, basinhopping, Bounds, LinearConstraint, NonlinearConstraint\n\ndef construct_packing():\n    N = 26\n    # Optimization variables: x0, y0, r0, x1, y1, r1, ...\n    # Total 3*N variables.\n    \n    # Indices for corner circles\n    C_BL, C_BR, C_TL, C_TR = 0, 1, 2, 3\n    OTHERS = list(range(4, N))\n    \n    # Precompute pairs for overlap constraints\n    pairs = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            pairs.append((i, j))\n    num_pairs = len(pairs)\n\n    # Objective: Maximize sum of radii -> Minimize -sum(radii)\n    def objective(w):\n        return -np.sum(w[2::3])\n\n    def objective_grad(w):\n        grad = np.zeros_like(w)\n        grad[2::3] = -1.0\n        return grad\n\n    # Constraints\n    # 1. Containment (Linear)\n    # x - r >= 0, x + r <= 1, y - r >= 0, y + r <= 1\n    # Form: A @ w <= b\n    # 4 constraints per circle. Total 4*N.\n    # We can also use bounds on x,y,r and these linear constraints.\n    # However, for SLSQP, explicit linear constraints are good.\n    \n    # A matrix for linear constraints\n    # For each circle i:\n    # -x_i + r_i <= 0\n    # x_i + r_i <= 1\n    # -y_i + r_i <= 0\n    # y_i + r_i <= 1\n    \n    A_list = []\n    b_list = []\n    for i in range(N):\n        # Indices in w: 3*i (x), 3*i+1 (y), 3*i+2 (r)\n        base = 3*i\n        \n        # -x + r <= 0\n        row = np.zeros(3*N)\n        row[base] = -1; row[base+2] = 1\n        A_list.append(row); b_list.append(0.0)\n        \n        # x + r <= 1\n        row = np.zeros(3*N)\n        row[base] = 1; row[base+2] = 1\n        A_list.append(row); b_list.append(1.0)\n        \n        # -y + r <= 0\n        row = np.zeros(3*N)\n        row[base+1] = -1; row[base+2] = 1\n        A_list.append(row); b_list.append(0.0)\n        \n        # y + r <= 1\n        row = np.zeros(3*N)\n        row[base+1] = 1; row[base+2] = 1\n        A_list.append(row); b_list.append(1.0)\n        \n    A = np.array(A_list)\n    b = np.array(b_list)\n    linear_cons = LinearConstraint(A, -np.inf, b)\n\n    # 2. Pinned Corners (Equality)\n    # C_BL (0): x = r, y = r  => x-r=0, y-r=0\n    # C_BR (1): x = 1-r, y = r => x+r=1, y-r=0\n    # C_TL (2): x = r, y = 1-r => x-r=0, y+r=1\n    # C_TR (3): x = 1-r, y = 1-r => x+r=1, y+r=1\n    \n    cnt_corner_eq = 8\n    A_eq_list = []\n    b_eq_list = []\n    \n    # Helper to add eq constraint\n    def add_eq(idx, c_type):\n        base = 3*idx\n        row_x = np.zeros(3*N)\n        row_y = np.zeros(3*N)\n        \n        if c_type == 'BL': # x-r=0, y-r=0\n            row_x[base] = 1; row_x[base+2] = -1; val_x = 0\n            row_y[base+1] = 1; row_y[base+2] = -1; val_y = 0\n        elif c_type == 'BR': # x+r=1, y-r=0\n            row_x[base] = 1; row_x[base+2] = 1; val_x = 1\n            row_y[base+1] = 1; row_y[base+2] = -1; val_y = 0\n        elif c_type == 'TL': # x-r=0, y+r=1\n            row_x[base] = 1; row_x[base+2] = -1; val_x = 0\n            row_y[base+1] = 1; row_y[base+2] = 1; val_y = 1\n        elif c_type == 'TR': # x+r=1, y+r=1\n            row_x[base] = 1; row_x[base+2] = 1; val_x = 1\n            row_y[base+1] = 1; row_y[base+2] = 1; val_y = 1\n            \n        A_eq_list.append(row_x); b_eq_list.append(val_x)\n        A_eq_list.append(row_y); b_eq_list.append(val_y)\n\n    add_eq(C_BL, 'BL')\n    add_eq(C_BR, 'BR')\n    add_eq(C_TL, 'TL')\n    add_eq(C_TR, 'TR')\n    \n    A_eq = np.array(A_eq_list)\n    b_eq = np.array(b_eq_list)\n    # We incorporate these as LinearConstraint with lb=ub\n    corner_cons = LinearConstraint(A_eq, b_eq, b_eq)\n\n    # 3. Non-overlap (Nonlinear)\n    # (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2 >= 0\n    def overlap_fun(w):\n        res = []\n        x = w[0::3]\n        y = w[1::3]\n        r = w[2::3]\n        for (i, j) in pairs:\n            dist_sq = (x[i]-x[j])**2 + (y[i]-y[j])**2\n            r_sum_sq = (r[i]+r[j])**2\n            res.append(dist_sq - r_sum_sq)\n        return np.array(res)\n\n    def overlap_jac(w):\n        jac = np.zeros((num_pairs, 3*N))\n        x = w[0::3]\n        y = w[1::3]\n        r = w[2::3]\n        for k, (i, j) in enumerate(pairs):\n            dx = x[i] - x[j]\n            dy = y[i] - y[j]\n            r_sum = r[i] + r[j]\n            \n            # d/dxi = 2(xi-xj)\n            jac[k, 3*i] = 2*dx\n            # d/dxj = -2(xi-xj)\n            jac[k, 3*j] = -2*dx\n            # d/dyi\n            jac[k, 3*i+1] = 2*dy\n            # d/dyj\n            jac[k, 3*j+1] = -2*dy\n            # d/dri = -2(ri+rj)\n            jac[k, 3*i+2] = -2*r_sum\n            # d/drj\n            jac[k, 3*j+2] = -2*r_sum\n        return jac\n\n    overlap_cons = NonlinearConstraint(overlap_fun, 0.0, np.inf, jac=overlap_jac)\n\n    # Initial Guess\n    # 4 corners\n    w0 = np.zeros(3*N)\n    \n    # Initialize corners with small radius\n    r_start = 0.1\n    # BL\n    w0[3*C_BL] = r_start; w0[3*C_BL+1] = r_start; w0[3*C_BL+2] = r_start\n    # BR\n    w0[3*C_BR] = 1-r_start; w0[3*C_BR+1] = r_start; w0[3*C_BR+2] = r_start\n    # TL\n    w0[3*C_TL] = r_start; w0[3*C_TL+1] = 1-r_start; w0[3*C_TL+2] = r_start\n    # TR\n    w0[3*C_TR] = 1-r_start; w0[3*C_TR+1] = 1-r_start; w0[3*C_TR+2] = r_start\n    \n    # Initialize others in a grid in the center\n    # 22 circles. 5x5 grid = 25 points.\n    gx = np.linspace(0.2, 0.8, 5)\n    gy = np.linspace(0.2, 0.8, 5)\n    grid_pts = []\n    for xx in gx:\n        for yy in gy:\n            grid_pts.append((xx, yy))\n    \n    # Take first 22 points\n    for k, idx in enumerate(OTHERS):\n        if k < len(grid_pts):\n            w0[3*idx] = grid_pts[k][0]\n            w0[3*idx+1] = grid_pts[k][1]\n            w0[3*idx+2] = 0.05 # small start radius\n        else:\n            w0[3*idx] = 0.5\n            w0[3*idx+1] = 0.5\n            w0[3*idx+2] = 0.05\n\n    # Bounds for variables\n    # x,y in [0,1], r in [0, 0.5]\n    lb = []\n    ub = []\n    for i in range(N):\n        lb.extend([0.0, 0.0, 0.0])\n        ub.extend([1.0, 1.0, 0.5])\n    bounds = Bounds(lb, ub)\n\n    # Custom Step Taker for Basin Hopping\n    class RandomDisplacement:\n        def __init__(self, stepsize=0.05):\n            self.stepsize = stepsize\n        def __call__(self, x):\n            # Perturb coordinates\n            s = self.stepsize\n            perturb = np.random.uniform(-s, s, size=x.shape)\n            # Apply perturbation primarily to positions, less to radii\n            # Mask radii to perturb less?\n            # Actually, let's just perturb everything and let bounds clip.\n            x_new = x + perturb\n            # Clip to bounds\n            x_new = np.clip(x_new, lb, ub)\n            return x_new\n\n    # Optimization\n    # We use SLSQP inside basinhopping\n    minimizer_kwargs = {\n        'method': 'SLSQP',\n        'jac': objective_grad,\n        'bounds': bounds,\n        'constraints': [linear_cons, corner_cons, overlap_cons],\n        'options': {'ftol': 1e-4, 'disp': False, 'maxiter': 100}\n    }\n\n    # Run Basin Hopping\n    # We limit iterations to keep runtime reasonable for the environment\n    res = basinhopping(\n        objective, \n        w0, \n        minimizer_kwargs=minimizer_kwargs,\n        niter=30, # Sufficient to shake up the grid\n        T=0.5,\n        stepsize=0.1,\n        take_step=RandomDisplacement(0.05),\n        seed=42\n    )\n    \n    # Final Polish\n    # Run one last high-precision minimization on the best found\n    w_final = res.x\n    minimizer_kwargs['options']['ftol'] = 1e-9\n    minimizer_kwargs['options']['maxiter'] = 1000\n    final_res = minimize(objective, w_final, **minimizer_kwargs)\n    w_best = final_res.x\n\n    # Extract results\n    centers = np.zeros((N, 2))\n    radii = np.zeros(N)\n    for i in range(N):\n        centers[i, 0] = w_best[3*i]\n        centers[i, 1] = w_best[3*i+1]\n        radii[i] = w_best[3*i+2]\n    \n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.573001826030509,
    "eval_time": 2.2704739570617676,
    "error": null
  },
  "prompt": "Combine the strategies of {CODE_TRIAL_3_0} (Basin Hopping) and {CODE_TRIAL_3_3} (Corner Bias). \n\nStrategy: **Pinned Corner Basin Hopping**.\n- Initialize with the Hex grid.\n- FORCE the 4 corner circles to be exactly at (r,r), (r, 1-r), etc.\n- Run `basinhopping` optimizing primarily the *other* 22 circles, but allowing the corners to wiggle slightly.\n- This reduces the search space dimensionality.\n\nCRITICAL INSTRUCTION:\nYour response must contain ONLY a single Python code block (```python ... ```). \nDO NOT write any introduction, explanation, or conclusion.\nJust the code.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping, Bounds, LinearConstraint, NonlinearConstraint\n\ndef construct_packing():\n    N = 26\n    # Optimization variables: x0, y0, r0, x1, y1, r1, ...\n    # Total 3*N variables.\n    \n    # Indices for corner circles\n    C_BL, C_BR, C_TL, C_TR = 0, 1, 2, 3\n    OTHERS = list(range(4, N))\n    \n    # Precompute pairs for overlap constraints\n    pairs = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            pairs.append((i, j))\n    num_pairs = len(pairs)\n\n    # Objective: Maximize sum of radii -> Minimize -sum(radii)\n    def objective(w):\n        return -np.sum(w[2::3])\n\n    def objective_grad(w):\n        grad = np.zeros_like(w)\n        grad[2::3] = -1.0\n        return grad\n\n    # Constraints\n    # 1. Containment (Linear)\n    # x - r >= 0, x + r <= 1, y - r >= 0, y + r <= 1\n    # Form: A @ w <= b\n    # 4 constraints per circle. Total 4*N.\n    # We can also use bounds on x,y,r and these linear constraints.\n    # However, for SLSQP, explicit linear constraints are good.\n    \n    # A matrix for linear constraints\n    # For each circle i:\n    # -x_i + r_i <= 0\n    # x_i + r_i <= 1\n    # -y_i + r_i <= 0\n    # y_i + r_i <= 1\n    \n    A_list = []\n    b_list = []\n    for i in range(N):\n        # Indices in w: 3*i (x), 3*i+1 (y), 3*i+2 (r)\n        base = 3*i\n        \n        # -x + r <= 0\n        row = np.zeros(3*N)\n        row[base] = -1; row[base+2] = 1\n        A_list.append(row); b_list.append(0.0)\n        \n        # x + r <= 1\n        row = np.zeros(3*N)\n        row[base] = 1; row[base+2] = 1\n        A_list.append(row); b_list.append(1.0)\n        \n        # -y + r <= 0\n        row = np.zeros(3*N)\n        row[base+1] = -1; row[base+2] = 1\n        A_list.append(row); b_list.append(0.0)\n        \n        # y + r <= 1\n        row = np.zeros(3*N)\n        row[base+1] = 1; row[base+2] = 1\n        A_list.append(row); b_list.append(1.0)\n        \n    A = np.array(A_list)\n    b = np.array(b_list)\n    linear_cons = LinearConstraint(A, -np.inf, b)\n\n    # 2. Pinned Corners (Equality)\n    # C_BL (0): x = r, y = r  => x-r=0, y-r=0\n    # C_BR (1): x = 1-r, y = r => x+r=1, y-r=0\n    # C_TL (2): x = r, y = 1-r => x-r=0, y+r=1\n    # C_TR (3): x = 1-r, y = 1-r => x+r=1, y+r=1\n    \n    cnt_corner_eq = 8\n    A_eq_list = []\n    b_eq_list = []\n    \n    # Helper to add eq constraint\n    def add_eq(idx, c_type):\n        base = 3*idx\n        row_x = np.zeros(3*N)\n        row_y = np.zeros(3*N)\n        \n        if c_type == 'BL': # x-r=0, y-r=0\n            row_x[base] = 1; row_x[base+2] = -1; val_x = 0\n            row_y[base+1] = 1; row_y[base+2] = -1; val_y = 0\n        elif c_type == 'BR': # x+r=1, y-r=0\n            row_x[base] = 1; row_x[base+2] = 1; val_x = 1\n            row_y[base+1] = 1; row_y[base+2] = -1; val_y = 0\n        elif c_type == 'TL': # x-r=0, y+r=1\n            row_x[base] = 1; row_x[base+2] = -1; val_x = 0\n            row_y[base+1] = 1; row_y[base+2] = 1; val_y = 1\n        elif c_type == 'TR': # x+r=1, y+r=1\n            row_x[base] = 1; row_x[base+2] = 1; val_x = 1\n            row_y[base+1] = 1; row_y[base+2] = 1; val_y = 1\n            \n        A_eq_list.append(row_x); b_eq_list.append(val_x)\n        A_eq_list.append(row_y); b_eq_list.append(val_y)\n\n    add_eq(C_BL, 'BL')\n    add_eq(C_BR, 'BR')\n    add_eq(C_TL, 'TL')\n    add_eq(C_TR, 'TR')\n    \n    A_eq = np.array(A_eq_list)\n    b_eq = np.array(b_eq_list)\n    # We incorporate these as LinearConstraint with lb=ub\n    corner_cons = LinearConstraint(A_eq, b_eq, b_eq)\n\n    # 3. Non-overlap (Nonlinear)\n    # (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2 >= 0\n    def overlap_fun(w):\n        res = []\n        x = w[0::3]\n        y = w[1::3]\n        r = w[2::3]\n        for (i, j) in pairs:\n            dist_sq = (x[i]-x[j])**2 + (y[i]-y[j])**2\n            r_sum_sq = (r[i]+r[j])**2\n            res.append(dist_sq - r_sum_sq)\n        return np.array(res)\n\n    def overlap_jac(w):\n        jac = np.zeros((num_pairs, 3*N))\n        x = w[0::3]\n        y = w[1::3]\n        r = w[2::3]\n        for k, (i, j) in enumerate(pairs):\n            dx = x[i] - x[j]\n            dy = y[i] - y[j]\n            r_sum = r[i] + r[j]\n            \n            # d/dxi = 2(xi-xj)\n            jac[k, 3*i] = 2*dx\n            # d/dxj = -2(xi-xj)\n            jac[k, 3*j] = -2*dx\n            # d/dyi\n            jac[k, 3*i+1] = 2*dy\n            # d/dyj\n            jac[k, 3*j+1] = -2*dy\n            # d/dri = -2(ri+rj)\n            jac[k, 3*i+2] = -2*r_sum\n            # d/drj\n            jac[k, 3*j+2] = -2*r_sum\n        return jac\n\n    overlap_cons = NonlinearConstraint(overlap_fun, 0.0, np.inf, jac=overlap_jac)\n\n    # Initial Guess\n    # 4 corners\n    w0 = np.zeros(3*N)\n    \n    # Initialize corners with small radius\n    r_start = 0.1\n    # BL\n    w0[3*C_BL] = r_start; w0[3*C_BL+1] = r_start; w0[3*C_BL+2] = r_start\n    # BR\n    w0[3*C_BR] = 1-r_start; w0[3*C_BR+1] = r_start; w0[3*C_BR+2] = r_start\n    # TL\n    w0[3*C_TL] = r_start; w0[3*C_TL+1] = 1-r_start; w0[3*C_TL+2] = r_start\n    # TR\n    w0[3*C_TR] = 1-r_start; w0[3*C_TR+1] = 1-r_start; w0[3*C_TR+2] = r_start\n    \n    # Initialize others in a grid in the center\n    # 22 circles. 5x5 grid = 25 points.\n    gx = np.linspace(0.2, 0.8, 5)\n    gy = np.linspace(0.2, 0.8, 5)\n    grid_pts = []\n    for xx in gx:\n        for yy in gy:\n            grid_pts.append((xx, yy))\n    \n    # Take first 22 points\n    for k, idx in enumerate(OTHERS):\n        if k < len(grid_pts):\n            w0[3*idx] = grid_pts[k][0]\n            w0[3*idx+1] = grid_pts[k][1]\n            w0[3*idx+2] = 0.05 # small start radius\n        else:\n            w0[3*idx] = 0.5\n            w0[3*idx+1] = 0.5\n            w0[3*idx+2] = 0.05\n\n    # Bounds for variables\n    # x,y in [0,1], r in [0, 0.5]\n    lb = []\n    ub = []\n    for i in range(N):\n        lb.extend([0.0, 0.0, 0.0])\n        ub.extend([1.0, 1.0, 0.5])\n    bounds = Bounds(lb, ub)\n\n    # Custom Step Taker for Basin Hopping\n    class RandomDisplacement:\n        def __init__(self, stepsize=0.05):\n            self.stepsize = stepsize\n        def __call__(self, x):\n            # Perturb coordinates\n            s = self.stepsize\n            perturb = np.random.uniform(-s, s, size=x.shape)\n            # Apply perturbation primarily to positions, less to radii\n            # Mask radii to perturb less?\n            # Actually, let's just perturb everything and let bounds clip.\n            x_new = x + perturb\n            # Clip to bounds\n            x_new = np.clip(x_new, lb, ub)\n            return x_new\n\n    # Optimization\n    # We use SLSQP inside basinhopping\n    minimizer_kwargs = {\n        'method': 'SLSQP',\n        'jac': objective_grad,\n        'bounds': bounds,\n        'constraints': [linear_cons, corner_cons, overlap_cons],\n        'options': {'ftol': 1e-4, 'disp': False, 'maxiter': 100}\n    }\n\n    # Run Basin Hopping\n    # We limit iterations to keep runtime reasonable for the environment\n    res = basinhopping(\n        objective, \n        w0, \n        minimizer_kwargs=minimizer_kwargs,\n        niter=30, # Sufficient to shake up the grid\n        T=0.5,\n        stepsize=0.1,\n        take_step=RandomDisplacement(0.05),\n        seed=42\n    )\n    \n    # Final Polish\n    # Run one last high-precision minimization on the best found\n    w_final = res.x\n    minimizer_kwargs['options']['ftol'] = 1e-9\n    minimizer_kwargs['options']['maxiter'] = 1000\n    final_res = minimize(objective, w_final, **minimizer_kwargs)\n    w_best = final_res.x\n\n    # Extract results\n    centers = np.zeros((N, 2))\n    radii = np.zeros(N)\n    for i in range(N):\n        centers[i, 0] = w_best[3*i]\n        centers[i, 1] = w_best[3*i+1]\n        radii[i] = w_best[3*i+2]\n    \n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T10:30:54.060511",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 380,
        "candidates_token_count": 3221,
        "thoughts_token_count": 4683
      },
      "response_text_len": 7794
    }
  }
}