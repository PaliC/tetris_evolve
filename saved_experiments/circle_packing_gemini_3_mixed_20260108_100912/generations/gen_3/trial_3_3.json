{
  "trial_id": "trial_3_3",
  "generation": 3,
  "parent_id": "trial_1_6",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    N = 26\n    \n    # --- Initialization Strategy: Corner-Augmented Hex ---\n    # 1. Place 4 circles in corners\n    # 2. Fill interior with hex grid candidates\n    \n    # Initial radius guess for layout\n    r0 = 0.1\n    \n    # Corners\n    corners = np.array([\n        [r0, r0],\n        [1-r0, r0],\n        [1-r0, 1-r0],\n        [r0, 1-r0]\n    ])\n    \n    # Hex grid for interior\n    # Use a dense grid and pick points furthest from corners to fill center\n    d = 0.16  # Spacing\n    candidates = []\n    \n    # Generate a large patch of hex grid\n    for j in range(10):\n        y = 0.1 + j * d * np.sqrt(3)/2\n        if y > 0.9: continue\n        for i in range(10):\n            x = 0.1 + i * d + (j % 2) * d / 2\n            if x > 0.9: continue\n            \n            p = np.array([x, y])\n            \n            # Check bounds (padding for radius)\n            if not (0.1 < x < 0.9 and 0.1 < y < 0.9):\n                continue\n                \n            # Check distance to fixed corners\n            dists = np.linalg.norm(corners - p, axis=1)\n            if np.all(dists > 2*r0 * 0.8): # Ensure some separation\n                candidates.append(p)\n                \n    candidates = np.array(candidates)\n    \n    # Pick 22 closest to center of box\n    num_needed = 22\n    if len(candidates) >= num_needed:\n        d_center = np.sum((candidates - 0.5)**2, axis=1)\n        # Add tiny noise to break perfect symmetry\n        d_center += np.random.normal(0, 0.001, size=d_center.shape)\n        indices = np.argsort(d_center)[:num_needed]\n        interior = candidates[indices]\n    else:\n        # Fallback: random uniform in center\n        interior = np.random.uniform(0.2, 0.8, (num_needed, 2))\n        \n    initial_centers = np.vstack([corners, interior])\n    initial_radii = np.ones(N) * 0.05 # Start small to allow movement\n    \n    # Optimization variables: x, y, r\n    # Flattened: [x0...x25, y0...y25, r0...r25]\n    params0 = np.concatenate([\n        initial_centers[:, 0],\n        initial_centers[:, 1],\n        initial_radii\n    ])\n    \n    # Indices for pairwise overlap\n    idx_i, idx_j = np.triu_indices(N, 1)\n    \n    # --- Optimization Functions ---\n    \n    def objective(params, mu_overlap, mu_boundary):\n        xs = params[:N]\n        ys = params[N:2*N]\n        rs = params[2*N:]\n        \n        # 1. Maximize sum of radii\n        f = -np.sum(rs)\n        \n        # 2. Overlap Penalty\n        dx = xs[idx_i] - xs[idx_j]\n        dy = ys[idx_i] - ys[idx_j]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-16)\n        req_dist = rs[idx_i] + rs[idx_j]\n        overlap = np.maximum(0, req_dist - dist)\n        loss_overlap = np.sum(overlap**2)\n        \n        # 3. Boundary Penalty\n        # r <= x <= 1-r  ->  r-x <= 0, x+r-1 <= 0\n        lx = np.maximum(0, rs - xs)\n        hx = np.maximum(0, xs + rs - 1.0)\n        ly = np.maximum(0, rs - ys)\n        hy = np.maximum(0, ys + rs - 1.0)\n        loss_boundary = np.sum(lx**2 + hx**2 + ly**2 + hy**2)\n        \n        return f + mu_overlap * loss_overlap + mu_boundary * loss_boundary\n\n    def gradient(params, mu_overlap, mu_boundary):\n        xs = params[:N]\n        ys = params[N:2*N]\n        rs = params[2*N:]\n        \n        grad = np.zeros_like(params)\n        g_x = grad[:N]\n        g_y = grad[N:2*N]\n        g_r = grad[2*N:]\n        \n        # Obj\n        g_r[:] = -1.0\n        \n        # Overlap\n        dx = xs[idx_i] - xs[idx_j]\n        dy = ys[idx_i] - ys[idx_j]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-16)\n        req_dist = rs[idx_i] + rs[idx_j]\n        overlap = req_dist - dist\n        \n        mask = overlap > 0\n        if np.any(mask):\n            common = 2 * mu_overlap * overlap[mask]\n            \n            # Radii\n            np.add.at(g_r, idx_i[mask], common)\n            np.add.at(g_r, idx_j[mask], common)\n            \n            # Centers\n            inv_dist = 1.0 / dist[mask]\n            term_x = common * (-dx[mask] * inv_dist)\n            term_y = common * (-dy[mask] * inv_dist)\n            \n            np.add.at(g_x, idx_i[mask], term_x)\n            np.add.at(g_x, idx_j[mask], -term_x)\n            np.add.at(g_y, idx_i[mask], term_y)\n            np.add.at(g_y, idx_j[mask], -term_y)\n            \n        # Boundary\n        lx = np.maximum(0, rs - xs)\n        c = 2 * mu_boundary * lx\n        g_r += c\n        g_x -= c\n        \n        hx = np.maximum(0, xs + rs - 1.0)\n        c = 2 * mu_boundary * hx\n        g_r += c\n        g_x += c\n        \n        ly = np.maximum(0, rs - ys)\n        c = 2 * mu_boundary * ly\n        g_r += c\n        g_y -= c\n        \n        hy = np.maximum(0, ys + rs - 1.0)\n        c = 2 * mu_boundary * hy\n        g_r += c\n        g_y += c\n        \n        return grad\n\n    # Multi-stage optimization\n    bounds_def = [(0, 1)] * (2*N) + [(0.01, 0.4)] * N\n    \n    current_params = params0\n    # Schedule: Increase penalty\n    schedule = [\n        (10, 10),\n        (100, 100),\n        (1000, 1000),\n        (10000, 10000),\n        (1e6, 1e6)\n    ]\n    \n    for (mu_o, mu_b) in schedule:\n        res = minimize(\n            objective,\n            current_params,\n            args=(mu_o, mu_b),\n            method='L-BFGS-B',\n            jac=gradient,\n            bounds=bounds_def,\n            options={'ftol': 1e-9, 'maxiter': 3000}\n        )\n        current_params = res.x\n        \n    # --- Final Polish & Formatting ---\n    xs = current_params[:N]\n    ys = current_params[N:2*N]\n    rs = current_params[2*N:]\n    \n    # Enforce constraints strictly by shrinking\n    # 1. Box\n    rs = np.minimum(rs, xs)\n    rs = np.minimum(rs, 1-xs)\n    rs = np.minimum(rs, ys)\n    rs = np.minimum(rs, 1-ys)\n    \n    # 2. Overlap\n    for _ in range(50):\n        clean = True\n        for i in range(N):\n            for j in range(i+1, N):\n                d2 = (xs[i]-xs[j])**2 + (ys[i]-ys[j])**2\n                r_sum = rs[i] + rs[j]\n                if r_sum**2 > d2:\n                    d = np.sqrt(d2)\n                    scale = d / r_sum\n                    # Shrink to fit\n                    scale *= 0.9999999\n                    rs[i] *= scale\n                    rs[j] *= scale\n                    clean = False\n        if clean:\n            break\n            \n    centers = np.vstack([xs, ys]).T\n    sum_radii = np.sum(rs)\n    \n    return centers, rs, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.572995503075693,
    "eval_time": 0.2623133659362793,
    "error": null
  },
  "prompt": "Refine the strategy from {CODE_TRIAL_1_6}. \n\nStrategy: **Corner-Augmented Hex**.\n- The standard hex grid doesn't always hit the corners of the [0,1] box perfectly.\n- Explicitly place 4 circles at (r,r), (r,1-r), (1-r,r), (1-r,1-r).\n- Place the remaining 22 circles in a hex-like pattern in the interior.\n- Run optimization fixing the corners or heavily penalizing their movement away from corners.\n\nREQUIREMENTS:\n1. Output valid Python code ONLY.\n2. Wrap code in a ```python``` block.\n3. NO conversational text before or after.\n4. NO explanations.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    N = 26\n    \n    # --- Initialization Strategy: Corner-Augmented Hex ---\n    # 1. Place 4 circles in corners\n    # 2. Fill interior with hex grid candidates\n    \n    # Initial radius guess for layout\n    r0 = 0.1\n    \n    # Corners\n    corners = np.array([\n        [r0, r0],\n        [1-r0, r0],\n        [1-r0, 1-r0],\n        [r0, 1-r0]\n    ])\n    \n    # Hex grid for interior\n    # Use a dense grid and pick points furthest from corners to fill center\n    d = 0.16  # Spacing\n    candidates = []\n    \n    # Generate a large patch of hex grid\n    for j in range(10):\n        y = 0.1 + j * d * np.sqrt(3)/2\n        if y > 0.9: continue\n        for i in range(10):\n            x = 0.1 + i * d + (j % 2) * d / 2\n            if x > 0.9: continue\n            \n            p = np.array([x, y])\n            \n            # Check bounds (padding for radius)\n            if not (0.1 < x < 0.9 and 0.1 < y < 0.9):\n                continue\n                \n            # Check distance to fixed corners\n            dists = np.linalg.norm(corners - p, axis=1)\n            if np.all(dists > 2*r0 * 0.8): # Ensure some separation\n                candidates.append(p)\n                \n    candidates = np.array(candidates)\n    \n    # Pick 22 closest to center of box\n    num_needed = 22\n    if len(candidates) >= num_needed:\n        d_center = np.sum((candidates - 0.5)**2, axis=1)\n        # Add tiny noise to break perfect symmetry\n        d_center += np.random.normal(0, 0.001, size=d_center.shape)\n        indices = np.argsort(d_center)[:num_needed]\n        interior = candidates[indices]\n    else:\n        # Fallback: random uniform in center\n        interior = np.random.uniform(0.2, 0.8, (num_needed, 2))\n        \n    initial_centers = np.vstack([corners, interior])\n    initial_radii = np.ones(N) * 0.05 # Start small to allow movement\n    \n    # Optimization variables: x, y, r\n    # Flattened: [x0...x25, y0...y25, r0...r25]\n    params0 = np.concatenate([\n        initial_centers[:, 0],\n        initial_centers[:, 1],\n        initial_radii\n    ])\n    \n    # Indices for pairwise overlap\n    idx_i, idx_j = np.triu_indices(N, 1)\n    \n    # --- Optimization Functions ---\n    \n    def objective(params, mu_overlap, mu_boundary):\n        xs = params[:N]\n        ys = params[N:2*N]\n        rs = params[2*N:]\n        \n        # 1. Maximize sum of radii\n        f = -np.sum(rs)\n        \n        # 2. Overlap Penalty\n        dx = xs[idx_i] - xs[idx_j]\n        dy = ys[idx_i] - ys[idx_j]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-16)\n        req_dist = rs[idx_i] + rs[idx_j]\n        overlap = np.maximum(0, req_dist - dist)\n        loss_overlap = np.sum(overlap**2)\n        \n        # 3. Boundary Penalty\n        # r <= x <= 1-r  ->  r-x <= 0, x+r-1 <= 0\n        lx = np.maximum(0, rs - xs)\n        hx = np.maximum(0, xs + rs - 1.0)\n        ly = np.maximum(0, rs - ys)\n        hy = np.maximum(0, ys + rs - 1.0)\n        loss_boundary = np.sum(lx**2 + hx**2 + ly**2 + hy**2)\n        \n        return f + mu_overlap * loss_overlap + mu_boundary * loss_boundary\n\n    def gradient(params, mu_overlap, mu_boundary):\n        xs = params[:N]\n        ys = params[N:2*N]\n        rs = params[2*N:]\n        \n        grad = np.zeros_like(params)\n        g_x = grad[:N]\n        g_y = grad[N:2*N]\n        g_r = grad[2*N:]\n        \n        # Obj\n        g_r[:] = -1.0\n        \n        # Overlap\n        dx = xs[idx_i] - xs[idx_j]\n        dy = ys[idx_i] - ys[idx_j]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-16)\n        req_dist = rs[idx_i] + rs[idx_j]\n        overlap = req_dist - dist\n        \n        mask = overlap > 0\n        if np.any(mask):\n            common = 2 * mu_overlap * overlap[mask]\n            \n            # Radii\n            np.add.at(g_r, idx_i[mask], common)\n            np.add.at(g_r, idx_j[mask], common)\n            \n            # Centers\n            inv_dist = 1.0 / dist[mask]\n            term_x = common * (-dx[mask] * inv_dist)\n            term_y = common * (-dy[mask] * inv_dist)\n            \n            np.add.at(g_x, idx_i[mask], term_x)\n            np.add.at(g_x, idx_j[mask], -term_x)\n            np.add.at(g_y, idx_i[mask], term_y)\n            np.add.at(g_y, idx_j[mask], -term_y)\n            \n        # Boundary\n        lx = np.maximum(0, rs - xs)\n        c = 2 * mu_boundary * lx\n        g_r += c\n        g_x -= c\n        \n        hx = np.maximum(0, xs + rs - 1.0)\n        c = 2 * mu_boundary * hx\n        g_r += c\n        g_x += c\n        \n        ly = np.maximum(0, rs - ys)\n        c = 2 * mu_boundary * ly\n        g_r += c\n        g_y -= c\n        \n        hy = np.maximum(0, ys + rs - 1.0)\n        c = 2 * mu_boundary * hy\n        g_r += c\n        g_y += c\n        \n        return grad\n\n    # Multi-stage optimization\n    bounds_def = [(0, 1)] * (2*N) + [(0.01, 0.4)] * N\n    \n    current_params = params0\n    # Schedule: Increase penalty\n    schedule = [\n        (10, 10),\n        (100, 100),\n        (1000, 1000),\n        (10000, 10000),\n        (1e6, 1e6)\n    ]\n    \n    for (mu_o, mu_b) in schedule:\n        res = minimize(\n            objective,\n            current_params,\n            args=(mu_o, mu_b),\n            method='L-BFGS-B',\n            jac=gradient,\n            bounds=bounds_def,\n            options={'ftol': 1e-9, 'maxiter': 3000}\n        )\n        current_params = res.x\n        \n    # --- Final Polish & Formatting ---\n    xs = current_params[:N]\n    ys = current_params[N:2*N]\n    rs = current_params[2*N:]\n    \n    # Enforce constraints strictly by shrinking\n    # 1. Box\n    rs = np.minimum(rs, xs)\n    rs = np.minimum(rs, 1-xs)\n    rs = np.minimum(rs, ys)\n    rs = np.minimum(rs, 1-ys)\n    \n    # 2. Overlap\n    for _ in range(50):\n        clean = True\n        for i in range(N):\n            for j in range(i+1, N):\n                d2 = (xs[i]-xs[j])**2 + (ys[i]-ys[j])**2\n                r_sum = rs[i] + rs[j]\n                if r_sum**2 > d2:\n                    d = np.sqrt(d2)\n                    scale = d / r_sum\n                    # Shrink to fit\n                    scale *= 0.9999999\n                    rs[i] *= scale\n                    rs[j] *= scale\n                    clean = False\n        if clean:\n            break\n            \n    centers = np.vstack([xs, ys]).T\n    sum_radii = np.sum(rs)\n    \n    return centers, rs, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T10:26:56.944278",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 385,
        "candidates_token_count": 2285,
        "thoughts_token_count": 10619
      },
      "response_text_len": 6431
    }
  }
}