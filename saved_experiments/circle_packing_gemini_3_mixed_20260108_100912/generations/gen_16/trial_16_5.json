{
  "trial_id": "trial_16_5",
  "generation": 16,
  "parent_id": "trial_6_6",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Packs 26 circles into a unit square to maximize the sum of their radii.\n    The strategy uses a seed pool of 50 configurations (half constructive, half random),\n    optimizes each using a combination of L-BFGS-B (penalty-based) and SLSQP,\n    and returns the best result.\n    \"\"\"\n    n = 26\n    \n    def get_max_r(centers_flat):\n        \"\"\"Calculates the maximum possible common radius for a given set of centers.\"\"\"\n        centers = centers_flat.reshape(n, 2)\n        # Boundary constraint: r <= x_i and r <= 1 - x_i\n        r_bound = np.min(np.concatenate([centers.flatten(), 1.0 - centers.flatten()]))\n        # Overlap constraint: 2r <= distance between any two centers\n        dist_sq = np.sum((centers[:, np.newaxis, :] - centers[np.newaxis, :, :])**2, axis=-1)\n        np.fill_diagonal(dist_sq, np.inf)\n        r_overlap = np.sqrt(np.max([np.min(dist_sq), 0])) / 2.0\n        return max(0, min(r_bound, r_overlap))\n\n    def get_seed(i):\n        \"\"\"Generates constructive or random initial centers for the seed pool.\"\"\"\n        if i < 25: # Constructive seeds\n            if i < 15: # Perturbed 5x5 grid + 1 extra circle\n                grid = np.linspace(0.1, 0.9, 5)\n                centers = np.array([[x, y] for x in grid for y in grid])\n                centers = np.vstack([centers, [0.5, 0.5]])\n            else: # Perturbed 6x4 grid + 2 extra circles\n                x_grid = np.linspace(0.1, 0.9, 6)\n                y_grid = np.linspace(0.1, 0.9, 4)\n                centers = np.array([[x, y] for x in x_grid for y in y_grid])\n                centers = np.vstack([centers, [[0.3, 0.5], [0.7, 0.5]]])\n            centers += np.random.normal(0, 0.04, (n, 2))\n        else: # Random seeds\n            centers = np.random.rand(n, 2)\n        return np.clip(centers, 0, 1).flatten()\n\n    # Objective function for SLSQP: maximize r\n    def obj(vars):\n        return -vars[-1]\n\n    # Constraint function for SLSQP: boundary and overlap constraints\n    def cons_fn(vars):\n        coords = vars[:-1].reshape(n, 2)\n        r = vars[-1]\n        # Boundary constraints: coords - r >= 0 and 1 - r - coords >= 0\n        b = np.concatenate([coords.flatten() - r, 1.0 - r - coords.flatten()])\n        # Overlap constraints: dist^2 - (2r)^2 >= 0\n        dist_sq = np.sum((coords[:, np.newaxis, :] - coords[np.newaxis, :, :])**2, axis=-1)\n        o = dist_sq[np.triu_indices(n, k=1)] - 4.0 * r**2\n        return np.concatenate([b, o])\n\n    best_x = None\n    best_r = -1\n    \n    # Process 50 seeds\n    for i in range(50):\n        seed_centers = get_seed(i)\n        r_init = get_max_r(seed_centers)\n        \n        # Step 1: L-BFGS-B with penalty to quickly find a promising local region\n        def penalty_obj(vars):\n            coords = vars[:-1].reshape(n, 2)\n            r = vars[-1]\n            # Penalize boundary and overlap violations\n            b_penalty = np.sum(np.maximum(0, r - coords)**2) + \\\n                        np.sum(np.maximum(0, coords - (1.0 - r))**2)\n            dist_sq = np.sum((coords[:, np.newaxis, :] - coords[np.newaxis, :, :])**2, axis=-1)\n            o_penalty = np.sum(np.maximum(0, 4.0 * r**2 - dist_sq[np.triu_indices(n, k=1)])**2)\n            return -r + 100.0 * (b_penalty + o_penalty)\n\n        res_p = minimize(penalty_obj, np.hstack([seed_centers, r_init]), \n                         method='L-BFGS-B', \n                         bounds=[(0, 1)]*(2*n) + [(0, 0.5)])\n        \n        # Step 2: Brief SLSQP refinement for each seed\n        res = minimize(obj, res_p.x, method='SLSQP', \n                       constraints={'type': 'ineq', 'fun': cons_fn},\n                       options={'maxiter': 10})\n        \n        r_eff = get_max_r(res.x[:-1])\n        if r_eff > best_r:\n            best_r = r_eff\n            best_x = res.x[:-1]\n\n    # Step 3: Final thorough refinement of the best found configuration\n    res = minimize(obj, np.hstack([best_x, best_r]), method='SLSQP', \n                   constraints={'type': 'ineq', 'fun': cons_fn},\n                   options={'maxiter': 100})\n    \n    final_r = get_max_r(res.x[:-1])\n    final_centers = res.x[:-1].reshape(n, 2)\n    # Project centers to valid boundary range\n    final_centers = np.clip(final_centers, final_r, 1.0 - final_r)\n    \n    radii = np.full(n, final_r)\n    sum_radii = n * final_r\n    \n    return final_centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.495049219149256,
    "eval_time": 26.228100061416626,
    "error": null
  },
  "prompt": "Combine {CODE_TRIAL_6_6} (Constructive) and {CODE_TRIAL_11_11} (Random). \n\nStrategy: **Seed Pool**.\n- Create a list of 50 seeds.\n- Half from the constructive pattern (with slight noise).\n- Half completely random.\n- Optimize all 50 in parallel (or loop).\n- Return the best.\n\nCRITICAL: Output ONLY a single Python code block starting with ```python and ending with ```. Do not write any text before or after the block.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Packs 26 circles into a unit square to maximize the sum of their radii.\n    The strategy uses a seed pool of 50 configurations (half constructive, half random),\n    optimizes each using a combination of L-BFGS-B (penalty-based) and SLSQP,\n    and returns the best result.\n    \"\"\"\n    n = 26\n    \n    def get_max_r(centers_flat):\n        \"\"\"Calculates the maximum possible common radius for a given set of centers.\"\"\"\n        centers = centers_flat.reshape(n, 2)\n        # Boundary constraint: r <= x_i and r <= 1 - x_i\n        r_bound = np.min(np.concatenate([centers.flatten(), 1.0 - centers.flatten()]))\n        # Overlap constraint: 2r <= distance between any two centers\n        dist_sq = np.sum((centers[:, np.newaxis, :] - centers[np.newaxis, :, :])**2, axis=-1)\n        np.fill_diagonal(dist_sq, np.inf)\n        r_overlap = np.sqrt(np.max([np.min(dist_sq), 0])) / 2.0\n        return max(0, min(r_bound, r_overlap))\n\n    def get_seed(i):\n        \"\"\"Generates constructive or random initial centers for the seed pool.\"\"\"\n        if i < 25: # Constructive seeds\n            if i < 15: # Perturbed 5x5 grid + 1 extra circle\n                grid = np.linspace(0.1, 0.9, 5)\n                centers = np.array([[x, y] for x in grid for y in grid])\n                centers = np.vstack([centers, [0.5, 0.5]])\n            else: # Perturbed 6x4 grid + 2 extra circles\n                x_grid = np.linspace(0.1, 0.9, 6)\n                y_grid = np.linspace(0.1, 0.9, 4)\n                centers = np.array([[x, y] for x in x_grid for y in y_grid])\n                centers = np.vstack([centers, [[0.3, 0.5], [0.7, 0.5]]])\n            centers += np.random.normal(0, 0.04, (n, 2))\n        else: # Random seeds\n            centers = np.random.rand(n, 2)\n        return np.clip(centers, 0, 1).flatten()\n\n    # Objective function for SLSQP: maximize r\n    def obj(vars):\n        return -vars[-1]\n\n    # Constraint function for SLSQP: boundary and overlap constraints\n    def cons_fn(vars):\n        coords = vars[:-1].reshape(n, 2)\n        r = vars[-1]\n        # Boundary constraints: coords - r >= 0 and 1 - r - coords >= 0\n        b = np.concatenate([coords.flatten() - r, 1.0 - r - coords.flatten()])\n        # Overlap constraints: dist^2 - (2r)^2 >= 0\n        dist_sq = np.sum((coords[:, np.newaxis, :] - coords[np.newaxis, :, :])**2, axis=-1)\n        o = dist_sq[np.triu_indices(n, k=1)] - 4.0 * r**2\n        return np.concatenate([b, o])\n\n    best_x = None\n    best_r = -1\n    \n    # Process 50 seeds\n    for i in range(50):\n        seed_centers = get_seed(i)\n        r_init = get_max_r(seed_centers)\n        \n        # Step 1: L-BFGS-B with penalty to quickly find a promising local region\n        def penalty_obj(vars):\n            coords = vars[:-1].reshape(n, 2)\n            r = vars[-1]\n            # Penalize boundary and overlap violations\n            b_penalty = np.sum(np.maximum(0, r - coords)**2) + \\\n                        np.sum(np.maximum(0, coords - (1.0 - r))**2)\n            dist_sq = np.sum((coords[:, np.newaxis, :] - coords[np.newaxis, :, :])**2, axis=-1)\n            o_penalty = np.sum(np.maximum(0, 4.0 * r**2 - dist_sq[np.triu_indices(n, k=1)])**2)\n            return -r + 100.0 * (b_penalty + o_penalty)\n\n        res_p = minimize(penalty_obj, np.hstack([seed_centers, r_init]), \n                         method='L-BFGS-B', \n                         bounds=[(0, 1)]*(2*n) + [(0, 0.5)])\n        \n        # Step 2: Brief SLSQP refinement for each seed\n        res = minimize(obj, res_p.x, method='SLSQP', \n                       constraints={'type': 'ineq', 'fun': cons_fn},\n                       options={'maxiter': 10})\n        \n        r_eff = get_max_r(res.x[:-1])\n        if r_eff > best_r:\n            best_r = r_eff\n            best_x = res.x[:-1]\n\n    # Step 3: Final thorough refinement of the best found configuration\n    res = minimize(obj, np.hstack([best_x, best_r]), method='SLSQP', \n                   constraints={'type': 'ineq', 'fun': cons_fn},\n                   options={'maxiter': 100})\n    \n    final_r = get_max_r(res.x[:-1])\n    final_centers = res.x[:-1].reshape(n, 2)\n    # Project centers to valid boundary range\n    final_centers = np.clip(final_centers, final_r, 1.0 - final_r)\n    \n    radii = np.full(n, final_r)\n    sum_radii = n * final_r\n    \n    return final_centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T11:27:18.230147",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 340,
        "candidates_token_count": 1492,
        "thoughts_token_count": 13711
      },
      "response_text_len": 4492
    }
  }
}