{
  "trial_id": "trial_15_5",
  "generation": 15,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import dual_annealing, linprog\nfrom scipy.spatial.distance import pdist\n\ndef construct_packing():\n    N = 26\n    \n    # Precompute indices for vectorization of pairs\n    triu_indices = np.triu_indices(N, k=1)\n    idx_i = triu_indices[0]\n    idx_j = triu_indices[1]\n\n    def objective(params):\n        # params shape: (3*N,) -> (N, 3)\n        # columns: x, y, r\n        data = params.reshape((N, 3))\n        coords = data[:, :2]\n        radii = data[:, 2]\n        \n        # 1. Boundary violations\n        # x < r => violation = r - x\n        # x > 1-r => violation = x - (1-r) = x + r - 1\n        # y < r => violation = r - y\n        # y > 1-r => violation = y + r - 1\n        \n        # Calculate violations (if < 0, then 0)\n        v_xl = radii - coords[:, 0]\n        v_xr = coords[:, 0] + radii - 1.0\n        v_yl = radii - coords[:, 1]\n        v_yr = coords[:, 1] + radii - 1.0\n        \n        # Sum of squared positive violations\n        boundary_penalty = np.sum(np.maximum(0, v_xl)**2 + \n                                  np.maximum(0, v_xr)**2 + \n                                  np.maximum(0, v_yl)**2 + \n                                  np.maximum(0, v_yr)**2)\n        \n        # 2. Overlap violations\n        # dist < r_i + r_j\n        dists = pdist(coords)\n        r_sums = radii[idx_i] + radii[idx_j]\n        \n        overlap_violations = np.maximum(0, r_sums - dists)\n        overlap_penalty = np.sum(overlap_violations**2)\n        \n        # Objective: Maximize sum(r) -> Minimize -sum(r)\n        # Penalty weight\n        w = 1e5\n        \n        return -np.sum(radii) + w * (boundary_penalty + overlap_penalty)\n\n    # Bounds: x, y in [0, 1], r in [0, 0.5]\n    bounds = [(0, 1), (0, 1), (0, 0.5)] * N\n    \n    # Initial guess: Grid\n    x0 = np.zeros(3 * N)\n    grid_w, grid_h = 5, 6\n    cnt = 0\n    for i in range(grid_w):\n        for j in range(grid_h):\n            if cnt >= N: break\n            # Place in grid\n            x0[3*cnt] = (i + 0.5) / grid_w\n            x0[3*cnt+1] = (j + 0.5) / grid_h\n            x0[3*cnt+2] = 0.05 # Initial radius\n            cnt += 1\n            \n    # Run Dual Annealing\n    res = dual_annealing(\n        objective, \n        bounds=bounds, \n        x0=x0, \n        maxiter=500, \n        seed=42\n    )\n    \n    # Extract centers\n    best_data = res.x.reshape((N, 3))\n    centers = best_data[:, :2]\n    \n    # Post-process with LP to get maximal valid radii for these centers\n    # Maximize sum(r) s.t. constraints\n    \n    # 1. Wall constraints: r_i <= d_wall_i\n    d_walls = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    d_walls = np.maximum(0, d_walls) # Clip to 0 just in case\n    lp_bounds = [(0, d) for d in d_walls]\n    \n    # 2. Pair constraints: r_i + r_j <= dist_ij\n    dists = pdist(centers)\n    num_pairs = len(dists)\n    \n    # Construct constraint matrix\n    A_ub = np.zeros((num_pairs, N))\n    A_ub[np.arange(num_pairs), idx_i] = 1.0\n    A_ub[np.arange(num_pairs), idx_j] = 1.0\n    b_ub = dists\n    \n    # Objective: Minimize -sum(r)\n    c_lp = -np.ones(N)\n    \n    lp_res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds, method='highs')\n    \n    if lp_res.success:\n        final_radii = lp_res.x\n        sum_radii = -lp_res.fun\n    else:\n        # Fallback if LP fails (unlikely), use DA results clamped\n        final_radii = np.abs(best_data[:, 2])\n        sum_radii = np.sum(final_radii)\n        \n    return centers, final_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.3497915954585364,
    "eval_time": 3.5947797298431396,
    "error": null
  },
  "prompt": "Solve circle packing (26 circles). \n\nStrategy: **Dual Annealing**.\n- Use `scipy.optimize.dual_annealing`.\n- This combines Simulated Annealing with local search.\n- Max iter: 500.\n\nIMPORTANT: Your response must contain exactly one Python code block starting with ```python and ending with ```. The code must define `construct_packing`. DO NOT WRITE ANY TEXT OUTSIDE THE CODE BLOCK.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import dual_annealing, linprog\nfrom scipy.spatial.distance import pdist\n\ndef construct_packing():\n    N = 26\n    \n    # Precompute indices for vectorization of pairs\n    triu_indices = np.triu_indices(N, k=1)\n    idx_i = triu_indices[0]\n    idx_j = triu_indices[1]\n\n    def objective(params):\n        # params shape: (3*N,) -> (N, 3)\n        # columns: x, y, r\n        data = params.reshape((N, 3))\n        coords = data[:, :2]\n        radii = data[:, 2]\n        \n        # 1. Boundary violations\n        # x < r => violation = r - x\n        # x > 1-r => violation = x - (1-r) = x + r - 1\n        # y < r => violation = r - y\n        # y > 1-r => violation = y + r - 1\n        \n        # Calculate violations (if < 0, then 0)\n        v_xl = radii - coords[:, 0]\n        v_xr = coords[:, 0] + radii - 1.0\n        v_yl = radii - coords[:, 1]\n        v_yr = coords[:, 1] + radii - 1.0\n        \n        # Sum of squared positive violations\n        boundary_penalty = np.sum(np.maximum(0, v_xl)**2 + \n                                  np.maximum(0, v_xr)**2 + \n                                  np.maximum(0, v_yl)**2 + \n                                  np.maximum(0, v_yr)**2)\n        \n        # 2. Overlap violations\n        # dist < r_i + r_j\n        dists = pdist(coords)\n        r_sums = radii[idx_i] + radii[idx_j]\n        \n        overlap_violations = np.maximum(0, r_sums - dists)\n        overlap_penalty = np.sum(overlap_violations**2)\n        \n        # Objective: Maximize sum(r) -> Minimize -sum(r)\n        # Penalty weight\n        w = 1e5\n        \n        return -np.sum(radii) + w * (boundary_penalty + overlap_penalty)\n\n    # Bounds: x, y in [0, 1], r in [0, 0.5]\n    bounds = [(0, 1), (0, 1), (0, 0.5)] * N\n    \n    # Initial guess: Grid\n    x0 = np.zeros(3 * N)\n    grid_w, grid_h = 5, 6\n    cnt = 0\n    for i in range(grid_w):\n        for j in range(grid_h):\n            if cnt >= N: break\n            # Place in grid\n            x0[3*cnt] = (i + 0.5) / grid_w\n            x0[3*cnt+1] = (j + 0.5) / grid_h\n            x0[3*cnt+2] = 0.05 # Initial radius\n            cnt += 1\n            \n    # Run Dual Annealing\n    res = dual_annealing(\n        objective, \n        bounds=bounds, \n        x0=x0, \n        maxiter=500, \n        seed=42\n    )\n    \n    # Extract centers\n    best_data = res.x.reshape((N, 3))\n    centers = best_data[:, :2]\n    \n    # Post-process with LP to get maximal valid radii for these centers\n    # Maximize sum(r) s.t. constraints\n    \n    # 1. Wall constraints: r_i <= d_wall_i\n    d_walls = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    d_walls = np.maximum(0, d_walls) # Clip to 0 just in case\n    lp_bounds = [(0, d) for d in d_walls]\n    \n    # 2. Pair constraints: r_i + r_j <= dist_ij\n    dists = pdist(centers)\n    num_pairs = len(dists)\n    \n    # Construct constraint matrix\n    A_ub = np.zeros((num_pairs, N))\n    A_ub[np.arange(num_pairs), idx_i] = 1.0\n    A_ub[np.arange(num_pairs), idx_j] = 1.0\n    b_ub = dists\n    \n    # Objective: Minimize -sum(r)\n    c_lp = -np.ones(N)\n    \n    lp_res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds, method='highs')\n    \n    if lp_res.success:\n        final_radii = lp_res.x\n        sum_radii = -lp_res.fun\n    else:\n        # Fallback if LP fails (unlikely), use DA results clamped\n        final_radii = np.abs(best_data[:, 2])\n        sum_radii = np.sum(final_radii)\n        \n    return centers, final_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T11:21:18.681972",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 315,
        "candidates_token_count": 1279,
        "thoughts_token_count": 11329
      },
      "response_text_len": 3532
    }
  }
}