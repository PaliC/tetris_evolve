{
  "trial_id": "trial_15_4",
  "generation": 15,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import differential_evolution, linprog\n\ndef construct_packing():\n    N = 26\n    \n    # Precompute indices for upper triangle to speed up distance calculations in objective\n    iu = np.triu_indices(N, 1)\n\n    def objective(w):\n        # w is a flat array of size 3*N\n        # Reshape to (N, 3) where columns are x, y, r\n        P = w.reshape((N, 3))\n        x = P[:, 0]\n        y = P[:, 1]\n        r = P[:, 2]\n        \n        # 1. Wall constraints violations\n        # Circle must be inside [0,1]^2: r <= x, r <= 1-x, r <= y, r <= 1-y\n        # Violations are positive if constraint is broken\n        v_wall = np.sum(np.maximum(0, r - x)**2 + \n                        np.maximum(0, x + r - 1)**2 + \n                        np.maximum(0, r - y)**2 + \n                        np.maximum(0, y + r - 1)**2)\n        \n        # 2. Overlap constraints violations\n        # Distance between centers >= sum of radii\n        dx = x[:, np.newaxis] - x\n        dy = y[:, np.newaxis] - y\n        d = np.sqrt(dx**2 + dy**2)\n        \n        r_sum = r[:, np.newaxis] + r\n        \n        # Only consider upper triangle pairs to avoid self-check and double counting\n        d_vals = d[iu]\n        r_sum_vals = r_sum[iu]\n        \n        # Violation if r_sum > d\n        v_overlap = np.sum(np.maximum(0, r_sum_vals - d_vals)**2)\n        \n        # Objective: Maximize sum(r) => Minimize -sum(r)\n        # Add heavy penalty for violations\n        penalty_weight = 1e6\n        return -np.sum(r) + penalty_weight * (v_wall + v_overlap)\n\n    # Define bounds for variables\n    # x, y in [0, 1], r in [0, 0.4] (heuristic upper bound for packing 26 circles)\n    bounds = [(0, 1), (0, 1), (0, 0.4)] * N\n\n    # Run Differential Evolution\n    # popsize is multiplier for total variables (3*N). \n    # popsize=3 -> ~234 individuals. \n    result = differential_evolution(objective, bounds, \n                                    strategy='best1bin', \n                                    maxiter=2000, \n                                    popsize=3, \n                                    tol=1e-3, \n                                    mutation=(0.5, 1), \n                                    recombination=0.7, \n                                    polish=True, \n                                    workers=-1)\n    \n    # Extract optimized centers\n    w_opt = result.x.reshape((N, 3))\n    xc = w_opt[:, 0]\n    yc = w_opt[:, 1]\n    \n    # Post-processing: Optimize radii for the found centers using Linear Programming\n    # This ensures strict feasibility and maximizes radii for the specific arrangement.\n    \n    # LP Objective: Maximize sum(r) -> Minimize -sum(r)\n    c_lp = -np.ones(N)\n    \n    # Bounds for radii based on wall proximity\n    # r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n    max_r_walls = np.minimum(np.minimum(xc, 1-xc), np.minimum(yc, 1-yc))\n    # Ensure non-negative bounds (in case DE polish pushed slightly out)\n    max_r_walls = np.maximum(0, max_r_walls)\n    bounds_lp = [(0, m) for m in max_r_walls]\n    \n    # Constraints for overlaps: r_i + r_j <= d_ij\n    A_ub = []\n    b_ub = []\n    \n    for i in range(N):\n        for j in range(i + 1, N):\n            dist = np.sqrt((xc[i]-xc[j])**2 + (yc[i]-yc[j])**2)\n            row = np.zeros(N)\n            row[i] = 1\n            row[j] = 1\n            A_ub.append(row)\n            b_ub.append(dist)\n            \n    # Solve LP\n    # 'highs' method is preferred for performance and stability in newer scipy\n    try:\n        res_lp = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=bounds_lp, method='highs')\n    except:\n        # Fallback for older scipy versions\n        res_lp = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=bounds_lp)\n        \n    if res_lp.success:\n        final_radii = res_lp.x\n    else:\n        # Fallback to DE radii clipped to walls (unlikely to happen)\n        final_radii = np.minimum(w_opt[:, 2], max_r_walls)\n        \n    centers = np.column_stack((xc, yc))\n    sum_radii = np.sum(final_radii)\n    \n    return centers, final_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 0.36652207374572754,
    "error": "PicklingError: Can't pickle local object <function construct_packing.<locals>.objective at 0x103404300>"
  },
  "prompt": "Solve circle packing (26 circles). \n\nStrategy: **Differential Evolution (DE)**.\n- Use `scipy.optimize.differential_evolution`.\n- Objective: Maximize sum of radii.\n- Bounds: [0,1] for all variables.\n- Use `polish=True`.\n- This is a strong global optimizer.\n\nIMPORTANT: Your response must contain exactly one Python code block starting with ```python and ending with ```. The code must define `construct_packing`. DO NOT WRITE ANY TEXT OUTSIDE THE CODE BLOCK.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import differential_evolution, linprog\n\ndef construct_packing():\n    N = 26\n    \n    # Precompute indices for upper triangle to speed up distance calculations in objective\n    iu = np.triu_indices(N, 1)\n\n    def objective(w):\n        # w is a flat array of size 3*N\n        # Reshape to (N, 3) where columns are x, y, r\n        P = w.reshape((N, 3))\n        x = P[:, 0]\n        y = P[:, 1]\n        r = P[:, 2]\n        \n        # 1. Wall constraints violations\n        # Circle must be inside [0,1]^2: r <= x, r <= 1-x, r <= y, r <= 1-y\n        # Violations are positive if constraint is broken\n        v_wall = np.sum(np.maximum(0, r - x)**2 + \n                        np.maximum(0, x + r - 1)**2 + \n                        np.maximum(0, r - y)**2 + \n                        np.maximum(0, y + r - 1)**2)\n        \n        # 2. Overlap constraints violations\n        # Distance between centers >= sum of radii\n        dx = x[:, np.newaxis] - x\n        dy = y[:, np.newaxis] - y\n        d = np.sqrt(dx**2 + dy**2)\n        \n        r_sum = r[:, np.newaxis] + r\n        \n        # Only consider upper triangle pairs to avoid self-check and double counting\n        d_vals = d[iu]\n        r_sum_vals = r_sum[iu]\n        \n        # Violation if r_sum > d\n        v_overlap = np.sum(np.maximum(0, r_sum_vals - d_vals)**2)\n        \n        # Objective: Maximize sum(r) => Minimize -sum(r)\n        # Add heavy penalty for violations\n        penalty_weight = 1e6\n        return -np.sum(r) + penalty_weight * (v_wall + v_overlap)\n\n    # Define bounds for variables\n    # x, y in [0, 1], r in [0, 0.4] (heuristic upper bound for packing 26 circles)\n    bounds = [(0, 1), (0, 1), (0, 0.4)] * N\n\n    # Run Differential Evolution\n    # popsize is multiplier for total variables (3*N). \n    # popsize=3 -> ~234 individuals. \n    result = differential_evolution(objective, bounds, \n                                    strategy='best1bin', \n                                    maxiter=2000, \n                                    popsize=3, \n                                    tol=1e-3, \n                                    mutation=(0.5, 1), \n                                    recombination=0.7, \n                                    polish=True, \n                                    workers=-1)\n    \n    # Extract optimized centers\n    w_opt = result.x.reshape((N, 3))\n    xc = w_opt[:, 0]\n    yc = w_opt[:, 1]\n    \n    # Post-processing: Optimize radii for the found centers using Linear Programming\n    # This ensures strict feasibility and maximizes radii for the specific arrangement.\n    \n    # LP Objective: Maximize sum(r) -> Minimize -sum(r)\n    c_lp = -np.ones(N)\n    \n    # Bounds for radii based on wall proximity\n    # r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n    max_r_walls = np.minimum(np.minimum(xc, 1-xc), np.minimum(yc, 1-yc))\n    # Ensure non-negative bounds (in case DE polish pushed slightly out)\n    max_r_walls = np.maximum(0, max_r_walls)\n    bounds_lp = [(0, m) for m in max_r_walls]\n    \n    # Constraints for overlaps: r_i + r_j <= d_ij\n    A_ub = []\n    b_ub = []\n    \n    for i in range(N):\n        for j in range(i + 1, N):\n            dist = np.sqrt((xc[i]-xc[j])**2 + (yc[i]-yc[j])**2)\n            row = np.zeros(N)\n            row[i] = 1\n            row[j] = 1\n            A_ub.append(row)\n            b_ub.append(dist)\n            \n    # Solve LP\n    # 'highs' method is preferred for performance and stability in newer scipy\n    try:\n        res_lp = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=bounds_lp, method='highs')\n    except:\n        # Fallback for older scipy versions\n        res_lp = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=bounds_lp)\n        \n    if res_lp.success:\n        final_radii = res_lp.x\n    else:\n        # Fallback to DE radii clipped to walls (unlikely to happen)\n        final_radii = np.minimum(w_opt[:, 2], max_r_walls)\n        \n    centers = np.column_stack((xc, yc))\n    sum_radii = np.sum(final_radii)\n    \n    return centers, final_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T11:21:10.844835",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 335,
        "candidates_token_count": 1342,
        "thoughts_token_count": 10740
      },
      "response_text_len": 4112
    }
  }
}