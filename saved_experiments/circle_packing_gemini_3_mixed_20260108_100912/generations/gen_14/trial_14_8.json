{
  "trial_id": "trial_14_8",
  "generation": 14,
  "parent_id": "trial_12_3",
  "code": "",
  "metrics": {},
  "prompt": "Combine import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    N = 26\n    n_seeds = 20\n    \n    # Precompute pairs for overlap constraints\n    pairs = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            pairs.append((i, j))\n            \n    # Helper to generate initial guess using Maximin strategy\n    def generate_seed(rng):\n        centers = []\n        # Start with one random point\n        centers.append(rng.random(2))\n        \n        # Add others maximizing distance to nearest existing center\n        for _ in range(N - 1):\n            candidates = rng.random((500, 2))\n            c_arr = np.array(centers)\n            # Vectorized distance computation\n            # (n_cand, 1, 2) - (1, n_exist, 2) -> (n_cand, n_exist, 2)\n            diff = candidates[:, np.newaxis, :] - c_arr[np.newaxis, :, :]\n            d2 = np.sum(diff**2, axis=2) # (n_cand, n_exist)\n            min_d2 = np.min(d2, axis=1) # (n_cand,)\n            best_idx = np.argmax(min_d2)\n            centers.append(candidates[best_idx])\n            \n        centers = np.array(centers)\n        # Conservative initial radii\n        radii = np.full(N, 0.01)\n        \n        x0 = np.zeros(3 * N)\n        x0[0::3] = centers[:, 0]\n        x0[1::3] = centers[:, 1]\n        x0[2::3] = radii\n        return x0\n\n    # Optimization definitions\n    def objective(x):\n        return -np.sum(x[2::3])\n\n    def obj_jac(x):\n        grad = np.zeros_like(x)\n        grad[2::3] = -1.0\n        return grad\n        \n    def overlap_fun(x):\n        X = x[0::3]\n        Y = x[1::3]\n        R = x[2::3]\n        res = []\n        for i, j in pairs:\n            d2 = (X[i] - X[j])**2 + (Y[i] - Y[j])**2\n            r_sum = R[i] + R[j]\n            res.append(d2 - r_sum**2)\n        return np.array(res)\n\n    def overlap_jac(x):\n        X = x[0::3]\n        Y = x[1::3]\n        R = x[2::3]\n        jac = np.zeros((len(pairs), 3 * N))\n        for idx, (i, j) in enumerate(pairs):\n            dx = X[i] - X[j]\n            dy = Y[i] - Y[j]\n            sr = R[i] + R[j]\n            \n            jac[idx, 3*i]     = 2 * dx\n            jac[idx, 3*i + 1] = 2 * dy\n            jac[idx, 3*i + 2] = -2 * sr\n            \n            jac[idx, 3*j]     = -2 * dx\n            jac[idx, 3*j + 1] = -2 * dy\n            jac[idx, 3*j + 2] = -2 * sr\n        return jac\n\n    # Box constraints matrix\n    n_box = 4 * N\n    A = np.zeros((n_box, 3 * N))\n    b = np.zeros(n_box)\n    for i in range(N):\n        # xi - ri >= 0\n        A[4*i, 3*i] = 1; A[4*i, 3*i+2] = -1; b[4*i] = 0\n        # -xi - ri >= -1\n        A[4*i+1, 3*i] = -1; A[4*i+1, 3*i+2] = -1; b[4*i+1] = -1\n        # yi - ri >= 0\n        A[4*i+2, 3*i+1] = 1; A[4*i+2, 3*i+2] = -1; b[4*i+2] = 0\n        # -yi - ri >= -1\n        A[4*i+3, 3*i+1] = -1; A[4*i+3, 3*i+2] = -1; b[4*i+3] = -1\n\n    linear_con = {'type': 'ineq', 'fun': lambda x: A @ x - b, 'jac': lambda x: A}\n    nonlinear_con = {'type': 'ineq', 'fun': overlap_fun, 'jac': overlap_jac}\n    constraints = [linear_con, nonlinear_con]\n    \n    bounds = [(0, 1)] * (3 * N)\n    for i in range(N):\n        bounds[3*i+2] = (0, 0.5)\n\n    rng = np.random.RandomState(42)\n    \n    best_x = None\n    best_val = -np.inf\n    \n    for _ in range(n_seeds):\n        x0 = generate_seed(rng)\n        # Use SLSQP to polish\n        res = minimize(objective, x0, method='SLSQP', jac=obj_jac, \n                       bounds=bounds, constraints=constraints, \n                       options={'maxiter': 800, 'ftol': 1e-5})\n        \n        # Check if successful or at least feasible\n        # Even if not 'success', the result might be good.\n        # We assume SLSQP satisfies constraints mostly.\n        current_val = -res.fun\n        if current_val > best_val:\n            best_val = current_val\n            best_x = res.x\n\n    # Extract result\n    centers = np.zeros((N, 2))\n    centers[:, 0] = best_x[0::3]\n    centers[:, 1] = best_x[1::3]\n    radii = best_x[2::3]\n    \n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    return construct_packing() (Constructive Ensemble) and import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    \n    def objective(p):\n        # p contains [x1...x26, y1...y26, r1...r26]\n        # Minimize -sum(radii) to maximize sum(radii)\n        return -np.sum(p[2*n:])\n\n    def constraint_fn(p):\n        x = p[:n]\n        y = p[n:2*n]\n        r = p[2*n:]\n        \n        # Boundary constraints: r_i <= x_i <= 1-r_i and r_i <= y_i <= 1-r_i\n        c = [x - r, 1.0 - x - r, y - r, 1.0 - y - r]\n        \n        # Non-overlap constraints: dist(i, j) >= r_i + r_j\n        for i in range(n - 1):\n            dx = x[i] - x[i+1:]\n            dy = y[i] - y[i+1:]\n            dr = r[i] + r[i+1:]\n            c.append(dx*dx + dy*dy - dr*dr)\n            \n        return np.concatenate(c)\n\n    best_p = None\n    min_obj = float('inf')\n    \n    # Define bounds for x, y in [0, 1] and r in [0, 0.5]\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n\n    # Random search phase: 100 trials with 10 iterations each\n    for _ in range(100):\n        x0 = np.random.rand(n)\n        y0 = np.random.rand(n)\n        r0 = np.full(n, 0.04) # Small initial radii to avoid heavy overlap\n        p0 = np.concatenate([x0, y0, r0])\n        \n        res = minimize(objective, p0, method='SLSQP', \n                       bounds=bounds,\n                       constraints={'type': 'ineq', 'fun': constraint_fn},\n                       options={'maxiter': 10})\n        \n        if res.fun < min_obj:\n            min_obj = res.fun\n            best_p = res.x\n\n    # Local polish phase: run until convergence or maxiter\n    res = minimize(objective, best_p, method='SLSQP', \n                   bounds=bounds,\n                   constraints={'type': 'ineq', 'fun': constraint_fn},\n                   options={'maxiter': 200})\n    \n    p = res.x\n    centers = np.stack([p[:n], p[n:2*n]], axis=1)\n    radii = p[2*n:]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing() (Random Search). \n\nStrategy: **Hybrid Pool**.\n- Generate 100 Constructive seeds.\n- Generate 100 Random seeds.\n- Polish all 200.\n- Return the best.\n\nCRITICAL: Return the solution in valid JSON format with a single key 'code' containing the Python string.\nExample:\n```json\n{\"code\": \"import numpy as np\\ndef construct_packing():\\n    ...\"}\n```\nDo not output markdown text outside the JSON block.",
  "response": "\n```json\n{\"code\": \"import numpy as np\\nfrom scipy.optimize import minimize\\n\\ndef construct_packing():\\n    N = 26\\n    \\n    # Objective function: maximize the sum of radii (minimize -sum)\\n    def objective(params):\\n        return -np.sum(params[2::3])\\n\\n    def objective_jac(params):\\n        grad = np.zeros_like(params)\\n        grad[2::3] = -1.0\\n        return grad\\n\\n    # Precompute indices for efficiency\\n    iu = np.triu_indices(N, k=1)\\n\\n    def constraints_fn(params):\\n        x = params[0::3]\\n        y = params[1::3]\\n        r = params[2::3]\\n        \\n        # Boundary constraints: r <= x <= 1-r and r <= y <= 1-r\\n        c_boundary = np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r])\\n        \\n        # Non-overlap constraints: (xi-xj)^2 + (yi-yj)^2 >= (ri+rj)^2\\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\\n        sr = r[:, np.newaxis] + r[np.newaxis, :]\\n        \\n        dist_sq = dx**2 + dy**2\\n        sr_sq = sr**2\\n        \\n        c_overlap = dist_sq[iu] - sr_sq[iu]\\n        \\n        return np.concatenate([c_boundary, c_overlap])\\n\\n    def constraints_jac(params):\\n        x = params[0::3]\\n        y = params[1::3]\\n        r = params[2::3]\\n        # 4*N boundary + N*(N-1)/2 overlap\\n        jac = np.zeros((4 * N + N * (N - 1) // 2, 3 * N))\\n        \\n        for i in range(N):\\n            # x - r >= 0\\n            jac[i, 3*i] = 1; jac[i, 3*i+2] = -1\\n            # 1 - x - r >= 0\\n            jac[N+i, 3*i] = -1; jac[N+i, 3*i+2] = -1\\n            # y - r >= 0\\n            jac[2*N+i, 3*i+1] = 1; jac[2*N+i, 3*i+2] = -1\\n            #",
  "reasoning": "```json\n{\"code\": \"import numpy as np\\nfrom scipy.optimize import minimize\\n\\ndef construct_packing():\\n    N = 26\\n    \\n    # Objective function: maximize the sum of radii (minimize -sum)\\n    def objective(params):\\n        return -np.sum(params[2::3])\\n\\n    def objective_jac(params):\\n        grad = np.zeros_like(params)\\n        grad[2::3] = -1.0\\n        return grad\\n\\n    # Precompute indices for efficiency\\n    iu = np.triu_indices(N, k=1)\\n\\n    def constraints_fn(params):\\n        x = params[0::3]\\n        y = params[1::3]\\n        r = params[2::3]\\n        \\n        # Boundary constraints: r <= x <= 1-r and r <= y <= 1-r\\n        c_boundary = np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r])\\n        \\n        # Non-overlap constraints: (xi-xj)^2 + (yi-yj)^2 >= (ri+rj)^2\\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\\n        sr = r[:, np.newaxis] + r[np.newaxis, :]\\n        \\n        dist_sq = dx**2 + dy**2\\n        sr_sq = sr**2\\n        \\n        c_overlap = dist_sq[iu] - sr_sq[iu]\\n        \\n        return np.concatenate([c_boundary, c_overlap])\\n\\n    def constraints_jac(params):\\n        x = params[0::3]\\n        y = params[1::3]\\n        r = params[2::3]\\n        # 4*N boundary + N*(N-1)/2 overlap\\n        jac = np.zeros((4 * N + N * (N - 1) // 2, 3 * N))\\n        \\n        for i in range(N):\\n            # x - r >= 0\\n            jac[i, 3*i] = 1; jac[i, 3*i+2] = -1\\n            # 1 - x - r >= 0\\n            jac[N+i, 3*i] = -1; jac[N+i, 3*i+2] = -1\\n            # y - r >= 0\\n            jac[2*N+i, 3*i+1] = 1; jac[2*N+i, 3*i+2] = -1\\n            #",
  "timestamp": "2026-01-08T11:17:57.255554",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "MAX_TOKENS",
      "usage_metadata": {
        "prompt_token_count": 2591,
        "candidates_token_count": 656,
        "thoughts_token_count": 15724
      },
      "response_text_len": 1651
    }
  }
}