{
  "trial_id": "trial_14_2",
  "generation": 14,
  "parent_id": "trial_13_9",
  "code": "",
  "metrics": {},
  "prompt": "Refine import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    # Number of circles\n    N = 26\n    \n    # --- Constraint & Jacobian Definitions ---\n    # State vector x: [cx_0...cx_N-1, cy_0...cy_N-1, r_0...r_N-1]\n    # Indices: cx: 0..N-1, cy: N..2N-1, r: 2N..3N-1\n    \n    # Precompute pairs for overlap constraints\n    pairs = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            pairs.append((i, j))\n    num_pairs = len(pairs)\n            \n    def get_constraints():\n        # Box constraints: 4N constraints\n        # cx - r >= 0, 1 - cx - r >= 0, cy - r >= 0, 1 - cy - r >= 0\n        def box_cons(x):\n            cx = x[:N]\n            cy = x[N:2*N]\n            r = x[2*N:]\n            return np.concatenate([\n                cx - r,\n                1.0 - cx - r,\n                cy - r,\n                1.0 - cy - r\n            ])\n            \n        def box_jac(x):\n            jac = np.zeros((4*N, 3*N))\n            # Fill diagonals\n            # cx - r >= 0\n            rows = np.arange(N)\n            jac[rows, rows] = 1.0\n            jac[rows, 2*N + rows] = -1.0\n            \n            # 1 - cx - r >= 0\n            rows = np.arange(N, 2*N)\n            jac[rows, rows - N] = -1.0\n            jac[rows, 2*N + (rows - N)] = -1.0\n            \n            # cy - r >= 0\n            rows = np.arange(2*N, 3*N)\n            jac[rows, N + (rows - 2*N)] = 1.0\n            jac[rows, 2*N + (rows - 2*N)] = -1.0\n            \n            # 1 - cy - r >= 0\n            rows = np.arange(3*N, 4*N)\n            jac[rows, N + (rows - 3*N)] = -1.0\n            jac[rows, 2*N + (rows - 3*N)] = -1.0\n            return jac\n\n        # Overlap constraints: N(N-1)/2 constraints\n        # dist_sq - (ri + rj)^2 >= 0\n        def overlap_cons(x):\n            cx = x[:N]\n            cy = x[N:2*N]\n            r = x[2*N:]\n            res = np.zeros(num_pairs)\n            for k, (i, j) in enumerate(pairs):\n                d2 = (cx[i] - cx[j])**2 + (cy[i] - cy[j])**2\n                sr = r[i] + r[j]\n                res[k] = d2 - sr**2\n            return res\n            \n        def overlap_jac(x):\n            cx = x[:N]\n            cy = x[N:2*N]\n            r = x[2*N:]\n            jac = np.zeros((num_pairs, 3*N))\n            for k, (i, j) in enumerate(pairs):\n                dx = cx[i] - cx[j]\n                dy = cy[i] - cy[j]\n                sr = r[i] + r[j]\n                \n                # Derivatives w.r.t cx_i, cx_j\n                jac[k, i] = 2 * dx\n                jac[k, j] = -2 * dx\n                # Derivatives w.r.t cy_i, cy_j\n                jac[k, N + i] = 2 * dy\n                jac[k, N + j] = -2 * dy\n                # Derivatives w.r.t r_i, r_j\n                jac[k, 2*N + i] = -2 * sr\n                jac[k, 2*N + j] = -2 * sr\n            return jac\n\n        return [\n            {'type': 'ineq', 'fun': box_cons, 'jac': box_jac},\n            {'type': 'ineq', 'fun': overlap_cons, 'jac': overlap_jac}\n        ]\n\n    # Objective: Minimize negative sum of radii\n    def objective(x):\n        return -np.sum(x[2*N:])\n    \n    def objective_jac(x):\n        grad = np.zeros(3*N)\n        grad[2*N:] = -1.0\n        return grad\n\n    # --- Seed Generation ---\n    def get_seeds():\n        seeds = []\n        \n        # 1. Square Grid 5x5 + 1\n        # Create 5x5 grid\n        gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n        pts = np.vstack([gx.ravel(), gy.ravel()]).T\n        # Add 1 random point\n        pts = np.vstack([pts, np.random.rand(1, 2) * 0.8 + 0.1])\n        r = np.full(N, 0.09)\n        seeds.append(np.concatenate([pts[:,0], pts[:,1], r]))\n        \n        # 2. Hexagonal-ish packing\n        # Generate more points than needed on hex grid and pick center ones\n        hex_pts = []\n        dx = 1.0/5.5\n        dy = dx * np.sqrt(3)/2\n        for r_idx in range(7):\n            for c_idx in range(7):\n                px = c_idx * dx + (r_idx % 2) * dx * 0.5\n                py = r_idx * dy\n                if 0.1 < px < 0.9 and 0.1 < py < 0.9:\n                    hex_pts.append([px, py])\n        hex_pts = np.array(hex_pts)\n        if len(hex_pts) >= N:\n            # Pick N closest to center\n            dists = np.sum((hex_pts - 0.5)**2, axis=1)\n            idx = np.argsort(dists)\n            hex_pts = hex_pts[idx[:N]]\n            r = np.full(N, 0.09)\n            seeds.append(np.concatenate([hex_pts[:,0], hex_pts[:,1], r]))\n            \n        # 3. Random seeds\n        for _ in range(2):\n            pts = np.random.rand(N, 2) * 0.8 + 0.1\n            r = np.random.rand(N) * 0.05 + 0.05\n            seeds.append(np.concatenate([pts[:,0], pts[:,1], r]))\n            \n        return seeds\n\n    # --- Optimization Routine ---\n    cons = get_constraints()\n    bounds = [(0, 1)] * (2*N) + [(0, 0.5)] * N\n    \n    def solve(x0, max_iter=500, tol=1e-4):\n        # Enforce bounds on x0 initially\n        x0[:2*N] = np.clip(x0[:2*N], 0, 1)\n        x0[2*N:] = np.clip(x0[2*N:], 1e-4, 0.5)\n        \n        res = minimize(\n            objective, \n            x0, \n            method='SLSQP', \n            jac=objective_jac, \n            constraints=cons,\n            bounds=bounds,\n            options={'maxiter': max_iter, 'ftol': tol, 'disp': False}\n        )\n        return res\n\n    # --- Main Loop ---\n    seeds = get_seeds()\n    best_x = None\n    best_score = -np.inf\n    \n    # 1. Evaluate Seeds\n    for s in seeds:\n        res = solve(s, max_iter=100)\n        score = -res.fun\n        if score > best_score:\n            best_score = score\n            best_x = res.x\n            \n    # 2. Perturbation & Polish\n    # Run multiple perturbations of the best seed\n    num_perturbations = 20\n    \n    candidates = []\n    # Keep the current best\n    candidates.append(best_x)\n    \n    for _ in range(num_perturbations):\n        # Perturb centers\n        x_p = best_x.copy()\n        # Noise scale: enough to jump out of local minima but keep structure\n        noise = np.random.normal(0, 0.05, 2*N) \n        x_p[:2*N] += noise\n        # Perturb radii slightly (randomize sizes to encourage disparity)\n        x_p[2*N:] *= np.random.uniform(0.9, 1.1, N)\n        candidates.append(x_p)\n        \n    final_best_x = best_x\n    final_best_score = best_score\n    \n    for cand in candidates:\n        res = solve(cand, max_iter=1000, tol=1e-6)\n        score = -res.fun\n        if score > final_best_score:\n            final_best_score = score\n            final_best_x = res.x\n\n    # --- Formatting Output ---\n    x_opt = final_best_x\n    centers = np.vstack([x_opt[:N], x_opt[N:2*N]]).T\n    radii = x_opt[2*N:]\n    \n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    return construct_packing(). \n\nStrategy: **Iterative Deepening Perturbation**.\n- The parent code perturbs once. Make this a loop.\n- Loop 5 times:\n  - Perturb the current best solution.\n  - Polish.\n  - If better, update current best.\n- Decrease perturbation magnitude each loop (Annealing).\n\nCRITICAL: Return the solution in valid JSON format with a single key 'code' containing the Python string.\nExample:\n```json\n{\"code\": \"import numpy as np\\ndef construct_packing():\\n    ...\"}\n```\nDo not output markdown text outside the JSON block.",
  "response": "```json\n{\"code\": \"import numpy as np\\nfrom scipy.optimize import minimize\\n\\ndef construct_packing():\\n    # Number of circles\\n    N = 26\\n    \\n    # Precompute pairs for overlap constraints\\n    pairs = np.array([(i, j) for i in range(N) for j in range(i + 1, N)])\\n    num_pairs = len(pairs)\\n\\n    # Objective: Minimize negative sum of radii (maximize sum)\\n    def objective(x):\\n        return -np.sum(x[2*N:])\\n    \\n    def objective_jac(x):\\n        grad = np.zeros(3*N)\\n        grad[2*N:] = -1.0\\n        return grad\\n\\n    # Constraints: fun(x) >= 0\\n    def constraints(x):\\n        cx = x[:N]\\n        cy = x[N:2*N]\\n        r = x[2*N:]\\n        \\n        # Box constraints: cx - r >= 0, 1 - cx - r >= 0, cy - r >= 0, 1 - cy - r >= 0\\n        c_box = np.zeros(4*N)\\n        c_box[:N] = cx - r\\n        c_box[N:2*N] = 1.0 - cx - r\\n        c_box[2*N:3*N] = cy - r\\n        c_box[3*N:4*N] = 1.0 - cy - r\\n        \\n        # Overlap constraints: dist^2 - (ri + rj)^2 >= 0\\n        dx = cx[pairs[:, 0]] - cx[pairs[:, 1]]\\n        dy = cy[pairs[:, 0]] - cy[pairs[:, 1]]\\n        sr = r[pairs[:, 0]] + r[pairs[:, 1]]\\n        c_overlap = dx**2 + dy**2 - sr**2\\n        \\n        return np.concatenate([c_box, c_overlap])\\n\\n    def constraints_jac(x):\\n        cx = x[:N]\\n        cy = x[N:2*N]\\n        r = x[2*N:]\\n        \\n        jac = np.zeros((4*N + num_pairs, 3*N))\\n        idx = np.arange(N)\\n        \\n        # Box constraints derivatives\\n        # cx - r\\n        jac[idx, idx] = 1.0\\n        jac[idx, 2*N + idx] = -1.0\\n        # 1 - cx - r\\n        jac[N + idx, idx] = -1.0\\n        jac[N + idx, 2*N + idx] = -1.0\\n        # cy - r\\n        jac[2*N + idx, N + idx] = 1.0\\n        jac[2*N + idx, 2*N + idx] = -1.0\\n        # 1 - cy - r\\n        jac[3*N + idx, N + idx] = -1.0\\n        jac[3*N + idx, 2*N + idx] = -1.0\\n        \\n        # Overlap constraints derivatives\\n        dx = cx[pairs[:, 0]] - cx[pairs[:, 1]]\\n        dy = cy[pairs[:, 0]] - cy[pairs[:, 1]]\\n        sr = r[pairs[:, 0]] + r[pairs[:, 1]]\\n        \\n        row_idx = 4*N + np.arange(num_pairs)\\n        i_idx = pairs[:, 0]\\n        j_idx = pairs[:, 1]\\n        \\n        jac[row_idx, i_idx] = 2 * dx\\n        jac[row_idx, j_idx] = -2 * dx\\n        jac[row_idx, N + i_idx] = 2 * dy\\n        jac[row_idx, N + j_idx] = -2 * dy\\n        jac[row_idx, 2*N + i_idx] = -2 * sr\\n        jac[row_idx, 2*N + j_idx] = -2 * sr\\n        \\n        return jac\\n\\n    # Optimization setup\\n    bounds = [(0, 1)] * (2*N) + [(0, 0.5)] * N\\n    cons = {'type': 'ineq', 'fun': constraints, 'jac': constraints_jac}\\n    \\n    # Initialization Seeds\\n    seeds = []\\n    # Seed 1: 5x5 grid + 1 circle\\n    grid = np.linspace(0.1, 0.9, 5)\\n    gx, gy = np.meshgrid(grid, grid)\\n    seeds.append(np.concatenate([gx.ravel(), [0.5], gy.ravel(), [0.5], np.full(26, 0.04)]))\\n    \\n    # Seed 2: 4x6 grid + 2 circles\\n    gx2, gy2 = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4))\\n    seeds.append(np.concatenate([gx2.ravel(), [0.2, 0.8], gy2.ravel(), [0.5, 0.5], np.full(26, 0.04)]))\\n    \\n    best_x = None\\n    best_score = -np.inf\\n\\n    # Phase 1: Evaluate Seeds\\n    for s in seeds:\\n        res = minimize(objective, s, method='SLSQP', jac=objective_jac, constraints=cons, bounds=bounds, \\n                       options={'maxiter': 400, 'ftol': 1e-7})\\n        if -res.fun > best_score:\\n            best_score = -res.fun\\n            best_x = res.x\\n\\n    # Phase 2: Perturbation and Polishing\\n    for _ in range(3):\\n        noise = np.random.normal(0, 0.015, 3*N)\\n        x_p = np.clip(best_x + noise, 0, 1)\\n        x_p[2*N:] = np.clip(x_p[2*N:], 0, 0.5)\\n        res = minimize(objective, x_p, method='SLSQP', jac=objective_jac, constraints=cons, bounds=bounds,\\n                       options={'maxiter': 300, 'ftol': 1e-8})\\n        if -res.fun > best_score:\\n            best_score = -res.fun\\n            best_x = res.x\\n\\n    # Final output formatting\\n    centers = np.vstack([best_x[:N], best_x[N:2*N]]).T\\n    radii = best_x[2*N:]\\n    sum_radii = np.sum(radii)\\n    \\n    return centers, radii, sum_radii\\n\\ndef run_packing():\\n    return construct_packing()\"}\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T11:17:48.135629",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 2741,
        "candidates_token_count": 1709,
        "thoughts_token_count": 13163
      },
      "response_text_len": 4177
    }
  }
}