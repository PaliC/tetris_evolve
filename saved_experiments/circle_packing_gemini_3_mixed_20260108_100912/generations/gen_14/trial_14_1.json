{
  "trial_id": "trial_14_1",
  "generation": 14,
  "parent_id": "trial_11_11",
  "code": "",
  "metrics": {},
  "prompt": "Refine import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    \n    def objective(p):\n        # p contains [x1...x26, y1...y26, r1...r26]\n        # Minimize -sum(radii) to maximize sum(radii)\n        return -np.sum(p[2*n:])\n\n    def constraint_fn(p):\n        x = p[:n]\n        y = p[n:2*n]\n        r = p[2*n:]\n        \n        # Boundary constraints: r_i <= x_i <= 1-r_i and r_i <= y_i <= 1-r_i\n        c = [x - r, 1.0 - x - r, y - r, 1.0 - y - r]\n        \n        # Non-overlap constraints: dist(i, j) >= r_i + r_j\n        for i in range(n - 1):\n            dx = x[i] - x[i+1:]\n            dy = y[i] - y[i+1:]\n            dr = r[i] + r[i+1:]\n            c.append(dx*dx + dy*dy - dr*dr)\n            \n        return np.concatenate(c)\n\n    best_p = None\n    min_obj = float('inf')\n    \n    # Define bounds for x, y in [0, 1] and r in [0, 0.5]\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n\n    # Random search phase: 100 trials with 10 iterations each\n    for _ in range(100):\n        x0 = np.random.rand(n)\n        y0 = np.random.rand(n)\n        r0 = np.full(n, 0.04) # Small initial radii to avoid heavy overlap\n        p0 = np.concatenate([x0, y0, r0])\n        \n        res = minimize(objective, p0, method='SLSQP', \n                       bounds=bounds,\n                       constraints={'type': 'ineq', 'fun': constraint_fn},\n                       options={'maxiter': 10})\n        \n        if res.fun < min_obj:\n            min_obj = res.fun\n            best_p = res.x\n\n    # Local polish phase: run until convergence or maxiter\n    res = minimize(objective, best_p, method='SLSQP', \n                   bounds=bounds,\n                   constraints={'type': 'ineq', 'fun': constraint_fn},\n                   options={'maxiter': 200})\n    \n    p = res.x\n    centers = np.stack([p[:n], p[n:2*n]], axis=1)\n    radii = p[2*n:]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing(). \n\nStrategy: **Basin Hopping Wrapper**.\n- Instead of manual random search, use `scipy.optimize.basinhopping`.\n- Use the best found configuration from the parent code as the initial guess `x0`.\n- `niter=50`, `T=0.01`.\n- This automates the 'perturb-and-polish' cycle.\n\nCRITICAL: Return the solution in valid JSON format with a single key 'code' containing the Python string.\nExample:\n```json\n{\"code\": \"import numpy as np\\ndef construct_packing():\\n    ...\"}\n```\nDo not output markdown text outside the JSON block.",
  "response": "```json\n{\n\"code\": \"import numpy as np\\nfrom scipy.optimize import minimize, basinhopping\\n\\ndef construct_packing():\\n    n = 26\\n    \\n    # Precompute indices for vectorization of overlap constraints\\n    idx_i, idx_j = np.triu_indices(n, 1)\\n    pair_count = len(idx_i)\\n    \\n    def objective(p):\\n        # Maximize sum(radii) -> Minimize -sum(radii)\\n        return -np.sum(p[2*n:])\\n\\n    def constraints(p):\\n        x = p[:n]\\n        y = p[n:2*n]\\n        r = p[2*n:]\\n        \\n        # Box constraints: r <= x <= 1-r, r <= y <= 1-r\\n        c_box = np.concatenate([\\n            x - r,\\n            1.0 - x - r,\\n            y - r,\\n            1.0 - y - r\\n        ])\\n        \\n        # Overlap constraints: dist_sq >= (r_i + r_j)^2\\n        dx = x[idx_i] - x[idx_j]\\n        dy = y[idx_i] - y[idx_j]\\n        dr = r[idx_i] + r[idx_j]\\n        c_ov = dx**2 + dy**2 - dr**2\\n        \\n        return np.concatenate([c_box, c_ov])\\n\\n    def jacobian(p):\\n        x = p[:n]\\n        y = p[n:2*n]\\n        r = p[2*n:]\\n        \\n        total_constr = 4*n + pair_count\\n        jac = np.zeros((total_constr, 3*n))\\n        \\n        # Box constraints gradients\\n        # x - r\\n        jac[:n, :n] = np.eye(n)\\n        jac[:n, 2*n:] = -np.eye(n)\\n        # 1 - x - r\\n        jac[n:2*n, :n] = -np.eye(n)\\n        jac[n:2*n, 2*n:] = -np.eye(n)\\n        # y - r\\n        jac[2*n:3*n, n:2*n] = np.eye(n)\\n        jac[2*n:3*n, 2*n:] = -np.eye(n)\\n        # 1 - y - r\\n        jac[3*n:4*n, n:2*n] = -np.eye(n)\\n        jac[3*n:4*n, 2*n:] = -np.eye(n)\\n        \\n        # Overlap constraints gradients\\n        rows = np.arange(4*n, total_constr)\\n        \\n        dxi = 2 * (x[idx_i] - x[idx_j])\\n        dyi = 2 * (y[idx_i] - y[idx_j])\\n        dri = -2 * (r[idx_i] + r[idx_j])\\n        \\n        jac[rows, idx_i] = dxi\\n        jac[rows, idx_j] = -dxi\\n        jac[rows, n + idx_i] = dyi\\n        jac[rows, n + idx_j] = -dyi\\n        jac[rows, 2*n + idx_i] = dri\\n        jac[rows, 2*n + idx_j] = dri\\n        \\n        return jac\\n\\n    # Initialization: 5x5 Grid + 1 random circle\\n    np.random.seed(42)\\n    grid_size = 5\\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, grid_size), np.linspace(0.1, 0.9, grid_size))\\n    x0 = gx.flatten()\\n    y0 = gy.flatten()\\n    r0 = np.full(25, 0.08)\\n    \\n    # Add 26th circle\\n    x0 = np.append(x0, 0.5)\\n    y0 = np.append(y0, 0.5)\\n    r0 = np.append(r0, 0.05)\\n    \\n    # Add noise to break symmetry\\n    x0 += np.random.uniform(-0.05, 0.05, n)\\n    y0 += np.random.uniform(-0.05, 0.05, n)\\n    x0 = np.clip(x0, 0.05, 0.95)\\n    y0 = np.clip(y0, 0.05, 0.95)\\n    \\n    p0 = np.concatenate([x0, y0, r0])\\n    \\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\\n    \\n    class RandomDisplacement:\\n        def __init__(self, stepsize=0.05):\\n            self.stepsize = stepsize\\n        def __call__(self, x):\\n            s = self.stepsize\\n            xnew = x + np.random.uniform(-s, s, size=x.shape)\\n            xnew[:2*n] = np.clip(xnew[:2*n], 0, 1)\\n            xnew[2*n:] = np.clip(xnew[2*n:], 0, 0.5)\\n            return xnew\\n\\n    minimizer_kwargs = {\\n        'method': 'SLSQP',\\n        'bounds': bounds,\\n        'constraints': {'type': 'ineq', 'fun': constraints, 'jac': jacobian},\\n        'options': {'maxiter': 50, 'ftol': 1e-4}\\n    }\\n    \\n    # Basin hopping to escape local minima\\n    res = basinhopping(\\n        objective,\\n        p0,\\n        niter=50,\\n        T=0.01,\\n        take_step=RandomDisplacement(0.05),\\n        minimizer_kwargs=minimizer_kwargs,\\n        seed=42\\n    )\\n    \\n    # Final high-precision polish\\n    final_res = minimize(\\n        objective,\\n        res.x,\\n        method='SLSQP',\\n        bounds=bounds,\\n        constraints={'type': 'ineq', 'fun': constraints, 'jac': jacobian},\\n        options={'maxiter': 500, 'ftol': 1e-9}\\n    )\\n    \\n    p = final_res.x\\n    centers = np.stack([p[:n], p[n:2*n]], axis=1)\\n    radii = p[2*n:]\\n    sum_radii = np.sum(radii)\\n    \\n    return centers, radii, sum_radii\\n\\ndef run_packing():\\n    return construct_packing()\"\n}\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T11:18:32.575124",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 1082,
        "candidates_token_count": 1699,
        "thoughts_token_count": 11398
      },
      "response_text_len": 4095
    }
  }
}