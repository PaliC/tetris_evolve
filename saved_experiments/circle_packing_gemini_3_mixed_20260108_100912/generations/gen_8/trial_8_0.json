{
  "trial_id": "trial_8_0",
  "generation": 8,
  "parent_id": "trial_6_6",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    N = 26\n    # Store state as list of [x, y, r]\n    # We will flatten this for the optimizer\n    circles = np.zeros((0, 3))\n    \n    rng = np.random.default_rng(42)\n    \n    # Objective: Minimize -sum(r)\n    def objective(params):\n        # params format: x1, y1, r1, x2, y2, r2...\n        rs = params[2::3]\n        return -np.sum(rs)\n\n    def obj_jac(params):\n        grad = np.zeros_like(params)\n        grad[2::3] = -1.0\n        return grad\n    \n    # Helper to generate constraints for a given number of circles n\n    def get_constraints(n):\n        def cons_fun(params):\n            xs = params[0::3]\n            ys = params[1::3]\n            rs = params[2::3]\n            \n            # Wall constraints: x-r>=0, 1-x-r>=0, y-r>=0, 1-y-r>=0\n            c_walls = np.concatenate([\n                xs - rs,\n                1.0 - xs - rs,\n                ys - rs,\n                1.0 - ys - rs\n            ])\n            \n            if n == 1:\n                return c_walls\n            \n            # Overlap constraints: dist_sq - (ri+rj)^2 >= 0\n            overlaps = []\n            for i in range(n):\n                for j in range(i + 1, n):\n                    d2 = (xs[i] - xs[j])**2 + (ys[i] - ys[j])**2\n                    r_sum2 = (rs[i] + rs[j])**2\n                    overlaps.append(d2 - r_sum2)\n            \n            return np.concatenate([c_walls, overlaps])\n\n        def cons_jac(params):\n            n_vars = 3 * n\n            n_walls = 4 * n\n            n_overlaps = n * (n - 1) // 2\n            jac = np.zeros((n_walls + n_overlaps, n_vars))\n            \n            xs = params[0::3]\n            ys = params[1::3]\n            rs = params[2::3]\n            \n            # Wall gradients\n            for k in range(n):\n                # x-r\n                jac[k, 3*k] = 1; jac[k, 3*k+2] = -1\n                # 1-x-r\n                jac[n+k, 3*k] = -1; jac[n+k, 3*k+2] = -1\n                # y-r\n                jac[2*n+k, 3*k+1] = 1; jac[2*n+k, 3*k+2] = -1\n                # 1-y-r\n                jac[3*n+k, 3*k+1] = -1; jac[3*n+k, 3*k+2] = -1\n            \n            # Overlap gradients\n            row = n_walls\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dx = xs[i] - xs[j]\n                    dy = ys[i] - ys[j]\n                    sr = rs[i] + rs[j]\n                    \n                    # wrt i\n                    jac[row, 3*i] = 2*dx\n                    jac[row, 3*i+1] = 2*dy\n                    jac[row, 3*i+2] = -2*sr\n                    \n                    # wrt j\n                    jac[row, 3*j] = -2*dx\n                    jac[row, 3*j+1] = -2*dy\n                    jac[row, 3*j+2] = -2*sr\n                    \n                    row += 1\n            return jac\n        \n        return cons_fun, cons_jac\n\n    # Iteratively add circles\n    for i in range(N):\n        # Best-of-K Insertion\n        K = 20\n        best_cand = None\n        best_r = -np.inf\n        \n        curr_centers = circles[:, :2]\n        curr_radii = circles[:, 2]\n        \n        candidates = rng.random((K, 2))\n        \n        for cand in candidates:\n            cx, cy = cand\n            # Distance to walls\n            r_bound = min(cx, 1-cx, cy, 1-cy)\n            if r_bound < 0: continue\n            \n            # Distance to existing circles\n            if i > 0:\n                dists = np.sqrt(np.sum((curr_centers - cand)**2, axis=1))\n                gaps = dists - curr_radii\n                r_cand = min(r_bound, np.min(gaps))\n            else:\n                r_cand = r_bound\n            \n            if r_cand > best_r:\n                best_r = r_cand\n                best_cand = np.array([cx, cy, max(1e-4, r_cand)])\n        \n        # Fallback if valid spot not found (unlikely)\n        if best_cand is None:\n             best_cand = np.array([rng.random(), rng.random(), 1e-4])\n             \n        # Add to state\n        x0 = np.concatenate([circles.flatten(), best_cand])\n        n_curr = i + 1\n        \n        # Optimize\n        cf, cj = get_constraints(n_curr)\n        bounds = [(0, 1), (0, 1), (0, 0.6)] * n_curr\n        \n        # Tighter tolerance for the final step, looser for intermediate\n        ftol = 1e-4 if i < N - 1 else 1e-9\n        maxiter = 500 if i < N - 1 else 1500\n        \n        res = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            jac=obj_jac,\n            bounds=bounds,\n            constraints={'type': 'ineq', 'fun': cf, 'jac': cj},\n            options={'maxiter': maxiter, 'ftol': ftol}\n        )\n        \n        circles = res.x.reshape((-1, 3))\n\n    centers = circles[:, :2]\n    radii = circles[:, 2]\n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.59462490295403,
    "eval_time": 0.5641779899597168,
    "error": null
  },
  "prompt": "Refine the code from {CODE_TRIAL_6_6}. \n\nStrategy: **Best-of-K Insertion**.\n- In the loop where you add a new circle:\n- Instead of picking 1 random location, generate 20 random locations.\n- For each, compute the distance to the nearest existing circle.\n- Pick the location with the LARGEST distance (Maximin).\n- Use that as the starting point for the `minimize` step.\n- This gives the optimizer the best possible head start.\n\nCRITICAL: You must output ONLY a single Python code block (```python ... ```). \nDO NOT write any introduction. \nDO NOT write 'Here is the code'. \nDO NOT write any explanation after. \nJust the code block.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    N = 26\n    # Store state as list of [x, y, r]\n    # We will flatten this for the optimizer\n    circles = np.zeros((0, 3))\n    \n    rng = np.random.default_rng(42)\n    \n    # Objective: Minimize -sum(r)\n    def objective(params):\n        # params format: x1, y1, r1, x2, y2, r2...\n        rs = params[2::3]\n        return -np.sum(rs)\n\n    def obj_jac(params):\n        grad = np.zeros_like(params)\n        grad[2::3] = -1.0\n        return grad\n    \n    # Helper to generate constraints for a given number of circles n\n    def get_constraints(n):\n        def cons_fun(params):\n            xs = params[0::3]\n            ys = params[1::3]\n            rs = params[2::3]\n            \n            # Wall constraints: x-r>=0, 1-x-r>=0, y-r>=0, 1-y-r>=0\n            c_walls = np.concatenate([\n                xs - rs,\n                1.0 - xs - rs,\n                ys - rs,\n                1.0 - ys - rs\n            ])\n            \n            if n == 1:\n                return c_walls\n            \n            # Overlap constraints: dist_sq - (ri+rj)^2 >= 0\n            overlaps = []\n            for i in range(n):\n                for j in range(i + 1, n):\n                    d2 = (xs[i] - xs[j])**2 + (ys[i] - ys[j])**2\n                    r_sum2 = (rs[i] + rs[j])**2\n                    overlaps.append(d2 - r_sum2)\n            \n            return np.concatenate([c_walls, overlaps])\n\n        def cons_jac(params):\n            n_vars = 3 * n\n            n_walls = 4 * n\n            n_overlaps = n * (n - 1) // 2\n            jac = np.zeros((n_walls + n_overlaps, n_vars))\n            \n            xs = params[0::3]\n            ys = params[1::3]\n            rs = params[2::3]\n            \n            # Wall gradients\n            for k in range(n):\n                # x-r\n                jac[k, 3*k] = 1; jac[k, 3*k+2] = -1\n                # 1-x-r\n                jac[n+k, 3*k] = -1; jac[n+k, 3*k+2] = -1\n                # y-r\n                jac[2*n+k, 3*k+1] = 1; jac[2*n+k, 3*k+2] = -1\n                # 1-y-r\n                jac[3*n+k, 3*k+1] = -1; jac[3*n+k, 3*k+2] = -1\n            \n            # Overlap gradients\n            row = n_walls\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dx = xs[i] - xs[j]\n                    dy = ys[i] - ys[j]\n                    sr = rs[i] + rs[j]\n                    \n                    # wrt i\n                    jac[row, 3*i] = 2*dx\n                    jac[row, 3*i+1] = 2*dy\n                    jac[row, 3*i+2] = -2*sr\n                    \n                    # wrt j\n                    jac[row, 3*j] = -2*dx\n                    jac[row, 3*j+1] = -2*dy\n                    jac[row, 3*j+2] = -2*sr\n                    \n                    row += 1\n            return jac\n        \n        return cons_fun, cons_jac\n\n    # Iteratively add circles\n    for i in range(N):\n        # Best-of-K Insertion\n        K = 20\n        best_cand = None\n        best_r = -np.inf\n        \n        curr_centers = circles[:, :2]\n        curr_radii = circles[:, 2]\n        \n        candidates = rng.random((K, 2))\n        \n        for cand in candidates:\n            cx, cy = cand\n            # Distance to walls\n            r_bound = min(cx, 1-cx, cy, 1-cy)\n            if r_bound < 0: continue\n            \n            # Distance to existing circles\n            if i > 0:\n                dists = np.sqrt(np.sum((curr_centers - cand)**2, axis=1))\n                gaps = dists - curr_radii\n                r_cand = min(r_bound, np.min(gaps))\n            else:\n                r_cand = r_bound\n            \n            if r_cand > best_r:\n                best_r = r_cand\n                best_cand = np.array([cx, cy, max(1e-4, r_cand)])\n        \n        # Fallback if valid spot not found (unlikely)\n        if best_cand is None:\n             best_cand = np.array([rng.random(), rng.random(), 1e-4])\n             \n        # Add to state\n        x0 = np.concatenate([circles.flatten(), best_cand])\n        n_curr = i + 1\n        \n        # Optimize\n        cf, cj = get_constraints(n_curr)\n        bounds = [(0, 1), (0, 1), (0, 0.6)] * n_curr\n        \n        # Tighter tolerance for the final step, looser for intermediate\n        ftol = 1e-4 if i < N - 1 else 1e-9\n        maxiter = 500 if i < N - 1 else 1500\n        \n        res = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            jac=obj_jac,\n            bounds=bounds,\n            constraints={'type': 'ineq', 'fun': cf, 'jac': cj},\n            options={'maxiter': maxiter, 'ftol': ftol}\n        )\n        \n        circles = res.x.reshape((-1, 3))\n\n    centers = circles[:, :2]\n    radii = circles[:, 2]\n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T10:50:03.326348",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 387,
        "candidates_token_count": 1593,
        "thoughts_token_count": 9819
      },
      "response_text_len": 4853
    }
  }
}