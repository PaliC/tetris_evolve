{
  "trial_id": "trial_11_3",
  "generation": 11,
  "parent_id": "trial_9_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    N = 26\n    \n    # --- Energy Function for Physics/Relaxation ---\n    def get_energy_func(n_circles, weight=1e5):\n        def energy(p):\n            # p: [x0, y0, ..., xN, yN, r0, ..., rN]\n            c = p[:2*n_circles].reshape((n_circles, 2))\n            r = p[2*n_circles:]\n            \n            # Objective: Maximize sum(r) -> Minimize -sum(r)\n            obj = -np.sum(r)\n            \n            # Penalty 1: Boundary violations\n            # r <= x, r <= 1-x, r <= y, r <= 1-y\n            # Violation: (r - x)^2 if r > x\n            p_walls = 0\n            p_walls += np.sum(np.maximum(0, r - c[:, 0])**2)\n            p_walls += np.sum(np.maximum(0, c[:, 0] + r - 1)**2)\n            p_walls += np.sum(np.maximum(0, r - c[:, 1])**2)\n            p_walls += np.sum(np.maximum(0, c[:, 1] + r - 1)**2)\n            \n            # Penalty 2: Overlaps\n            # dist_ij < r_i + r_j\n            c_exp_1 = c[:, None, :]\n            c_exp_2 = c[None, :, :]\n            dist_sq = np.sum((c_exp_1 - c_exp_2)**2, axis=2)\n            dist = np.sqrt(dist_sq + 1e-12)\n            \n            r_sum = r[:, None] + r[None, :]\n            \n            # Only consider i < j\n            iu = np.triu_indices(n_circles, 1)\n            overlaps = np.maximum(0, r_sum[iu] - dist[iu])\n            p_overlap = np.sum(overlaps**2)\n            \n            return obj + weight * (p_walls + p_overlap)\n        return energy\n\n    # --- Phase 1: Physics Relaxation (Global) ---\n    # Initialize random circles\n    x0 = np.random.rand(N * 3)\n    x0[2*N:] = 0.05 # Initial small radii\n    \n    # Bounds: x,y in [0,1], r in [epsilon, 0.5]\n    bounds = [(0, 1)] * (2*N) + [(1e-5, 0.5)] * N\n    \n    # Run optimization\n    res = minimize(get_energy_func(N, 1e4), x0, method='L-BFGS-B', bounds=bounds, options={'maxiter': 500})\n    \n    p = res.x\n    coords = p[:2*N].reshape((N, 2))\n    radii = p[2*N:]\n    \n    # --- Phase 2: Pruning Outer Circles ---\n    # Calculate distance from center (0.5, 0.5)\n    d_center = np.sum((coords - 0.5)**2, axis=1)\n    # Remove 8 furthest circles (outer layer)\n    idx_remove = np.argsort(d_center)[::-1][:8]\n    mask = np.ones(N, dtype=bool)\n    mask[idx_remove] = False\n    \n    fixed_coords = coords[mask]\n    fixed_radii = radii[mask]\n    \n    # --- Phase 3: Look-Ahead / Greedy Re-insertion ---\n    # Re-add 8 circles one by one into the largest available gaps\n    curr_c = list(fixed_coords)\n    curr_r = list(fixed_radii)\n    \n    for _ in range(8):\n        # Function to find max radius at (x,y)\n        def neg_radius_at(xy):\n            x, y = xy\n            # Distance to walls\n            dw = min(x, 1-x, y, 1-y)\n            if dw <= 0: return 10.0 # Invalid\n            \n            # Distance to existing circles\n            c_arr = np.array(curr_c)\n            r_arr = np.array(curr_r)\n            d_sq = np.sum((c_arr - xy)**2, axis=1)\n            d = np.sqrt(d_sq)\n            \n            # Available radius is dist - existing_radius\n            dr = d - r_arr\n            \n            # Max valid radius is min of all constraints\n            r_valid = min(dw, np.min(dr))\n            return -r_valid\n\n        # Search for best hole using grid seeds + local opt\n        best_r = -1e9\n        best_xy = np.array([0.5, 0.5])\n        \n        gs = 6 # 6x6 grid\n        for i in range(gs):\n            for j in range(gs):\n                seed = [(i+0.5)/gs, (j+0.5)/gs]\n                # Check if seed is feasible (positive radius)\n                if neg_radius_at(seed) < 0:\n                    res_hole = minimize(neg_radius_at, seed, bounds=[(0,1), (0,1)], method='L-BFGS-B')\n                    if -res_hole.fun > best_r:\n                        best_r = -res_hole.fun\n                        best_xy = res_hole.x\n        \n        curr_c.append(best_xy)\n        curr_r.append(max(0, best_r))\n        \n    # --- Phase 4: Final Polish ---\n    # Optimize all 26 circles together with high penalty\n    final_coords = np.array(curr_c)\n    final_radii = np.array(curr_r)\n    p_final = np.concatenate([final_coords.flatten(), final_radii])\n    \n    res_final = minimize(get_energy_func(N, 1e7), p_final, method='L-BFGS-B', bounds=bounds, options={'maxiter': 1000, 'ftol': 1e-6})\n    \n    p_out = res_final.x\n    c_out = p_out[:2*N].reshape((N, 2))\n    r_out = p_out[2*N:]\n    \n    # --- Validation & Cleanup ---\n    # 1. Enforce Wall Constraints\n    r_out = np.minimum(r_out, c_out[:, 0])\n    r_out = np.minimum(r_out, 1 - c_out[:, 0])\n    r_out = np.minimum(r_out, c_out[:, 1])\n    r_out = np.minimum(r_out, 1 - c_out[:, 1])\n    \n    # 2. Enforce Overlap Constraints (Iterative Shrinking)\n    # If overlaps exist, shrink both circles slightly to resolve\n    for _ in range(10):\n        changed = False\n        for i in range(N):\n            for j in range(i+1, N):\n                d = np.linalg.norm(c_out[i] - c_out[j])\n                sum_r = r_out[i] + r_out[j]\n                if sum_r > d + 1e-9:\n                    overlap = sum_r - d\n                    # Shrink both\n                    r_out[i] -= overlap/2 + 1e-10\n                    r_out[j] -= overlap/2 + 1e-10\n                    changed = True\n        if not changed: break\n        \n    r_out = np.maximum(r_out, 0)\n    \n    return c_out, r_out, np.sum(r_out)\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.2332490174821564,
    "eval_time": 1.721951961517334,
    "error": null
  },
  "prompt": "Combine {CODE_TRIAL_9_0} (Hybrid) and {CODE_TRIAL_10_3} (Look-Ahead). \n\nStrategy: **Hybrid Look-Ahead**.\n- Step 1: Run the Physics simulation (from trial_9_0) to get a dense core of 26 circles.\n- Step 2: Remove the **outer 8 circles**.\n- Step 3: Re-add these 8 circles using the Look-Ahead strategy (from trial_10_3).\n- This combines the global packing of physics with the smart placement of look-ahead for the boundary.\n\nCRITICAL: Output ONLY a single Python code block (```python ... ```). \nNO intro text. NO explanation. NO 'Here is the code'. \nJust the code.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    N = 26\n    \n    # --- Energy Function for Physics/Relaxation ---\n    def get_energy_func(n_circles, weight=1e5):\n        def energy(p):\n            # p: [x0, y0, ..., xN, yN, r0, ..., rN]\n            c = p[:2*n_circles].reshape((n_circles, 2))\n            r = p[2*n_circles:]\n            \n            # Objective: Maximize sum(r) -> Minimize -sum(r)\n            obj = -np.sum(r)\n            \n            # Penalty 1: Boundary violations\n            # r <= x, r <= 1-x, r <= y, r <= 1-y\n            # Violation: (r - x)^2 if r > x\n            p_walls = 0\n            p_walls += np.sum(np.maximum(0, r - c[:, 0])**2)\n            p_walls += np.sum(np.maximum(0, c[:, 0] + r - 1)**2)\n            p_walls += np.sum(np.maximum(0, r - c[:, 1])**2)\n            p_walls += np.sum(np.maximum(0, c[:, 1] + r - 1)**2)\n            \n            # Penalty 2: Overlaps\n            # dist_ij < r_i + r_j\n            c_exp_1 = c[:, None, :]\n            c_exp_2 = c[None, :, :]\n            dist_sq = np.sum((c_exp_1 - c_exp_2)**2, axis=2)\n            dist = np.sqrt(dist_sq + 1e-12)\n            \n            r_sum = r[:, None] + r[None, :]\n            \n            # Only consider i < j\n            iu = np.triu_indices(n_circles, 1)\n            overlaps = np.maximum(0, r_sum[iu] - dist[iu])\n            p_overlap = np.sum(overlaps**2)\n            \n            return obj + weight * (p_walls + p_overlap)\n        return energy\n\n    # --- Phase 1: Physics Relaxation (Global) ---\n    # Initialize random circles\n    x0 = np.random.rand(N * 3)\n    x0[2*N:] = 0.05 # Initial small radii\n    \n    # Bounds: x,y in [0,1], r in [epsilon, 0.5]\n    bounds = [(0, 1)] * (2*N) + [(1e-5, 0.5)] * N\n    \n    # Run optimization\n    res = minimize(get_energy_func(N, 1e4), x0, method='L-BFGS-B', bounds=bounds, options={'maxiter': 500})\n    \n    p = res.x\n    coords = p[:2*N].reshape((N, 2))\n    radii = p[2*N:]\n    \n    # --- Phase 2: Pruning Outer Circles ---\n    # Calculate distance from center (0.5, 0.5)\n    d_center = np.sum((coords - 0.5)**2, axis=1)\n    # Remove 8 furthest circles (outer layer)\n    idx_remove = np.argsort(d_center)[::-1][:8]\n    mask = np.ones(N, dtype=bool)\n    mask[idx_remove] = False\n    \n    fixed_coords = coords[mask]\n    fixed_radii = radii[mask]\n    \n    # --- Phase 3: Look-Ahead / Greedy Re-insertion ---\n    # Re-add 8 circles one by one into the largest available gaps\n    curr_c = list(fixed_coords)\n    curr_r = list(fixed_radii)\n    \n    for _ in range(8):\n        # Function to find max radius at (x,y)\n        def neg_radius_at(xy):\n            x, y = xy\n            # Distance to walls\n            dw = min(x, 1-x, y, 1-y)\n            if dw <= 0: return 10.0 # Invalid\n            \n            # Distance to existing circles\n            c_arr = np.array(curr_c)\n            r_arr = np.array(curr_r)\n            d_sq = np.sum((c_arr - xy)**2, axis=1)\n            d = np.sqrt(d_sq)\n            \n            # Available radius is dist - existing_radius\n            dr = d - r_arr\n            \n            # Max valid radius is min of all constraints\n            r_valid = min(dw, np.min(dr))\n            return -r_valid\n\n        # Search for best hole using grid seeds + local opt\n        best_r = -1e9\n        best_xy = np.array([0.5, 0.5])\n        \n        gs = 6 # 6x6 grid\n        for i in range(gs):\n            for j in range(gs):\n                seed = [(i+0.5)/gs, (j+0.5)/gs]\n                # Check if seed is feasible (positive radius)\n                if neg_radius_at(seed) < 0:\n                    res_hole = minimize(neg_radius_at, seed, bounds=[(0,1), (0,1)], method='L-BFGS-B')\n                    if -res_hole.fun > best_r:\n                        best_r = -res_hole.fun\n                        best_xy = res_hole.x\n        \n        curr_c.append(best_xy)\n        curr_r.append(max(0, best_r))\n        \n    # --- Phase 4: Final Polish ---\n    # Optimize all 26 circles together with high penalty\n    final_coords = np.array(curr_c)\n    final_radii = np.array(curr_r)\n    p_final = np.concatenate([final_coords.flatten(), final_radii])\n    \n    res_final = minimize(get_energy_func(N, 1e7), p_final, method='L-BFGS-B', bounds=bounds, options={'maxiter': 1000, 'ftol': 1e-6})\n    \n    p_out = res_final.x\n    c_out = p_out[:2*N].reshape((N, 2))\n    r_out = p_out[2*N:]\n    \n    # --- Validation & Cleanup ---\n    # 1. Enforce Wall Constraints\n    r_out = np.minimum(r_out, c_out[:, 0])\n    r_out = np.minimum(r_out, 1 - c_out[:, 0])\n    r_out = np.minimum(r_out, c_out[:, 1])\n    r_out = np.minimum(r_out, 1 - c_out[:, 1])\n    \n    # 2. Enforce Overlap Constraints (Iterative Shrinking)\n    # If overlaps exist, shrink both circles slightly to resolve\n    for _ in range(10):\n        changed = False\n        for i in range(N):\n            for j in range(i+1, N):\n                d = np.linalg.norm(c_out[i] - c_out[j])\n                sum_r = r_out[i] + r_out[j]\n                if sum_r > d + 1e-9:\n                    overlap = sum_r - d\n                    # Shrink both\n                    r_out[i] -= overlap/2 + 1e-10\n                    r_out[j] -= overlap/2 + 1e-10\n                    changed = True\n        if not changed: break\n        \n    r_out = np.maximum(r_out, 0)\n    \n    return c_out, r_out, np.sum(r_out)\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T11:03:24.670547",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 394,
        "candidates_token_count": 1904,
        "thoughts_token_count": 10024
      },
      "response_text_len": 5402
    }
  }
}