{
  "trial_id": "trial_7_2",
  "generation": 7,
  "parent_id": "trial_6_6",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    # Target: Pack 26 circles in [0,1]x[0,1] maximizing sum of radii\n    n_circles = 26\n    \n    # Use a fixed seed for reproducibility\n    rng = np.random.default_rng(42)\n    \n    circles = [] # List of [x, y, r] arrays\n\n    # Iteratively add circles\n    for k in range(1, n_circles + 1):\n        # 1. Smart Insertion Strategy\n        # Generate 50 random candidates\n        candidates = rng.random((50, 2))\n        \n        best_p = None\n        best_metric = -np.inf\n        \n        if k == 1:\n            best_p = np.array([0.5, 0.5])\n            best_metric = 0.5\n        else:\n            # Extract existing data\n            data = np.array(circles)\n            ex_xy = data[:, :2]\n            ex_r = data[:, 2]\n            \n            for p in candidates:\n                x, y = p\n                # Distance to boundaries (max radius limited by walls)\n                d_bound = min(x, 1-x, y, 1-y)\n                \n                # Distance to existing circles (max radius limited by neighbors)\n                # dist(p, c_j) - r_j\n                dists = np.linalg.norm(ex_xy - p, axis=1) - ex_r\n                d_circle = np.min(dists)\n                \n                # Max feasible radius at this point (Maximin)\n                r_feas = min(d_bound, d_circle)\n                \n                # We pick the position that allows the largest radius (or least overlap)\n                if r_feas > best_metric:\n                    best_metric = r_feas\n                    best_p = p\n        \n        # Initial radius: prevent negative start if possible\n        init_r = max(best_metric, 1e-4)\n        \n        # Add new circle to the list\n        circles.append(np.array([best_p[0], best_p[1], init_r]))\n        \n        # 2. Local Optimizer (SLSQP)\n        # Flatten state vector: [x1, y1, r1, x2, y2, r2, ...]\n        x0 = np.array(circles).flatten()\n        n = len(circles)\n        \n        # Bounds: x, y in [0, 1], r >= 0\n        bounds = []\n        for _ in range(n):\n            bounds.extend([(0, 1), (0, 1), (0, None)])\n            \n        # Precompute indices for pairwise constraints\n        idx_i, idx_j = np.tril_indices(n, -1)\n        \n        # Define Objective: Minimize negative sum of radii\n        def objective(x):\n            return -np.sum(x[2::3])\n        \n        def obj_jac(x):\n            g = np.zeros_like(x)\n            g[2::3] = -1.0\n            return g\n        \n        # Constraints\n        def constraints_func(x):\n            P = x.reshape((n, 3))\n            X, Y, R = P[:,0], P[:,1], P[:,2]\n            \n            # Boundary constraints (val >= 0)\n            c1 = X - R         # x >= r\n            c2 = 1 - X - R     # x <= 1 - r\n            c3 = Y - R         # y >= r\n            c4 = 1 - Y - R     # y <= 1 - r\n            \n            # Pairwise constraints\n            if len(idx_i) > 0:\n                dx = X[idx_i] - X[idx_j]\n                dy = Y[idx_i] - Y[idx_j]\n                sr = R[idx_i] + R[idx_j]\n                # dist^2 >= (r_i + r_j)^2\n                c_pair = (dx**2 + dy**2) - sr**2\n                return np.concatenate([c1, c2, c3, c4, c_pair])\n            else:\n                return np.concatenate([c1, c2, c3, c4])\n        \n        # Jacobian of constraints\n        def constraints_jac(x):\n            P = x.reshape((n, 3))\n            X, Y, R = P[:,0], P[:,1], P[:,2]\n            \n            n_vars = 3 * n\n            n_bound = 4 * n\n            n_pair = len(idx_i)\n            total_constr = n_bound + n_pair\n            \n            jac = np.zeros((total_constr, n_vars))\n            \n            # Boundary jacobian\n            # c1: X - R\n            rows_c1 = np.arange(n)\n            jac[rows_c1, 3*rows_c1] = 1.0\n            jac[rows_c1, 3*rows_c1+2] = -1.0\n            \n            # c2: 1 - X - R\n            rows_c2 = np.arange(n, 2*n)\n            ci = np.arange(n)\n            jac[rows_c2, 3*ci] = -1.0\n            jac[rows_c2, 3*ci+2] = -1.0\n            \n            # c3: Y - R\n            rows_c3 = np.arange(2*n, 3*n)\n            jac[rows_c3, 3*ci+1] = 1.0\n            jac[rows_c3, 3*ci+2] = -1.0\n            \n            # c4: 1 - Y - R\n            rows_c4 = np.arange(3*n, 4*n)\n            jac[rows_c4, 3*ci+1] = -1.0\n            jac[rows_c4, 3*ci+2] = -1.0\n            \n            # Pairwise jacobian\n            if n_pair > 0:\n                offset = 4*n\n                rows = np.arange(offset, offset + n_pair)\n                \n                dx = X[idx_i] - X[idx_j]\n                dy = Y[idx_i] - Y[idx_j]\n                sr = R[idx_i] + R[idx_j]\n                \n                # Derivatives w.r.t i\n                jac[rows, 3*idx_i] = 2 * dx\n                jac[rows, 3*idx_i+1] = 2 * dy\n                jac[rows, 3*idx_i+2] = -2 * sr\n                \n                # Derivatives w.r.t j\n                jac[rows, 3*idx_j] = -2 * dx\n                jac[rows, 3*idx_j+1] = -2 * dy\n                jac[rows, 3*idx_j+2] = -2 * sr\n                \n            return jac\n\n        # Run optimization for current N circles\n        # ftol=1e-4 is sufficient for intermediate steps\n        res = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            jac=obj_jac,\n            bounds=bounds,\n            constraints={'type': 'ineq', 'fun': constraints_func, 'jac': constraints_jac},\n            options={'maxiter': 200, 'ftol': 1e-4}\n        )\n        \n        # Update circles with optimized result\n        circles = res.x.reshape((n, 3)).tolist()\n\n    # Final Polish: Run optimization with higher precision on the full set\n    x0 = np.array(circles).flatten()\n    n = n_circles\n    idx_i, idx_j = np.tril_indices(n, -1)\n    \n    # We reuse the functions defined in the last iteration (which correspond to n=26)\n    res = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        jac=obj_jac,\n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraints_func, 'jac': constraints_jac},\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n    \n    final_data = res.x.reshape((n, 3))\n    centers = final_data[:, :2]\n    radii = final_data[:, 2]\n    \n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.539697601158217,
    "eval_time": 0.5439670085906982,
    "error": null
  },
  "prompt": "Refine the strategy from {CODE_TRIAL_6_6}. \n\nStrategy: **Smart Insertion**.\n- Currently, the new circle might be placed randomly.\n- Change the insertion logic: When adding circle N+1, try 50 random positions.\n- Pick the one that is furthest from the existing N circles (Maximin distance).\n- Then run the local optimizer.\n- This gives the optimizer a better starting point.\n\nCRITICAL: Output ONLY valid Python code wrapped in ```python ... ```. NO text before or after. NO explanations.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    # Target: Pack 26 circles in [0,1]x[0,1] maximizing sum of radii\n    n_circles = 26\n    \n    # Use a fixed seed for reproducibility\n    rng = np.random.default_rng(42)\n    \n    circles = [] # List of [x, y, r] arrays\n\n    # Iteratively add circles\n    for k in range(1, n_circles + 1):\n        # 1. Smart Insertion Strategy\n        # Generate 50 random candidates\n        candidates = rng.random((50, 2))\n        \n        best_p = None\n        best_metric = -np.inf\n        \n        if k == 1:\n            best_p = np.array([0.5, 0.5])\n            best_metric = 0.5\n        else:\n            # Extract existing data\n            data = np.array(circles)\n            ex_xy = data[:, :2]\n            ex_r = data[:, 2]\n            \n            for p in candidates:\n                x, y = p\n                # Distance to boundaries (max radius limited by walls)\n                d_bound = min(x, 1-x, y, 1-y)\n                \n                # Distance to existing circles (max radius limited by neighbors)\n                # dist(p, c_j) - r_j\n                dists = np.linalg.norm(ex_xy - p, axis=1) - ex_r\n                d_circle = np.min(dists)\n                \n                # Max feasible radius at this point (Maximin)\n                r_feas = min(d_bound, d_circle)\n                \n                # We pick the position that allows the largest radius (or least overlap)\n                if r_feas > best_metric:\n                    best_metric = r_feas\n                    best_p = p\n        \n        # Initial radius: prevent negative start if possible\n        init_r = max(best_metric, 1e-4)\n        \n        # Add new circle to the list\n        circles.append(np.array([best_p[0], best_p[1], init_r]))\n        \n        # 2. Local Optimizer (SLSQP)\n        # Flatten state vector: [x1, y1, r1, x2, y2, r2, ...]\n        x0 = np.array(circles).flatten()\n        n = len(circles)\n        \n        # Bounds: x, y in [0, 1], r >= 0\n        bounds = []\n        for _ in range(n):\n            bounds.extend([(0, 1), (0, 1), (0, None)])\n            \n        # Precompute indices for pairwise constraints\n        idx_i, idx_j = np.tril_indices(n, -1)\n        \n        # Define Objective: Minimize negative sum of radii\n        def objective(x):\n            return -np.sum(x[2::3])\n        \n        def obj_jac(x):\n            g = np.zeros_like(x)\n            g[2::3] = -1.0\n            return g\n        \n        # Constraints\n        def constraints_func(x):\n            P = x.reshape((n, 3))\n            X, Y, R = P[:,0], P[:,1], P[:,2]\n            \n            # Boundary constraints (val >= 0)\n            c1 = X - R         # x >= r\n            c2 = 1 - X - R     # x <= 1 - r\n            c3 = Y - R         # y >= r\n            c4 = 1 - Y - R     # y <= 1 - r\n            \n            # Pairwise constraints\n            if len(idx_i) > 0:\n                dx = X[idx_i] - X[idx_j]\n                dy = Y[idx_i] - Y[idx_j]\n                sr = R[idx_i] + R[idx_j]\n                # dist^2 >= (r_i + r_j)^2\n                c_pair = (dx**2 + dy**2) - sr**2\n                return np.concatenate([c1, c2, c3, c4, c_pair])\n            else:\n                return np.concatenate([c1, c2, c3, c4])\n        \n        # Jacobian of constraints\n        def constraints_jac(x):\n            P = x.reshape((n, 3))\n            X, Y, R = P[:,0], P[:,1], P[:,2]\n            \n            n_vars = 3 * n\n            n_bound = 4 * n\n            n_pair = len(idx_i)\n            total_constr = n_bound + n_pair\n            \n            jac = np.zeros((total_constr, n_vars))\n            \n            # Boundary jacobian\n            # c1: X - R\n            rows_c1 = np.arange(n)\n            jac[rows_c1, 3*rows_c1] = 1.0\n            jac[rows_c1, 3*rows_c1+2] = -1.0\n            \n            # c2: 1 - X - R\n            rows_c2 = np.arange(n, 2*n)\n            ci = np.arange(n)\n            jac[rows_c2, 3*ci] = -1.0\n            jac[rows_c2, 3*ci+2] = -1.0\n            \n            # c3: Y - R\n            rows_c3 = np.arange(2*n, 3*n)\n            jac[rows_c3, 3*ci+1] = 1.0\n            jac[rows_c3, 3*ci+2] = -1.0\n            \n            # c4: 1 - Y - R\n            rows_c4 = np.arange(3*n, 4*n)\n            jac[rows_c4, 3*ci+1] = -1.0\n            jac[rows_c4, 3*ci+2] = -1.0\n            \n            # Pairwise jacobian\n            if n_pair > 0:\n                offset = 4*n\n                rows = np.arange(offset, offset + n_pair)\n                \n                dx = X[idx_i] - X[idx_j]\n                dy = Y[idx_i] - Y[idx_j]\n                sr = R[idx_i] + R[idx_j]\n                \n                # Derivatives w.r.t i\n                jac[rows, 3*idx_i] = 2 * dx\n                jac[rows, 3*idx_i+1] = 2 * dy\n                jac[rows, 3*idx_i+2] = -2 * sr\n                \n                # Derivatives w.r.t j\n                jac[rows, 3*idx_j] = -2 * dx\n                jac[rows, 3*idx_j+1] = -2 * dy\n                jac[rows, 3*idx_j+2] = -2 * sr\n                \n            return jac\n\n        # Run optimization for current N circles\n        # ftol=1e-4 is sufficient for intermediate steps\n        res = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            jac=obj_jac,\n            bounds=bounds,\n            constraints={'type': 'ineq', 'fun': constraints_func, 'jac': constraints_jac},\n            options={'maxiter': 200, 'ftol': 1e-4}\n        )\n        \n        # Update circles with optimized result\n        circles = res.x.reshape((n, 3)).tolist()\n\n    # Final Polish: Run optimization with higher precision on the full set\n    x0 = np.array(circles).flatten()\n    n = n_circles\n    idx_i, idx_j = np.tril_indices(n, -1)\n    \n    # We reuse the functions defined in the last iteration (which correspond to n=26)\n    res = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        jac=obj_jac,\n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraints_func, 'jac': constraints_jac},\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n    \n    final_data = res.x.reshape((n, 3))\n    centers = final_data[:, :2]\n    radii = final_data[:, 2]\n    \n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T10:45:42.310674",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 340,
        "candidates_token_count": 2066,
        "thoughts_token_count": 12351
      },
      "response_text_len": 6314
    }
  }
}