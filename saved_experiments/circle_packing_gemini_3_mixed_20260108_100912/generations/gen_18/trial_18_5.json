{
  "trial_id": "trial_18_5",
  "generation": 18,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef construct_packing():\n    \"\"\"\n    Packs 26 circles into a unit square to maximize the sum of their radii.\n    Uses the Basin Hopping global optimization algorithm with SLSQP local minimization.\n    \"\"\"\n    n = 26\n    \n    def objective(p):\n        # The goal is to maximize the sum of radii.\n        # Here we simplify the problem by assuming all radii are equal to r.\n        # p = [x1, ..., xn, y1, ..., yn, r]\n        # Sum of radii = n * r\n        return -p[-1] * n\n\n    def constraints(p):\n        x = p[:n]\n        y = p[n:2*n]\n        r = p[-1]\n        \n        # Boundary constraints: All circles must be inside [0, 1] x [0, 1]\n        # x_i - r >= 0, 1 - x_i - r >= 0, y_i - r >= 0, 1 - y_i - r >= 0\n        c_boundary = np.zeros(4 * n)\n        c_boundary[0:n] = x - r\n        c_boundary[n:2*n] = 1.0 - r - x\n        c_boundary[2*n:3*n] = y - r\n        c_boundary[3*n:4*n] = 1.0 - r - y\n        \n        # Non-overlap constraints: Distance between any two centers >= sum of radii\n        # (x_i - x_j)^2 + (y_i - y_j)^2 >= (2*r)^2\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\n        dist_sq = dx**2 + dy**2\n        \n        # Use only the upper triangle of the distance matrix to avoid redundant constraints\n        iu = np.triu_indices(n, k=1)\n        c_overlap = dist_sq[iu] - 4.0 * r**2\n        \n        return np.concatenate([c_boundary, c_overlap])\n\n    best_p = None\n    best_val = float('inf')\n\n    # SLSQP is efficient for problems with many inequality constraints.\n    minimizer_kwargs = {\n        \"method\": \"SLSQP\",\n        \"constraints\": {\"type\": \"ineq\", \"fun\": constraints},\n        \"bounds\": [(0, 1)] * (2 * n) + [(0, 0.5)],\n        \"options\": {\"maxiter\": 40}\n    }\n\n    # Parallel Basin Hopping strategy: Run 10 independent optimization runs.\n    for i in range(10):\n        # Initial guess: random centers and a small initial radius\n        x0 = np.random.uniform(0.1, 0.9, n)\n        y0 = np.random.uniform(0.1, 0.9, n)\n        r0 = 0.05\n        p0 = np.concatenate([x0, y0, [r0]])\n        \n        # Run basin-hopping to explore the search space\n        res = basinhopping(\n            objective, p0, niter=20,\n            minimizer_kwargs=minimizer_kwargs,\n            stepsize=0.1\n        )\n        \n        if res.fun < best_val:\n            best_val = res.fun\n            best_p = res.x\n\n    if best_p is None:\n        # Fallback in case no solution was found (highly unlikely)\n        best_p = p0\n        best_val = objective(p0)\n\n    # Prepare final output\n    centers = np.column_stack((best_p[:n], best_p[n:2*n]))\n    radii = np.full(n, best_p[-1])\n    sum_radii = -best_val\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"\n    Executes the circle packing construction and returns the results.\n    \"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.5053336878183434,
    "eval_time": 20.140552282333374,
    "error": null
  },
  "prompt": "System: Output ONLY Python code. Solve circle packing (26 circles). \n\nStrategy: **Parallel Basin Hopping**. \n- Generate 10 random initial guesses.\n- Run `basinhopping` on EACH guess with `niter=20`.\n- Return the best result found across all runs.\n\nCRITICAL: Output ONLY a single Python code block starting with ```python and ending with ```. Do not write any text before or after the block.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef construct_packing():\n    \"\"\"\n    Packs 26 circles into a unit square to maximize the sum of their radii.\n    Uses the Basin Hopping global optimization algorithm with SLSQP local minimization.\n    \"\"\"\n    n = 26\n    \n    def objective(p):\n        # The goal is to maximize the sum of radii.\n        # Here we simplify the problem by assuming all radii are equal to r.\n        # p = [x1, ..., xn, y1, ..., yn, r]\n        # Sum of radii = n * r\n        return -p[-1] * n\n\n    def constraints(p):\n        x = p[:n]\n        y = p[n:2*n]\n        r = p[-1]\n        \n        # Boundary constraints: All circles must be inside [0, 1] x [0, 1]\n        # x_i - r >= 0, 1 - x_i - r >= 0, y_i - r >= 0, 1 - y_i - r >= 0\n        c_boundary = np.zeros(4 * n)\n        c_boundary[0:n] = x - r\n        c_boundary[n:2*n] = 1.0 - r - x\n        c_boundary[2*n:3*n] = y - r\n        c_boundary[3*n:4*n] = 1.0 - r - y\n        \n        # Non-overlap constraints: Distance between any two centers >= sum of radii\n        # (x_i - x_j)^2 + (y_i - y_j)^2 >= (2*r)^2\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\n        dist_sq = dx**2 + dy**2\n        \n        # Use only the upper triangle of the distance matrix to avoid redundant constraints\n        iu = np.triu_indices(n, k=1)\n        c_overlap = dist_sq[iu] - 4.0 * r**2\n        \n        return np.concatenate([c_boundary, c_overlap])\n\n    best_p = None\n    best_val = float('inf')\n\n    # SLSQP is efficient for problems with many inequality constraints.\n    minimizer_kwargs = {\n        \"method\": \"SLSQP\",\n        \"constraints\": {\"type\": \"ineq\", \"fun\": constraints},\n        \"bounds\": [(0, 1)] * (2 * n) + [(0, 0.5)],\n        \"options\": {\"maxiter\": 40}\n    }\n\n    # Parallel Basin Hopping strategy: Run 10 independent optimization runs.\n    for i in range(10):\n        # Initial guess: random centers and a small initial radius\n        x0 = np.random.uniform(0.1, 0.9, n)\n        y0 = np.random.uniform(0.1, 0.9, n)\n        r0 = 0.05\n        p0 = np.concatenate([x0, y0, [r0]])\n        \n        # Run basin-hopping to explore the search space\n        res = basinhopping(\n            objective, p0, niter=20,\n            minimizer_kwargs=minimizer_kwargs,\n            stepsize=0.1\n        )\n        \n        if res.fun < best_val:\n            best_val = res.fun\n            best_p = res.x\n\n    if best_p is None:\n        # Fallback in case no solution was found (highly unlikely)\n        best_p = p0\n        best_val = objective(p0)\n\n    # Prepare final output\n    centers = np.column_stack((best_p[:n], best_p[n:2*n]))\n    radii = np.full(n, best_p[-1])\n    sum_radii = -best_val\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"\n    Executes the circle packing construction and returns the results.\n    \"\"\"\n    return construct_packing()\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T11:36:56.339234",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 319,
        "candidates_token_count": 983,
        "thoughts_token_count": 13285
      },
      "response_text_len": 2929
    }
  }
}