{
  "trial_id": "trial_18_0",
  "generation": 18,
  "parent_id": "trial_17_3",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef construct_packing():\n    N = 26\n    \n    # Initialize with a heuristic pattern\n    # 5 rows: 5, 5, 6, 5, 5\n    x0_centers = []\n    row_counts = [5, 5, 6, 5, 5]\n    n_rows = len(row_counts)\n    \n    ys = np.linspace(0.1, 0.9, n_rows)\n    for i, count in enumerate(row_counts):\n        xs = np.linspace(0.1, 0.9, count)\n        for x in xs:\n            x0_centers.append([x, ys[i]])\n            \n    x0_centers = np.array(x0_centers)\n    if len(x0_centers) < N:\n        extra = N - len(x0_centers)\n        x0_centers = np.vstack([x0_centers, np.random.uniform(0.1, 0.9, (extra, 2))])\n    x0_centers = x0_centers[:N]\n    \n    # Add noise\n    np.random.seed(42)\n    x0_centers += np.random.uniform(-0.02, 0.02, x0_centers.shape)\n    x0_centers = np.clip(x0_centers, 0.01, 0.99)\n    \n    # Initial radii\n    x0_radii = np.ones(N) * 0.08\n    x0 = np.concatenate([x0_centers.flatten(), x0_radii])\n    \n    bounds = [(0, 1)] * (2 * N) + [(0.001, 0.5)] * N\n    \n    def get_arrays(p):\n        centers = p[:2*N].reshape((N, 2))\n        radii = p[2*N:]\n        return centers, radii\n    \n    def objective(p, penalty_weight=1e4):\n        c, r = get_arrays(p)\n        obj = -np.sum(r)\n        \n        # Boundary constraints\n        p_bound = np.sum(np.maximum(0, r - c[:, 0])**2) + \\\n                  np.sum(np.maximum(0, c[:, 0] + r - 1)**2) + \\\n                  np.sum(np.maximum(0, r - c[:, 1])**2) + \\\n                  np.sum(np.maximum(0, c[:, 1] + r - 1)**2)\n                  \n        # Overlap constraints\n        r_sum_sq = (r[:, None] + r[None, :])**2\n        diff = c[:, None, :] - c[None, :, :]\n        d_sq = np.sum(diff**2, axis=-1)\n        mask = np.triu(np.ones((N, N), dtype=bool), k=1)\n        p_overlap = np.sum(np.maximum(0, r_sum_sq[mask] - d_sq[mask])**2)\n        \n        return obj + penalty_weight * (p_bound + p_overlap)\n\n    class RandomDisplacement:\n        def __init__(self, stepsize=0.05):\n            self.stepsize = stepsize\n        def __call__(self, x):\n            s = self.stepsize\n            x_new = x.copy()\n            x_new[:2*N] += np.random.uniform(-s, s, 2*N)\n            x_new[2*N:] += np.random.uniform(-s*0.2, s*0.2, N)\n            # Clip to bounds\n            lower = np.array([b[0] for b in bounds])\n            upper = np.array([b[1] for b in bounds])\n            x_new = np.clip(x_new, lower, upper)\n            return x_new\n\n    minimizer_kwargs = {\n        \"method\": \"L-BFGS-B\",\n        \"bounds\": bounds,\n        \"args\": (1e4,),\n        \"options\": {\"maxiter\": 50, \"ftol\": 1e-4}\n    }\n\n    # Run Basin Hopping\n    res = basinhopping(\n        objective,\n        x0,\n        niter=100,\n        T=0.01,\n        stepsize=0.05,\n        take_step=RandomDisplacement(0.05),\n        minimizer_kwargs=minimizer_kwargs,\n        seed=42\n    )\n    \n    # Polish\n    minimizer_kwargs_polish = {\n        \"method\": \"L-BFGS-B\",\n        \"bounds\": bounds,\n        \"args\": (1e9,),\n        \"options\": {\"maxiter\": 2000, \"ftol\": 1e-10}\n    }\n    res_final = minimize(objective, res.x, **minimizer_kwargs_polish)\n    \n    centers, radii = get_arrays(res_final.x)\n    \n    # Post-process to ensure strict validity\n    for i in range(N):\n        radii[i] = min(radii[i], centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n        \n    for _ in range(1000):\n        clean = True\n        for i in range(N):\n            for j in range(i+1, N):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                sum_r = radii[i] + radii[j]\n                if sum_r > dist:\n                    clean = False\n                    overlap = sum_r - dist + 1e-12\n                    # Shrink proportionally\n                    f_i = radii[i] / sum_r\n                    f_j = radii[j] / sum_r\n                    radii[i] -= overlap * f_i\n                    radii[j] -= overlap * f_j\n        if clean:\n            break\n            \n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.475059706599433,
    "eval_time": 23.39702820777893,
    "error": null
  },
  "prompt": "System: Output ONLY Python code. Refine {CODE_TRIAL_17_3}. \n\nStrategy: **More Exploration**. \n- The parent code uses `T=0.001` and `stepsize=0.02`. \n- Change to `T=0.01` and `stepsize=0.05` to explore a wider area around the champion.\n- Increase `niter` to 100.\n\nCRITICAL: Output ONLY a single Python code block starting with ```python and ending with ```. Do not write any text before or after the block.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef construct_packing():\n    N = 26\n    \n    # Initialize with a heuristic pattern\n    # 5 rows: 5, 5, 6, 5, 5\n    x0_centers = []\n    row_counts = [5, 5, 6, 5, 5]\n    n_rows = len(row_counts)\n    \n    ys = np.linspace(0.1, 0.9, n_rows)\n    for i, count in enumerate(row_counts):\n        xs = np.linspace(0.1, 0.9, count)\n        for x in xs:\n            x0_centers.append([x, ys[i]])\n            \n    x0_centers = np.array(x0_centers)\n    if len(x0_centers) < N:\n        extra = N - len(x0_centers)\n        x0_centers = np.vstack([x0_centers, np.random.uniform(0.1, 0.9, (extra, 2))])\n    x0_centers = x0_centers[:N]\n    \n    # Add noise\n    np.random.seed(42)\n    x0_centers += np.random.uniform(-0.02, 0.02, x0_centers.shape)\n    x0_centers = np.clip(x0_centers, 0.01, 0.99)\n    \n    # Initial radii\n    x0_radii = np.ones(N) * 0.08\n    x0 = np.concatenate([x0_centers.flatten(), x0_radii])\n    \n    bounds = [(0, 1)] * (2 * N) + [(0.001, 0.5)] * N\n    \n    def get_arrays(p):\n        centers = p[:2*N].reshape((N, 2))\n        radii = p[2*N:]\n        return centers, radii\n    \n    def objective(p, penalty_weight=1e4):\n        c, r = get_arrays(p)\n        obj = -np.sum(r)\n        \n        # Boundary constraints\n        p_bound = np.sum(np.maximum(0, r - c[:, 0])**2) + \\\n                  np.sum(np.maximum(0, c[:, 0] + r - 1)**2) + \\\n                  np.sum(np.maximum(0, r - c[:, 1])**2) + \\\n                  np.sum(np.maximum(0, c[:, 1] + r - 1)**2)\n                  \n        # Overlap constraints\n        r_sum_sq = (r[:, None] + r[None, :])**2\n        diff = c[:, None, :] - c[None, :, :]\n        d_sq = np.sum(diff**2, axis=-1)\n        mask = np.triu(np.ones((N, N), dtype=bool), k=1)\n        p_overlap = np.sum(np.maximum(0, r_sum_sq[mask] - d_sq[mask])**2)\n        \n        return obj + penalty_weight * (p_bound + p_overlap)\n\n    class RandomDisplacement:\n        def __init__(self, stepsize=0.05):\n            self.stepsize = stepsize\n        def __call__(self, x):\n            s = self.stepsize\n            x_new = x.copy()\n            x_new[:2*N] += np.random.uniform(-s, s, 2*N)\n            x_new[2*N:] += np.random.uniform(-s*0.2, s*0.2, N)\n            # Clip to bounds\n            lower = np.array([b[0] for b in bounds])\n            upper = np.array([b[1] for b in bounds])\n            x_new = np.clip(x_new, lower, upper)\n            return x_new\n\n    minimizer_kwargs = {\n        \"method\": \"L-BFGS-B\",\n        \"bounds\": bounds,\n        \"args\": (1e4,),\n        \"options\": {\"maxiter\": 50, \"ftol\": 1e-4}\n    }\n\n    # Run Basin Hopping\n    res = basinhopping(\n        objective,\n        x0,\n        niter=100,\n        T=0.01,\n        stepsize=0.05,\n        take_step=RandomDisplacement(0.05),\n        minimizer_kwargs=minimizer_kwargs,\n        seed=42\n    )\n    \n    # Polish\n    minimizer_kwargs_polish = {\n        \"method\": \"L-BFGS-B\",\n        \"bounds\": bounds,\n        \"args\": (1e9,),\n        \"options\": {\"maxiter\": 2000, \"ftol\": 1e-10}\n    }\n    res_final = minimize(objective, res.x, **minimizer_kwargs_polish)\n    \n    centers, radii = get_arrays(res_final.x)\n    \n    # Post-process to ensure strict validity\n    for i in range(N):\n        radii[i] = min(radii[i], centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n        \n    for _ in range(1000):\n        clean = True\n        for i in range(N):\n            for j in range(i+1, N):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                sum_r = radii[i] + radii[j]\n                if sum_r > dist:\n                    clean = False\n                    overlap = sum_r - dist + 1e-12\n                    # Shrink proportionally\n                    f_i = radii[i] / sum_r\n                    f_j = radii[j] / sum_r\n                    radii[i] -= overlap * f_i\n                    radii[j] -= overlap * f_j\n        if clean:\n            break\n            \n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T11:37:54.055117",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 352,
        "candidates_token_count": 1496,
        "thoughts_token_count": 10569
      },
      "response_text_len": 4053
    }
  }
}