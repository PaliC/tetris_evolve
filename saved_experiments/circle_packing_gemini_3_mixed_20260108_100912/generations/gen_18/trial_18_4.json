{
  "trial_id": "trial_18_4",
  "generation": 18,
  "parent_id": "trial_11_11",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, dual_annealing, linprog\n\ndef construct_packing():\n    N = 26\n    \n    # Helper to unpack variables\n    # params: x1, y1, r1, x2, y2, r2, ...\n    def unpack(params):\n        data = params.reshape((N, 3))\n        return data[:, :2], data[:, 2]\n\n    # Objective function: Minimize -sum(radii) + Penalties\n    def objective(params):\n        centers, radii = unpack(params)\n        \n        # 1. Boundary Constraints\n        # r <= x <= 1-r  =>  r-x <= 0  and  x+r-1 <= 0\n        # r <= y <= 1-r  =>  r-y <= 0  and  y+r-1 <= 0\n        v_min = np.maximum(0, radii[:, None] - centers) \n        v_max = np.maximum(0, centers + radii[:, None] - 1)\n        p_bound = np.sum(v_min**2 + v_max**2)\n        \n        # 2. Overlap Constraints\n        # dist_ij >= r_i + r_j\n        diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dist_sq = np.sum(diff**2, axis=2)\n        dist = np.sqrt(dist_sq + 1e-12)\n        np.fill_diagonal(dist, np.inf)\n        \n        r_sum = radii[:, np.newaxis] + radii[np.newaxis, :]\n        p_overlap = np.sum(np.maximum(0, r_sum - dist)**2) / 2.0\n        \n        # 3. Positivity\n        p_neg = np.sum(np.maximum(0, -radii)**2)\n        \n        # Weighted penalty\n        # 1e5 is sufficiently large to enforce constraints for the optimizer\n        return -np.sum(radii) + 1e5 * (p_bound + p_overlap + p_neg)\n\n    # 1. Initialization\n    # We create a few starting configurations and pick the best one after local optimization\n    starts = []\n    \n    # Grid-based start (5x5 + 1)\n    k = 5\n    gx = np.linspace(1/(2*k), 1-1/(2*k), k)\n    xx, yy = np.meshgrid(gx, gx)\n    c_grid = np.vstack([xx.flatten(), yy.flatten()]).T\n    # Add 26th point near center\n    c_grid = np.vstack([c_grid, [0.5, 0.5]])\n    # Add small noise\n    c_grid += np.random.uniform(-0.01, 0.01, c_grid.shape)\n    r_grid = np.full(N, 0.09)\n    starts.append(np.hstack([c_grid, r_grid[:, None]]).flatten())\n    \n    # Random starts\n    for _ in range(2):\n        c_rand = np.random.rand(N, 2)\n        r_rand = np.full(N, 0.05)\n        starts.append(np.hstack([c_rand, r_rand[:, None]]).flatten())\n\n    # Bounds for variables: x,y in [0,1], r in [0, 0.25]\n    base_bounds = []\n    for _ in range(N):\n        base_bounds.extend([(0, 1), (0, 1), (0.001, 0.25)])\n\n    # Phase 2: Find \"Champion\" via Local Optimization\n    best_x = None\n    best_fun = float('inf')\n    \n    for x0 in starts:\n        res = minimize(objective, x0, method='L-BFGS-B', bounds=base_bounds, options={'maxiter': 500})\n        if res.fun < best_fun:\n            best_fun = res.fun\n            best_x = res.x\n            \n    # Phase 3: Refine Champion using Dual Annealing\n    # Restrict bounds to a tight window around the current best solution\n    da_bounds = []\n    c_curr, r_curr = unpack(best_x)\n    w_pos = 0.1  # Window for position\n    w_rad = 0.05 # Window for radius\n    \n    for i in range(N):\n        cx, cy = c_curr[i]\n        rr = r_curr[i]\n        da_bounds.append((max(0, cx - w_pos), min(1, cx + w_pos)))\n        da_bounds.append((max(0, cy - w_pos), min(1, cy + w_pos)))\n        da_bounds.append((max(0.001, rr - w_rad), min(0.25, rr + w_rad)))\n        \n    # Dual Annealing allows escaping local optima within the promising region\n    res_da = dual_annealing(objective, bounds=da_bounds, x0=best_x, maxiter=200, initial_temp=100)\n    refined_x = res_da.x\n    \n    # Phase 4: Final Polish of Centers\n    res_final = minimize(objective, refined_x, method='L-BFGS-B', bounds=base_bounds, options={'ftol': 1e-12, 'maxiter': 1000})\n    final_centers, _ = unpack(res_final.x)\n    \n    # Phase 5: Exact Radius Optimization via Linear Programming\n    # Fix centers, maximize sum(r) subject to valid packing constraints\n    # Variables: r_1, ..., r_N\n    c_lp = -np.ones(N) # Maximize sum(r) -> Minimize -sum(r)\n    \n    A_ub = []\n    b_ub = []\n    \n    # Constraint: r_i + r_j <= dist_ij\n    for i in range(N):\n        for j in range(i+1, N):\n            dist = np.linalg.norm(final_centers[i] - final_centers[j])\n            row = np.zeros(N)\n            row[i] = 1\n            row[j] = 1\n            A_ub.append(row)\n            b_ub.append(dist)\n            \n    # Bounds: 0 <= r_i <= dist_to_wall\n    r_bounds = []\n    for i in range(N):\n        cx, cy = final_centers[i]\n        max_r = min(cx, 1-cx, cy, 1-cy)\n        r_bounds.append((0, max_r))\n        \n    # Solve LP\n    # Default method (usually highs or interior-point) is robust\n    res_lp = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=r_bounds)\n    \n    if res_lp.success:\n        final_radii = res_lp.x\n    else:\n        # Fallback if LP fails: derive safe radii from centers\n        final_radii = np.zeros(N)\n        for i in range(N):\n            d_wall = min(final_centers[i,0], 1-final_centers[i,0], final_centers[i,1], 1-final_centers[i,1])\n            d_neigh = np.inf\n            for j in range(N):\n                if i != j:\n                    d = np.linalg.norm(final_centers[i] - final_centers[j])\n                    d_neigh = min(d_neigh, d/2.0)\n            final_radii[i] = min(d_wall, d_neigh)\n\n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.524189028945744,
    "eval_time": 3.5915801525115967,
    "error": null
  },
  "prompt": "System: Output ONLY Python code. Refine {CODE_TRIAL_11_11}. \n\nStrategy: **Dual Annealing**. \n- Instead of Basin Hopping, use `scipy.optimize.dual_annealing` on the champion's coordinates.\n- Set tight bounds around the current best solution (+/- 0.05).\n- This is a global search restricted to the promising region.\n\nCRITICAL: Output ONLY a single Python code block starting with ```python and ending with ```. Do not write any text before or after the block.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, dual_annealing, linprog\n\ndef construct_packing():\n    N = 26\n    \n    # Helper to unpack variables\n    # params: x1, y1, r1, x2, y2, r2, ...\n    def unpack(params):\n        data = params.reshape((N, 3))\n        return data[:, :2], data[:, 2]\n\n    # Objective function: Minimize -sum(radii) + Penalties\n    def objective(params):\n        centers, radii = unpack(params)\n        \n        # 1. Boundary Constraints\n        # r <= x <= 1-r  =>  r-x <= 0  and  x+r-1 <= 0\n        # r <= y <= 1-r  =>  r-y <= 0  and  y+r-1 <= 0\n        v_min = np.maximum(0, radii[:, None] - centers) \n        v_max = np.maximum(0, centers + radii[:, None] - 1)\n        p_bound = np.sum(v_min**2 + v_max**2)\n        \n        # 2. Overlap Constraints\n        # dist_ij >= r_i + r_j\n        diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dist_sq = np.sum(diff**2, axis=2)\n        dist = np.sqrt(dist_sq + 1e-12)\n        np.fill_diagonal(dist, np.inf)\n        \n        r_sum = radii[:, np.newaxis] + radii[np.newaxis, :]\n        p_overlap = np.sum(np.maximum(0, r_sum - dist)**2) / 2.0\n        \n        # 3. Positivity\n        p_neg = np.sum(np.maximum(0, -radii)**2)\n        \n        # Weighted penalty\n        # 1e5 is sufficiently large to enforce constraints for the optimizer\n        return -np.sum(radii) + 1e5 * (p_bound + p_overlap + p_neg)\n\n    # 1. Initialization\n    # We create a few starting configurations and pick the best one after local optimization\n    starts = []\n    \n    # Grid-based start (5x5 + 1)\n    k = 5\n    gx = np.linspace(1/(2*k), 1-1/(2*k), k)\n    xx, yy = np.meshgrid(gx, gx)\n    c_grid = np.vstack([xx.flatten(), yy.flatten()]).T\n    # Add 26th point near center\n    c_grid = np.vstack([c_grid, [0.5, 0.5]])\n    # Add small noise\n    c_grid += np.random.uniform(-0.01, 0.01, c_grid.shape)\n    r_grid = np.full(N, 0.09)\n    starts.append(np.hstack([c_grid, r_grid[:, None]]).flatten())\n    \n    # Random starts\n    for _ in range(2):\n        c_rand = np.random.rand(N, 2)\n        r_rand = np.full(N, 0.05)\n        starts.append(np.hstack([c_rand, r_rand[:, None]]).flatten())\n\n    # Bounds for variables: x,y in [0,1], r in [0, 0.25]\n    base_bounds = []\n    for _ in range(N):\n        base_bounds.extend([(0, 1), (0, 1), (0.001, 0.25)])\n\n    # Phase 2: Find \"Champion\" via Local Optimization\n    best_x = None\n    best_fun = float('inf')\n    \n    for x0 in starts:\n        res = minimize(objective, x0, method='L-BFGS-B', bounds=base_bounds, options={'maxiter': 500})\n        if res.fun < best_fun:\n            best_fun = res.fun\n            best_x = res.x\n            \n    # Phase 3: Refine Champion using Dual Annealing\n    # Restrict bounds to a tight window around the current best solution\n    da_bounds = []\n    c_curr, r_curr = unpack(best_x)\n    w_pos = 0.1  # Window for position\n    w_rad = 0.05 # Window for radius\n    \n    for i in range(N):\n        cx, cy = c_curr[i]\n        rr = r_curr[i]\n        da_bounds.append((max(0, cx - w_pos), min(1, cx + w_pos)))\n        da_bounds.append((max(0, cy - w_pos), min(1, cy + w_pos)))\n        da_bounds.append((max(0.001, rr - w_rad), min(0.25, rr + w_rad)))\n        \n    # Dual Annealing allows escaping local optima within the promising region\n    res_da = dual_annealing(objective, bounds=da_bounds, x0=best_x, maxiter=200, initial_temp=100)\n    refined_x = res_da.x\n    \n    # Phase 4: Final Polish of Centers\n    res_final = minimize(objective, refined_x, method='L-BFGS-B', bounds=base_bounds, options={'ftol': 1e-12, 'maxiter': 1000})\n    final_centers, _ = unpack(res_final.x)\n    \n    # Phase 5: Exact Radius Optimization via Linear Programming\n    # Fix centers, maximize sum(r) subject to valid packing constraints\n    # Variables: r_1, ..., r_N\n    c_lp = -np.ones(N) # Maximize sum(r) -> Minimize -sum(r)\n    \n    A_ub = []\n    b_ub = []\n    \n    # Constraint: r_i + r_j <= dist_ij\n    for i in range(N):\n        for j in range(i+1, N):\n            dist = np.linalg.norm(final_centers[i] - final_centers[j])\n            row = np.zeros(N)\n            row[i] = 1\n            row[j] = 1\n            A_ub.append(row)\n            b_ub.append(dist)\n            \n    # Bounds: 0 <= r_i <= dist_to_wall\n    r_bounds = []\n    for i in range(N):\n        cx, cy = final_centers[i]\n        max_r = min(cx, 1-cx, cy, 1-cy)\n        r_bounds.append((0, max_r))\n        \n    # Solve LP\n    # Default method (usually highs or interior-point) is robust\n    res_lp = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=r_bounds)\n    \n    if res_lp.success:\n        final_radii = res_lp.x\n    else:\n        # Fallback if LP fails: derive safe radii from centers\n        final_radii = np.zeros(N)\n        for i in range(N):\n            d_wall = min(final_centers[i,0], 1-final_centers[i,0], final_centers[i,1], 1-final_centers[i,1])\n            d_neigh = np.inf\n            for j in range(N):\n                if i != j:\n                    d = np.linalg.norm(final_centers[i] - final_centers[j])\n                    d_neigh = min(d_neigh, d/2.0)\n            final_radii[i] = min(d_wall, d_neigh)\n\n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T11:37:25.955573",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 342,
        "candidates_token_count": 1906,
        "thoughts_token_count": 10171
      },
      "response_text_len": 5241
    }
  }
}