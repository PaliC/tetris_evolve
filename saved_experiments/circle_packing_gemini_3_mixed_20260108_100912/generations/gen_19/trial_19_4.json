{
  "trial_id": "trial_19_4",
  "generation": 19,
  "parent_id": "trial_18_3",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Packs 26 circles into a [0,1]x[0,1] square to maximize the sum of their radii.\n    Uses Sequential Quadratic Programming (SLSQP) with a structured initial guess.\n    \"\"\"\n    n = 26\n    \n    # Strategy: Initialize centers in a structured grid that fits 26 circles.\n    # We use 5 rows, with the middle row containing 6 circles and others 5.\n    centers = []\n    for r_idx in range(5):\n        num_cols = 6 if r_idx == 2 else 5\n        for c_idx in range(num_cols):\n            # Distribute centers evenly within the row/column\n            x = (c_idx + 0.5) / num_cols\n            y = (r_idx + 0.5) / 5\n            centers.append([x, y])\n    \n    centers = np.array(centers)\n    \n    # State vector: [x_0...x_25, y_0...y_25, r_0...r_25]\n    x0 = np.zeros(3 * n)\n    x0[0:n] = centers[:, 0]\n    x0[n:2*n] = centers[:, 1]\n    x0[2*n:3*n] = 0.08  # Start with a safe, non-overlapping radius\n\n    def objective(vars):\n        # Maximize the sum of radii (minimize negative sum)\n        return -np.sum(vars[2*n:3*n])\n\n    def constraints(vars):\n        x = vars[0:n]\n        y = vars[n:2*n]\n        r = vars[2*n:3*n]\n        \n        # Pre-allocate constraint array:\n        # 4 boundary constraints per circle (4*n)\n        # 1 overlap constraint per pair (n*(n-1)/2)\n        c = np.zeros(4*n + n*(n-1)//2)\n        \n        # Circle boundaries must stay within [0,1]\n        c[0:n] = x - r           # x_i >= r_i\n        c[n:2*n] = 1.0 - x - r   # x_i + r_i <= 1\n        c[2*n:3*n] = y - r       # y_i >= r_i\n        c[3*n:4*n] = 1.0 - y - r # y_i + r_i <= 1\n        \n        # No-overlap constraint: distance between centers >= sum of radii\n        # Represented as: (x_i - x_j)^2 + (y_i - y_j)^2 - (r_i + r_j)^2 >= 0\n        idx = 4*n\n        for i in range(n):\n            for j in range(i + 1, n):\n                c[idx] = (x[i] - x[j])**2 + (y[i] - y[j])**2 - (r[i] + r[j])**2\n                idx += 1\n        return c\n\n    # Variable bounds: x, y in [0, 1], r in [0, 0.5]\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n\n    # Optimize using SLSQP\n    res = minimize(\n        objective, \n        x0, \n        method='SLSQP',\n        constraints={'type': 'ineq', 'fun': constraints},\n        bounds=bounds,\n        options={'maxiter': 100, 'ftol': 1e-7}\n    )\n    \n    # Extract final results\n    v = res.x\n    final_centers = np.stack([v[0:n], v[n:2*n]], axis=1)\n    final_radii = v[2*n:3*n]\n    sum_radii = np.sum(final_radii)\n    \n    return final_centers, final_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.5889048999671456,
    "eval_time": 0.48062896728515625,
    "error": null
  },
  "prompt": "System: Output ONLY Python code. Refine {CODE_TRIAL_18_3}. \n\nStrategy: **Sequential Quadratic Programming**. \n- Explicitly define the constraints as a list of dictionaries.\n- Use `method='SLSQP'`.\n- Ensure gradients are handled automatically (jac='2-point').\n\nCRITICAL: Output ONLY a single Python code block starting with ```python and ending with ```. Do not write any text before or after the block.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Packs 26 circles into a [0,1]x[0,1] square to maximize the sum of their radii.\n    Uses Sequential Quadratic Programming (SLSQP) with a structured initial guess.\n    \"\"\"\n    n = 26\n    \n    # Strategy: Initialize centers in a structured grid that fits 26 circles.\n    # We use 5 rows, with the middle row containing 6 circles and others 5.\n    centers = []\n    for r_idx in range(5):\n        num_cols = 6 if r_idx == 2 else 5\n        for c_idx in range(num_cols):\n            # Distribute centers evenly within the row/column\n            x = (c_idx + 0.5) / num_cols\n            y = (r_idx + 0.5) / 5\n            centers.append([x, y])\n    \n    centers = np.array(centers)\n    \n    # State vector: [x_0...x_25, y_0...y_25, r_0...r_25]\n    x0 = np.zeros(3 * n)\n    x0[0:n] = centers[:, 0]\n    x0[n:2*n] = centers[:, 1]\n    x0[2*n:3*n] = 0.08  # Start with a safe, non-overlapping radius\n\n    def objective(vars):\n        # Maximize the sum of radii (minimize negative sum)\n        return -np.sum(vars[2*n:3*n])\n\n    def constraints(vars):\n        x = vars[0:n]\n        y = vars[n:2*n]\n        r = vars[2*n:3*n]\n        \n        # Pre-allocate constraint array:\n        # 4 boundary constraints per circle (4*n)\n        # 1 overlap constraint per pair (n*(n-1)/2)\n        c = np.zeros(4*n + n*(n-1)//2)\n        \n        # Circle boundaries must stay within [0,1]\n        c[0:n] = x - r           # x_i >= r_i\n        c[n:2*n] = 1.0 - x - r   # x_i + r_i <= 1\n        c[2*n:3*n] = y - r       # y_i >= r_i\n        c[3*n:4*n] = 1.0 - y - r # y_i + r_i <= 1\n        \n        # No-overlap constraint: distance between centers >= sum of radii\n        # Represented as: (x_i - x_j)^2 + (y_i - y_j)^2 - (r_i + r_j)^2 >= 0\n        idx = 4*n\n        for i in range(n):\n            for j in range(i + 1, n):\n                c[idx] = (x[i] - x[j])**2 + (y[i] - y[j])**2 - (r[i] + r[j])**2\n                idx += 1\n        return c\n\n    # Variable bounds: x, y in [0, 1], r in [0, 0.5]\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n\n    # Optimize using SLSQP\n    res = minimize(\n        objective, \n        x0, \n        method='SLSQP',\n        constraints={'type': 'ineq', 'fun': constraints},\n        bounds=bounds,\n        options={'maxiter': 100, 'ftol': 1e-7}\n    )\n    \n    # Extract final results\n    v = res.x\n    final_centers = np.stack([v[0:n], v[n:2*n]], axis=1)\n    final_radii = v[2*n:3*n]\n    sum_radii = np.sum(final_radii)\n    \n    return final_centers, final_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T11:40:52.985028",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 321,
        "candidates_token_count": 1003,
        "thoughts_token_count": 14201
      },
      "response_text_len": 2641
    }
  }
}