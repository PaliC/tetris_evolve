{
  "trial_id": "trial_19_3",
  "generation": 19,
  "parent_id": "trial_18_3",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint, LinearConstraint, Bounds, basinhopping\n\ndef construct_packing():\n    N = 26\n    \n    # --- Initialization ---\n    # Hexagonal grid heuristic for dense packing\n    points = []\n    rows = 6\n    cols = 6\n    for r in range(rows):\n        for c in range(cols):\n            x = c + 0.5 * (r % 2)\n            y = r * np.sqrt(3)/2\n            points.append([x, y])\n    points = np.array(points)\n    \n    # Normalize to fit in [0.1, 0.9]\n    min_p = np.min(points, axis=0)\n    max_p = np.max(points, axis=0)\n    points = (points - min_p) / (max_p - min_p) * 0.8 + 0.1\n    \n    # Select 26 points closest to center\n    center = np.array([0.5, 0.5])\n    dists = np.sum((points - center)**2, axis=1)\n    indices = np.argsort(dists)[:N]\n    init_pos = points[indices]\n    \n    # Variables vector: [x1, y1, r1, x2, y2, r2, ...]\n    x0 = np.zeros(3 * N)\n    x0[0::3] = init_pos[:, 0]\n    x0[1::3] = init_pos[:, 1]\n    x0[2::3] = 0.05 # Initial small radius\n\n    # --- Optimization Functions ---\n    def unpack(z):\n        return z[0::3], z[1::3], z[2::3]\n\n    def objective(z):\n        return -np.sum(z[2::3])\n\n    def obj_grad(z):\n        g = np.zeros_like(z)\n        g[2::3] = -1.0\n        return g\n\n    # --- Constraints ---\n    # 1. Linear: Boundary constraints (r <= x,y <= 1-r)\n    # 4 constraints per circle\n    A = np.zeros((4 * N, 3 * N))\n    lb = np.full(4 * N, -np.inf)\n    ub = np.full(4 * N, np.inf)\n    \n    for i in range(N):\n        r_idx = 4 * i\n        c_idx = 3 * i\n        # x - r >= 0\n        A[r_idx, c_idx] = 1; A[r_idx, c_idx+2] = -1; lb[r_idx] = 0\n        # y - r >= 0\n        A[r_idx+1, c_idx+1] = 1; A[r_idx+1, c_idx+2] = -1; lb[r_idx+1] = 0\n        # x + r <= 1\n        A[r_idx+2, c_idx] = 1; A[r_idx+2, c_idx+2] = 1; ub[r_idx+2] = 1\n        # y + r <= 1\n        A[r_idx+3, c_idx+1] = 1; A[r_idx+3, c_idx+2] = 1; ub[r_idx+3] = 1\n        \n    lin_constr = LinearConstraint(A, lb, ub)\n\n    # 2. Nonlinear: Overlap constraints\n    pairs = [(i, j) for i in range(N) for j in range(i + 1, N)]\n    n_ov = len(pairs)\n    \n    def overlap_fun(z):\n        res = np.empty(n_ov)\n        x, y, r = unpack(z)\n        for k, (i, j) in enumerate(pairs):\n            res[k] = (x[i]-x[j])**2 + (y[i]-y[j])**2 - (r[i]+r[j])**2\n        return res\n\n    def overlap_jac(z):\n        jac = np.zeros((n_ov, 3 * N))\n        x, y, r = unpack(z)\n        for k, (i, j) in enumerate(pairs):\n            dx = x[i] - x[j]\n            dy = y[i] - y[j]\n            s = r[i] + r[j]\n            jac[k, 3*i] = 2*dx; jac[k, 3*j] = -2*dx\n            jac[k, 3*i+1] = 2*dy; jac[k, 3*j+1] = -2*dy\n            jac[k, 3*i+2] = -2*s; jac[k, 3*j+2] = -2*s\n        return jac\n\n    nonlin_constr = NonlinearConstraint(overlap_fun, 0, np.inf, jac=overlap_jac)\n    \n    # Bounds for x,y,r\n    bounds = Bounds([0]*3*N, [1, 1, 0.5]*N)\n\n    # --- Basin Hopping Setup ---\n    class PerturbStep:\n        def __init__(self, stepsize=0.05):\n            self.step = stepsize\n        def __call__(self, z):\n            znew = z.copy()\n            d = np.random.uniform(-self.step, self.step, size=z.shape)\n            d[2::3] *= 0.1 # Perturb radii less\n            znew += d\n            return np.clip(znew, 0, 1)\n\n    min_kwargs = {\n        'method': 'trust-constr',\n        'jac': obj_grad,\n        'constraints': [lin_constr, nonlin_constr],\n        'bounds': bounds,\n        'options': {'maxiter': 30, 'verbose': 0}\n    }\n\n    # Run optimization\n    # Using niter=50 as requested\n    res = basinhopping(objective, x0, niter=50, minimizer_kwargs=min_kwargs,\n                       take_step=PerturbStep(), T=0.005, seed=42)\n    \n    # Final polish\n    final_res = minimize(objective, res.x, method='trust-constr', jac=obj_grad,\n                         constraints=[lin_constr, nonlin_constr],\n                         bounds=bounds,\n                         options={'maxiter': 500, 'verbose': 0, 'xtol': 1e-8, 'gtol': 1e-8})\n    \n    z_opt = final_res.x\n    x, y, r = unpack(z_opt)\n    \n    # --- Post-Processing (Strict Feasibility) ---\n    # 1. Enforce bounds\n    x = np.clip(x, 0, 1)\n    y = np.clip(y, 0, 1)\n    r = np.maximum(r, 0)\n    # r <= min(x, 1-x, y, 1-y)\n    wall_dist = np.minimum(np.minimum(x, 1-x), np.minimum(y, 1-y))\n    r = np.minimum(r, wall_dist)\n    \n    # 2. Enforce non-overlap\n    for _ in range(1000):\n        violation = False\n        for i in range(N):\n            for j in range(i+1, N):\n                dx = x[i] - x[j]\n                dy = y[i] - y[j]\n                d = np.sqrt(dx*dx + dy*dy)\n                s = r[i] + r[j]\n                if s > d + 1e-13:\n                    violation = True\n                    if s > 0:\n                        scale = (d / s) * 0.999999\n                        r[i] *= scale\n                        r[j] *= scale\n                    else:\n                        r[i] = 0; r[j] = 0\n        if not violation:\n            break\n            \n    centers = np.vstack((x, y)).T\n    return centers, r, np.sum(r)\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.4837669756041363,
    "eval_time": 22.757606983184814,
    "error": null
  },
  "prompt": "System: Output ONLY Python code. Refine {CODE_TRIAL_18_3}. \n\nStrategy: **Trust Region**. \n- Use `minimize(method='trust-constr')` for the local minimization step inside basin hopping.\n- This solver is more robust for hard constraints.\n- `niter=50`.\n\nCRITICAL: Output ONLY a single Python code block starting with ```python and ending with ```. Do not write any text before or after the block.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint, LinearConstraint, Bounds, basinhopping\n\ndef construct_packing():\n    N = 26\n    \n    # --- Initialization ---\n    # Hexagonal grid heuristic for dense packing\n    points = []\n    rows = 6\n    cols = 6\n    for r in range(rows):\n        for c in range(cols):\n            x = c + 0.5 * (r % 2)\n            y = r * np.sqrt(3)/2\n            points.append([x, y])\n    points = np.array(points)\n    \n    # Normalize to fit in [0.1, 0.9]\n    min_p = np.min(points, axis=0)\n    max_p = np.max(points, axis=0)\n    points = (points - min_p) / (max_p - min_p) * 0.8 + 0.1\n    \n    # Select 26 points closest to center\n    center = np.array([0.5, 0.5])\n    dists = np.sum((points - center)**2, axis=1)\n    indices = np.argsort(dists)[:N]\n    init_pos = points[indices]\n    \n    # Variables vector: [x1, y1, r1, x2, y2, r2, ...]\n    x0 = np.zeros(3 * N)\n    x0[0::3] = init_pos[:, 0]\n    x0[1::3] = init_pos[:, 1]\n    x0[2::3] = 0.05 # Initial small radius\n\n    # --- Optimization Functions ---\n    def unpack(z):\n        return z[0::3], z[1::3], z[2::3]\n\n    def objective(z):\n        return -np.sum(z[2::3])\n\n    def obj_grad(z):\n        g = np.zeros_like(z)\n        g[2::3] = -1.0\n        return g\n\n    # --- Constraints ---\n    # 1. Linear: Boundary constraints (r <= x,y <= 1-r)\n    # 4 constraints per circle\n    A = np.zeros((4 * N, 3 * N))\n    lb = np.full(4 * N, -np.inf)\n    ub = np.full(4 * N, np.inf)\n    \n    for i in range(N):\n        r_idx = 4 * i\n        c_idx = 3 * i\n        # x - r >= 0\n        A[r_idx, c_idx] = 1; A[r_idx, c_idx+2] = -1; lb[r_idx] = 0\n        # y - r >= 0\n        A[r_idx+1, c_idx+1] = 1; A[r_idx+1, c_idx+2] = -1; lb[r_idx+1] = 0\n        # x + r <= 1\n        A[r_idx+2, c_idx] = 1; A[r_idx+2, c_idx+2] = 1; ub[r_idx+2] = 1\n        # y + r <= 1\n        A[r_idx+3, c_idx+1] = 1; A[r_idx+3, c_idx+2] = 1; ub[r_idx+3] = 1\n        \n    lin_constr = LinearConstraint(A, lb, ub)\n\n    # 2. Nonlinear: Overlap constraints\n    pairs = [(i, j) for i in range(N) for j in range(i + 1, N)]\n    n_ov = len(pairs)\n    \n    def overlap_fun(z):\n        res = np.empty(n_ov)\n        x, y, r = unpack(z)\n        for k, (i, j) in enumerate(pairs):\n            res[k] = (x[i]-x[j])**2 + (y[i]-y[j])**2 - (r[i]+r[j])**2\n        return res\n\n    def overlap_jac(z):\n        jac = np.zeros((n_ov, 3 * N))\n        x, y, r = unpack(z)\n        for k, (i, j) in enumerate(pairs):\n            dx = x[i] - x[j]\n            dy = y[i] - y[j]\n            s = r[i] + r[j]\n            jac[k, 3*i] = 2*dx; jac[k, 3*j] = -2*dx\n            jac[k, 3*i+1] = 2*dy; jac[k, 3*j+1] = -2*dy\n            jac[k, 3*i+2] = -2*s; jac[k, 3*j+2] = -2*s\n        return jac\n\n    nonlin_constr = NonlinearConstraint(overlap_fun, 0, np.inf, jac=overlap_jac)\n    \n    # Bounds for x,y,r\n    bounds = Bounds([0]*3*N, [1, 1, 0.5]*N)\n\n    # --- Basin Hopping Setup ---\n    class PerturbStep:\n        def __init__(self, stepsize=0.05):\n            self.step = stepsize\n        def __call__(self, z):\n            znew = z.copy()\n            d = np.random.uniform(-self.step, self.step, size=z.shape)\n            d[2::3] *= 0.1 # Perturb radii less\n            znew += d\n            return np.clip(znew, 0, 1)\n\n    min_kwargs = {\n        'method': 'trust-constr',\n        'jac': obj_grad,\n        'constraints': [lin_constr, nonlin_constr],\n        'bounds': bounds,\n        'options': {'maxiter': 30, 'verbose': 0}\n    }\n\n    # Run optimization\n    # Using niter=50 as requested\n    res = basinhopping(objective, x0, niter=50, minimizer_kwargs=min_kwargs,\n                       take_step=PerturbStep(), T=0.005, seed=42)\n    \n    # Final polish\n    final_res = minimize(objective, res.x, method='trust-constr', jac=obj_grad,\n                         constraints=[lin_constr, nonlin_constr],\n                         bounds=bounds,\n                         options={'maxiter': 500, 'verbose': 0, 'xtol': 1e-8, 'gtol': 1e-8})\n    \n    z_opt = final_res.x\n    x, y, r = unpack(z_opt)\n    \n    # --- Post-Processing (Strict Feasibility) ---\n    # 1. Enforce bounds\n    x = np.clip(x, 0, 1)\n    y = np.clip(y, 0, 1)\n    r = np.maximum(r, 0)\n    # r <= min(x, 1-x, y, 1-y)\n    wall_dist = np.minimum(np.minimum(x, 1-x), np.minimum(y, 1-y))\n    r = np.minimum(r, wall_dist)\n    \n    # 2. Enforce non-overlap\n    for _ in range(1000):\n        violation = False\n        for i in range(N):\n            for j in range(i+1, N):\n                dx = x[i] - x[j]\n                dy = y[i] - y[j]\n                d = np.sqrt(dx*dx + dy*dy)\n                s = r[i] + r[j]\n                if s > d + 1e-13:\n                    violation = True\n                    if s > 0:\n                        scale = (d / s) * 0.999999\n                        r[i] *= scale\n                        r[j] *= scale\n                    else:\n                        r[i] = 0; r[j] = 0\n        if not violation:\n            break\n            \n    centers = np.vstack((x, y)).T\n    return centers, r, np.sum(r)\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T11:42:09.111360",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 324,
        "candidates_token_count": 2003,
        "thoughts_token_count": 11599
      },
      "response_text_len": 5082
    }
  }
}