{
  "trial_id": "trial_9_4",
  "generation": 9,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.spatial import Voronoi\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    # Problem constants\n    N = 26\n    ITERATIONS = 50\n    \n    # 1. Initialize random points\n    # Using a fixed seed ensures reproducibility and consistent performance\n    np.random.seed(42)\n    points = np.random.rand(N, 2)\n    \n    # Keep points slightly away from boundaries to avoid degenerate Voronoi cells initially\n    points = np.clip(points, 1e-5, 1 - 1e-5)\n\n    # 2. Voronoi Relaxation (Lloyd's Algorithm)\n    for _ in range(ITERATIONS):\n        # Create 9 copies of the points to simulate periodic/hard boundaries\n        # This ensures Voronoi cells for the internal [0,1] points are correctly clipped\n        # by the unit square walls (bisectors with reflections are exactly the axes).\n        \n        x = points[:, 0]\n        y = points[:, 1]\n        \n        # Reflections across axes and corners\n        # Center: (x, y)\n        # Neighbors:\n        # Left: (-x, y), Right: (2-x, y)\n        # Down: (x, -y), Up: (x, 2-y)\n        # Corners: (-x, -y), (-x, 2-y), (2-x, -y), (2-x, 2-y)\n        \n        # Construct arrays for all 9 tiles\n        # Offsets for reflections:\n        # We transform x -> -x or 2-x\n        # But simpler is to construct the specific reflection coordinates\n        \n        p_c = points\n        p_l = np.column_stack((-x, y))\n        p_r = np.column_stack((2-x, y))\n        p_d = np.column_stack((x, -y))\n        p_u = np.column_stack((x, 2-y))\n        \n        p_ld = np.column_stack((-x, -y))\n        p_lu = np.column_stack((-x, 2-y))\n        p_rd = np.column_stack((2-x, -y))\n        p_ru = np.column_stack((2-x, 2-y))\n        \n        # Order matters: first N points are the original ones\n        all_points = np.vstack([p_c, p_l, p_r, p_d, p_u, p_ld, p_lu, p_rd, p_ru])\n        \n        try:\n            vor = Voronoi(all_points)\n        except Exception:\n            # In case of Qhull error (rare with random points), perturbation helps\n            points += np.random.normal(0, 1e-5, points.shape)\n            points = np.clip(points, 1e-5, 1 - 1e-5)\n            continue\n\n        new_points = []\n        for i in range(N):\n            region_idx = vor.point_region[i]\n            region = vor.regions[region_idx]\n            \n            # The region for the central points should be closed and valid\n            if len(region) == 0 or -1 in region:\n                new_points.append(points[i])\n                continue\n                \n            verts = vor.vertices[region]\n            \n            # Compute Centroid of the polygon\n            # Shift vertices to origin relative to the first vertex to maintain precision\n            v_x = verts[:, 0]\n            v_y = verts[:, 1]\n            mean_x = np.mean(v_x)\n            mean_y = np.mean(v_y)\n            \n            v_x = v_x - mean_x\n            v_y = v_y - mean_y\n            \n            # Shoelace formula components\n            # Roll to get (x_i, y_i) and (x_{i+1}, y_{i+1})\n            v_x_next = np.roll(v_x, -1)\n            v_y_next = np.roll(v_y, -1)\n            \n            cross = v_x * v_y_next - v_x_next * v_y\n            area = 0.5 * np.sum(cross)\n            \n            if abs(area) < 1e-9:\n                new_points.append(points[i])\n            else:\n                cx = np.sum((v_x + v_x_next) * cross) / (6 * area)\n                cy = np.sum((v_y + v_y_next) * cross) / (6 * area)\n                new_points.append([cx + mean_x, cy + mean_y])\n                \n        points = np.array(new_points)\n        # Ensure points stay strictly inside\n        points = np.clip(points, 1e-6, 1 - 1e-6)\n\n    # 3. Optimization\n    # Maximize sum of radii\n    \n    # Initial guess for radii: half distance to nearest neighbor\n    from scipy.spatial.distance import pdist\n    dists = pdist(points)\n    min_dist = np.min(dists) if len(dists) > 0 else 0.1\n    r_init = np.full(N, min_dist / 2.0)\n    \n    # Variables vector: [x0, y0, r0, x1, y1, r1, ...]\n    x0 = np.zeros(3 * N)\n    x0[0::3] = points[:, 0]\n    x0[1::3] = points[:, 1]\n    x0[2::3] = r_init\n    \n    # Objective: Minimize negative sum of radii\n    def objective(vars):\n        radii = vars[2::3]\n        return -np.sum(radii)\n    \n    # Analytic Jacobian for objective\n    def obj_jac(vars):\n        grad = np.zeros_like(vars)\n        grad[2::3] = -1.0\n        return grad\n    \n    # Constraints\n    # 1. Wall constraints: Circles inside [0,1]x[0,1]\n    # x - r >= 0, 1 - x - r >= 0\n    # y - r >= 0, 1 - y - r >= 0\n    # Also r >= 0\n    \n    def cons_walls(vars):\n        xs = vars[0::3]\n        ys = vars[1::3]\n        rs = vars[2::3]\n        \n        # Concatenate all wall constraints\n        return np.concatenate([\n            xs - rs,        # Left wall\n            1.0 - xs - rs,  # Right wall\n            ys - rs,        # Bottom wall\n            1.0 - ys - rs,  # Top wall\n            rs              # Radius positive\n        ])\n    \n    # 2. Overlap constraints: dist_sq >= (ri + rj)^2\n    # Precompute pair indices\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    \n    def cons_overlap(vars):\n        xs = vars[0::3]\n        ys = vars[1::3]\n        rs = vars[2::3]\n        \n        dx = xs[idx_i] - xs[idx_j]\n        dy = ys[idx_i] - ys[idx_j]\n        d2 = dx**2 + dy**2\n        r_sum = rs[idx_i] + rs[idx_j]\n        \n        return d2 - r_sum**2\n\n    # Define constraints dictionary\n    constraints = [\n        {'type': 'ineq', 'fun': cons_walls},\n        {'type': 'ineq', 'fun': cons_overlap}\n    ]\n    \n    # Bounds: x, y in [0,1], r in [0, 0.6] (upper bound conservative)\n    bounds = []\n    for _ in range(N):\n        bounds.extend([(0, 1), (0, 1), (0, 0.6)])\n        \n    # Run optimization\n    # SLSQP is suitable for constrained optimization with many constraints\n    res = minimize(objective, x0, method='SLSQP', jac=obj_jac,\n                   bounds=bounds, constraints=constraints,\n                   options={'maxiter': 2000, 'ftol': 1e-6, 'disp': False})\n    \n    # Extract results\n    final_vars = res.x\n    centers = np.column_stack((final_vars[0::3], final_vars[1::3]))\n    radii = final_vars[2::3]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.6051539511885062,
    "eval_time": 0.37673020362854004,
    "error": null
  },
  "prompt": "Solve circle packing (26 circles). \n\nStrategy: **Voronoi Relaxation**.\n- Initialize 26 random points.\n- Loop 50 times:\n  1. Compute Voronoi diagram (clipped to unit square).\n  2. Move each point to the centroid of its Voronoi cell (Lloyd's algorithm).\n  3. This spreads points evenly.\n- Use these centers as the seed for `minimize` (maximizing radii).\n\nCRITICAL: Output valid Python code wrapped in ```python ... ```. The code must include all imports. NO TEXT before or after.",
  "response": "```python\nimport numpy as np\nfrom scipy.spatial import Voronoi\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    # Problem constants\n    N = 26\n    ITERATIONS = 50\n    \n    # 1. Initialize random points\n    # Using a fixed seed ensures reproducibility and consistent performance\n    np.random.seed(42)\n    points = np.random.rand(N, 2)\n    \n    # Keep points slightly away from boundaries to avoid degenerate Voronoi cells initially\n    points = np.clip(points, 1e-5, 1 - 1e-5)\n\n    # 2. Voronoi Relaxation (Lloyd's Algorithm)\n    for _ in range(ITERATIONS):\n        # Create 9 copies of the points to simulate periodic/hard boundaries\n        # This ensures Voronoi cells for the internal [0,1] points are correctly clipped\n        # by the unit square walls (bisectors with reflections are exactly the axes).\n        \n        x = points[:, 0]\n        y = points[:, 1]\n        \n        # Reflections across axes and corners\n        # Center: (x, y)\n        # Neighbors:\n        # Left: (-x, y), Right: (2-x, y)\n        # Down: (x, -y), Up: (x, 2-y)\n        # Corners: (-x, -y), (-x, 2-y), (2-x, -y), (2-x, 2-y)\n        \n        # Construct arrays for all 9 tiles\n        # Offsets for reflections:\n        # We transform x -> -x or 2-x\n        # But simpler is to construct the specific reflection coordinates\n        \n        p_c = points\n        p_l = np.column_stack((-x, y))\n        p_r = np.column_stack((2-x, y))\n        p_d = np.column_stack((x, -y))\n        p_u = np.column_stack((x, 2-y))\n        \n        p_ld = np.column_stack((-x, -y))\n        p_lu = np.column_stack((-x, 2-y))\n        p_rd = np.column_stack((2-x, -y))\n        p_ru = np.column_stack((2-x, 2-y))\n        \n        # Order matters: first N points are the original ones\n        all_points = np.vstack([p_c, p_l, p_r, p_d, p_u, p_ld, p_lu, p_rd, p_ru])\n        \n        try:\n            vor = Voronoi(all_points)\n        except Exception:\n            # In case of Qhull error (rare with random points), perturbation helps\n            points += np.random.normal(0, 1e-5, points.shape)\n            points = np.clip(points, 1e-5, 1 - 1e-5)\n            continue\n\n        new_points = []\n        for i in range(N):\n            region_idx = vor.point_region[i]\n            region = vor.regions[region_idx]\n            \n            # The region for the central points should be closed and valid\n            if len(region) == 0 or -1 in region:\n                new_points.append(points[i])\n                continue\n                \n            verts = vor.vertices[region]\n            \n            # Compute Centroid of the polygon\n            # Shift vertices to origin relative to the first vertex to maintain precision\n            v_x = verts[:, 0]\n            v_y = verts[:, 1]\n            mean_x = np.mean(v_x)\n            mean_y = np.mean(v_y)\n            \n            v_x = v_x - mean_x\n            v_y = v_y - mean_y\n            \n            # Shoelace formula components\n            # Roll to get (x_i, y_i) and (x_{i+1}, y_{i+1})\n            v_x_next = np.roll(v_x, -1)\n            v_y_next = np.roll(v_y, -1)\n            \n            cross = v_x * v_y_next - v_x_next * v_y\n            area = 0.5 * np.sum(cross)\n            \n            if abs(area) < 1e-9:\n                new_points.append(points[i])\n            else:\n                cx = np.sum((v_x + v_x_next) * cross) / (6 * area)\n                cy = np.sum((v_y + v_y_next) * cross) / (6 * area)\n                new_points.append([cx + mean_x, cy + mean_y])\n                \n        points = np.array(new_points)\n        # Ensure points stay strictly inside\n        points = np.clip(points, 1e-6, 1 - 1e-6)\n\n    # 3. Optimization\n    # Maximize sum of radii\n    \n    # Initial guess for radii: half distance to nearest neighbor\n    from scipy.spatial.distance import pdist\n    dists = pdist(points)\n    min_dist = np.min(dists) if len(dists) > 0 else 0.1\n    r_init = np.full(N, min_dist / 2.0)\n    \n    # Variables vector: [x0, y0, r0, x1, y1, r1, ...]\n    x0 = np.zeros(3 * N)\n    x0[0::3] = points[:, 0]\n    x0[1::3] = points[:, 1]\n    x0[2::3] = r_init\n    \n    # Objective: Minimize negative sum of radii\n    def objective(vars):\n        radii = vars[2::3]\n        return -np.sum(radii)\n    \n    # Analytic Jacobian for objective\n    def obj_jac(vars):\n        grad = np.zeros_like(vars)\n        grad[2::3] = -1.0\n        return grad\n    \n    # Constraints\n    # 1. Wall constraints: Circles inside [0,1]x[0,1]\n    # x - r >= 0, 1 - x - r >= 0\n    # y - r >= 0, 1 - y - r >= 0\n    # Also r >= 0\n    \n    def cons_walls(vars):\n        xs = vars[0::3]\n        ys = vars[1::3]\n        rs = vars[2::3]\n        \n        # Concatenate all wall constraints\n        return np.concatenate([\n            xs - rs,        # Left wall\n            1.0 - xs - rs,  # Right wall\n            ys - rs,        # Bottom wall\n            1.0 - ys - rs,  # Top wall\n            rs              # Radius positive\n        ])\n    \n    # 2. Overlap constraints: dist_sq >= (ri + rj)^2\n    # Precompute pair indices\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    \n    def cons_overlap(vars):\n        xs = vars[0::3]\n        ys = vars[1::3]\n        rs = vars[2::3]\n        \n        dx = xs[idx_i] - xs[idx_j]\n        dy = ys[idx_i] - ys[idx_j]\n        d2 = dx**2 + dy**2\n        r_sum = rs[idx_i] + rs[idx_j]\n        \n        return d2 - r_sum**2\n\n    # Define constraints dictionary\n    constraints = [\n        {'type': 'ineq', 'fun': cons_walls},\n        {'type': 'ineq', 'fun': cons_overlap}\n    ]\n    \n    # Bounds: x, y in [0,1], r in [0, 0.6] (upper bound conservative)\n    bounds = []\n    for _ in range(N):\n        bounds.extend([(0, 1), (0, 1), (0, 0.6)])\n        \n    # Run optimization\n    # SLSQP is suitable for constrained optimization with many constraints\n    res = minimize(objective, x0, method='SLSQP', jac=obj_jac,\n                   bounds=bounds, constraints=constraints,\n                   options={'maxiter': 2000, 'ftol': 1e-6, 'disp': False})\n    \n    # Extract results\n    final_vars = res.x\n    centers = np.column_stack((final_vars[0::3], final_vars[1::3]))\n    radii = final_vars[2::3]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T10:53:34.620373",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 347,
        "candidates_token_count": 2102,
        "thoughts_token_count": 10981
      },
      "response_text_len": 6274
    }
  }
}