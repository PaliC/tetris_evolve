{
  "trial_id": "trial_9_10",
  "generation": 9,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Strategy: Edge Gravitation (pushing circles toward the boundaries) followed by a cleanup phase.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # Initialization: Use a 5x5 grid (25 circles) and add the 26th circle manually.\n    # Grid coordinates: 0.1, 0.3, 0.5, 0.7, 0.9\n    coords = np.linspace(0.1, 0.9, 5)\n    X, Y = np.meshgrid(coords, coords)\n    x_init = X.flatten()\n    y_init = Y.flatten()\n    \n    # The 26th circle is placed between two existing circles to minimize initial overlap.\n    # Placing it at (0.5, 0.6) puts it exactly between (0.5, 0.5) and (0.5, 0.7).\n    x_init = np.append(x_init, 0.5)\n    y_init = np.append(y_init, 0.6)\n    \n    # Add a small amount of jitter to break symmetry for the optimizer.\n    x_init += np.random.uniform(-0.01, 0.01, n)\n    y_init += np.random.uniform(-0.01, 0.01, n)\n    \n    # Clip initial centers to ensure they stay within the square.\n    x_init = np.clip(x_init, 0.05, 0.95)\n    y_init = np.clip(y_init, 0.05, 0.95)\n    \n    # Initial radii estimate: 0.05 (sum of radii for 26 such circles is 1.3).\n    r_init = np.full(n, 0.05)\n    \n    # Variable vector: [radii, x_centers, y_centers]\n    v0 = np.concatenate([r_init, x_init, y_init])\n    \n    def constraints(v):\n        \"\"\"\n        Constraint function for SLSQP:\n        1. Boundary: r <= x <= 1-r and r <= y <= 1-r\n        2. Non-overlap: dist(i, j) >= r_i + r_j\n        \"\"\"\n        r = v[:n]\n        x = v[n:2*n]\n        y = v[2*n:]\n        \n        # Boundary constraints (must be >= 0)\n        # x - r >= 0, 1 - x - r >= 0, y - r >= 0, 1 - y - r >= 0\n        boundary = np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n        \n        # Non-overlap constraints (must be >= 0)\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist_sq = dx**2 + dy**2\n        \n        # We only care about the upper triangle of the distance matrix (i < j).\n        idx = np.triu_indices(n, k=1)\n        # Use a small epsilon to avoid NaN gradients at zero distance.\n        dists = np.sqrt(np.maximum(dist_sq[idx], 1e-12))\n        r_sum = r[:, None] + r[None, :]\n        overlap = dists - r_sum[idx]\n        \n        return np.concatenate([boundary, overlap])\n\n    def objective1(v):\n        \"\"\"\n        Phase 1 Objective: Edge Gravitation.\n        Maximize sum(radii) + 0.01 * sum(distance_to_center).\n        \"\"\"\n        r = v[:n]\n        x = v[n:2*n]\n        y = v[2*n:]\n        dist_to_center = np.sqrt((x - 0.5)**2 + (y - 0.5)**2 + 1e-12)\n        gravitation = 0.01 * np.sum(dist_to_center)\n        # minimize negative to maximize\n        return -(np.sum(r) + gravitation)\n\n    def objective2(v):\n        \"\"\"\n        Phase 2 Objective: Pure sum of radii.\n        \"\"\"\n        return -np.sum(v[:n])\n\n    # Constraints and bounds setup.\n    bounds = [(0.0, 0.5)] * n + [(0.0, 1.0)] * (2 * n)\n    cons = {'type': 'ineq', 'fun': constraints}\n    \n    # Pass 1: Solve with edge gravitation to push circles into efficient configurations.\n    res1 = minimize(objective1, v0, method='SLSQP', \n                    constraints=cons, bounds=bounds, \n                    options={'maxiter': 250, 'ftol': 1e-7})\n    \n    # Pass 2: Clean up optimization focusing solely on the sum of radii.\n    res2 = minimize(objective2, res1.x, method='SLSQP',\n                    constraints=cons, bounds=bounds, \n                    options={'maxiter': 200, 'ftol': 1e-8})\n    \n    # Extract results.\n    v_final = res2.x\n    radii = v_final[:n]\n    centers = np.stack([v_final[n:2*n], v_final[2*n:]], axis=1)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.607818204996112,
    "eval_time": 0.27956104278564453,
    "error": null
  },
  "prompt": "Write a Python function `construct_packing` that packs 26 circles. \n\nStrategy: **Edge Gravitation**.\n- Modify the objective function.\n- maximize sum(radii) + 0.01 * sum(distance_to_center).\n- This encourages circles to stick to the walls (where packing is most efficient).\n- Run `minimize`.\n- Then run a final clean `minimize` with just sum(radii).\n\nCRITICAL: Output valid Python code wrapped in ```python ... ```. The code must include all imports. NO TEXT before or after.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Strategy: Edge Gravitation (pushing circles toward the boundaries) followed by a cleanup phase.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # Initialization: Use a 5x5 grid (25 circles) and add the 26th circle manually.\n    # Grid coordinates: 0.1, 0.3, 0.5, 0.7, 0.9\n    coords = np.linspace(0.1, 0.9, 5)\n    X, Y = np.meshgrid(coords, coords)\n    x_init = X.flatten()\n    y_init = Y.flatten()\n    \n    # The 26th circle is placed between two existing circles to minimize initial overlap.\n    # Placing it at (0.5, 0.6) puts it exactly between (0.5, 0.5) and (0.5, 0.7).\n    x_init = np.append(x_init, 0.5)\n    y_init = np.append(y_init, 0.6)\n    \n    # Add a small amount of jitter to break symmetry for the optimizer.\n    x_init += np.random.uniform(-0.01, 0.01, n)\n    y_init += np.random.uniform(-0.01, 0.01, n)\n    \n    # Clip initial centers to ensure they stay within the square.\n    x_init = np.clip(x_init, 0.05, 0.95)\n    y_init = np.clip(y_init, 0.05, 0.95)\n    \n    # Initial radii estimate: 0.05 (sum of radii for 26 such circles is 1.3).\n    r_init = np.full(n, 0.05)\n    \n    # Variable vector: [radii, x_centers, y_centers]\n    v0 = np.concatenate([r_init, x_init, y_init])\n    \n    def constraints(v):\n        \"\"\"\n        Constraint function for SLSQP:\n        1. Boundary: r <= x <= 1-r and r <= y <= 1-r\n        2. Non-overlap: dist(i, j) >= r_i + r_j\n        \"\"\"\n        r = v[:n]\n        x = v[n:2*n]\n        y = v[2*n:]\n        \n        # Boundary constraints (must be >= 0)\n        # x - r >= 0, 1 - x - r >= 0, y - r >= 0, 1 - y - r >= 0\n        boundary = np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n        \n        # Non-overlap constraints (must be >= 0)\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist_sq = dx**2 + dy**2\n        \n        # We only care about the upper triangle of the distance matrix (i < j).\n        idx = np.triu_indices(n, k=1)\n        # Use a small epsilon to avoid NaN gradients at zero distance.\n        dists = np.sqrt(np.maximum(dist_sq[idx], 1e-12))\n        r_sum = r[:, None] + r[None, :]\n        overlap = dists - r_sum[idx]\n        \n        return np.concatenate([boundary, overlap])\n\n    def objective1(v):\n        \"\"\"\n        Phase 1 Objective: Edge Gravitation.\n        Maximize sum(radii) + 0.01 * sum(distance_to_center).\n        \"\"\"\n        r = v[:n]\n        x = v[n:2*n]\n        y = v[2*n:]\n        dist_to_center = np.sqrt((x - 0.5)**2 + (y - 0.5)**2 + 1e-12)\n        gravitation = 0.01 * np.sum(dist_to_center)\n        # minimize negative to maximize\n        return -(np.sum(r) + gravitation)\n\n    def objective2(v):\n        \"\"\"\n        Phase 2 Objective: Pure sum of radii.\n        \"\"\"\n        return -np.sum(v[:n])\n\n    # Constraints and bounds setup.\n    bounds = [(0.0, 0.5)] * n + [(0.0, 1.0)] * (2 * n)\n    cons = {'type': 'ineq', 'fun': constraints}\n    \n    # Pass 1: Solve with edge gravitation to push circles into efficient configurations.\n    res1 = minimize(objective1, v0, method='SLSQP', \n                    constraints=cons, bounds=bounds, \n                    options={'maxiter': 250, 'ftol': 1e-7})\n    \n    # Pass 2: Clean up optimization focusing solely on the sum of radii.\n    res2 = minimize(objective2, res1.x, method='SLSQP',\n                    constraints=cons, bounds=bounds, \n                    options={'maxiter': 200, 'ftol': 1e-8})\n    \n    # Extract results.\n    v_final = res2.x\n    radii = v_final[:n]\n    centers = np.stack([v_final[n:2*n], v_final[2*n:]], axis=1)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T10:52:48.340026",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 345,
        "candidates_token_count": 1396,
        "thoughts_token_count": 14963
      },
      "response_text_len": 3849
    }
  }
}