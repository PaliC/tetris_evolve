{
  "trial_id": "trial_1_0",
  "generation": 1,
  "parent_id": "trial_0_3",
  "code": "import numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    # Parameters\n    N = 26\n    n_steps = 15000  # Increased iterations for convergence\n    dt = 0.001       # Time step\n    \n    # Physics parameters\n    k_repel = 1000.0 # Stiff repulsion\n    \n    # Annealing schedule\n    temp_initial = 0.01\n    temp_final = 1e-6\n    \n    # Growth schedule\n    growth_rate_initial = 0.0005\n    growth_rate_final = 1e-6\n    \n    # Initialize\n    # Start with random centers in the box\n    centers = np.random.rand(N, 2)\n    \n    # Start with very small radii\n    radii = np.ones(N) * 0.001\n    \n    for step in range(n_steps):\n        progress = step / n_steps\n        \n        # Current parameters based on schedule\n        current_temp = temp_initial * (1 - progress) + temp_final * progress\n        current_growth = growth_rate_initial * (1 - progress) + growth_rate_final * progress\n        \n        # 1. Compute Distances and Overlaps\n        # Shape (N, N, 2)\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dist_sq = np.sum(diffs**2, axis=2)\n        \n        # Distance matrix (N, N)\n        dists = np.sqrt(dist_sq)\n        # Avoid division by zero on diagonal\n        np.fill_diagonal(dists, 1.0)\n        \n        # Sum of radii matrix (N, N)\n        radii_sum = radii[:, np.newaxis] + radii[np.newaxis, :]\n        \n        # Overlaps: (r_i + r_j) - d_ij\n        overlaps = radii_sum - dists\n        np.fill_diagonal(overlaps, -1.0) # Ignore self\n        \n        # 2. Forces\n        # Repulsion force\n        mask = overlaps > 0\n        \n        # Normalized direction vectors\n        # If dist is very small, use random direction to break symmetry\n        norm_diffs = np.zeros_like(diffs)\n        valid_mask = dists > 1e-9\n        norm_diffs[valid_mask] = diffs[valid_mask] / dists[valid_mask][:, np.newaxis]\n        \n        # Force magnitude: proportional to overlap (Hooke's law)\n        force_mags = k_repel * overlaps * mask\n        \n        # Sum forces on each particle\n        # (N, 2)\n        forces = np.sum(force_mags[:, :, np.newaxis] * norm_diffs, axis=1)\n        \n        # Wall forces (Repulsion from boundaries)\n        # Left\n        overlap_l = radii - centers[:, 0]\n        forces[overlap_l > 0, 0] += k_repel * overlap_l[overlap_l > 0]\n        # Right\n        overlap_r = radii - (1 - centers[:, 0])\n        forces[overlap_r > 0, 0] -= k_repel * overlap_r[overlap_r > 0]\n        # Bottom\n        overlap_b = radii - centers[:, 1]\n        forces[overlap_b > 0, 1] += k_repel * overlap_b[overlap_b > 0]\n        # Top\n        overlap_t = radii - (1 - centers[:, 1])\n        forces[overlap_t > 0, 1] -= k_repel * overlap_t[overlap_t > 0]\n        \n        # 3. Thermal Jitter\n        noise = np.random.normal(0, current_temp, (N, 2))\n        \n        # 4. Integration (Overdamped)\n        move = (forces + noise / dt) * dt\n        centers += move\n        \n        # Enforce hard box constraints for centers\n        centers = np.clip(centers, 0, 1)\n        \n        # 5. Adaptive Inflation\n        # Calculate crowding for each circle (sum of positive overlaps)\n        crowding = np.sum(np.maximum(0, overlaps), axis=1)\n        \n        # Add wall crowding\n        crowding += np.maximum(0, radii - centers[:, 0])\n        crowding += np.maximum(0, radii - (1 - centers[:, 0]))\n        crowding += np.maximum(0, radii - centers[:, 1])\n        crowding += np.maximum(0, radii - (1 - centers[:, 1]))\n        \n        # Growth factor inhibits growth if crowded\n        # Using a soft constraint to allow settling\n        growth_factors = np.exp(-1000 * crowding) \n        \n        radii += current_growth * growth_factors\n        \n    # Final Optimization Step\n    # Use Linear Programming to maximize sum of radii for the found centers\n    \n    # Objective: Maximize sum(r) -> Minimize -sum(r)\n    c = -np.ones(N)\n    \n    # Constraints\n    # r_i + r_j <= dist_ij\n    num_pairs = N * (N - 1) // 2\n    A_ub = np.zeros((num_pairs, N))\n    b_ub = np.zeros(num_pairs)\n    \n    # Recompute distances for final centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    \n    idx = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            A_ub[idx, i] = 1\n            A_ub[idx, j] = 1\n            b_ub[idx] = dists[i, j]\n            idx += 1\n            \n    # Bounds: 0 <= r_i <= distance to nearest wall\n    bounds = []\n    for i in range(N):\n        x, y = centers[i]\n        max_r = min(x, 1-x, y, 1-y)\n        bounds.append((0, max_r))\n        \n    # Solve\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n    \n    if res.success:\n        final_radii = res.x\n    else:\n        # Fallback: shrink existing radii until valid\n        final_radii = radii.copy()\n        for _ in range(100):\n            valid = True\n            # Wall checks\n            for i in range(N):\n                x, y = centers[i]\n                limit = min(x, 1-x, y, 1-y)\n                if final_radii[i] > limit:\n                    final_radii[i] = limit\n                    valid = False\n            # Pair checks\n            for i in range(N):\n                for j in range(i+1, N):\n                    d = dists[i, j]\n                    if final_radii[i] + final_radii[j] > d:\n                        scale = d / (final_radii[i] + final_radii[j])\n                        final_radii[i] *= scale\n                        final_radii[j] *= scale\n                        valid = False\n            if valid:\n                break\n    \n    return centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 1.4198400636334552,
    "eval_time": 1.525338888168335,
    "error": null
  },
  "prompt": "Improve the physics-based circle packing algorithm from {CODE_TRIAL_0_3}. \n\nChanges:\n1. Add 'Thermal Jitter': Add random noise to circle positions at each step, decreasing over time (Simulated Annealing style).\n2. Slow down the inflation rate as the system becomes more crowded.\n3. Run for more iterations to ensure convergence.\n\nIMPORTANT: Output ONLY the Python code in a ```python``` block. Do not add explanations or text outside the block.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    # Parameters\n    N = 26\n    n_steps = 15000  # Increased iterations for convergence\n    dt = 0.001       # Time step\n    \n    # Physics parameters\n    k_repel = 1000.0 # Stiff repulsion\n    \n    # Annealing schedule\n    temp_initial = 0.01\n    temp_final = 1e-6\n    \n    # Growth schedule\n    growth_rate_initial = 0.0005\n    growth_rate_final = 1e-6\n    \n    # Initialize\n    # Start with random centers in the box\n    centers = np.random.rand(N, 2)\n    \n    # Start with very small radii\n    radii = np.ones(N) * 0.001\n    \n    for step in range(n_steps):\n        progress = step / n_steps\n        \n        # Current parameters based on schedule\n        current_temp = temp_initial * (1 - progress) + temp_final * progress\n        current_growth = growth_rate_initial * (1 - progress) + growth_rate_final * progress\n        \n        # 1. Compute Distances and Overlaps\n        # Shape (N, N, 2)\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dist_sq = np.sum(diffs**2, axis=2)\n        \n        # Distance matrix (N, N)\n        dists = np.sqrt(dist_sq)\n        # Avoid division by zero on diagonal\n        np.fill_diagonal(dists, 1.0)\n        \n        # Sum of radii matrix (N, N)\n        radii_sum = radii[:, np.newaxis] + radii[np.newaxis, :]\n        \n        # Overlaps: (r_i + r_j) - d_ij\n        overlaps = radii_sum - dists\n        np.fill_diagonal(overlaps, -1.0) # Ignore self\n        \n        # 2. Forces\n        # Repulsion force\n        mask = overlaps > 0\n        \n        # Normalized direction vectors\n        # If dist is very small, use random direction to break symmetry\n        norm_diffs = np.zeros_like(diffs)\n        valid_mask = dists > 1e-9\n        norm_diffs[valid_mask] = diffs[valid_mask] / dists[valid_mask][:, np.newaxis]\n        \n        # Force magnitude: proportional to overlap (Hooke's law)\n        force_mags = k_repel * overlaps * mask\n        \n        # Sum forces on each particle\n        # (N, 2)\n        forces = np.sum(force_mags[:, :, np.newaxis] * norm_diffs, axis=1)\n        \n        # Wall forces (Repulsion from boundaries)\n        # Left\n        overlap_l = radii - centers[:, 0]\n        forces[overlap_l > 0, 0] += k_repel * overlap_l[overlap_l > 0]\n        # Right\n        overlap_r = radii - (1 - centers[:, 0])\n        forces[overlap_r > 0, 0] -= k_repel * overlap_r[overlap_r > 0]\n        # Bottom\n        overlap_b = radii - centers[:, 1]\n        forces[overlap_b > 0, 1] += k_repel * overlap_b[overlap_b > 0]\n        # Top\n        overlap_t = radii - (1 - centers[:, 1])\n        forces[overlap_t > 0, 1] -= k_repel * overlap_t[overlap_t > 0]\n        \n        # 3. Thermal Jitter\n        noise = np.random.normal(0, current_temp, (N, 2))\n        \n        # 4. Integration (Overdamped)\n        move = (forces + noise / dt) * dt\n        centers += move\n        \n        # Enforce hard box constraints for centers\n        centers = np.clip(centers, 0, 1)\n        \n        # 5. Adaptive Inflation\n        # Calculate crowding for each circle (sum of positive overlaps)\n        crowding = np.sum(np.maximum(0, overlaps), axis=1)\n        \n        # Add wall crowding\n        crowding += np.maximum(0, radii - centers[:, 0])\n        crowding += np.maximum(0, radii - (1 - centers[:, 0]))\n        crowding += np.maximum(0, radii - centers[:, 1])\n        crowding += np.maximum(0, radii - (1 - centers[:, 1]))\n        \n        # Growth factor inhibits growth if crowded\n        # Using a soft constraint to allow settling\n        growth_factors = np.exp(-1000 * crowding) \n        \n        radii += current_growth * growth_factors\n        \n    # Final Optimization Step\n    # Use Linear Programming to maximize sum of radii for the found centers\n    \n    # Objective: Maximize sum(r) -> Minimize -sum(r)\n    c = -np.ones(N)\n    \n    # Constraints\n    # r_i + r_j <= dist_ij\n    num_pairs = N * (N - 1) // 2\n    A_ub = np.zeros((num_pairs, N))\n    b_ub = np.zeros(num_pairs)\n    \n    # Recompute distances for final centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    \n    idx = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            A_ub[idx, i] = 1\n            A_ub[idx, j] = 1\n            b_ub[idx] = dists[i, j]\n            idx += 1\n            \n    # Bounds: 0 <= r_i <= distance to nearest wall\n    bounds = []\n    for i in range(N):\n        x, y = centers[i]\n        max_r = min(x, 1-x, y, 1-y)\n        bounds.append((0, max_r))\n        \n    # Solve\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n    \n    if res.success:\n        final_radii = res.x\n    else:\n        # Fallback: shrink existing radii until valid\n        final_radii = radii.copy()\n        for _ in range(100):\n            valid = True\n            # Wall checks\n            for i in range(N):\n                x, y = centers[i]\n                limit = min(x, 1-x, y, 1-y)\n                if final_radii[i] > limit:\n                    final_radii[i] = limit\n                    valid = False\n            # Pair checks\n            for i in range(N):\n                for j in range(i+1, N):\n                    d = dists[i, j]\n                    if final_radii[i] + final_radii[j] > d:\n                        scale = d / (final_radii[i] + final_radii[j])\n                        final_radii[i] *= scale\n                        final_radii[j] *= scale\n                        valid = False\n            if valid:\n                break\n    \n    return centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T10:18:15.307510",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 325,
        "candidates_token_count": 1833,
        "thoughts_token_count": 8503
      },
      "response_text_len": 5701
    }
  }
}