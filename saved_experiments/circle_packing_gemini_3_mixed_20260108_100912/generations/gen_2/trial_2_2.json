{
  "trial_id": "trial_2_2",
  "generation": 2,
  "parent_id": "trial_1_6",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef construct_packing():\n    # Parameters\n    N = 26\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    \n    # --- Helper Functions ---\n    \n    def get_dists_sq(centers):\n        diff = centers[idx_i] - centers[idx_j]\n        return np.sum(diff**2, axis=1), diff\n\n    def optimize_radii_for_centers(centers):\n        # Maximize sum(r) subject to non-overlap and boundary constraints\n        # Objective: min -sum(r)\n        c_obj = -np.ones(N)\n        \n        # Overlap constraints: r_i + r_j <= d_ij\n        d2, _ = get_dists_sq(centers)\n        dists = np.sqrt(d2)\n        \n        num_pairs = len(idx_i)\n        A_ub = np.zeros((num_pairs, N))\n        A_ub[np.arange(num_pairs), idx_i] = 1\n        A_ub[np.arange(num_pairs), idx_j] = 1\n        b_ub = dists\n        \n        # Boundary constraints: 0 <= r_i <= dist_to_wall\n        # x_i, y_i are fixed. r_i <= x_i, r_i <= 1-x_i, etc.\n        bounds = []\n        for k in range(N):\n            x, y = centers[k]\n            # Distance to nearest wall\n            max_r = min(x, 1-x, y, 1-y)\n            # Ensure non-negative (if center is outside, max_r < 0, but we clip to 0)\n            max_r = max(0.0, max_r)\n            bounds.append((0, max_r))\n            \n        # Solve LP\n        # Use 'highs' if available, else 'interior-point'\n        try:\n            res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        except:\n            res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='interior-point')\n            \n        if res.success:\n            return res.x, -res.fun\n        else:\n            return np.zeros(N), 0.0\n\n    def loss_func(x_vec, phase='pure'):\n        # x_vec: [x0, y0, x1, y1, ..., r0, r1, ...]\n        centers = x_vec[:2*N].reshape((N, 2))\n        radii = x_vec[2*N:]\n        \n        # Distances\n        diff = centers[idx_i] - centers[idx_j]\n        d2 = np.sum(diff**2, axis=1)\n        d = np.sqrt(d2 + 1e-12) # Smooth sqrt\n        \n        # Overlap violations: r_i + r_j > d_ij\n        r_sum = radii[idx_i] + radii[idx_j]\n        violations = np.maximum(0, r_sum - d)\n        \n        penalty_overlap = np.sum(violations**2)\n        \n        # Objective: Maximize sum(r) -> Minimize -sum(r)\n        obj_val = -np.sum(radii)\n        \n        # Variance Strategy\n        if phase == 'variance':\n            # Encourage variance: Minimize -std(r) => Add -k * sum((r-mean)^2)\n            # This makes the energy landscape favor unequal radii\n            r_mean = np.mean(radii)\n            var_term = -np.sum((radii - r_mean)**2)\n            obj_val += 0.5 * var_term\n        elif phase == 'homogenize':\n             # Penalize variance\n            r_mean = np.mean(radii)\n            var_term = np.sum((radii - r_mean)**2)\n            obj_val += 2.0 * var_term\n            \n        mu = 1000.0 # Penalty coefficient\n        total_loss = obj_val + mu * penalty_overlap\n        \n        # --- Gradient Calculation ---\n        grad = np.zeros_like(x_vec)\n        grad_c = grad[:2*N].reshape((N, 2))\n        grad_r = grad[2*N:]\n        \n        # Obj gradient w.r.t radii\n        grad_r[:] = -1.0\n        if phase == 'variance':\n            # Derivative of -0.5 * sum((r_i - mean)^2) is -(r_i - mean) approx\n            grad_r[:] += -1.0 * (radii - np.mean(radii))\n        elif phase == 'homogenize':\n            grad_r[:] += 4.0 * (radii - np.mean(radii))\n            \n        # Penalty gradient\n        # d/dr P = 2 * violation * 1\n        mask = violations > 0\n        if np.any(mask):\n            v_act = violations[mask]\n            factor = 2 * mu * v_act\n            \n            # Radii grad\n            np.add.at(grad_r, idx_i[mask], factor)\n            np.add.at(grad_r, idx_j[mask], factor)\n            \n            # Center grad\n            # d/dx_i = 2 * violation * (r+r-d)' = 2*v * (-d')\n            # d' w.r.t x_i is (x_i - x_j)/d\n            # So dP/dx_i = -2 * v * (x_i - x_j) / d\n            # dP/dx_j = 2 * v * (x_i - x_j) / d\n            \n            diff_act = diff[mask]\n            d_act = d[mask]\n            grad_factor = (factor[:, None] * diff_act) / d_act[:, None]\n            \n            np.add.at(grad_c, idx_i[mask], -grad_factor)\n            np.add.at(grad_c, idx_j[mask], grad_factor)\n            \n        return total_loss, grad\n\n    # --- Optimization Loop ---\n    \n    best_centers = None\n    best_radii = None\n    best_score = -np.inf\n    \n    # Define bounds\n    # Centers [0,1], Radii [0, 0.4]\n    bounds = [(0, 1)] * (2*N) + [(0.001, 0.4)] * N\n    \n    # Seeds\n    seeds = []\n    np.random.seed(123)\n    \n    # 1. Random seeds\n    for _ in range(8):\n        x0 = np.random.rand(3*N)\n        # Initialize radii to something reasonable (approx 1/sqrt(N)/2)\n        x0[2*N:] = 0.1 \n        seeds.append(x0)\n        \n    # 2. Grid seed (5x5 + 1)\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid_pts = np.vstack([gx.ravel(), gy.ravel()]).T\n    x0_grid = np.zeros(3*N)\n    x0_grid[:50] = grid_pts.flatten()\n    # Add one random point\n    x0_grid[50:52] = np.random.rand(2)\n    x0_grid[2*N:] = 0.09\n    seeds.append(x0_grid)\n    \n    for i, x0 in enumerate(seeds):\n        # Clip to bounds\n        x0[:2*N] = np.clip(x0[:2*N], 0, 1)\n        x0[2*N:] = np.clip(x0[2*N:], 0.001, 0.4)\n        \n        current_x = x0.copy()\n        \n        # Stage 1: Variance Emphasis (Push for unequal holes)\n        res1 = minimize(loss_func, current_x, args=('variance',), method='L-BFGS-B', jac=True, bounds=bounds, options={'maxiter': 400})\n        current_x = res1.x\n        \n        # Stage 2: Pure Optimization (Maximize sum)\n        res2 = minimize(loss_func, current_x, args=('pure',), method='L-BFGS-B', jac=True, bounds=bounds, options={'maxiter': 800})\n        current_x = res2.x\n        \n        # Extract centers\n        c_opt = current_x[:2*N].reshape((N, 2))\n        \n        # Exact Radius Calculation via LP\n        r_opt, score = optimize_radii_for_centers(c_opt)\n        \n        if score > best_score:\n            best_score = score\n            best_centers = c_opt\n            best_radii = r_opt\n\n    return best_centers, best_radii, best_score\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 1.4619036631142965,
    "eval_time": 0.6105270385742188,
    "error": null
  },
  "prompt": "Refine the strategy from {CODE_TRIAL_1_6}. \n\nStrategy: **Variable Radius Emphasis**.\n- The current best solution likely has near-uniform radii.\n- Modify the objective function to encourage *variance* initially (pushing some circles to be very large), then slowly penalize variance to homogenize them.\n- This might help find a configuration where 1-2 circles are slightly larger or smaller to fit gaps better.\n\nIMPORTANT: Your response must contain ONLY the Python code block. No introductory text, no explanations, no markdown outside the code block. The code must be self-contained.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef construct_packing():\n    # Parameters\n    N = 26\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    \n    # --- Helper Functions ---\n    \n    def get_dists_sq(centers):\n        diff = centers[idx_i] - centers[idx_j]\n        return np.sum(diff**2, axis=1), diff\n\n    def optimize_radii_for_centers(centers):\n        # Maximize sum(r) subject to non-overlap and boundary constraints\n        # Objective: min -sum(r)\n        c_obj = -np.ones(N)\n        \n        # Overlap constraints: r_i + r_j <= d_ij\n        d2, _ = get_dists_sq(centers)\n        dists = np.sqrt(d2)\n        \n        num_pairs = len(idx_i)\n        A_ub = np.zeros((num_pairs, N))\n        A_ub[np.arange(num_pairs), idx_i] = 1\n        A_ub[np.arange(num_pairs), idx_j] = 1\n        b_ub = dists\n        \n        # Boundary constraints: 0 <= r_i <= dist_to_wall\n        # x_i, y_i are fixed. r_i <= x_i, r_i <= 1-x_i, etc.\n        bounds = []\n        for k in range(N):\n            x, y = centers[k]\n            # Distance to nearest wall\n            max_r = min(x, 1-x, y, 1-y)\n            # Ensure non-negative (if center is outside, max_r < 0, but we clip to 0)\n            max_r = max(0.0, max_r)\n            bounds.append((0, max_r))\n            \n        # Solve LP\n        # Use 'highs' if available, else 'interior-point'\n        try:\n            res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        except:\n            res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='interior-point')\n            \n        if res.success:\n            return res.x, -res.fun\n        else:\n            return np.zeros(N), 0.0\n\n    def loss_func(x_vec, phase='pure'):\n        # x_vec: [x0, y0, x1, y1, ..., r0, r1, ...]\n        centers = x_vec[:2*N].reshape((N, 2))\n        radii = x_vec[2*N:]\n        \n        # Distances\n        diff = centers[idx_i] - centers[idx_j]\n        d2 = np.sum(diff**2, axis=1)\n        d = np.sqrt(d2 + 1e-12) # Smooth sqrt\n        \n        # Overlap violations: r_i + r_j > d_ij\n        r_sum = radii[idx_i] + radii[idx_j]\n        violations = np.maximum(0, r_sum - d)\n        \n        penalty_overlap = np.sum(violations**2)\n        \n        # Objective: Maximize sum(r) -> Minimize -sum(r)\n        obj_val = -np.sum(radii)\n        \n        # Variance Strategy\n        if phase == 'variance':\n            # Encourage variance: Minimize -std(r) => Add -k * sum((r-mean)^2)\n            # This makes the energy landscape favor unequal radii\n            r_mean = np.mean(radii)\n            var_term = -np.sum((radii - r_mean)**2)\n            obj_val += 0.5 * var_term\n        elif phase == 'homogenize':\n             # Penalize variance\n            r_mean = np.mean(radii)\n            var_term = np.sum((radii - r_mean)**2)\n            obj_val += 2.0 * var_term\n            \n        mu = 1000.0 # Penalty coefficient\n        total_loss = obj_val + mu * penalty_overlap\n        \n        # --- Gradient Calculation ---\n        grad = np.zeros_like(x_vec)\n        grad_c = grad[:2*N].reshape((N, 2))\n        grad_r = grad[2*N:]\n        \n        # Obj gradient w.r.t radii\n        grad_r[:] = -1.0\n        if phase == 'variance':\n            # Derivative of -0.5 * sum((r_i - mean)^2) is -(r_i - mean) approx\n            grad_r[:] += -1.0 * (radii - np.mean(radii))\n        elif phase == 'homogenize':\n            grad_r[:] += 4.0 * (radii - np.mean(radii))\n            \n        # Penalty gradient\n        # d/dr P = 2 * violation * 1\n        mask = violations > 0\n        if np.any(mask):\n            v_act = violations[mask]\n            factor = 2 * mu * v_act\n            \n            # Radii grad\n            np.add.at(grad_r, idx_i[mask], factor)\n            np.add.at(grad_r, idx_j[mask], factor)\n            \n            # Center grad\n            # d/dx_i = 2 * violation * (r+r-d)' = 2*v * (-d')\n            # d' w.r.t x_i is (x_i - x_j)/d\n            # So dP/dx_i = -2 * v * (x_i - x_j) / d\n            # dP/dx_j = 2 * v * (x_i - x_j) / d\n            \n            diff_act = diff[mask]\n            d_act = d[mask]\n            grad_factor = (factor[:, None] * diff_act) / d_act[:, None]\n            \n            np.add.at(grad_c, idx_i[mask], -grad_factor)\n            np.add.at(grad_c, idx_j[mask], grad_factor)\n            \n        return total_loss, grad\n\n    # --- Optimization Loop ---\n    \n    best_centers = None\n    best_radii = None\n    best_score = -np.inf\n    \n    # Define bounds\n    # Centers [0,1], Radii [0, 0.4]\n    bounds = [(0, 1)] * (2*N) + [(0.001, 0.4)] * N\n    \n    # Seeds\n    seeds = []\n    np.random.seed(123)\n    \n    # 1. Random seeds\n    for _ in range(8):\n        x0 = np.random.rand(3*N)\n        # Initialize radii to something reasonable (approx 1/sqrt(N)/2)\n        x0[2*N:] = 0.1 \n        seeds.append(x0)\n        \n    # 2. Grid seed (5x5 + 1)\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid_pts = np.vstack([gx.ravel(), gy.ravel()]).T\n    x0_grid = np.zeros(3*N)\n    x0_grid[:50] = grid_pts.flatten()\n    # Add one random point\n    x0_grid[50:52] = np.random.rand(2)\n    x0_grid[2*N:] = 0.09\n    seeds.append(x0_grid)\n    \n    for i, x0 in enumerate(seeds):\n        # Clip to bounds\n        x0[:2*N] = np.clip(x0[:2*N], 0, 1)\n        x0[2*N:] = np.clip(x0[2*N:], 0.001, 0.4)\n        \n        current_x = x0.copy()\n        \n        # Stage 1: Variance Emphasis (Push for unequal holes)\n        res1 = minimize(loss_func, current_x, args=('variance',), method='L-BFGS-B', jac=True, bounds=bounds, options={'maxiter': 400})\n        current_x = res1.x\n        \n        # Stage 2: Pure Optimization (Maximize sum)\n        res2 = minimize(loss_func, current_x, args=('pure',), method='L-BFGS-B', jac=True, bounds=bounds, options={'maxiter': 800})\n        current_x = res2.x\n        \n        # Extract centers\n        c_opt = current_x[:2*N].reshape((N, 2))\n        \n        # Exact Radius Calculation via LP\n        r_opt, score = optimize_radii_for_centers(c_opt)\n        \n        if score > best_score:\n            best_score = score\n            best_centers = c_opt\n            best_radii = r_opt\n\n    return best_centers, best_radii, best_score\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T10:22:21.318389",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 350,
        "candidates_token_count": 2254,
        "thoughts_token_count": 7711
      },
      "response_text_len": 6271
    }
  }
}