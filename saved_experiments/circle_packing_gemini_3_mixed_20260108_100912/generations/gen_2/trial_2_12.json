{
  "trial_id": "trial_2_12",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    N = 26\n    \n    # Use a fixed seed for reproducibility. \n    # Random initialization allows the solver to find a configuration.\n    np.random.seed(42)\n    \n    # Initial guess: Random positions, small radii\n    x_init = np.random.uniform(0.1, 0.9, N)\n    y_init = np.random.uniform(0.1, 0.9, N)\n    r_init = np.full(N, 0.05)\n    w = np.concatenate([x_init, y_init, r_init])\n    \n    # Precompute indices for pairwise constraints\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    \n    # Bounds for L-BFGS-B: x, y in [0, 1], r in [epsilon, 0.5]\n    bounds = [(0, 1) for _ in range(2 * N)] + [(1e-8, 0.5) for _ in range(N)]\n    \n    # Augmented Lagrangian parameters\n    # Constraints: 4*N wall constraints + N*(N-1)/2 pair constraints\n    num_constraints = 4 * N + len(idx_i)\n    lam = np.zeros(num_constraints)\n    rho = 10.0\n    \n    def unpack(w_vec):\n        return w_vec[:N], w_vec[N:2N], w_vec[2N:]\n\n    def objective_grad(w_vec):\n        x, y, r = unpack(w_vec)\n        \n        # --- Constraint Evaluation ---\n        # 1. Wall constraints (g >= 0)\n        g1 = x - r             # Left\n        g2 = 1.0 - x - r       # Right\n        g3 = y - r             # Bottom\n        g4 = 1.0 - y - r       # Top\n        \n        # 2. Pairwise non-overlap constraints (g >= 0)\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n        g_pair = dx**2 + dy**2 - sr**2\n        \n        g = np.concatenate([g1, g2, g3, g4, g_pair])\n        \n        # --- Augmented Lagrangian Calculation ---\n        # Effective multiplier: max(0, lambda - rho * g)\n        shifted = lam - rho * g\n        eff_lam = np.maximum(0, shifted)\n        \n        # Objective: Minimize -sum(r) + Penalty\n        # Penalty term: (1 / 2rho) * ||eff_lam||^2\n        f = -np.sum(r)\n        penalty = np.sum(eff_lam**2) / (2.0 * rho)\n        obj = f + penalty\n        \n        # --- Gradient Calculation ---\n        grad = np.zeros_like(w_vec)\n        \n        # Gradient of f (sum of radii)\n        grad[2*N:] = -1.0\n        \n        # Gradient of penalty term\n        # The term added to gradient is: - sum( eff_lam_k * grad_g_k )\n        \n        # 1. Wall constraints gradients\n        # g1: d/dx=1, d/dr=-1\n        m = eff_lam[0:N]\n        grad[0:N] -= m\n        grad[2*N:] -= m * (-1)\n        \n        # g2: d/dx=-1, d/dr=-1\n        m = eff_lam[N:2N]\n        grad[0:N] -= m * (-1)\n        grad[2*N:] -= m * (-1)\n        \n        # g3: d/dy=1, d/dr=-1\n        m = eff_lam[2N:3N]\n        grad[N:2*N] -= m\n        grad[2*N:] -= m * (-1)\n        \n        # g4: d/dy=-1, d/dr=-1\n        m = eff_lam[3N:4N]\n        grad[N:2*N] -= m * (-1)\n        grad[2*N:] -= m * (-1)\n        \n        # 2. Pair constraints gradients\n        # g_pair = dx^2 + dy^2 - (ri+rj)^2\n        m = eff_lam[4*N:]\n        term_x = m * 2 * dx\n        term_y = m * 2 * dy\n        term_r = m * (-2 * sr)\n        \n        # Distribute gradients to indices\n        np.add.at(grad, idx_i, -term_x)\n        np.add.at(grad, idx_j, term_x)      # - (-2dx)\n        np.add.at(grad, N + idx_i, -term_y)\n        np.add.at(grad, N + idx_j, term_y)\n        np.add.at(grad, 2*N + idx_i, -term_r)\n        np.add.at(grad, 2*N + idx_j, -term_r)\n        \n        return obj, grad\n\n    # --- ALM Outer Loop ---\n    max_outer = 25\n    for k in range(max_outer):\n        # Inner minimization using L-BFGS-B\n        # Tighter tolerances as we progress\n        tol = 1e-4 if k < 10 else 1e-6\n        res = minimize(objective_grad, w, method='L-BFGS-B', jac=True, bounds=bounds,\n                       options={'maxiter': 500, 'ftol': tol, 'gtol': tol})\n        w = res.x\n        \n        # Evaluate constraints to update multipliers\n        x, y, r = unpack(w)\n        g1 = x - r\n        g2 = 1.0 - x - r\n        g3 = y - r\n        g4 = 1.0 - y - r\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n        g_pair = dx**2 + dy**2 - sr**2\n        g = np.concatenate([g1, g2, g3, g4, g_pair])\n        \n        # Update Lagrange multipliers\n        lam = np.maximum(0, lam - rho * g)\n        \n        # Update penalty parameter rho\n        # Increase rho if constraints are violated\n        viol = np.max(np.maximum(0, -g))\n        if viol > 1e-6:\n            rho = min(rho * 2.0, 1e6)\n        elif k > 15:\n            # Convergence check\n            break\n\n    x, y, r = unpack(w)\n    centers = np.column_stack((x, y))\n    return centers, r, np.sum(r)\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 0.08356785774230957,
    "error": "SyntaxError: invalid decimal literal (<string>, line 30)"
  },
  "prompt": "Solve the circle packing problem (26 circles). \n\nStrategy: **Augmented Lagrangian (Custom Loop)**.\n- Implement the Method of Multipliers manually.\n- Maximize sum(radii) subject to constraints.\n- Update Lagrange multipliers in an outer loop.\n- Minimize the augmented Lagrangian in the inner loop using BFGS.\n- This avoids the black-box nature of `minimize(method='constrained')` and gives more control.\n\nIMPORTANT: Your response must contain ONLY the Python code block. No introductory text, no explanations, no markdown outside the code block. The code must be self-contained.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    N = 26\n    \n    # Use a fixed seed for reproducibility. \n    # Random initialization allows the solver to find a configuration.\n    np.random.seed(42)\n    \n    # Initial guess: Random positions, small radii\n    x_init = np.random.uniform(0.1, 0.9, N)\n    y_init = np.random.uniform(0.1, 0.9, N)\n    r_init = np.full(N, 0.05)\n    w = np.concatenate([x_init, y_init, r_init])\n    \n    # Precompute indices for pairwise constraints\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    \n    # Bounds for L-BFGS-B: x, y in [0, 1], r in [epsilon, 0.5]\n    bounds = [(0, 1) for _ in range(2 * N)] + [(1e-8, 0.5) for _ in range(N)]\n    \n    # Augmented Lagrangian parameters\n    # Constraints: 4*N wall constraints + N*(N-1)/2 pair constraints\n    num_constraints = 4 * N + len(idx_i)\n    lam = np.zeros(num_constraints)\n    rho = 10.0\n    \n    def unpack(w_vec):\n        return w_vec[:N], w_vec[N:2N], w_vec[2N:]\n\n    def objective_grad(w_vec):\n        x, y, r = unpack(w_vec)\n        \n        # --- Constraint Evaluation ---\n        # 1. Wall constraints (g >= 0)\n        g1 = x - r             # Left\n        g2 = 1.0 - x - r       # Right\n        g3 = y - r             # Bottom\n        g4 = 1.0 - y - r       # Top\n        \n        # 2. Pairwise non-overlap constraints (g >= 0)\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n        g_pair = dx**2 + dy**2 - sr**2\n        \n        g = np.concatenate([g1, g2, g3, g4, g_pair])\n        \n        # --- Augmented Lagrangian Calculation ---\n        # Effective multiplier: max(0, lambda - rho * g)\n        shifted = lam - rho * g\n        eff_lam = np.maximum(0, shifted)\n        \n        # Objective: Minimize -sum(r) + Penalty\n        # Penalty term: (1 / 2rho) * ||eff_lam||^2\n        f = -np.sum(r)\n        penalty = np.sum(eff_lam**2) / (2.0 * rho)\n        obj = f + penalty\n        \n        # --- Gradient Calculation ---\n        grad = np.zeros_like(w_vec)\n        \n        # Gradient of f (sum of radii)\n        grad[2*N:] = -1.0\n        \n        # Gradient of penalty term\n        # The term added to gradient is: - sum( eff_lam_k * grad_g_k )\n        \n        # 1. Wall constraints gradients\n        # g1: d/dx=1, d/dr=-1\n        m = eff_lam[0:N]\n        grad[0:N] -= m\n        grad[2*N:] -= m * (-1)\n        \n        # g2: d/dx=-1, d/dr=-1\n        m = eff_lam[N:2N]\n        grad[0:N] -= m * (-1)\n        grad[2*N:] -= m * (-1)\n        \n        # g3: d/dy=1, d/dr=-1\n        m = eff_lam[2N:3N]\n        grad[N:2*N] -= m\n        grad[2*N:] -= m * (-1)\n        \n        # g4: d/dy=-1, d/dr=-1\n        m = eff_lam[3N:4N]\n        grad[N:2*N] -= m * (-1)\n        grad[2*N:] -= m * (-1)\n        \n        # 2. Pair constraints gradients\n        # g_pair = dx^2 + dy^2 - (ri+rj)^2\n        m = eff_lam[4*N:]\n        term_x = m * 2 * dx\n        term_y = m * 2 * dy\n        term_r = m * (-2 * sr)\n        \n        # Distribute gradients to indices\n        np.add.at(grad, idx_i, -term_x)\n        np.add.at(grad, idx_j, term_x)      # - (-2dx)\n        np.add.at(grad, N + idx_i, -term_y)\n        np.add.at(grad, N + idx_j, term_y)\n        np.add.at(grad, 2*N + idx_i, -term_r)\n        np.add.at(grad, 2*N + idx_j, -term_r)\n        \n        return obj, grad\n\n    # --- ALM Outer Loop ---\n    max_outer = 25\n    for k in range(max_outer):\n        # Inner minimization using L-BFGS-B\n        # Tighter tolerances as we progress\n        tol = 1e-4 if k < 10 else 1e-6\n        res = minimize(objective_grad, w, method='L-BFGS-B', jac=True, bounds=bounds,\n                       options={'maxiter': 500, 'ftol': tol, 'gtol': tol})\n        w = res.x\n        \n        # Evaluate constraints to update multipliers\n        x, y, r = unpack(w)\n        g1 = x - r\n        g2 = 1.0 - x - r\n        g3 = y - r\n        g4 = 1.0 - y - r\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n        g_pair = dx**2 + dy**2 - sr**2\n        g = np.concatenate([g1, g2, g3, g4, g_pair])\n        \n        # Update Lagrange multipliers\n        lam = np.maximum(0, lam - rho * g)\n        \n        # Update penalty parameter rho\n        # Increase rho if constraints are violated\n        viol = np.max(np.maximum(0, -g))\n        if viol > 1e-6:\n            rho = min(rho * 2.0, 1e6)\n        elif k > 15:\n            # Convergence check\n            break\n\n    x, y, r = unpack(w)\n    centers = np.column_stack((x, y))\n    return centers, r, np.sum(r)\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T10:21:19.743900",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 350,
        "candidates_token_count": 1718,
        "thoughts_token_count": 11306
      },
      "response_text_len": 4605
    }
  }
}