{
  "trial_id": "trial_6_8",
  "generation": 6,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    N = 26\n    pop_size = 20\n    generations = 50\n\n    def calculate_max_equal_r(centers):\n        # Distance to boundaries\n        d_boundary = np.min([centers[:, 0], 1 - centers[:, 0], centers[:, 1], 1 - centers[:, 1]])\n        # Pairwise distances\n        dx = centers[:, 0][:, np.newaxis] - centers[:, 0][np.newaxis, :]\n        dy = centers[:, 1][:, np.newaxis] - centers[:, 1][np.newaxis, :]\n        dist_sq = dx**2 + dy**2\n        np.fill_diagonal(dist_sq, np.inf)\n        d_min_sq = np.min(dist_sq)\n        d_pairwise = np.sqrt(max(0, d_min_sq)) / 2.0\n        return max(0, min(d_boundary, d_pairwise))\n\n    # Initialize population: 20 packings\n    population = [np.random.rand(N, 2) for _ in range(pop_size)]\n    \n    # Genetic Algorithm Loop\n    for gen in range(generations):\n        # Fitness: Best radius sum (using equal radii as proxy)\n        fitness = np.array([calculate_max_equal_r(c) * N for c in population])\n        \n        # Selection: Sort by fitness\n        idx = np.argsort(fitness)[::-1]\n        population = [population[i] for i in idx]\n        \n        # Create next generation\n        new_population = [population[0]] # Elitism\n        while len(new_population) < pop_size:\n            # Selection: Pick from top 10 individuals\n            parent_indices = np.random.choice(min(10, pop_size), 2, replace=False)\n            p1, p2 = population[parent_indices[0]], population[parent_indices[1]]\n            \n            # Crossover: Take half circles from parent A, half from parent B\n            child = np.concatenate([p1[:13], p2[13:]], axis=0)\n            \n            # Mutation: Move 1 circle randomly\n            if np.random.rand() < 0.5:\n                child[np.random.randint(N)] = np.random.rand(2)\n            \n            new_population.append(child)\n        population = new_population\n\n    best_centers = population[0]\n    best_r = max(1e-6, calculate_max_equal_r(best_centers))\n\n    # SLSQP Polishing\n    tri_i, tri_j = np.triu_indices(N, k=1)\n\n    # Step 1: Maximize equal radius r to find a tight packing structure\n    def constraints_r(vars):\n        xy = vars[:-1].reshape((N, 2))\n        r = vars[-1]\n        b_cons = np.concatenate([xy[:, 0] - r, 1.0 - xy[:, 0] - r, xy[:, 1] - r, 1.0 - xy[:, 1] - r])\n        dists = np.sqrt((xy[tri_i, 0] - xy[tri_j, 0])**2 + (xy[tri_i, 1] - xy[tri_j, 1])**2 + 1e-12)\n        o_cons = dists - 2 * r\n        return np.concatenate([b_cons, o_cons])\n\n    x0_r = np.concatenate([best_centers.flatten(), [best_r]])\n    res_r = minimize(lambda v: -v[-1], x0_r, method='SLSQP',\n                     constraints={'type': 'ineq', 'fun': constraints_r},\n                     bounds=[(0, 1)] * (2*N) + [(0, 0.5)],\n                     options={'maxiter': 100})\n\n    # Step 2: Maximize sum of radii starting from the equal-radius configuration\n    def constraints_sum(vars):\n        xy = vars[:2*N].reshape((N, 2))\n        rs = vars[2*N:]\n        b_cons = np.concatenate([xy[:, 0] - rs, 1.0 - xy[:, 0] - rs, xy[:, 1] - rs, 1.0 - xy[:, 1] - rs])\n        dists = np.sqrt((xy[tri_i, 0] - xy[tri_j, 0])**2 + (xy[tri_i, 1] - xy[tri_j, 1])**2 + 1e-12)\n        o_cons = dists - (rs[tri_i] + rs[tri_j])\n        return np.concatenate([b_cons, o_cons])\n\n    final_centers_r = res_r.x[:-1].reshape((N, 2))\n    final_r = res_r.x[-1]\n    x0_sum = np.concatenate([final_centers_r.flatten(), np.full(N, final_r)])\n    \n    res_sum = minimize(lambda v: -np.sum(v[2*N:]), x0_sum, method='SLSQP',\n                       constraints={'type': 'ineq', 'fun': constraints_sum},\n                       bounds=[(0, 1)] * (2*N) + [(0, 0.5)] * N,\n                       options={'maxiter': 100})\n\n    final_vars = res_sum.x\n    centers = np.clip(final_vars[:2*N].reshape((N, 2)), 0, 1)\n    radii = np.maximum(final_vars[2*N:], 0)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.614659383088337,
    "eval_time": 0.36451101303100586,
    "error": null
  },
  "prompt": "Solve the circle packing problem (26 circles). \n\nStrategy: **Genetic Algorithm (Simple)**.\n- Population: 20 packings.\n- Crossover: Take half circles from parent A, half from parent B.\n- Mutation: Move 1 circle randomly.\n- Selection: Best radius sum.\n- Run 50 generations.\n- Polish best with SLSQP.\n\nCRITICAL: You must output ONLY a single Python code block (```python ... ```). \nDO NOT write any introduction. \nDO NOT write 'Here is the code'. \nDO NOT write any explanation after. \nJust the code block.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    N = 26\n    pop_size = 20\n    generations = 50\n\n    def calculate_max_equal_r(centers):\n        # Distance to boundaries\n        d_boundary = np.min([centers[:, 0], 1 - centers[:, 0], centers[:, 1], 1 - centers[:, 1]])\n        # Pairwise distances\n        dx = centers[:, 0][:, np.newaxis] - centers[:, 0][np.newaxis, :]\n        dy = centers[:, 1][:, np.newaxis] - centers[:, 1][np.newaxis, :]\n        dist_sq = dx**2 + dy**2\n        np.fill_diagonal(dist_sq, np.inf)\n        d_min_sq = np.min(dist_sq)\n        d_pairwise = np.sqrt(max(0, d_min_sq)) / 2.0\n        return max(0, min(d_boundary, d_pairwise))\n\n    # Initialize population: 20 packings\n    population = [np.random.rand(N, 2) for _ in range(pop_size)]\n    \n    # Genetic Algorithm Loop\n    for gen in range(generations):\n        # Fitness: Best radius sum (using equal radii as proxy)\n        fitness = np.array([calculate_max_equal_r(c) * N for c in population])\n        \n        # Selection: Sort by fitness\n        idx = np.argsort(fitness)[::-1]\n        population = [population[i] for i in idx]\n        \n        # Create next generation\n        new_population = [population[0]] # Elitism\n        while len(new_population) < pop_size:\n            # Selection: Pick from top 10 individuals\n            parent_indices = np.random.choice(min(10, pop_size), 2, replace=False)\n            p1, p2 = population[parent_indices[0]], population[parent_indices[1]]\n            \n            # Crossover: Take half circles from parent A, half from parent B\n            child = np.concatenate([p1[:13], p2[13:]], axis=0)\n            \n            # Mutation: Move 1 circle randomly\n            if np.random.rand() < 0.5:\n                child[np.random.randint(N)] = np.random.rand(2)\n            \n            new_population.append(child)\n        population = new_population\n\n    best_centers = population[0]\n    best_r = max(1e-6, calculate_max_equal_r(best_centers))\n\n    # SLSQP Polishing\n    tri_i, tri_j = np.triu_indices(N, k=1)\n\n    # Step 1: Maximize equal radius r to find a tight packing structure\n    def constraints_r(vars):\n        xy = vars[:-1].reshape((N, 2))\n        r = vars[-1]\n        b_cons = np.concatenate([xy[:, 0] - r, 1.0 - xy[:, 0] - r, xy[:, 1] - r, 1.0 - xy[:, 1] - r])\n        dists = np.sqrt((xy[tri_i, 0] - xy[tri_j, 0])**2 + (xy[tri_i, 1] - xy[tri_j, 1])**2 + 1e-12)\n        o_cons = dists - 2 * r\n        return np.concatenate([b_cons, o_cons])\n\n    x0_r = np.concatenate([best_centers.flatten(), [best_r]])\n    res_r = minimize(lambda v: -v[-1], x0_r, method='SLSQP',\n                     constraints={'type': 'ineq', 'fun': constraints_r},\n                     bounds=[(0, 1)] * (2*N) + [(0, 0.5)],\n                     options={'maxiter': 100})\n\n    # Step 2: Maximize sum of radii starting from the equal-radius configuration\n    def constraints_sum(vars):\n        xy = vars[:2*N].reshape((N, 2))\n        rs = vars[2*N:]\n        b_cons = np.concatenate([xy[:, 0] - rs, 1.0 - xy[:, 0] - rs, xy[:, 1] - rs, 1.0 - xy[:, 1] - rs])\n        dists = np.sqrt((xy[tri_i, 0] - xy[tri_j, 0])**2 + (xy[tri_i, 1] - xy[tri_j, 1])**2 + 1e-12)\n        o_cons = dists - (rs[tri_i] + rs[tri_j])\n        return np.concatenate([b_cons, o_cons])\n\n    final_centers_r = res_r.x[:-1].reshape((N, 2))\n    final_r = res_r.x[-1]\n    x0_sum = np.concatenate([final_centers_r.flatten(), np.full(N, final_r)])\n    \n    res_sum = minimize(lambda v: -np.sum(v[2*N:]), x0_sum, method='SLSQP',\n                       constraints={'type': 'ineq', 'fun': constraints_sum},\n                       bounds=[(0, 1)] * (2*N) + [(0, 0.5)] * N,\n                       options={'maxiter': 100})\n\n    final_vars = res_sum.x\n    centers = np.clip(final_vars[:2*N].reshape((N, 2)), 0, 1)\n    radii = np.maximum(final_vars[2*N:], 0)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T10:38:31.944967",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 358,
        "candidates_token_count": 1414,
        "thoughts_token_count": 14548
      },
      "response_text_len": 3995
    }
  }
}