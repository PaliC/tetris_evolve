{
  "trial_id": "trial_0_2",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n_circles = 26\n    n_vars = 3 * n_circles  # x, y, r for each circle\n    \n    def objective(x):\n        radii = x[2::3]  # Every 3rd element starting from index 2\n        return -np.sum(radii)  # Minimize negative sum to maximize sum\n    \n    def constraints_func(x):\n        constraints = []\n        \n        # Extract centers and radii\n        centers = x.reshape(-1, 3)[:, :2]  # x, y coordinates\n        radii = x[2::3]  # radii\n        \n        # Constraint 1: Circles inside square\n        for i in range(n_circles):\n            r = radii[i]\n            cx, cy = centers[i]\n            constraints.extend([\n                cx - r,      # cx >= r\n                1 - r - cx,  # cx <= 1 - r\n                cy - r,      # cy >= r\n                1 - r - cy   # cy <= 1 - r\n            ])\n        \n        # Constraint 2: No overlaps\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Constraint 3: Non-negative radii\n        constraints.extend(radii)\n        \n        return np.array(constraints)\n    \n    # Create initial guess using grid placement\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    initial_centers = []\n    initial_radii = []\n    \n    # Place circles in a grid pattern\n    spacing = 1.0 / (grid_size + 1)\n    initial_radius = spacing * 0.4  # Conservative initial radius\n    \n    count = 0\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if count >= n_circles:\n                break\n            x = (i + 1) * spacing\n            y = (j + 1) * spacing\n            initial_centers.append([x, y])\n            initial_radii.append(initial_radius)\n            count += 1\n    \n    # If we need more circles, add them randomly\n    while len(initial_centers) < n_circles:\n        x = np.random.uniform(initial_radius, 1 - initial_radius)\n        y = np.random.uniform(initial_radius, 1 - initial_radius)\n        initial_centers.append([x, y])\n        initial_radii.append(initial_radius * 0.5)\n    \n    # Flatten initial guess\n    x0 = []\n    for i in range(n_circles):\n        x0.extend([initial_centers[i][0], initial_centers[i][1], initial_radii[i]])\n    x0 = np.array(x0)\n    \n    # Set bounds\n    bounds = []\n    for i in range(n_circles):\n        bounds.extend([\n            (0, 1),      # x coordinate\n            (0, 1),      # y coordinate\n            (0, 0.5)     # radius (upper bound to prevent trivial solutions)\n        ])\n    \n    # Define constraint\n    constraint = {\n        'type': 'ineq',\n        'fun': constraints_func\n    }\n    \n    # Optimize with multiple attempts\n    best_result = None\n    best_sum = -np.inf\n    \n    for attempt in range(5):\n        # Add some randomness to initial guess\n        if attempt > 0:\n            noise = np.random.normal(0, 0.05, size=x0.shape)\n            x0_noisy = x0 + noise\n            # Ensure bounds are respected\n            for i in range(n_circles):\n                x0_noisy[3*i] = np.clip(x0_noisy[3*i], 0.1, 0.9)      # x\n                x0_noisy[3*i+1] = np.clip(x0_noisy[3*i+1], 0.1, 0.9)  # y\n                x0_noisy[3*i+2] = np.clip(x0_noisy[3*i+2], 0.01, 0.2) # r\n        else:\n            x0_noisy = x0.copy()\n        \n        try:\n            result = minimize(\n                objective,\n                x0_noisy,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraint,\n                options={'maxiter': 1000, 'ftol': 1e-9}\n            )\n            \n            if result.success:\n                current_sum = -result.fun\n                if current_sum > best_sum:\n                    best_sum = current_sum\n                    best_result = result\n        except:\n            continue\n    \n    # If optimization failed, try trust-constr\n    if best_result is None:\n        try:\n            result = minimize(\n                objective,\n                x0,\n                method='trust-constr',\n                bounds=bounds,\n                constraints=constraint,\n                options={'maxiter': 500}\n            )\n            best_result = result\n        except:\n            # Fallback to initial guess\n            best_result = type('obj', (object,), {'x': x0, 'fun': objective(x0)})\n    \n    # Extract final solution\n    x_final = best_result.x\n    centers = x_final.reshape(-1, 3)[:, :2]\n    radii = x_final[2::3]\n    \n    # Ensure all constraints are satisfied (post-processing)\n    for i in range(n_circles):\n        r = radii[i]\n        cx, cy = centers[i]\n        # Ensure circle is inside square\n        centers[i, 0] = np.clip(cx, r, 1 - r)\n        centers[i, 1] = np.clip(cy, r, 1 - r)\n        # Ensure non-negative radius\n        radii[i] = max(0, r)\n    \n    # Final overlap check and adjustment\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                          (centers[i, 1] - centers[j, 1])**2)\n            if dist < radii[i] + radii[j]:\n                # Shrink both radii proportionally\n                total_r = radii[i] + radii[j]\n                if total_r > 0:\n                    factor = max(0, (dist - 1e-6) / total_r)\n                    radii[i] *= factor\n                    radii[j] *= factor\n    \n    return centers, radii, float(np.sum(radii))\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.5999896569843375,
    "eval_time": 1.2696030139923096,
    "error": null
  },
  "prompt": "Create a circle packing algorithm for 26 circles in a unit square [0,1]x[0,1] to maximize sum of radii.\n\nUse SCIPY OPTIMIZATION with constraints:\n1. Decision variables: 26 centers (x,y) and 26 radii = 78 variables\n2. Constraints:\n   - Each circle inside square: r <= x <= 1-r, r <= y <= 1-r\n   - No overlap: distance(c_i, c_j) >= r_i + r_j for all pairs\n   - r >= 0\n3. Objective: maximize sum(radii) = minimize -sum(radii)\n4. Use SLSQP or trust-constr with good initial guess\n\nReturn format:\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    # Your scipy optimization here\n    return centers, radii, float(np.sum(radii))\n\ndef run_packing():\n    return construct_packing()\n```",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n_circles = 26\n    n_vars = 3 * n_circles  # x, y, r for each circle\n    \n    def objective(x):\n        radii = x[2::3]  # Every 3rd element starting from index 2\n        return -np.sum(radii)  # Minimize negative sum to maximize sum\n    \n    def constraints_func(x):\n        constraints = []\n        \n        # Extract centers and radii\n        centers = x.reshape(-1, 3)[:, :2]  # x, y coordinates\n        radii = x[2::3]  # radii\n        \n        # Constraint 1: Circles inside square\n        for i in range(n_circles):\n            r = radii[i]\n            cx, cy = centers[i]\n            constraints.extend([\n                cx - r,      # cx >= r\n                1 - r - cx,  # cx <= 1 - r\n                cy - r,      # cy >= r\n                1 - r - cy   # cy <= 1 - r\n            ])\n        \n        # Constraint 2: No overlaps\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Constraint 3: Non-negative radii\n        constraints.extend(radii)\n        \n        return np.array(constraints)\n    \n    # Create initial guess using grid placement\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    initial_centers = []\n    initial_radii = []\n    \n    # Place circles in a grid pattern\n    spacing = 1.0 / (grid_size + 1)\n    initial_radius = spacing * 0.4  # Conservative initial radius\n    \n    count = 0\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if count >= n_circles:\n                break\n            x = (i + 1) * spacing\n            y = (j + 1) * spacing\n            initial_centers.append([x, y])\n            initial_radii.append(initial_radius)\n            count += 1\n    \n    # If we need more circles, add them randomly\n    while len(initial_centers) < n_circles:\n        x = np.random.uniform(initial_radius, 1 - initial_radius)\n        y = np.random.uniform(initial_radius, 1 - initial_radius)\n        initial_centers.append([x, y])\n        initial_radii.append(initial_radius * 0.5)\n    \n    # Flatten initial guess\n    x0 = []\n    for i in range(n_circles):\n        x0.extend([initial_centers[i][0], initial_centers[i][1], initial_radii[i]])\n    x0 = np.array(x0)\n    \n    # Set bounds\n    bounds = []\n    for i in range(n_circles):\n        bounds.extend([\n            (0, 1),      # x coordinate\n            (0, 1),      # y coordinate\n            (0, 0.5)     # radius (upper bound to prevent trivial solutions)\n        ])\n    \n    # Define constraint\n    constraint = {\n        'type': 'ineq',\n        'fun': constraints_func\n    }\n    \n    # Optimize with multiple attempts\n    best_result = None\n    best_sum = -np.inf\n    \n    for attempt in range(5):\n        # Add some randomness to initial guess\n        if attempt > 0:\n            noise = np.random.normal(0, 0.05, size=x0.shape)\n            x0_noisy = x0 + noise\n            # Ensure bounds are respected\n            for i in range(n_circles):\n                x0_noisy[3*i] = np.clip(x0_noisy[3*i], 0.1, 0.9)      # x\n                x0_noisy[3*i+1] = np.clip(x0_noisy[3*i+1], 0.1, 0.9)  # y\n                x0_noisy[3*i+2] = np.clip(x0_noisy[3*i+2], 0.01, 0.2) # r\n        else:\n            x0_noisy = x0.copy()\n        \n        try:\n            result = minimize(\n                objective,\n                x0_noisy,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraint,\n                options={'maxiter': 1000, 'ftol': 1e-9}\n            )\n            \n            if result.success:\n                current_sum = -result.fun\n                if current_sum > best_sum:\n                    best_sum = current_sum\n                    best_result = result\n        except:\n            continue\n    \n    # If optimization failed, try trust-constr\n    if best_result is None:\n        try:\n            result = minimize(\n                objective,\n                x0,\n                method='trust-constr',\n                bounds=bounds,\n                constraints=constraint,\n                options={'maxiter': 500}\n            )\n            best_result = result\n        except:\n            # Fallback to initial guess\n            best_result = type('obj', (object,), {'x': x0, 'fun': objective(x0)})\n    \n    # Extract final solution\n    x_final = best_result.x\n    centers = x_final.reshape(-1, 3)[:, :2]\n    radii = x_final[2::3]\n    \n    # Ensure all constraints are satisfied (post-processing)\n    for i in range(n_circles):\n        r = radii[i]\n        cx, cy = centers[i]\n        # Ensure circle is inside square\n        centers[i, 0] = np.clip(cx, r, 1 - r)\n        centers[i, 1] = np.clip(cy, r, 1 - r)\n        # Ensure non-negative radius\n        radii[i] = max(0, r)\n    \n    # Final overlap check and adjustment\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                          (centers[i, 1] - centers[j, 1])**2)\n            if dist < radii[i] + radii[j]:\n                # Shrink both radii proportionally\n                total_r = radii[i] + radii[j]\n                if total_r > 0:\n                    factor = max(0, (dist - 1e-6) / total_r)\n                    radii[i] *= factor\n                    radii[j] *= factor\n    \n    return centers, radii, float(np.sum(radii))\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T00:21:05.530356",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4",
    "temperature": 0.5
  }
}