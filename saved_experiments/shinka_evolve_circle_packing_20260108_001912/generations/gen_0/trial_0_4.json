{
  "trial_id": "trial_0_4",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    N = 26\n    centers = np.zeros((N, 2))\n    radii = np.zeros(N)\n\n    # Step 1: Place 4 large corner circles, tangent to 2 walls\n    # We choose large equal radii for corners to maximize sum but leave space for edges/interior\n    corner_r = 0.12\n    radii[0:4] = corner_r\n    # corners: bottom-left, bottom-right, top-right, top-left\n    centers[0] = [corner_r, corner_r]\n    centers[1] = [1 - corner_r, corner_r]\n    centers[2] = [1 - corner_r, 1 - corner_r]\n    centers[3] = [corner_r, 1 - corner_r]\n\n    # Step 2: Place circles along edges between corners\n    # We put 5 circles per edge (20 total), somewhat smaller, tangent linearly\n    # radii smaller than corners to fit nicely, start with 0.05\n    edge_r = 0.05\n    radii[4:24] = edge_r\n\n    def linspace_centers(p1, p2, r, n):\n        # place n circles with radius r evenly spaced tangent along segment p1->p2\n        # distance between centers = 2r\n        # total length between centers = (n-1)*2r\n        # segment length\n        seg_len = np.linalg.norm(p2 - p1)\n        # we want centers along the segment so that first center is at p1+radius along vector\n        # last center is at p2 - radius along vector\n        # spacing between centers is 2r, so total length between first and last center is (n-1)*2r\n        # If (n-1)*2r > seg_len, reduce r to fit\n        max_r = seg_len / (2*(n-1))\n        r_use = min(r, max_r)\n        spacing = 2*r_use\n        # unit vector along edge\n        v = (p2 - p1) / seg_len\n        # centers start at p1 + r_use*v, then add spacing*v each step\n        centers_edge = np.array([p1 + v*(r_use + i*spacing) for i in range(n)])\n        return centers_edge, r_use\n\n    # bottom edge: between corner 0 and 1, indices 4..8 (5 circles)\n    c_bot, r_bot = linspace_centers(centers[0], centers[1], edge_r, 5)\n    centers[4:9] = c_bot\n    radii[4:9] = r_bot\n\n    # right edge: between corner 1 and 2, indices 9..13 (5 circles)\n    c_right, r_right = linspace_centers(centers[1], centers[2], edge_r, 5)\n    centers[9:14] = c_right\n    radii[9:14] = r_right\n\n    # top edge: between corner 2 and 3, indices 14..18 (5 circles)\n    c_top, r_top = linspace_centers(centers[2], centers[3], edge_r, 5)\n    centers[14:19] = c_top\n    radii[14:19] = r_top\n\n    # left edge: between corner 3 and 0, indices 19..23 (5 circles)\n    c_left, r_left = linspace_centers(centers[3], centers[0], edge_r, 5)\n    centers[19:24] = c_left\n    radii[19:24] = r_left\n\n    # Step 3: Fill interior with remaining 2 circles (indices 24, 25)\n    # Start with two medium circles roughly centered inside\n    # We guess radius smaller than edge circles so interior circles fit well\n    interior_r = 0.06\n    radii[24:26] = interior_r\n    # place roughly centered, avoiding edges by margin ~edge circle radius\n    centers[24] = [0.5 - interior_r, 0.5]\n    centers[25] = [0.5 + interior_r, 0.5]\n\n    # Step 4: Local optimization to fine-tune all positions and radii\n\n    # Variables: (x0,y0,r0, x1,y1,r1, ..., x25,y25,r25)\n    # 3*26 = 78 variables\n    # Initial guess vector\n    x0 = np.zeros(3*N)\n    x0[0::3] = centers[:,0]\n    x0[1::3] = centers[:,1]\n    x0[2::3] = radii\n\n    # Constraints:\n    cons = []\n\n    # 1) Circles inside box: r_i <= x_i <= 1-r_i, r_i <= y_i <= 1-r_i\n    # We implement as bounds instead of constraints\n    bounds = []\n    for i in range(N):\n        # x_i bounds\n        bounds.append((0, 1))  # x_i initially 0..1, will constrain via constraints\n        bounds.append((0, 1))  # y_i\n        bounds.append((0, 0.5))  # radius max 0.5 obviously\n\n    # But we need constraints to ensure circle inside box:\n    # x_i - r_i >=0 => x_i - r_i >= 0\n    # 1 - r_i - x_i >=0 => 1 - r_i - x_i >= 0\n    # similarly for y_i\n    for i in range(N):\n        def inside_left(x, i=i):\n            return x[3*i+0] - x[3*i+2]  # x_i - r_i >= 0\n        def inside_right(x, i=i):\n            return 1 - x[3*i+2] - x[3*i+0]  # 1 - r_i - x_i >= 0\n        def inside_bottom(x, i=i):\n            return x[3*i+1] - x[3*i+2]  # y_i - r_i >= 0\n        def inside_top(x, i=i):\n            return 1 - x[3*i+2] - x[3*i+1]  # 1 - r_i - y_i >= 0\n\n        cons.append({'type': 'ineq', 'fun': inside_left})\n        cons.append({'type': 'ineq', 'fun': inside_right})\n        cons.append({'type': 'ineq', 'fun': inside_bottom})\n        cons.append({'type': 'ineq', 'fun': inside_top})\n\n    # 2) No overlaps: distance between centers >= sum of radii\n    for i in range(N):\n        for j in range(i+1, N):\n            def no_overlap(x, i=i, j=j):\n                dx = x[3*i+0] - x[3*j+0]\n                dy = x[3*i+1] - x[3*j+1]\n                dist = np.sqrt(dx*dx + dy*dy)\n                return dist - (x[3*i+2] + x[3*j+2])\n            cons.append({'type': 'ineq', 'fun': no_overlap})\n\n    # Objective: maximize sum of radii => minimize negative sum of radii\n    def objective(x):\n        return -np.sum(x[2::3])\n\n    # Use method='SLSQP' suitable for nonlinear constraints\n    res = minimize(objective, x0, method='SLSQP', constraints=cons,\n                   options={'maxiter': 500, 'ftol':1e-9, 'disp': False})\n\n    if res.success:\n        x_opt = res.x\n    else:\n        # fallback to initial guess if optimization fails\n        x_opt = x0\n\n    centers_opt = np.vstack((x_opt[0::3], x_opt[1::3])).T\n    radii_opt = x_opt[2::3]\n    sum_radii = float(np.sum(radii_opt))\n\n    return centers_opt, radii_opt, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.569827427151867,
    "eval_time": 7.188207149505615,
    "error": null
  },
  "prompt": "Create a circle packing algorithm for 26 circles in a unit square [0,1]x[0,1] to maximize sum of radii.\n\nUse a CORNER-PRIORITY with SIZE ORDERING approach:\n1. Place 4 large circles in the 4 corners (each tangent to 2 walls)\n2. Place circles along the 4 edges between corner circles\n3. Fill the interior with remaining circles\n4. Use local optimization to fine-tune all positions and radii\n\nStrategy: larger circles in corners/edges maximize space utilization.\n\nReturn format:\n```python\nimport numpy as np\n\ndef construct_packing():\n    # Your corner-priority algorithm here\n    return centers, radii, float(np.sum(radii))\n\ndef run_packing():\n    return construct_packing()\n```",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    N = 26\n    centers = np.zeros((N, 2))\n    radii = np.zeros(N)\n\n    # Step 1: Place 4 large corner circles, tangent to 2 walls\n    # We choose large equal radii for corners to maximize sum but leave space for edges/interior\n    corner_r = 0.12\n    radii[0:4] = corner_r\n    # corners: bottom-left, bottom-right, top-right, top-left\n    centers[0] = [corner_r, corner_r]\n    centers[1] = [1 - corner_r, corner_r]\n    centers[2] = [1 - corner_r, 1 - corner_r]\n    centers[3] = [corner_r, 1 - corner_r]\n\n    # Step 2: Place circles along edges between corners\n    # We put 5 circles per edge (20 total), somewhat smaller, tangent linearly\n    # radii smaller than corners to fit nicely, start with 0.05\n    edge_r = 0.05\n    radii[4:24] = edge_r\n\n    def linspace_centers(p1, p2, r, n):\n        # place n circles with radius r evenly spaced tangent along segment p1->p2\n        # distance between centers = 2r\n        # total length between centers = (n-1)*2r\n        # segment length\n        seg_len = np.linalg.norm(p2 - p1)\n        # we want centers along the segment so that first center is at p1+radius along vector\n        # last center is at p2 - radius along vector\n        # spacing between centers is 2r, so total length between first and last center is (n-1)*2r\n        # If (n-1)*2r > seg_len, reduce r to fit\n        max_r = seg_len / (2*(n-1))\n        r_use = min(r, max_r)\n        spacing = 2*r_use\n        # unit vector along edge\n        v = (p2 - p1) / seg_len\n        # centers start at p1 + r_use*v, then add spacing*v each step\n        centers_edge = np.array([p1 + v*(r_use + i*spacing) for i in range(n)])\n        return centers_edge, r_use\n\n    # bottom edge: between corner 0 and 1, indices 4..8 (5 circles)\n    c_bot, r_bot = linspace_centers(centers[0], centers[1], edge_r, 5)\n    centers[4:9] = c_bot\n    radii[4:9] = r_bot\n\n    # right edge: between corner 1 and 2, indices 9..13 (5 circles)\n    c_right, r_right = linspace_centers(centers[1], centers[2], edge_r, 5)\n    centers[9:14] = c_right\n    radii[9:14] = r_right\n\n    # top edge: between corner 2 and 3, indices 14..18 (5 circles)\n    c_top, r_top = linspace_centers(centers[2], centers[3], edge_r, 5)\n    centers[14:19] = c_top\n    radii[14:19] = r_top\n\n    # left edge: between corner 3 and 0, indices 19..23 (5 circles)\n    c_left, r_left = linspace_centers(centers[3], centers[0], edge_r, 5)\n    centers[19:24] = c_left\n    radii[19:24] = r_left\n\n    # Step 3: Fill interior with remaining 2 circles (indices 24, 25)\n    # Start with two medium circles roughly centered inside\n    # We guess radius smaller than edge circles so interior circles fit well\n    interior_r = 0.06\n    radii[24:26] = interior_r\n    # place roughly centered, avoiding edges by margin ~edge circle radius\n    centers[24] = [0.5 - interior_r, 0.5]\n    centers[25] = [0.5 + interior_r, 0.5]\n\n    # Step 4: Local optimization to fine-tune all positions and radii\n\n    # Variables: (x0,y0,r0, x1,y1,r1, ..., x25,y25,r25)\n    # 3*26 = 78 variables\n    # Initial guess vector\n    x0 = np.zeros(3*N)\n    x0[0::3] = centers[:,0]\n    x0[1::3] = centers[:,1]\n    x0[2::3] = radii\n\n    # Constraints:\n    cons = []\n\n    # 1) Circles inside box: r_i <= x_i <= 1-r_i, r_i <= y_i <= 1-r_i\n    # We implement as bounds instead of constraints\n    bounds = []\n    for i in range(N):\n        # x_i bounds\n        bounds.append((0, 1))  # x_i initially 0..1, will constrain via constraints\n        bounds.append((0, 1))  # y_i\n        bounds.append((0, 0.5))  # radius max 0.5 obviously\n\n    # But we need constraints to ensure circle inside box:\n    # x_i - r_i >=0 => x_i - r_i >= 0\n    # 1 - r_i - x_i >=0 => 1 - r_i - x_i >= 0\n    # similarly for y_i\n    for i in range(N):\n        def inside_left(x, i=i):\n            return x[3*i+0] - x[3*i+2]  # x_i - r_i >= 0\n        def inside_right(x, i=i):\n            return 1 - x[3*i+2] - x[3*i+0]  # 1 - r_i - x_i >= 0\n        def inside_bottom(x, i=i):\n            return x[3*i+1] - x[3*i+2]  # y_i - r_i >= 0\n        def inside_top(x, i=i):\n            return 1 - x[3*i+2] - x[3*i+1]  # 1 - r_i - y_i >= 0\n\n        cons.append({'type': 'ineq', 'fun': inside_left})\n        cons.append({'type': 'ineq', 'fun': inside_right})\n        cons.append({'type': 'ineq', 'fun': inside_bottom})\n        cons.append({'type': 'ineq', 'fun': inside_top})\n\n    # 2) No overlaps: distance between centers >= sum of radii\n    for i in range(N):\n        for j in range(i+1, N):\n            def no_overlap(x, i=i, j=j):\n                dx = x[3*i+0] - x[3*j+0]\n                dy = x[3*i+1] - x[3*j+1]\n                dist = np.sqrt(dx*dx + dy*dy)\n                return dist - (x[3*i+2] + x[3*j+2])\n            cons.append({'type': 'ineq', 'fun': no_overlap})\n\n    # Objective: maximize sum of radii => minimize negative sum of radii\n    def objective(x):\n        return -np.sum(x[2::3])\n\n    # Use method='SLSQP' suitable for nonlinear constraints\n    res = minimize(objective, x0, method='SLSQP', constraints=cons,\n                   options={'maxiter': 500, 'ftol':1e-9, 'disp': False})\n\n    if res.success:\n        x_opt = res.x\n    else:\n        # fallback to initial guess if optimization fails\n        x_opt = x0\n\n    centers_opt = np.vstack((x_opt[0::3], x_opt[1::3])).T\n    radii_opt = x_opt[2::3]\n    sum_radii = float(np.sum(radii_opt))\n\n    return centers_opt, radii_opt, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T00:21:13.608725",
  "cost_data": null,
  "model_config": {
    "model": "openai/gpt-4.1-mini",
    "temperature": 0.7
  }
}