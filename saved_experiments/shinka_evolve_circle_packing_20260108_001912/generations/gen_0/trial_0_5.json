{
  "trial_id": "trial_0_5",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import linprog\n\ndef max_radii_for_centers(centers):\n    \"\"\"\n    Given circle centers (n x 2), compute max radii (n,)\n    satisfying:\n      - radii[i] >= 0\n      - radii[i] <= min distance to boundary (x=0,1 or y=0,1)\n      - radii[i] + radii[j] <= dist(center[i], center[j])\n    Maximize sum(radii).\n    \n    This is a linear program:\n      variables: radii[i] for i in [0..n-1]\n      objective: maximize sum(radii) = minimize -sum(radii)\n      constraints:\n         radii[i] >= 0\n         radii[i] <= dist_to_boundary[i]\n         radii[i] + radii[j] <= dist_centers[i,j]\n    \"\"\"\n    n = centers.shape[0]\n    # Objective: minimize -sum(radii)\n    c = -np.ones(n)\n    \n    # Bounds for radii: [0, dist_to_boundary]\n    dist_to_boundary = np.minimum.reduce([\n        centers[:,0] - 0,\n        1 - centers[:,0],\n        centers[:,1] - 0,\n        1 - centers[:,1]\n    ])\n    bounds = [(0, dist_to_boundary[i]) for i in range(n)]\n    \n    # Inequality constraints A_ub x <= b_ub for pairs radii[i] + radii[j] <= dist_centers[i,j]\n    pairs = []\n    dist_centers = np.linalg.norm(centers[:,None,:] - centers[None,:,:], axis=2)\n    # Only consider i<j pairs\n    A_ub = []\n    b_ub = []\n    for i in range(n):\n        for j in range(i+1, n):\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            A_ub.append(row)\n            b_ub.append(dist_centers[i,j])\n    A_ub = np.array(A_ub)\n    b_ub = np.array(b_ub)\n    \n    # Solve LP\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n    if res.success:\n        return res.x\n    else:\n        # If LP fails (rare), return zeros\n        return np.zeros(n)\n\n\ndef perturb_centers(centers, scale=0.02):\n    \"\"\"\n    Small random perturbation of centers within [0,1]^2.\n    \"\"\"\n    perturbed = centers + np.random.uniform(-scale, scale, centers.shape)\n    np.clip(perturbed, 0, 1, out=perturbed)\n    return perturbed\n\n\ndef sum_radii_for_centers(centers):\n    radii = max_radii_for_centers(centers)\n    return np.sum(radii), radii\n\n\ndef construct_packing():\n    n = 26\n    np.random.seed(42)\n    best_centers = None\n    best_radii = None\n    best_sum = -1\n    \n    # Parameters\n    starts = 60         # number of random starts\n    local_iters = 150   # local search iterations per start\n    perturb_scale = 0.02\n    \n    for start_i in range(starts):\n        # Random initial centers uniformly in unit square\n        centers = np.random.uniform(0,1,(n,2))\n        sum_r, radii = sum_radii_for_centers(centers)\n        \n        # Local search\n        for it in range(local_iters):\n            candidate_centers = perturb_centers(centers, scale=perturb_scale)\n            candidate_sum, candidate_radii = sum_radii_for_centers(candidate_centers)\n            if candidate_sum > sum_r:\n                centers = candidate_centers\n                sum_r = candidate_sum\n                radii = candidate_radii\n        \n        if sum_r > best_sum:\n            best_sum = sum_r\n            best_centers = centers\n            best_radii = radii\n    \n    return best_centers, best_radii, float(best_sum)\n\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.069870525078338,
    "eval_time": 7.430418968200684,
    "error": null
  },
  "prompt": "Create a circle packing algorithm for 26 circles in a unit square [0,1]x[0,1] to maximize sum of radii.\n\nUse a MULTI-START RANDOM + LOCAL SEARCH approach:\n1. Generate multiple random initial configurations\n2. For each configuration, compute maximum possible radii (given centers)\n3. Apply local search: perturb centers, recompute radii, keep if better\n4. Return the best configuration found\n\nKey insight: For fixed centers, optimal radii can be computed via linear program or iterative shrinking.\n\nReturn format:\n```python\nimport numpy as np\n\ndef construct_packing():\n    # Your multi-start local search here\n    return centers, radii, float(np.sum(radii))\n\ndef run_packing():\n    return construct_packing()\n```",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef max_radii_for_centers(centers):\n    \"\"\"\n    Given circle centers (n x 2), compute max radii (n,)\n    satisfying:\n      - radii[i] >= 0\n      - radii[i] <= min distance to boundary (x=0,1 or y=0,1)\n      - radii[i] + radii[j] <= dist(center[i], center[j])\n    Maximize sum(radii).\n    \n    This is a linear program:\n      variables: radii[i] for i in [0..n-1]\n      objective: maximize sum(radii) = minimize -sum(radii)\n      constraints:\n         radii[i] >= 0\n         radii[i] <= dist_to_boundary[i]\n         radii[i] + radii[j] <= dist_centers[i,j]\n    \"\"\"\n    n = centers.shape[0]\n    # Objective: minimize -sum(radii)\n    c = -np.ones(n)\n    \n    # Bounds for radii: [0, dist_to_boundary]\n    dist_to_boundary = np.minimum.reduce([\n        centers[:,0] - 0,\n        1 - centers[:,0],\n        centers[:,1] - 0,\n        1 - centers[:,1]\n    ])\n    bounds = [(0, dist_to_boundary[i]) for i in range(n)]\n    \n    # Inequality constraints A_ub x <= b_ub for pairs radii[i] + radii[j] <= dist_centers[i,j]\n    pairs = []\n    dist_centers = np.linalg.norm(centers[:,None,:] - centers[None,:,:], axis=2)\n    # Only consider i<j pairs\n    A_ub = []\n    b_ub = []\n    for i in range(n):\n        for j in range(i+1, n):\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            A_ub.append(row)\n            b_ub.append(dist_centers[i,j])\n    A_ub = np.array(A_ub)\n    b_ub = np.array(b_ub)\n    \n    # Solve LP\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n    if res.success:\n        return res.x\n    else:\n        # If LP fails (rare), return zeros\n        return np.zeros(n)\n\n\ndef perturb_centers(centers, scale=0.02):\n    \"\"\"\n    Small random perturbation of centers within [0,1]^2.\n    \"\"\"\n    perturbed = centers + np.random.uniform(-scale, scale, centers.shape)\n    np.clip(perturbed, 0, 1, out=perturbed)\n    return perturbed\n\n\ndef sum_radii_for_centers(centers):\n    radii = max_radii_for_centers(centers)\n    return np.sum(radii), radii\n\n\ndef construct_packing():\n    n = 26\n    np.random.seed(42)\n    best_centers = None\n    best_radii = None\n    best_sum = -1\n    \n    # Parameters\n    starts = 60         # number of random starts\n    local_iters = 150   # local search iterations per start\n    perturb_scale = 0.02\n    \n    for start_i in range(starts):\n        # Random initial centers uniformly in unit square\n        centers = np.random.uniform(0,1,(n,2))\n        sum_r, radii = sum_radii_for_centers(centers)\n        \n        # Local search\n        for it in range(local_iters):\n            candidate_centers = perturb_centers(centers, scale=perturb_scale)\n            candidate_sum, candidate_radii = sum_radii_for_centers(candidate_centers)\n            if candidate_sum > sum_r:\n                centers = candidate_centers\n                sum_r = candidate_sum\n                radii = candidate_radii\n        \n        if sum_r > best_sum:\n            best_sum = sum_r\n            best_centers = centers\n            best_radii = radii\n    \n    return best_centers, best_radii, float(best_sum)\n\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-08T00:21:00.120835",
  "cost_data": null,
  "model_config": {
    "model": "openai/gpt-4.1-mini",
    "temperature": 0.8
  }
}