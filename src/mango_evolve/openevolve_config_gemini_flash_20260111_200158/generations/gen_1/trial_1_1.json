{
  "trial_id": "trial_1_1",
  "generation": 1,
  "parent_id": "trial_0_7",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef is_valid(centers, radii):\n    \"\"\"Checks if the packing is valid.\"\"\"\n    n = len(centers)\n    for i in range(n):\n        # Check if inside the unit square\n        if centers[i][0] - radii[i] < 0 or centers[i][0] + radii[i] > 1 or \\\n           centers[i][1] - radii[i] < 0 or centers[i][1] + radii[i] > 1:\n            return False\n        # Check for overlaps\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j]:\n                return False\n    return True\n\ndef max_radius_for_circle(idx, centers, radii):\n    \"\"\"Calculate maximum possible radius for circle idx without overlapping others.\"\"\"\n    n = len(centers)\n    max_r = min(centers[idx][0], centers[idx][1], 1 - centers[idx][0], 1 - centers[idx][1])\n    \n    for j in range(n):\n        if j != idx:\n            dist = np.linalg.norm(centers[idx] - centers[j])\n            max_r = min(max_r, max(0, dist - radii[j]))\n    \n    return max_r\n\ndef optimize_radii(centers):\n    \"\"\"Optimize all radii for given centers.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    # Initial assignment of radii\n    for i in range(n):\n        radii[i] = max_radius_for_circle(i, centers, radii)\n    \n    # Iterative refinement\n    for _ in range(5):  # A few iterations to converge\n        for i in range(n):\n            radii[i] = max_radius_for_circle(i, centers, radii)\n    \n    return radii\n\ndef local_optimization(centers, radii):\n    \"\"\"Perform local optimization of centers to maximize sum of radii.\"\"\"\n    n = len(centers)\n    \n    def objective(x):\n        # Reshape x to get centers\n        new_centers = x.reshape(n, 2)\n        new_radii = optimize_radii(new_centers)\n        return -np.sum(new_radii)  # Negative because we're minimizing\n    \n    # Flatten centers for optimizer\n    x0 = centers.flatten()\n    \n    # Bounds to keep centers in [0,1]\u00d7[0,1]\n    bounds = [(0, 1) for _ in range(2*n)]\n    \n    # Run optimization\n    result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds, options={'maxiter': 100})\n    \n    # Extract results\n    new_centers = result.x.reshape(n, 2)\n    new_radii = optimize_radii(new_centers)\n    \n    return new_centers, new_radii\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) where:\n    - centers: np.array shape (26, 2)\n    - radii: np.array shape (26,)\n    - sum_radii: float\n    \"\"\"\n    n = 26\n    \n    # Initialize with hexagonal packing pattern\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Parameters for simulated annealing\n    max_iterations = 200000\n    initial_temp = 1.0\n    cooling_rate = 0.99995\n    \n    # Best solution tracking\n    best_centers = None\n    best_radii = None\n    best_sum_radii = 0\n    \n    # Multiple starting configurations\n    for start_config in range(5):\n        # Initialize with different patterns\n        if start_config == 0:\n            # Hexagonal-like pattern\n            rows, cols = 5, 6\n            idx = 0\n            for i in range(rows):\n                for j in range(cols):\n                    if idx < n:\n                        offset = 0.05 * (i % 2)  # Offset every other row\n                        centers[idx] = [0.1 + (j * 0.8 / (cols - 1)) + offset, 0.1 + (i * 0.8 / (rows - 1))]\n                        idx += 1\n        elif start_config == 1:\n            # Concentric circles pattern\n            center = np.array([0.5, 0.5])\n            radii_vals = np.linspace(0.05, 0.45, 5)\n            idx = 0\n            for r_val in radii_vals:\n                if r_val < 0.1:\n                    num_points = 1\n                else:\n                    num_points = min(n - idx, int(2 * np.pi * r_val / 0.15))\n                \n                if idx + num_points > n:\n                    num_points = n - idx\n                \n                if num_points == 1 and idx < n:\n                    centers[idx] = center\n                    idx += 1\n                else:\n                    for i in range(num_points):\n                        if idx < n:\n                            angle = 2 * np.pi * i / num_points\n                            centers[idx] = center + r_val * np.array([np.cos(angle), np.sin(angle)])\n                            idx += 1\n                \n                if idx >= n:\n                    break\n        else:\n            # Random initialization with some structure\n            centers = np.random.rand(n, 2) * 0.8 + 0.1\n        \n        # Initial radii\n        radii = optimize_radii(centers)\n        \n        # Simulated annealing\n        current_centers = centers.copy()\n        current_radii = radii.copy()\n        current_sum_radii = np.sum(radii)\n        \n        temp = initial_temp\n        \n        for iteration in range(max_iterations):\n            # Adaptive perturbation size based on temperature\n            perturbation_scale = 0.05 * temp\n            \n            # Copy current state\n            new_centers = current_centers.copy()\n            \n            # Choose perturbation strategy\n            strategy = np.random.choice(['move_one', 'move_pair', 'swap_pair'])\n            \n            if strategy == 'move_one':\n                # Move a single circle\n                idx = np.random.randint(n)\n                new_centers[idx] += np.random.normal(0, perturbation_scale, 2)\n                # Keep within bounds\n                new_centers[idx] = np.clip(new_centers[idx], 0, 1)\n            \n            elif strategy == 'move_pair':\n                # Move a pair of circles in opposite directions\n                idx1, idx2 = np.random.choice(n, 2, replace=False)\n                move_vector = np.random.normal(0, perturbation_scale, 2)\n                new_centers[idx1] += move_vector\n                new_centers[idx2] -= move_vector\n                # Keep within bounds\n                new_centers[idx1] = np.clip(new_centers[idx1], 0, 1)\n                new_centers[idx2] = np.clip(new_centers[idx2], 0, 1)\n            \n            elif strategy == 'swap_pair':\n                # Swap two circles\n                if n >= 2:\n                    idx1, idx2 = np.random.choice(n, 2, replace=False)\n                    new_centers[idx1], new_centers[idx2] = new_centers[idx2].copy(), new_centers[idx1].copy()\n            \n            # Optimize radii for new configuration\n            new_radii = optimize_radii(new_centers)\n            new_sum_radii = np.sum(new_radii)\n            \n            # Acceptance probability\n            delta = new_sum_radii - current_sum_radii\n            acceptance_prob = np.exp(delta / temp) if temp > 1e-10 else 0\n            \n            # Accept or reject\n            if delta > 0 or np.random.random() < acceptance_prob:\n                current_centers = new_centers\n                current_radii = new_radii\n                current_sum_radii = new_sum_radii\n                \n                # Update best solution\n                if current_sum_radii > best_sum_radii:\n                    best_centers = current_centers.copy()\n                    best_radii = current_radii.copy()\n                    best_sum_radii = current_sum_radii\n            \n            # Cool down\n            temp *= cooling_rate\n            \n            # Early stopping if temperature is too low\n            if temp < 1e-6:\n                break\n        \n        # Local optimization after simulated annealing\n        if best_centers is not None:\n            refined_centers, refined_radii = local_optimization(best_centers, best_radii)\n            refined_sum_radii = np.sum(refined_radii)\n            \n            if refined_sum_radii > best_sum_radii:\n                best_centers = refined_centers\n                best_radii = refined_radii\n                best_sum_radii = refined_sum_radii\n    \n    # Final refinement\n    if best_centers is not None:\n        for _ in range(3):  # Multiple refinement passes\n            refined_centers, refined_radii = local_optimization(best_centers, best_radii)\n            refined_sum_radii = np.sum(refined_radii)\n            \n            if refined_sum_radii > best_sum_radii:\n                best_centers = refined_centers\n                best_radii = refined_radii\n                best_sum_radii = refined_sum_radii\n    \n    return best_centers, best_radii, best_sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 90.00790691375732,
    "error": "Timeout after 90s"
  },
  "prompt": "\nEnhance this stochastic circle packing solution (score=2.3333912935802035):\n\nimport numpy as np\n\ndef is_valid(centers, radii):\n    \"\"\"Checks if the packing is valid.\"\"\"\n    n = len(centers)\n    for i in range(n):\n        # Check if inside the unit square\n        if centers[i][0] - radii[i] < 0 or centers[i][0] + radii[i] > 1 or \\\n           centers[i][1] - radii[i] < 0 or centers[i][1] + radii[i] > 1:\n            return False\n        # Check for overlaps\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j]:\n                return False\n    return True\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) where:\n    - centers: np.array shape (26, 2)\n    - radii: np.array shape (26,)\n    - sum_radii: float\n    \"\"\"\n    n = 26\n    \n    # Initial placement (grid-like)\n    rows = 5\n    cols = 6\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        row = i // cols\n        col = i % cols\n        centers[i] = np.array([0.1 + col * 0.8 / (cols - 1) if cols > 1 else 0.5, 0.1 + row * 0.8 / (rows - 1) if rows > 1 else 0.5])\n        radii[i] = 0.05  # Initial radius\n    \n    # Perturbation loop\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum_radii = np.sum(radii)\n    \n    for iteration in range(100000):\n        # Copy current best\n        centers = best_centers.copy()\n        radii = best_radii.copy()\n        \n        # Randomly choose a circle\n        idx = np.random.randint(n)\n        \n        # Perturb the center\n        centers[idx] += np.random.normal(0, 0.001, 2)\n        \n        # Perturb the radius\n        radii[idx] += np.random.normal(0, 0.0005)\n        radii[idx] = max(0.001, radii[idx])  # Ensure radius is non-negative and not too small\n        \n        # Check validity\n        if is_valid(centers, radii):\n            current_sum_radii = np.sum(radii)\n            if current_sum_radii > best_sum_radii:\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                best_sum_radii = current_sum_radii\n    \n    return best_centers, best_radii, best_sum_radii\n\ndef run_packing():\n    return construct_packing()\n\nThis solution uses random perturbations. Improve it by:\n1. Implementing a simulated annealing cooling schedule to decrease perturbation sizes over time\n2. Using smarter perturbation strategies that adjust to the local geometry\n3. Adding adaptive radius adjustment instead of uniform changes\n4. Increasing iterations or implementing early stopping\n5. Adding local search after the stochastic process\n\nReturn your improved solution in the required format.\n",
  "response": "I'll enhance the stochastic circle packing solution using several advanced optimization techniques.\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef is_valid(centers, radii):\n    \"\"\"Checks if the packing is valid.\"\"\"\n    n = len(centers)\n    for i in range(n):\n        # Check if inside the unit square\n        if centers[i][0] - radii[i] < 0 or centers[i][0] + radii[i] > 1 or \\\n           centers[i][1] - radii[i] < 0 or centers[i][1] + radii[i] > 1:\n            return False\n        # Check for overlaps\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j]:\n                return False\n    return True\n\ndef max_radius_for_circle(idx, centers, radii):\n    \"\"\"Calculate maximum possible radius for circle idx without overlapping others.\"\"\"\n    n = len(centers)\n    max_r = min(centers[idx][0], centers[idx][1], 1 - centers[idx][0], 1 - centers[idx][1])\n    \n    for j in range(n):\n        if j != idx:\n            dist = np.linalg.norm(centers[idx] - centers[j])\n            max_r = min(max_r, max(0, dist - radii[j]))\n    \n    return max_r\n\ndef optimize_radii(centers):\n    \"\"\"Optimize all radii for given centers.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    # Initial assignment of radii\n    for i in range(n):\n        radii[i] = max_radius_for_circle(i, centers, radii)\n    \n    # Iterative refinement\n    for _ in range(5):  # A few iterations to converge\n        for i in range(n):\n            radii[i] = max_radius_for_circle(i, centers, radii)\n    \n    return radii\n\ndef local_optimization(centers, radii):\n    \"\"\"Perform local optimization of centers to maximize sum of radii.\"\"\"\n    n = len(centers)\n    \n    def objective(x):\n        # Reshape x to get centers\n        new_centers = x.reshape(n, 2)\n        new_radii = optimize_radii(new_centers)\n        return -np.sum(new_radii)  # Negative because we're minimizing\n    \n    # Flatten centers for optimizer\n    x0 = centers.flatten()\n    \n    # Bounds to keep centers in [0,1]\u00d7[0,1]\n    bounds = [(0, 1) for _ in range(2*n)]\n    \n    # Run optimization\n    result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds, options={'maxiter': 100})\n    \n    # Extract results\n    new_centers = result.x.reshape(n, 2)\n    new_radii = optimize_radii(new_centers)\n    \n    return new_centers, new_radii\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) where:\n    - centers: np.array shape (26, 2)\n    - radii: np.array shape (26,)\n    - sum_radii: float\n    \"\"\"\n    n = 26\n    \n    # Initialize with hexagonal packing pattern\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Parameters for simulated annealing\n    max_iterations = 200000\n    initial_temp = 1.0\n    cooling_rate = 0.99995\n    \n    # Best solution tracking\n    best_centers = None\n    best_radii = None\n    best_sum_radii = 0\n    \n    # Multiple starting configurations\n    for start_config in range(5):\n        # Initialize with different patterns\n        if start_config == 0:\n            # Hexagonal-like pattern\n            rows, cols = 5, 6\n            idx = 0\n            for i in range(rows):\n                for j in range(cols):\n                    if idx < n:\n                        offset = 0.05 * (i % 2)  # Offset every other row\n                        centers[idx] = [0.1 + (j * 0.8 / (cols - 1)) + offset, 0.1 + (i * 0.8 / (rows - 1))]\n                        idx += 1\n        elif start_config == 1:\n            # Concentric circles pattern\n            center = np.array([0.5, 0.5])\n            radii_vals = np.linspace(0.05, 0.45, 5)\n            idx = 0\n            for r_val in radii_vals:\n                if r_val < 0.1:\n                    num_points = 1\n                else:\n                    num_points = min(n - idx, int(2 * np.pi * r_val / 0.15))\n                \n                if idx + num_points > n:\n                    num_points = n - idx\n                \n                if num_points == 1 and idx < n:\n                    centers[idx] = center\n                    idx += 1\n                else:\n                    for i in range(num_points):\n                        if idx < n:\n                            angle = 2 * np.pi * i / num_points\n                            centers[idx] = center + r_val * np.array([np.cos(angle), np.sin(angle)])\n                            idx += 1\n                \n                if idx >= n:\n                    break\n        else:\n            # Random initialization with some structure\n            centers = np.random.rand(n, 2) * 0.8 + 0.1\n        \n        # Initial radii\n        radii = optimize_radii(centers)\n        \n        # Simulated annealing\n        current_centers = centers.copy()\n        current_radii = radii.copy()\n        current_sum_radii = np.sum(radii)\n        \n        temp = initial_temp\n        \n        for iteration in range(max_iterations):\n            # Adaptive perturbation size based on temperature\n            perturbation_scale = 0.05 * temp\n            \n            # Copy current state\n            new_centers = current_centers.copy()\n            \n            # Choose perturbation strategy\n            strategy = np.random.choice(['move_one', 'move_pair', 'swap_pair'])\n            \n            if strategy == 'move_one':\n                # Move a single circle\n                idx = np.random.randint(n)\n                new_centers[idx] += np.random.normal(0, perturbation_scale, 2)\n                # Keep within bounds\n                new_centers[idx] = np.clip(new_centers[idx], 0, 1)\n            \n            elif strategy == 'move_pair':\n                # Move a pair of circles in opposite directions\n                idx1, idx2 = np.random.choice(n, 2, replace=False)\n                move_vector = np.random.normal(0, perturbation_scale, 2)\n                new_centers[idx1] += move_vector\n                new_centers[idx2] -= move_vector\n                # Keep within bounds\n                new_centers[idx1] = np.clip(new_centers[idx1], 0, 1)\n                new_centers[idx2] = np.clip(new_centers[idx2], 0, 1)\n            \n            elif strategy == 'swap_pair':\n                # Swap two circles\n                if n >= 2:\n                    idx1, idx2 = np.random.choice(n, 2, replace=False)\n                    new_centers[idx1], new_centers[idx2] = new_centers[idx2].copy(), new_centers[idx1].copy()\n            \n            # Optimize radii for new configuration\n            new_radii = optimize_radii(new_centers)\n            new_sum_radii = np.sum(new_radii)\n            \n            # Acceptance probability\n            delta = new_sum_radii - current_sum_radii\n            acceptance_prob = np.exp(delta / temp) if temp > 1e-10 else 0\n            \n            # Accept or reject\n            if delta > 0 or np.random.random() < acceptance_prob:\n                current_centers = new_centers\n                current_radii = new_radii\n                current_sum_radii = new_sum_radii\n                \n                # Update best solution\n                if current_sum_radii > best_sum_radii:\n                    best_centers = current_centers.copy()\n                    best_radii = current_radii.copy()\n                    best_sum_radii = current_sum_radii\n            \n            # Cool down\n            temp *= cooling_rate\n            \n            # Early stopping if temperature is too low\n            if temp < 1e-6:\n                break\n        \n        # Local optimization after simulated annealing\n        if best_centers is not None:\n            refined_centers, refined_radii = local_optimization(best_centers, best_radii)\n            refined_sum_radii = np.sum(refined_radii)\n            \n            if refined_sum_radii > best_sum_radii:\n                best_centers = refined_centers\n                best_radii = refined_radii\n                best_sum_radii = refined_sum_radii\n    \n    # Final refinement\n    if best_centers is not None:\n        for _ in range(3):  # Multiple refinement passes\n            refined_centers, refined_radii = local_optimization(best_centers, best_radii)\n            refined_sum_radii = np.sum(refined_radii)\n            \n            if refined_sum_radii > best_sum_radii:\n                best_centers = refined_centers\n                best_radii = refined_radii\n                best_sum_radii = refined_sum_radii\n    \n    return best_centers, best_radii, best_sum_radii\n\ndef run_packing():\n    return construct_packing()\n```\n\nThis enhanced solution includes:\n\n1. **Simulated annealing** with a cooling schedule that gradually decreases perturbation sizes\n2. **Multiple starting configurations** including hexagonal and concentric patterns\n3. **Adaptive perturbation strategies** that include:\n   - Moving single circles\n   - Moving pairs of circles in opposite directions\n   - Swapping circle positions\n4. **Intelligent radius optimization** that maximizes each circle's radius based on its surroundings\n5. **Local optimization** using L-BFGS-B to fine-tune the solution after the stochastic process\n6. **Multiple refinement passes** to further improve the final solution\n\nThe solution balances exploration (through simulated annealing) and exploitation (through local optimization) to find high-quality packings.",
  "reasoning": "I'll enhance the stochastic circle packing solution using several advanced optimization techniques.\n\nThis enhanced solution includes:\n\n1. **Simulated annealing** with a cooling schedule that gradually decreases perturbation sizes\n2. **Multiple starting configurations** including hexagonal and concentric patterns\n3. **Adaptive perturbation strategies** that include:\n   - Moving single circles\n   - Moving pairs of circles in opposite directions\n   - Swapping circle positions\n4. **Intelligent radius optimization** that maximizes each circle's radius based on its surroundings\n5. **Local optimization** using L-BFGS-B to fine-tune the solution after the stochastic process\n6. **Multiple refinement passes** to further improve the final solution\n\nThe solution balances exploration (through simulated annealing) and exploitation (through local optimization) to find high-quality packings.",
  "timestamp": "2026-01-11T20:10:19.522138",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-3.7-sonnet",
    "temperature": 0.3
  }
}