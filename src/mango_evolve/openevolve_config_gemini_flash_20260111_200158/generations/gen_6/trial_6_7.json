{
  "trial_id": "trial_6_7",
  "generation": 6,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport copy\n\ndef calculate_distance(center1, center2):\n    return np.sqrt((center1[0] - center2[0])**2 + (center1[1] - center2[1])**2)\n\ndef check_validity(centers, radii):\n    \"\"\"Checks if the packing is valid.\"\"\"\n    n = len(centers)\n    for i in range(n):\n        # Check if circle is inside the square\n        if not (0 <= centers[i][0] - radii[i] and centers[i][0] + radii[i] <= 1 and\n                0 <= centers[i][1] - radii[i] and centers[i][1] + radii[i] <= 1):\n            return False\n        # Check for overlaps with other circles\n        for j in range(i + 1, n):\n            distance = calculate_distance(centers[i], centers[j])\n            if distance < radii[i] + radii[j]:\n                return False\n    return True\n\ndef calculate_sum_radii(radii):\n    return np.sum(radii)\n\ndef objective_function(x, n):\n    \"\"\"Objective function to minimize the negative sum of radii.\"\"\"\n    centers = x[:2*n].reshape(n, 2)\n    radii = x[2*n:]\n    return -calculate_sum_radii(radii)\n\ndef constraint_function(x, n):\n    \"\"\"Constraint function to ensure circles are within the unit square and do not overlap.\"\"\"\n    centers = x[:2*n].reshape(n, 2)\n    radii = x[2*n:]\n    constraints = []\n\n    # Circle within unit square constraints\n    for i in range(n):\n        constraints.extend([\n            centers[i][0] - radii[i],  # x - r >= 0\n            1 - (centers[i][0] + radii[i]),  # 1 - (x + r) >= 0\n            centers[i][1] - radii[i],  # y - r >= 0\n            1 - (centers[i][1] + radii[i])   # 1 - (y + r) >= 0\n        ])\n\n    # Non-overlapping constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            distance = calculate_distance(centers[i], centers[j])\n            constraints.append(distance - (radii[i] + radii[j]))  # distance - (r1 + r2) >= 0\n\n    return np.array(constraints)\n\ndef local_refinement(centers, radii):\n    \"\"\"Performs local refinement of the circle packing.\"\"\"\n    n = len(centers)\n    x0 = np.concatenate([centers.flatten(), radii])\n    constraints = {'type': 'ineq', 'fun': constraint_function, 'args': (n,)}\n    bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n  # Radius upper bound\n    result = minimize(objective_function, x0, args=(n,), constraints=constraints, bounds=bounds, method='SLSQP', options={'maxiter': 100})\n    \n    refined_centers = result.x[:2*n].reshape(n, 2)\n    refined_radii = result.x[2*n:]\n    \n    return refined_centers, refined_radii\n\ndef perturbation(centers, radii, temperature):\n    \"\"\"Applies a perturbation to the centers and radii.\"\"\"\n    n = len(centers)\n    perturbed_centers = centers + np.random.normal(0, temperature, size=(n, 2))\n    perturbed_radii = radii + np.random.normal(0, temperature/5, size=n)\n    perturbed_radii = np.clip(perturbed_radii, 0.01, 0.5) # Radius lower bound\n    return perturbed_centers, perturbed_radii\n\ndef construct_packing():\n    n = 26\n    best_sum_radii = 0\n    best_centers = None\n    best_radii = None\n    \n    # Multiple initial configurations\n    for initial_seed in range(3):\n        np.random.seed(initial_seed)\n        initial_centers = np.random.rand(n, 2)\n        initial_radii = np.random.rand(n) * 0.1 + 0.02 # Ensure initial radii are not too large or small\n\n        centers = initial_centers.copy()\n        radii = initial_radii.copy()\n\n        # Simulated annealing-like schedule\n        temperature = 0.1\n        cooling_rate = 0.95\n        \n        for i in range(100):\n            perturbed_centers, perturbed_radii = perturbation(centers, radii, temperature)\n            \n            # Local refinement after perturbation\n            refined_centers, refined_radii = local_refinement(perturbed_centers, perturbed_radii)\n            \n            if check_validity(refined_centers, refined_radii):\n                current_sum_radii = calculate_sum_radii(refined_radii)\n                \n                if current_sum_radii > calculate_sum_radii(radii):\n                    centers = refined_centers\n                    radii = refined_radii\n                    \n                    if current_sum_radii > best_sum_radii:\n                        best_sum_radii = current_sum_radii\n                        best_centers = centers.copy()\n                        best_radii = radii.copy()\n            \n            temperature *= cooling_rate\n\n    # Final global optimization\n    final_centers, final_radii = local_refinement(best_centers, best_radii)\n    if check_validity(final_centers, final_radii):\n        final_sum_radii = calculate_sum_radii(final_radii)\n        if final_sum_radii > best_sum_radii:\n            best_centers = final_centers\n            best_radii = final_radii\n            best_sum_radii = final_sum_radii\n\n    return best_centers, best_radii, best_sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.607463765484484,
    "eval_time": 54.21988606452942,
    "error": null
  },
  "prompt": "\nDesign a circle packing solution that implements a novel perturbation-based approach:\n\n1. Start with multiple high-quality initial configurations\n2. Apply systematic perturbations to escape local optima\n3. Use a simulated annealing-like schedule to control perturbation magnitude\n4. Implement local refinement after each perturbation phase\n5. Apply a final global optimization once the best configuration is found\n\nLearn from our best performers:\n- trial_3_9 (score=2.6260059219995324)\n- trial_5_9 (score=2.6252017826694773)\n\nReturn your solution in the required format.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport copy\n\ndef calculate_distance(center1, center2):\n    return np.sqrt((center1[0] - center2[0])**2 + (center1[1] - center2[1])**2)\n\ndef check_validity(centers, radii):\n    \"\"\"Checks if the packing is valid.\"\"\"\n    n = len(centers)\n    for i in range(n):\n        # Check if circle is inside the square\n        if not (0 <= centers[i][0] - radii[i] and centers[i][0] + radii[i] <= 1 and\n                0 <= centers[i][1] - radii[i] and centers[i][1] + radii[i] <= 1):\n            return False\n        # Check for overlaps with other circles\n        for j in range(i + 1, n):\n            distance = calculate_distance(centers[i], centers[j])\n            if distance < radii[i] + radii[j]:\n                return False\n    return True\n\ndef calculate_sum_radii(radii):\n    return np.sum(radii)\n\ndef objective_function(x, n):\n    \"\"\"Objective function to minimize the negative sum of radii.\"\"\"\n    centers = x[:2*n].reshape(n, 2)\n    radii = x[2*n:]\n    return -calculate_sum_radii(radii)\n\ndef constraint_function(x, n):\n    \"\"\"Constraint function to ensure circles are within the unit square and do not overlap.\"\"\"\n    centers = x[:2*n].reshape(n, 2)\n    radii = x[2*n:]\n    constraints = []\n\n    # Circle within unit square constraints\n    for i in range(n):\n        constraints.extend([\n            centers[i][0] - radii[i],  # x - r >= 0\n            1 - (centers[i][0] + radii[i]),  # 1 - (x + r) >= 0\n            centers[i][1] - radii[i],  # y - r >= 0\n            1 - (centers[i][1] + radii[i])   # 1 - (y + r) >= 0\n        ])\n\n    # Non-overlapping constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            distance = calculate_distance(centers[i], centers[j])\n            constraints.append(distance - (radii[i] + radii[j]))  # distance - (r1 + r2) >= 0\n\n    return np.array(constraints)\n\ndef local_refinement(centers, radii):\n    \"\"\"Performs local refinement of the circle packing.\"\"\"\n    n = len(centers)\n    x0 = np.concatenate([centers.flatten(), radii])\n    constraints = {'type': 'ineq', 'fun': constraint_function, 'args': (n,)}\n    bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n  # Radius upper bound\n    result = minimize(objective_function, x0, args=(n,), constraints=constraints, bounds=bounds, method='SLSQP', options={'maxiter': 100})\n    \n    refined_centers = result.x[:2*n].reshape(n, 2)\n    refined_radii = result.x[2*n:]\n    \n    return refined_centers, refined_radii\n\ndef perturbation(centers, radii, temperature):\n    \"\"\"Applies a perturbation to the centers and radii.\"\"\"\n    n = len(centers)\n    perturbed_centers = centers + np.random.normal(0, temperature, size=(n, 2))\n    perturbed_radii = radii + np.random.normal(0, temperature/5, size=n)\n    perturbed_radii = np.clip(perturbed_radii, 0.01, 0.5) # Radius lower bound\n    return perturbed_centers, perturbed_radii\n\ndef construct_packing():\n    n = 26\n    best_sum_radii = 0\n    best_centers = None\n    best_radii = None\n    \n    # Multiple initial configurations\n    for initial_seed in range(3):\n        np.random.seed(initial_seed)\n        initial_centers = np.random.rand(n, 2)\n        initial_radii = np.random.rand(n) * 0.1 + 0.02 # Ensure initial radii are not too large or small\n\n        centers = initial_centers.copy()\n        radii = initial_radii.copy()\n\n        # Simulated annealing-like schedule\n        temperature = 0.1\n        cooling_rate = 0.95\n        \n        for i in range(100):\n            perturbed_centers, perturbed_radii = perturbation(centers, radii, temperature)\n            \n            # Local refinement after perturbation\n            refined_centers, refined_radii = local_refinement(perturbed_centers, perturbed_radii)\n            \n            if check_validity(refined_centers, refined_radii):\n                current_sum_radii = calculate_sum_radii(refined_radii)\n                \n                if current_sum_radii > calculate_sum_radii(radii):\n                    centers = refined_centers\n                    radii = refined_radii\n                    \n                    if current_sum_radii > best_sum_radii:\n                        best_sum_radii = current_sum_radii\n                        best_centers = centers.copy()\n                        best_radii = radii.copy()\n            \n            temperature *= cooling_rate\n\n    # Final global optimization\n    final_centers, final_radii = local_refinement(best_centers, best_radii)\n    if check_validity(final_centers, final_radii):\n        final_sum_radii = calculate_sum_radii(final_radii)\n        if final_sum_radii > best_sum_radii:\n            best_centers = final_centers\n            best_radii = final_radii\n            best_sum_radii = final_sum_radii\n\n    return best_centers, best_radii, best_sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-11T20:31:32.976776",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.5,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 369,
        "candidates_token_count": 1457,
        "thoughts_token_count": 0
      },
      "response_text_len": 4832
    }
  }
}