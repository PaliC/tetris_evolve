{
  "trial_id": "trial_0_7",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\n\ndef is_valid(centers, radii):\n    \"\"\"Checks if the packing is valid.\"\"\"\n    n = len(centers)\n    for i in range(n):\n        # Check if inside the unit square\n        if centers[i][0] - radii[i] < 0 or centers[i][0] + radii[i] > 1 or \\\n           centers[i][1] - radii[i] < 0 or centers[i][1] + radii[i] > 1:\n            return False\n        # Check for overlaps\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j]:\n                return False\n    return True\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) where:\n    - centers: np.array shape (26, 2)\n    - radii: np.array shape (26,)\n    - sum_radii: float\n    \"\"\"\n    n = 26\n    \n    # Initial placement (grid-like)\n    rows = 5\n    cols = 6\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        row = i // cols\n        col = i % cols\n        centers[i] = np.array([0.1 + col * 0.8 / (cols - 1) if cols > 1 else 0.5, 0.1 + row * 0.8 / (rows - 1) if rows > 1 else 0.5])\n        radii[i] = 0.05  # Initial radius\n    \n    # Perturbation loop\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum_radii = np.sum(radii)\n    \n    for iteration in range(100000):\n        # Copy current best\n        centers = best_centers.copy()\n        radii = best_radii.copy()\n        \n        # Randomly choose a circle\n        idx = np.random.randint(n)\n        \n        # Perturb the center\n        centers[idx] += np.random.normal(0, 0.001, 2)\n        \n        # Perturb the radius\n        radii[idx] += np.random.normal(0, 0.0005)\n        radii[idx] = max(0.001, radii[idx])  # Ensure radius is non-negative and not too small\n        \n        # Check validity\n        if is_valid(centers, radii):\n            current_sum_radii = np.sum(radii)\n            if current_sum_radii > best_sum_radii:\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                best_sum_radii = current_sum_radii\n    \n    return best_centers, best_radii, best_sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.3333912935802035,
    "eval_time": 23.95769691467285,
    "error": null
  },
  "prompt": "\nDesign a circle packing algorithm that packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n- All circles must be entirely inside the unit square\n- No two circles may overlap\n- All radii must be non-negative\n\nImplement a perturbation-based approach that starts with an initial placement and randomly perturbs positions and sizes to find improvements.\n\nReturn your solution as:\n```python\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) where:\n    - centers: np.array shape (26, 2)\n    - radii: np.array shape (26,)\n    - sum_radii: float\n    \"\"\"\n    # Your implementation here\n    \ndef run_packing():\n    return construct_packing()\n```\n        ",
  "response": "```python\nimport numpy as np\n\ndef is_valid(centers, radii):\n    \"\"\"Checks if the packing is valid.\"\"\"\n    n = len(centers)\n    for i in range(n):\n        # Check if inside the unit square\n        if centers[i][0] - radii[i] < 0 or centers[i][0] + radii[i] > 1 or \\\n           centers[i][1] - radii[i] < 0 or centers[i][1] + radii[i] > 1:\n            return False\n        # Check for overlaps\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j]:\n                return False\n    return True\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) where:\n    - centers: np.array shape (26, 2)\n    - radii: np.array shape (26,)\n    - sum_radii: float\n    \"\"\"\n    n = 26\n    \n    # Initial placement (grid-like)\n    rows = 5\n    cols = 6\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        row = i // cols\n        col = i % cols\n        centers[i] = np.array([0.1 + col * 0.8 / (cols - 1) if cols > 1 else 0.5, 0.1 + row * 0.8 / (rows - 1) if rows > 1 else 0.5])\n        radii[i] = 0.05  # Initial radius\n    \n    # Perturbation loop\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum_radii = np.sum(radii)\n    \n    for iteration in range(100000):\n        # Copy current best\n        centers = best_centers.copy()\n        radii = best_radii.copy()\n        \n        # Randomly choose a circle\n        idx = np.random.randint(n)\n        \n        # Perturb the center\n        centers[idx] += np.random.normal(0, 0.001, 2)\n        \n        # Perturb the radius\n        radii[idx] += np.random.normal(0, 0.0005)\n        radii[idx] = max(0.001, radii[idx])  # Ensure radius is non-negative and not too small\n        \n        # Check validity\n        if is_valid(centers, radii):\n            current_sum_radii = np.sum(radii)\n            if current_sum_radii > best_sum_radii:\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                best_sum_radii = current_sum_radii\n    \n    return best_centers, best_radii, best_sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-01-11T20:04:49.556600",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.0-flash-001",
    "temperature": 0.4,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 408,
        "candidates_token_count": 744,
        "thoughts_token_count": 0
      },
      "response_text_len": 2177
    }
  }
}